{"fileType":"apogee workspace","jsLinks":[],"cssLinks":[],"workspace":{"fileType":"apogee workspace","version":0.2,"data":{"name":"reconstructMetaFile","type":"apogee.Folder","children":{"reconstruct":{"name":"reconstruct","type":"apogee.Folder","children":{"presets":{"name":"presets","type":"apogee.Folder","children":{"processEntry":{"name":"processEntry","type":"apogee.FunctionTable","updateData":{"argList":["output","metaFile","recipeEntry","fileEntry","fileEntryType","workingData"],"functionBody":"//----------------\n//load the section\n//----------------\nvar sectionValue = fileEntryType.Fields.section;\n\nvar majorSection = output[sectionValue[0]];\nif(!majorSection) {\n    majorSection = {};\n    output[sectionValue[0]] = majorSection;\n}\n\nvar minorSection = majorSection[sectionValue[1]];\nif(!minorSection) {\n    minorSection = [];\n    majorSection[sectionValue[1]] = minorSection;\n}\n\n//------------------------\n//create this preset entry\n//------------------------\nvar presetEntry = {};\nvar path;\n\nvar entryData = fileEntry.Fields.entry_data;\n\nvar parentPresetEntry = null;\nvar parentFileEntryTypeId = fileEntryType.Fields.entry_parent_id;\nif(parentFileEntryTypeId) {\n    var parentPresetEntry = getPresetEntry(workingData,sectionValue,parentFileEntryTypeId);\n    if(!parentPresetEntry) {\n        //throw new Error(\"parent entry not found!: \" + JSON.stringify(parentPath));\n        console.log(\"parent entry not found!: \" + JSON.stringify(parentPath));\n        return;\n    }\n}\n\nif(fileEntryType.Fields.entry_type == \"key\") {\n    //add any added entry fields\n    presetEntry.k = fileEntryType.Fields.entry_value;\n    presetEntry.input = entryData.input;\n    if(entryData.desc) presetEntry.desc = entryData.desc;\n    if(entryData.required) presetEntry.required = entryData.required;\n    if(entryData.is_array) presetEntry.is_array = entryData.is_array;\n    if(entryData.has_lang) presetEntry.has_lang = entryData.has_lang;\n    if(entryData.prop) presetEntry.prop = entryData.prop;\n    \n    //add the entry to the parent or the base of the section\n    if(parentPresetEntry) {\n        addKeyToParentPresetEntry(parentPresetEntry,presetEntry);\n    }\n    else {\n        minorSection.push(presetEntry);\n    }\n}\nelse {\n    var value = fileEntryType.Fields.entry_value;\n    \n    //add any added entry fields\n    if(entryData.desc) presetEntry.desc = entryData.desc;\n    \n    //add the entry to the parent\n    addValueToParentPresetEntry(parentPresetEntry,presetEntry,value);\n}\n\nstorePresetEntry(workingData,sectionValue,fileEntryType.Id,presetEntry);\n","supplementalCode":"function getPresetEntry(workingData,section,fileEntryTypeId) {\r\n    return workingData.storedEntries[fileEntryTypeId];\r\n}\r\n\r\n\r\nfunction storePresetEntry(workingData,section,fileEntryTypeId,entry) {\r\n    workingData.storedEntries[fileEntryTypeId] = entry;\r\n}\r\n\r\nfunction addKeyToParentPresetEntry(parentPresetEntry,presetEntry) {\r\n    var keyList = parentPresetEntry.ks;\r\n    if(!keyList) {\r\n        keyList = [];\r\n        parentPresetEntry.ks = keyList;\r\n    }\r\n    keyList.push(presetEntry);\r\n}\r\n\r\nfunction addValueToParentPresetEntry(parentPresetEntry,presetEntry,value) {\r\n    var valueSet = parentPresetEntry.v;\r\n    if(!valueSet) {\r\n        valueSet = {};\r\n        parentPresetEntry.v = valueSet;\r\n    }\r\n    valueSet[value] = presetEntry;\r\n}","description":""}},"postProcessFile":{"name":"postProcessFile","type":"apogee.FunctionTable","updateData":{"argList":["outFile","workingData"],"functionBody":"//we need to convert the named keys to a single object each rather than a list \n//and we should enforce that they only have one entry.\nfor(var namedKey in outFile.named_keys) {\n    var namedKeyEntry = outFile.named_keys[namedKey];\n    if(namedKeyEntry.length > 1) {\n        throw new Error(\"named key has mulitipl entries!\");\n    }\n    outFile.named_keys[namedKey] = namedKeyEntry[0];\n}","supplementalCode":"","description":""}},"initialize":{"name":"initialize","type":"apogee.FunctionTable","updateData":{"argList":["outFile"],"functionBody":"return {\"storedEntries\":{}};","supplementalCode":"","description":""}}}},"themeMap":{"name":"themeMap","type":"apogee.FunctionTable","updateData":{"argList":["baseFile"],"functionBody":"var outFile = {};\noutFile.ft = \"ThemeMap\";\noutFile.nm = baseFile.nm;\n\nfor(var sectionName in baseFile.data) {\n    var inSectionEntry = baseFile.data[sectionName];\n    var outSectionEntry = [];\n    outFile[sectionName] = outSectionEntry;\n    \n    for(var i = 0; i < inSectionEntry.length; i++) {\n        var inPriorityEntry = inSectionEntry[i];\n        \n        var outPriorityEntry = {};\n        outPriorityEntry.priority = inPriorityEntry.order;\n        outPriorityEntry.ks = [];\n        processInputEntries(inPriorityEntry.entries,outPriorityEntry);\n        \n        outSectionEntry.push(outPriorityEntry);\n    }\n}\n\nreturn outFile;","supplementalCode":"const propTypeToKeyTag = {\n    \"address\":\"ak\",\n    \"entity\":\"ek\",\n    \"geometry\":\"gk\"\n};\n\n//read all in entries and add them as out entries to the output priority section\nfunction processInputEntries(inEntryMap,outPriorityEntry) {\n    for(var tag in inEntryMap) {\n        var inEntry = inEntryMap[tag];\n        processInEntry(inEntry,outPriorityEntry)\n    }\n    return outEntryList;\n}\n\n//add this in entry to the output priority section\nfunction processInEntry(inEntry,outPriorityEntry) {\n    //only process if there is a payload - there should be\n    if(inEntry.payload) {\n        var pathType = inEntry.propType;\n        var path = inEntry.path;\n        var keyIndex = path.length-1;\n        var rootEntry = outPriorityEntry;\n        //read the proper key or value entry from the path\n        var resultEntry = getEntry(pathType,path,keyIndex,rootEntry);\n        addPayload(resultEntry,inEntry.payload);\n    }\n}\n\n//copies data from the payload to the entry\nfunction addPayload(entry,payload) {\n    for(var tag in payload) {\n        entry[tag] = payload[tag];\n    }\n}\n\n//This function looks up the entry as the given index of the path\nfunction getEntry(pathType,path,keyIndex,rootEntry) {\n    if(path.length === 0) {\n        //the root entry is the value entry\n        return rootEntry;\n    }   \n    else {\n        var parentValueEntry;\n        \n        //get the parent value entry\n        if(keyIndex === 0) {\n            parentValueEntry = rootEntry;\n        }\n        else {\n            var parentIndex = keyIndex - 1;\n            //we require all entries excpet that last is a key-value entry\n            if(path[parentIndex].length !== 2) throw new Error(\"Error: all path entries except the last must be a full key-value entry! path: \" + path);\n            \n            parentValueEntry = getEntry(pathType,path,parentIndex,rootEntry);\n        }\n        \n        //get the key or value element at this entry\n        var currentPathElement = path[keyIndex];\n        var key = currentPathElement[0];\n        var keyEntry = getKeyEntryFromValueEntry(parentValueEntry,pathType,key);\n        if(currentPathElement.length === 1) {\n            //this is a key entry\n            return keyEntry;\n        }\n        else {\n            //this is a value entry\n            var value = currentPathElement[1];\n            return getValueEntryFromKeyEntry(keyEntry,value);\n        }\n    }\n}\n\nfunction getValueEntryFromKeyEntry(keyEntry,value) {\n    //get the value map from the key entry\n    var valueMap = keyEntry.v;\n    if(valueMap === undefined) {\n       valueMap = {};\n       keyEntry.v = valueMap;\n    }\n    //lookup up the value entry\n    valueEntry = valueMap[value];\n    \n    if(valueEntry === undefined) {\n        //construct a new one if it doesn't exist\n        valueEntry = {};\n        valueMap[value] = valueEntry;\n    }\n    return valueEntry;\n}\n\nfunction getKeyEntryFromValueEntry(valueEntry,propType,key) {\n    //key varies by prop type: ak/ek/gk\n    var keyTag = propTypeToKeyTag[propType];\n    \n    //get the key list from the value entry\n    var keyList = valueEntry.ks;\n    if(keyList === undefined) {\n        keyList = [];\n        valueEntry.ks = keyList;\n    }\n    //check if the key entry already exists\n    for(var i = 0; i < keyList.length; i++) {\n        var keyEntry = keyList[i];\n        if(keyEntry[keyTag] == key) {\n            return keyEntry;\n        }\n    }\n    //make a new key entry\n    var keyEntry = {};\n    keyEntry[keyTag] = key;\n    keyList.push(keyEntry);\n    return keyEntry;\n}","description":""}},"inputColors":{"name":"inputColors","type":"apogee.FunctionTable","updateData":{"argList":["baseFile"],"functionBody":"//just get rid of the data section\nvar outFile = apogee.util.deepJsonCopy(baseFile.data);\noutFile.nm = baseFile.nm;\nreturn outFile;","supplementalCode":"","description":""}},"strings":{"name":"strings","type":"apogee.FunctionTable","updateData":{"argList":["baseFile"],"functionBody":"var outFile = {};\noutFile.nm = baseFile.nm;\n\nvar translations = {};\noutFile.translations = translations;\n\nfor(var lang in baseFile.data) {\n    var section = baseFile.data[lang];\n    \n    for(var key in section) {\n        var entry = section[key];\n        var translation = entry.trans;\n        addTranslation(key,lang,translation,translations);\n    }\n}\n\nreturn outFile;","supplementalCode":"function addTranslation(key,lang,translation,translations) {\n    var entry = translations[key];\n    if(entry === undefined) {\n        entry = {};\n        translations[key] = entry;\n    }\n    entry[lang] = translation;\n}","description":""}},"theme":{"name":"theme","type":"apogee.FunctionTable","updateData":{"argList":["baseFile"],"functionBody":"var outFile = {};\noutFile.nm = baseFile.nm;\noutFile.ft = \"thm5\";\n\nfor(var sectionName in baseFile.data) {\n    var newSectionName = SECTION_NAME_MAP[sectionName];\n    outFile[newSectionName] = baseFile.data[sectionName];\n}\n\nreturn outFile;","supplementalCode":"const SECTION_NAME_MAP = {\n    \"style\": \"s\",\n    \"icon\": \"i\",\n    \"labelStyle\": \"l\",\n    \"marker\": \"m\"\n}","description":""}},"presetOverride":{"name":"presetOverride","type":"apogee.FunctionTable","updateData":{"argList":["baseFile"],"functionBody":"var outFile = {};\n\nvar outEntriesSection = [];\nvar namedKeysSection = [];\n\n//identify the pattern based on current allowed types (for preset overrides)\nfor(var sectionName in baseFile.data) {\n    var section = baseFile.data[sectionName];\n    for(var entryValue in section) {\n        var inEntry = section[entryValue];\n        if(sectionName != \"named_entries\") {\n            var outEntry = createTreeOutEntry(inEntry,sectionName);\n            if(outEntry) {\n                outEntriesSection.push(outEntry);\n            }\n        }\n        else {\n            var outEntryList = createNamedOutEntryList(inEntry);\n            if(outEntryList) {\n                namedKeysSection = namedKeysSection.concat(outEntryList);\n            }\n        }\n    }\n}\n\nif(outEntriesSection.length > 0) {\n    outFile.entries = outEntriesSection;\n}\nif(namedKeysSection.length > 0) {\n    outFile.name_keys = namedKeysSection;\n}\n\nreturn outFile;","supplementalCode":"function createTreeOutEntry(inEntry,section) {\n    if(inEntry.extends !== undefined) {\n        return createExtendsEntry(inEntry,section);\n    }\n    else if(inEntry.modifies !== undefined) {\n        return createModifiesEntry(inEntry,section);\n    }\n    else {\n        throw new Error(\"Preset override supports only entry action extends and modifies\");\n    }\n}\n\nfunction createExtendsEntry(inEntry,section) {\n    if(inEntry.properties.length > 1) {\n        throw new Error(\"Preset override supports only extend entries with no new properties\");\n    }\n    \n    var firstProp = inEntry.properties[0];\n    \n    if((firstProp.action != \"modifies\")&&(firstProp.key != \"featureType\")) {\n        throw new Error(\"Preset override supports only extend entries for feature types\");\n    }\n    \n    var legacyKey = firstProp.legacyKey;\n    var legacyValue = firstProp.legacyValue;\n    \n    \n    //this is a simple new key-value\n    var outEntry = {};\n    outEntry.type = \"value\";\n    outEntry.tree = section;\n    outEntry.path = [legacyKey];\n    outEntry.value = legacyValue;\n    outEntry.entry = {};\n    \n    return outEntry;\n}\n\nfunction createModifiesEntry(inEntry,section) {\n    //lookup base entry\n    var parentCombinedEntry = lookupPropertyRulesEntry(section,inEntry.modifies);\n    parentEntryData = parentCombinedEntry.fileEntry.Fields.entry_data;\n    \n    //sanity check - because we are implmenting a subset of valid cases here\n    var parentFeatureTypeProp = parentEntryData.properties[0];\n    if(parentFeatureTypeProp.key != \"featureType\") {\n        throw new Error(\"Preset override failed on reading base entry for modifies: \" + entryValue);\n    }\n    \n    var parentLegacyKey = parentFeatureTypeProp.legacyKey;\n    var parentLegacyValue = parentFeatureTypeProp.legacyValue;\n    \n    //read the inEntry\n    if(inEntry.properties.length > 1) {\n        throw new Error(\"Preset override reconstruct only supports single property entries! Entry value = \" + inEntry.name);\n    }\n    var childProp = inEntry.properties[0];\n    \n    if(childProp.action == \"modifies\") {\n        return createChildValueEntry(section,parentLegacyKey,parentLegacyValue,childProp);\n    }\n    else if(childProp.action === undefined) {\n        return createChildKeyEntry(section,parentLegacyKey,parentLegacyValue,childProp);\n    }\n    else {\n        throw new Error(\"Unsupported property action in modifies entry: \" + childProp.action);\n    }\n}\n\n//This looks up an entry from property rules by name\nfunction lookupPropertyRulesEntry(section,entryValue) {\n    var propertyRulesId = data.getFileTypeId(\"propertyRules\");\n    var lookupKey = data.getEntryString(propertyRulesId,section,entryValue);\n    var fileEntryList = data.getEntryListFromRefString(lookupKey);\n    if(fileEntryList.length === 0) {\n        throw new Error(\"Preset overrides base entry for modifies not found: \" + entryValue);\n    }\n    //if there are multiple (different option names), they should all be equally valid for this purpose\n    return fileEntryList[0];\n}\n\nfunction createChildKeyEntry(section,parentLegacyKey,parentLegacyValue,childProp) {\n    \n    if(childProp.type != \"enum\") {\n        throw new Error(\"Preset override reconstruct supports only child key entry of type enum: childProp key = \" + childProp.key);\n    }\n    \n    //for enum, update the values format\n    var newValues = {};\n    childProp.values.forEach((element) => {newValues[element.value] = {}});\n    \n    var newData = {};\n    newData.k = childProp.key;\n    newData.type = childProp.input;\n    newData.values = newValues;\n    \n    var outEntry = {};\n    outEntry.type = \"value\";\n    outEntry.tree = section;\n    outEntry.path = [parentLegacyKey,parentLegacyValue];\n    outEntry.value = legacyValue;\n    outEntry.entry = newData;\n    \n    return outEntry;\n}\n\nfunction createChildValueEntry(section,parentLegacyKey,parentLegacyValue,childProp) {\n    \n    var childKey = childProp.key;\n    \n    if(childProp.values.length > 1) {\n        throw new Error(\"Preset override reconstruct supports only child value entry with a single added value: childProp key = \" + childKey);\n    }\n    \n    var childValue = childProp.values[0].value;\n    \n    var outEntry = {};\n    outEntry.type = \"value\";\n    outEntry.tree = section;\n    outEntry.path = [parentLegacyKey,parentLegacyValue,childKey];\n    outEntry.value = legacyValue;\n    outEntry.entry = {};\n    \n    return outEntry;\n}\n\nfunction createNamedOutEntryList(inEntry) {\n    //we support a very restricted set in this conversion - address key additions\n    if(inEntry.modifies != \"address keys\") {\n        throw new Error(\"Unsupported named entry in preset overrides conversion: \" + inEntry.modifies);\n    }\n    \n    if(inEntry.properties.length !== 1) {\n        throw new Error(\"Preset override resonctruct supports only a single property!\");\n    }\n    var addressProp = inEntry.properties[0];\n    if(addressProp.key != \"address keys\") {\n        throw new Error(\"Unsupported named entry key in preset overrides conversion: \" + addressProp.key);\n    }\n    if(addressProp.action != \"modifies\") {\n        throw new Error(\"Unsupported named key action in preset overrides conversion: \" + addressProp.action);\n    }\n    \n    var createNewEntry = (listEntry) => ({\"name\": \"address keys\",\"value\": listEntry.value,\"entry\": {}});\n    var outEntryList = addressProp.values.map(createNewEntry);\n    \n    return outEntryList;\n}\n    ","description":""}}}},"baseFile":{"name":"baseFile","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"//initialize, and load working data if applicable\nvar output = {};\noutput.nm = metaFileRecord.Fields.name;\noutput.data = {};\n\nvar isRecipeEntry = entry => entry.Type == \"recipe_entry\";\nvar addToOutput = recipeEntry => processEntry(output,metaFileRecord,recipeEntry,fileEntry);\n\nsupportingRecordList.filter(isRecipeEntry).map(addToOutput);\n\nreturn output;","supplementalCode":"function processEntry(outFile,metaFile,recipeEntry) {\n    \n    var fileEntry = lookupFileEntry(\"file_entry\",recipeEntry.Fields.file_entry_id);\n    if(!fileEntry) {\n        throw new Error(\"File entry not found. id=\" + recipeEntry.Fields.file_entry_id);\n    }\n    \n    //get the section or subsection to which this should be added\n    var ourSection;\n    var sectionName = fileEntry.Fields.entry_section;\n    var insertionInfo = recipeEntry.Fields.insertion_info;\n    if(insertionInfo != null) {\n        var subsectionEntry;\n        if(insertionInfo.taggedEntry !== undefined) {\n            subsectionEntry = getTaggedSubsection(outFile,sectionName,insertionInfo.taggedEntry);\n        }\n        else if(insertionInfo.orderedEntry !== undefined) {\n            subsectionEntry = getOrderedSubsection(outFile,sectionName,insertionInfo.orderedEntry);\n        }\n        else {\n            throw new Error(\"unrecognized subsection type\");\n        }\n        outSection = subsectionEntry;\n    } \n    else if(sectionName) {\n        outSection = getMapSection(outFile,sectionName);\n    }\n    else {\n        outSection = outFile.data;\n    }\n\n\n    //insert the data\n    var key = fileEntry.Fields.entry_value;\n    var data = fileEntry.Fields.entry_data;\n    \n    if(outSection[key] !== undefined) {\n        throw new Error(\"Repeat key! section: \" + sectionName + \". Key: \" + key);\n    }\n\n    outSection[key] = data;\n}\n\nfunction getMapSection(outFile,sectionName) {\n    var sectionEntry = outFile.data[sectionName];\n    if(sectionEntry === undefined) {\n        sectionEntry = {};\n        outFile.data[sectionName] = sectionEntry;\n    }\n    return sectionEntry;\n}\n\nfunction getTaggedSubsection(outFile,sectionName,tag) {\n    var sectionEntry = getMapSection(outFile,sectionName);\n    var subsectionEntry = sectionEntry[tag];\n    if(subsectionEntry === undefined) {\n        subsectionEntry = {};\n        sectionEntry[tag] = subsectionEntry;\n    }\n    return subsectionEntry;\n}\n\nfunction getOrderedSubsection(outFile,sectionName,order) {\n    //read the section\n    var sectionEntry = outFile.data[sectionName];\n    if(!sectionEntry) {\n        sectionEntry = [];\n        outFile.data[sectionName] = sectionEntry;\n    }\n    \n    //get or add the subsection, from the proper ordered location\n    var subsectionEntry;\n    var index = 0;\n    if(sectionEntry.length > 0) {\n        do {\n            var entry = sectionEntry[index];\n            if(entry.order === order) {\n                subsectionEntry = entry;\n            }\n            index++;\n        } while((entry.order < order)&&(index < sectionEntry.length));\n    }\n    \n    if(!subsectionEntry) {\n        subsectionEntry = {};\n        subsectionEntry.order = order;\n        subsectionEntry.entries = {};\n        sectionEntry.splice(index,0,subsectionEntry);\n    }\n    return subsectionEntry.entries;\n}\n\n","description":"This is the default file constructed from the inputs, according to a standard formula. An alternate file may be desired, in which case it can be constructed based on this file."}},"outFileType":{"name":"outFileType","type":"apogee.JsonTable","updateData":{"data":"theme","description":"This is the type of out file to create."}},"lookupFileEntry":{"name":"lookupFileEntry","type":"apogee.FunctionTable","updateData":{"argList":["fileType","id"],"functionBody":"return recordMap[fileType][id];","supplementalCode":"","description":""}},"recordMap":{"name":"recordMap","type":"apogee.JsonTable","updateData":{"data":{"file_entry":{}},"description":"This is a record map which should include all the needed file entries for the given meta file. The record map should be in the format:\n\n{\n    [file type 1]: {\n        [id]: [record],\n        ...\n    },\n    ...\n}\n\n"}},"metaFileRecord":{"name":"metaFileRecord","type":"apogee.JsonTable","updateData":{"data":{"edit_perm":15,"Type":"meta_file","Fields":{"name":"Modern","file_type_id":23,"file_context":"public"},"edit_ok":true,"read_perm":2,"Id":2},"description":"This is the meta file record from the DB."}},"supportingRecordList":{"name":"supportingRecordList","type":"apogee.JsonTable","updateData":{"data":[],"description":"This list of records should include all the recipe entries in the given meta file record.\n\nIt is OK to include additional fields such as any meta ref records, which are also included in a DB download."}},"outputFile":{"name":"outputFile","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"if(outFileType == \"baseFile\") {\n    return baseFile;\n}\nelse if(outFileType) {\n    return reconstruct[outFileType](baseFile);\n}\nelse {\n    return null;\n}","supplementalCode":"","description":""}}}}},"components":{"reconstruct":{"type":"apogeeapp.app.FolderComponent","windowState":{"posInfo":{"x":703,"y":186}},"children":{"presets":{"type":"apogeeapp.app.FolderComponent","windowState":{"posInfo":{"x":55,"y":257}},"children":{"processEntry":{"type":"apogeeapp.app.FunctionComponent","windowState":{"sizeInfo":{"width":915,"height":475},"posInfo":{"x":26,"y":135},"state":0,"viewType":"Private"}},"postProcessFile":{"type":"apogeeapp.app.FunctionComponent","windowState":{"sizeInfo":{"width":734,"height":400},"posInfo":{"x":563,"y":295},"state":0,"viewType":"Code"}},"initialize":{"type":"apogeeapp.app.FunctionComponent","windowState":{"sizeInfo":{"width":385,"height":59},"posInfo":{"x":25,"y":25},"state":0,"viewType":"Code"}}}},"themeMap":{"type":"apogeeapp.app.FunctionComponent","windowState":{"sizeInfo":{"width":922,"height":686},"posInfo":{"x":310,"y":21},"state":-1,"viewType":"Private"}},"inputColors":{"type":"apogeeapp.app.FunctionComponent","windowState":{"sizeInfo":{"width":632,"height":400},"posInfo":{"x":306,"y":69},"state":-1,"viewType":"Code"}},"strings":{"type":"apogeeapp.app.FunctionComponent","windowState":{"sizeInfo":{"width":712,"height":528},"posInfo":{"x":575,"y":26},"state":-1,"viewType":"Code"}},"theme":{"type":"apogeeapp.app.FunctionComponent","windowState":{"sizeInfo":{"width":641,"height":400},"posInfo":{"x":79,"y":21},"state":-1,"viewType":"Code"}},"presetOverride":{"type":"apogeeapp.app.FunctionComponent","windowState":{"sizeInfo":{"width":1043,"height":625},"posInfo":{"x":243,"y":118},"state":0,"viewType":"Code"}}}},"baseFile":{"type":"apogeeapp.app.JsonTableComponent","windowState":{"sizeInfo":{"width":785,"height":214},"posInfo":{"x":703,"y":132},"state":-1,"viewType":"Formula"}},"outFileType":{"type":"apogeeapp.app.JsonTableComponent","windowState":{"sizeInfo":{"width":315,"height":37},"posInfo":{"x":33,"y":23},"state":0,"viewType":"Notes"}},"lookupFileEntry":{"type":"apogeeapp.app.FunctionComponent","windowState":{"sizeInfo":{"width":358,"height":0},"posInfo":{"x":689,"y":32},"state":-1,"viewType":"Code"}},"recordMap":{"type":"apogeeapp.app.JsonTableComponent","windowState":{"sizeInfo":{"width":561,"height":316},"posInfo":{"x":38,"y":302},"state":0,"viewType":"Notes"}},"metaFileRecord":{"type":"apogeeapp.app.JsonTableComponent","windowState":{"sizeInfo":{"width":317,"height":36},"posInfo":{"x":33,"y":113},"state":0,"viewType":"Notes"}},"supportingRecordList":{"type":"apogeeapp.app.JsonTableComponent","windowState":{"sizeInfo":{"width":504,"height":52},"posInfo":{"x":32,"y":203},"state":0,"viewType":"Notes"}},"outputFile":{"type":"apogeeapp.app.JsonTableComponent","windowState":{"sizeInfo":{"width":520,"height":460},"posInfo":{"x":706,"y":240},"state":-1,"viewType":"JSON"}}}}