{"version":3,"file":"index.js","sources":["../src/diff.js","../src/fragment.js","../src/comparedeep.js","../src/mark.js","../src/replace.js","../src/resolvedpos.js","../src/node.js","../src/content.js","../src/schema.js","../src/from_dom.js","../src/to_dom.js"],"sourcesContent":["export function findDiffStart(a, b, pos) {\n  for (let i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      return a.childCount == b.childCount ? null : pos\n\n    let childA = a.child(i), childB = b.child(i)\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) return pos\n\n    if (childA.isText && childA.text != childB.text) {\n      for (let j = 0; childA.text[j] == childB.text[j]; j++)\n        pos++\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffStart(childA.content, childB.content, pos + 1)\n      if (inner != null) return inner\n    }\n    pos += childA.nodeSize\n  }\n}\n\nexport function findDiffEnd(a, b, posA, posB) {\n  for (let iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      return iA == iB ? null : {a: posA, b: posB}\n\n    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize\n    if (childA == childB) {\n      posA -= size; posB -= size\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) return {a: posA, b: posB}\n\n    if (childA.isText && childA.text != childB.text) {\n      let same = 0, minSize = Math.min(childA.text.length, childB.text.length)\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1)\n      if (inner) return inner\n    }\n    posA -= size; posB -= size\n  }\n}\n","import {findDiffStart, findDiffEnd} from \"./diff\"\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nexport class Fragment {\n  constructor(content, size) {\n    this.content = content\n    // :: number\n    // The size of the fragment, which is the total of the size of its\n    // content nodes.\n    this.size = size || 0\n    if (size == null) for (let i = 0; i < content.length; i++)\n      this.size += content[i].nodeSize\n  }\n\n  // :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes between the given two\n  // positions (relative to start of this fragment). Doesn't descend\n  // into a node when the callback returns `false`.\n  nodesBetween(from, to, f, nodeStart = 0, parent) {\n    for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n        let start = pos + 1\n        child.nodesBetween(Math.max(0, from - start),\n                           Math.min(child.content.size, to - start),\n                           f, nodeStart + start)\n      }\n      pos = end\n    }\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. The callback\n  // may return `false` to prevent traversal of a given node's children.\n  descendants(f) {\n    this.nodesBetween(0, this.size, f)\n  }\n\n  // : (number, number, ?string, ?string) → string\n  textBetween(from, to, blockSeparator, leafText) {\n    let text = \"\", separated = true\n    this.nodesBetween(from, to, (node, pos) => {\n      if (node.isText) {\n        text += node.text.slice(Math.max(from, pos) - pos, to - pos)\n        separated = !blockSeparator\n      } else if (node.isLeaf && leafText) {\n        text += leafText\n        separated = !blockSeparator\n      } else if (!separated && node.isBlock) {\n        text += blockSeparator\n        separated = true\n      }\n    }, 0)\n    return text\n  }\n\n  // :: (Fragment) → Fragment\n  // Create a new fragment containing the combined content of this\n  // fragment and the other.\n  append(other) {\n    if (!other.size) return this\n    if (!this.size) return other\n    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0\n    if (last.isText && last.sameMarkup(first)) {\n      content[content.length - 1] = last.withText(last.text + first.text)\n      i = 1\n    }\n    for (; i < other.content.length; i++) content.push(other.content[i])\n    return new Fragment(content, this.size + other.size)\n  }\n\n  // :: (number, ?number) → Fragment\n  // Cut out the sub-fragment between the two given positions.\n  cut(from, to) {\n    if (to == null) to = this.size\n    if (from == 0 && to == this.size) return this\n    let result = [], size = 0\n    if (to > from) for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from) {\n        if (pos < from || end > to) {\n          if (child.isText)\n            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos))\n          else\n            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1))\n        }\n        result.push(child)\n        size += child.nodeSize\n      }\n      pos = end\n    }\n    return new Fragment(result, size)\n  }\n\n  cutByIndex(from, to) {\n    if (from == to) return Fragment.empty\n    if (from == 0 && to == this.content.length) return this\n    return new Fragment(this.content.slice(from, to))\n  }\n\n  // :: (number, Node) → Fragment\n  // Create a new fragment in which the node at the given index is\n  // replaced by the given node.\n  replaceChild(index, node) {\n    let current = this.content[index]\n    if (current == node) return this\n    let copy = this.content.slice()\n    let size = this.size + node.nodeSize - current.nodeSize\n    copy[index] = node\n    return new Fragment(copy, size)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by prepending the given node to this\n  // fragment.\n  addToStart(node) {\n    return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by appending the given node to this\n  // fragment.\n  addToEnd(node) {\n    return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n  }\n\n  // :: (Fragment) → bool\n  // Compare this fragment to another one.\n  eq(other) {\n    if (this.content.length != other.content.length) return false\n    for (let i = 0; i < this.content.length; i++)\n      if (!this.content[i].eq(other.content[i])) return false\n    return true\n  }\n\n  // :: ?Node\n  // The first child of the fragment, or `null` if it is empty.\n  get firstChild() { return this.content.length ? this.content[0] : null }\n\n  // :: ?Node\n  // The last child of the fragment, or `null` if it is empty.\n  get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null }\n\n  // :: number\n  // The number of child nodes in this fragment.\n  get childCount() { return this.content.length }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raise an error when the\n  // index is out of range.\n  child(index) {\n    let found = this.content[index]\n    if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this)\n    return found\n  }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) {\n    return this.content[index]\n  }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) {\n    for (let i = 0, p = 0; i < this.content.length; i++) {\n      let child = this.content[i]\n      f(child, p, i)\n      p += child.nodeSize\n    }\n  }\n\n  // :: (Fragment) → ?number\n  // Find the first position at which this fragment and another\n  // fragment differ, or `null` if they are the same.\n  findDiffStart(other, pos = 0) {\n    return findDiffStart(this, other, pos)\n  }\n\n  // :: (Fragment) → ?{a: number, b: number}\n  // Find the first position, searching from the end, at which this\n  // fragment and the given fragment differ, or `null` if they are the\n  // same. Since this position will not be the same in both nodes, an\n  // object with two separate positions is returned.\n  findDiffEnd(other, pos = this.size, otherPos = other.size) {\n    return findDiffEnd(this, other, pos, otherPos)\n  }\n\n  // : (number, ?number) → {index: number, offset: number}\n  // Find the index and inner offset corresponding to a given relative\n  // position in this fragment. The result object will be reused\n  // (overwritten) the next time the function is called. (Not public.)\n  findIndex(pos, round = -1) {\n    if (pos == 0) return retIndex(0, pos)\n    if (pos == this.size) return retIndex(this.content.length, pos)\n    if (pos > this.size || pos < 0) throw new RangeError(`Position ${pos} outside of fragment (${this})`)\n    for (let i = 0, curPos = 0;; i++) {\n      let cur = this.child(i), end = curPos + cur.nodeSize\n      if (end >= pos) {\n        if (end == pos || round > 0) return retIndex(i + 1, end)\n        return retIndex(i, curPos)\n      }\n      curPos = end\n    }\n  }\n\n  // :: () → string\n  // Return a debugging string that describes this fragment.\n  toString() { return \"<\" + this.toStringInner() + \">\" }\n\n  toStringInner() { return this.content.join(\", \") }\n\n  // :: () → ?Object\n  // Create a JSON-serializeable representation of this fragment.\n  toJSON() {\n    return this.content.length ? this.content.map(n => n.toJSON()) : null\n  }\n\n  // :: (Schema, ?Object) → Fragment\n  // Deserialize a fragment from its JSON representation.\n  static fromJSON(schema, value) {\n    if (!value) return Fragment.empty\n    if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\")\n    return new Fragment(value.map(schema.nodeFromJSON))\n  }\n\n  // :: ([Node]) → Fragment\n  // Build a fragment from an array of nodes. Ensures that adjacent\n  // text nodes with the same marks are joined together.\n  static fromArray(array) {\n    if (!array.length) return Fragment.empty\n    let joined, size = 0\n    for (let i = 0; i < array.length; i++) {\n      let node = array[i]\n      size += node.nodeSize\n      if (i && node.isText && array[i - 1].sameMarkup(node)) {\n        if (!joined) joined = array.slice(0, i)\n        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text)\n      } else if (joined) {\n        joined.push(node)\n      }\n    }\n    return new Fragment(joined || array, size)\n  }\n\n  // :: (?union<Fragment, Node, [Node]>) → Fragment\n  // Create a fragment from something that can be interpreted as a set\n  // of nodes. For `null`, it returns the empty fragment. For a\n  // fragment, the fragment itself. For a node or array of nodes, a\n  // fragment containing those nodes.\n  static from(nodes) {\n    if (!nodes) return Fragment.empty\n    if (nodes instanceof Fragment) return nodes\n    if (Array.isArray(nodes)) return this.fromArray(nodes)\n    if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize)\n    throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                         (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n  }\n}\n\nconst found = {index: 0, offset: 0}\nfunction retIndex(index, offset) {\n  found.index = index\n  found.offset = offset\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0)\n","export function compareDeep(a, b) {\n  if (a === b) return true\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) return false\n  let array = Array.isArray(a)\n  if (Array.isArray(b) != array) return false\n  if (array) {\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false\n  } else {\n    for (let p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false\n    for (let p in b) if (!(p in a)) return false\n  }\n  return true\n}\n","import {compareDeep} from \"./comparedeep\"\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nexport class Mark {\n  constructor(type, attrs) {\n    // :: MarkType\n    // The type of this mark.\n    this.type = type\n    // :: Object\n    // The attributes associated with this mark.\n    this.attrs = attrs\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Given a set of marks, create a new set which contains this one as\n  // well, in the right position. If this mark is already in the set,\n  // the set itself is returned. If any marks that are set to be\n  // [exclusive](#model.MarkSpec.excludes) with this mark are present,\n  // those are replaced by this one.\n  addToSet(set) {\n    let copy, placed = false\n    for (let i = 0; i < set.length; i++) {\n      let other = set[i]\n      if (this.eq(other)) return set\n      if (this.type.excludes(other.type)) {\n        if (!copy) copy = set.slice(0, i)\n      } else if (other.type.excludes(this.type)) {\n        return set\n      } else {\n        if (!placed && other.type.rank > this.type.rank) {\n          if (!copy) copy = set.slice(0, i)\n          copy.push(this)\n          placed = true\n        }\n        if (copy) copy.push(other)\n      }\n    }\n    if (!copy) copy = set.slice()\n    if (!placed) copy.push(this)\n    return copy\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Remove this mark from the given set, returning a new set. If this\n  // mark is not in the set, the set itself is returned.\n  removeFromSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i]))\n        return set.slice(0, i).concat(set.slice(i + 1))\n    return set\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether this mark is in the given set of marks.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i])) return true\n    return false\n  }\n\n  // :: (Mark) → bool\n  // Test whether this mark has the same type and attributes as\n  // another mark.\n  eq(other) {\n    return this == other ||\n      (this.type == other.type && compareDeep(this.attrs, other.attrs))\n  }\n\n  // :: () → Object\n  // Convert this mark to a JSON-serializeable representation.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    return obj\n  }\n\n  // :: (Schema, Object) → Mark\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\")\n    let type = schema.marks[json.type]\n    if (!type) throw new RangeError(`There is no mark type ${json.type} in this schema`)\n    return type.create(json.attrs)\n  }\n\n  // :: ([Mark], [Mark]) → bool\n  // Test whether two sets of marks are identical.\n  static sameSet(a, b) {\n    if (a == b) return true\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++)\n      if (!a[i].eq(b[i])) return false\n    return true\n  }\n\n  // :: (?union<Mark, [Mark]>) → [Mark]\n  // Create a properly sorted mark set from null, a single mark, or an\n  // unsorted array of marks.\n  static setFrom(marks) {\n    if (!marks || marks.length == 0) return Mark.none\n    if (marks instanceof Mark) return [marks]\n    let copy = marks.slice()\n    copy.sort((a, b) => a.type.rank - b.type.rank)\n    return copy\n  }\n}\n\n// :: [Mark] The empty set of marks.\nMark.none = []\n","import {Fragment} from \"./fragment\"\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nexport function ReplaceError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = ReplaceError.prototype\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = \"ReplaceError\"\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\nexport class Slice {\n  // :: (Fragment, number, number)\n  // Create a slice. When specifying a non-zero open depth, you must\n  // make sure that there are nodes of at least that depth at the\n  // appropriate side of the fragment—i.e. if the fragment is an empty\n  // paragraph node, `openStart` and `openEnd` can't be greater than 1.\n  //\n  // It is not necessary for the content of open nodes to conform to\n  // the schema's content constraints, though it should be a valid\n  // start/end/middle for such a node, depending on which sides are\n  // open.\n  constructor(content, openStart, openEnd) {\n    // :: Fragment The slice's content.\n    this.content = content\n    // :: number The open depth at the start.\n    this.openStart = openStart\n    // :: number The open depth at the end.\n    this.openEnd = openEnd\n  }\n\n  // :: number\n  // The size this slice would add when inserted into a document.\n  get size() {\n    return this.content.size - this.openStart - this.openEnd\n  }\n\n  insertAt(pos, fragment) {\n    let content = insertInto(this.content, pos + this.openStart, fragment, null)\n    return content && new Slice(content, this.openStart, this.openEnd)\n  }\n\n  removeBetween(from, to) {\n    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n  }\n\n  // :: (Slice) → bool\n  // Tests whether this slice is equal to another slice.\n  eq(other) {\n    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n  }\n\n  toString() {\n    return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n  }\n\n  // :: () → ?Object\n  // Convert a slice to a JSON-serializable representation.\n  toJSON() {\n    if (!this.content.size) return null\n    let json = {content: this.content.toJSON()}\n    if (this.openStart > 0) json.openStart = this.openStart\n    if (this.openEnd > 0) json.openEnd = this.openEnd\n    return json\n  }\n\n  // :: (Schema, ?Object) → Slice\n  // Deserialize a slice from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) return Slice.empty\n    let openStart = json.openStart || 0, openEnd = json.openEnd || 0\n    if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n      throw new RangeError(\"Invalid input for Slice.fromJSON\")\n    return new Slice(Fragment.fromJSON(schema, json.content), json.openStart || 0, json.openEnd || 0)\n  }\n\n  // :: (Fragment, ?bool) → Slice\n  // Create a slice from a fragment by taking the maximum possible\n  // open value on both side of the fragment.\n  static maxOpen(fragment, openIsolating=true) {\n    let openStart = 0, openEnd = 0\n    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++\n    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild) openEnd++\n    return new Slice(fragment, openStart, openEnd)\n  }\n}\n\nfunction removeRange(content, from, to) {\n  let {index, offset} = content.findIndex(from), child = content.maybeChild(index)\n  let {index: indexTo, offset: offsetTo} = content.findIndex(to)\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\")\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) throw new RangeError(\"Removing non-flat range\")\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  let {index, offset} = content.findIndex(dist), child = content.maybeChild(index)\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) return null\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  let inner = insertInto(child.content, dist - offset - 1, insert)\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0)\n\nexport function replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    throw new ReplaceError(\"Inserted content deeper than insertion position\")\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    throw new ReplaceError(\"Inconsistent open depths\")\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  let index = $from.index(depth), node = $from.node(depth)\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    let inner = replaceOuter($from, $to, slice, depth + 1)\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    let parent = $from.parent, content = parent.content\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    let {start, end} = prepareSliceForReplace(slice, $from)\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name)\n}\n\nfunction joinable($before, $after, depth) {\n  let node = $before.node(depth)\n  checkJoin(node, $after.node(depth))\n  return node\n}\n\nfunction addNode(child, target) {\n  let last = target.length - 1\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    target[last] = child.withText(target[last].text + child.text)\n  else\n    target.push(child)\n}\n\nfunction addRange($start, $end, depth, target) {\n  let node = ($end || $start).node(depth)\n  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount\n  if ($start) {\n    startIndex = $start.index(depth)\n    if ($start.depth > depth) {\n      startIndex++\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target)\n      startIndex++\n    }\n  }\n  for (let i = startIndex; i < endIndex; i++) addNode(node.child(i), target)\n  if ($end && $end.depth == depth && $end.textOffset)\n    addNode($end.nodeBefore, target)\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    throw new ReplaceError(\"Invalid content for node \" + node.type.name)\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  let openStart = $from.depth > depth && joinable($from, $start, depth + 1)\n  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1)\n\n  let content = []\n  addRange(null, $from, depth, content)\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd)\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content)\n  } else {\n    if (openStart)\n      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content)\n    addRange($start, $end, depth, content)\n    if (openEnd)\n      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  let content = []\n  addRange(null, $from, depth, content)\n  if ($from.depth > depth) {\n    let type = joinable($from, $to, depth + 1)\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  let extra = $along.depth - slice.openStart, parent = $along.node(extra)\n  let node = parent.copy(slice.content)\n  for (let i = extra - 1; i >= 0; i--)\n    node = $along.node(i).copy(Fragment.from(node))\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n","import {Mark} from \"./mark\"\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nexport class ResolvedPos {\n  constructor(pos, path, parentOffset) {\n    // :: number The position that was resolved.\n    this.pos = pos\n    this.path = path\n    // :: number\n    // The number of levels the parent node is from the root. If this\n    // position points directly into the root node, it is 0. If it\n    // points into a top-level paragraph, 1, and so on.\n    this.depth = path.length / 3 - 1\n    // :: number The offset this position has into its parent node.\n    this.parentOffset = parentOffset\n  }\n\n  resolveDepth(val) {\n    if (val == null) return this.depth\n    if (val < 0) return this.depth + val\n    return val\n  }\n\n  // :: Node\n  // The parent node that the position points into. Note that even if\n  // a position points into a text node, that node is not considered\n  // the parent—text nodes are ‘flat’ in this model, and have no content.\n  get parent() { return this.node(this.depth) }\n\n  // :: Node\n  // The root node in which the position was resolved.\n  get doc() { return this.node(0) }\n\n  // :: (?number) → Node\n  // The ancestor node at the given level. `p.node(p.depth)` is the\n  // same as `p.parent`.\n  node(depth) { return this.path[this.resolveDepth(depth) * 3] }\n\n  // :: (?number) → number\n  // The index into the ancestor at the given level. If this points at\n  // the 3rd node in the 2nd paragraph on the top level, for example,\n  // `p.index(0)` is 2 and `p.index(1)` is 3.\n  index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1] }\n\n  // :: (?number) → number\n  // The index pointing after this position into the ancestor at the\n  // given level.\n  indexAfter(depth) {\n    depth = this.resolveDepth(depth)\n    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the start of the node at the given\n  // level.\n  start(depth) {\n    depth = this.resolveDepth(depth)\n    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the end of the node at the given\n  // level.\n  end(depth) {\n    depth = this.resolveDepth(depth)\n    return this.start(depth) + this.node(depth).content.size\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly before the wrapping node at the\n  // given level, or, when `level` is `this.depth + 1`, the original\n  // position.\n  before(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position before the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly after the wrapping node at the\n  // given level, or the original position when `level` is `this.depth + 1`.\n  after(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position after the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n  }\n\n  // :: number\n  // When this position points into a text node, this returns the\n  // distance between the position and the start of the text node.\n  // Will be zero for positions that point between nodes.\n  get textOffset() { return this.pos - this.path[this.path.length - 1] }\n\n  // :: ?Node\n  // Get the node directly after the position, if any. If the position\n  // points into a text node, only the part of that node after the\n  // position is returned.\n  get nodeAfter() {\n    let parent = this.parent, index = this.index(this.depth)\n    if (index == parent.childCount) return null\n    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index)\n    return dOff ? parent.child(index).cut(dOff) : child\n  }\n\n  // :: ?Node\n  // Get the node directly before the position, if any. If the\n  // position points into a text node, only the part of that node\n  // before the position is returned.\n  get nodeBefore() {\n    let index = this.index(this.depth)\n    let dOff = this.pos - this.path[this.path.length - 1]\n    if (dOff) return this.parent.child(index).cut(0, dOff)\n    return index == 0 ? null : this.parent.child(index - 1)\n  }\n\n  // :: () → [Mark]\n  // Get the marks at this position, factoring in the surrounding\n  // marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n  // position is at the start of a non-empty node, the marks of the\n  // node after it (if any) are returned.\n  marks() {\n    let parent = this.parent, index = this.index()\n\n    // In an empty parent, return the empty array\n    if (parent.content.size == 0) return Mark.none\n\n    // When inside a text node, just return the text node's marks\n    if (this.textOffset) return parent.child(index).marks\n\n    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index)\n    // If the `after` flag is true of there is no node before, make\n    // the node after this position the main reference.\n    if (!main) { let tmp = main; main = other; other = tmp }\n\n    // Use all marks in the main node, except those that have\n    // `inclusive` set to false and are not present in the other node.\n    let marks = main.marks\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n        marks = marks[i--].removeFromSet(marks)\n\n    return marks\n  }\n\n  // :: (ResolvedPos) → ?[Mark]\n  // Get the marks after the current position, if any, except those\n  // that are non-inclusive and not present at position `$end`. This\n  // is mostly useful for getting the set of marks to preserve after a\n  // deletion. Will return `null` if this position is at the end of\n  // its parent node or its parent node isn't a textblock (in which\n  // case no marks should be preserved).\n  marksAcross($end) {\n    let after = this.parent.maybeChild(this.index())\n    if (!after || !after.isInline) return null\n\n    let marks = after.marks, next = $end.parent.maybeChild($end.index())\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n        marks = marks[i--].removeFromSet(marks)\n    return marks\n  }\n\n  // :: (number) → number\n  // The depth up to which this position and the given (non-resolved)\n  // position share the same parent nodes.\n  sharedDepth(pos) {\n    for (let depth = this.depth; depth > 0; depth--)\n      if (this.start(depth) <= pos && this.end(depth) >= pos) return depth\n    return 0\n  }\n\n  // :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n  // Returns a range based on the place where this position and the\n  // given position diverge around block content. If both point into\n  // the same textblock, for example, a range around that textblock\n  // will be returned. If they point into different blocks, the range\n  // around those blocks in their shared ancestor is returned. You can\n  // pass in an optional predicate that will be called with a parent\n  // node to see if a range into that parent is acceptable.\n  blockRange(other = this, pred) {\n    if (other.pos < this.pos) return other.blockRange(this)\n    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n        return new NodeRange(this, other, d)\n  }\n\n  // :: (ResolvedPos) → bool\n  // Query whether the given position shares the same parent node.\n  sameParent(other) {\n    return this.pos - this.parentOffset == other.pos - other.parentOffset\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the greater of this and the given position.\n  max(other) {\n    return other.pos > this.pos ? other : this\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the smaller of this and the given position.\n  min(other) {\n    return other.pos < this.pos ? other : this\n  }\n\n  toString() {\n    let str = \"\"\n    for (let i = 1; i <= this.depth; i++)\n      str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1)\n    return str + \":\" + this.parentOffset\n  }\n\n  static resolve(doc, pos) {\n    if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\")\n    let path = []\n    let start = 0, parentOffset = pos\n    for (let node = doc;;) {\n      let {index, offset} = node.content.findIndex(parentOffset)\n      let rem = parentOffset - offset\n      path.push(node, index, start + offset)\n      if (!rem) break\n      node = node.child(index)\n      if (node.isText) break\n      parentOffset = rem - 1\n      start += offset + 1\n    }\n    return new ResolvedPos(pos, path, parentOffset)\n  }\n\n  static resolveCached(doc, pos) {\n    for (let i = 0; i < resolveCache.length; i++) {\n      let cached = resolveCache[i]\n      if (cached.pos == pos && cached.doc == doc) return cached\n    }\n    let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos)\n    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize\n    return result\n  }\n}\n\nlet resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nexport class NodeRange {\n  // :: (ResolvedPos, ResolvedPos, number)\n  // Construct a node range. `$from` and `$to` should point into the\n  // same node until at least the given `depth`, since a node range\n  // denotes an adjacent set of nodes in a single parent node.\n  constructor($from, $to, depth) {\n    // :: ResolvedPos A resolved position along the start of the\n    // content. May have a `depth` greater than this object's `depth`\n    // property, since these are the positions that were used to\n    // compute the range, not re-resolved positions directly at its\n    // boundaries.\n    this.$from = $from\n    // :: ResolvedPos A position along the end of the content. See\n    // caveat for [`$from`](#model.NodeRange.$from).\n    this.$to = $to\n    // :: number The depth of the node that this range points into.\n    this.depth = depth\n  }\n\n  // :: number The position at the start of the range.\n  get start() { return this.$from.before(this.depth + 1) }\n  // :: number The position at the end of the range.\n  get end() { return this.$to.after(this.depth + 1) }\n\n  // :: Node The parent node that the range points into.\n  get parent() { return this.$from.node(this.depth) }\n  // :: number The start index of the range in the parent node.\n  get startIndex() { return this.$from.index(this.depth) }\n  // :: number The end index of the range in the parent node.\n  get endIndex() { return this.$to.indexAfter(this.depth) }\n}\n","import {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {Slice, replace} from \"./replace\"\nimport {ResolvedPos} from \"./resolvedpos\"\nimport {compareDeep} from \"./comparedeep\"\n\nconst emptyAttrs = Object.create(null)\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nexport class Node {\n  constructor(type, attrs, content, marks) {\n    // :: NodeType\n    // The type of node that this is.\n    this.type = type\n\n    // :: Object\n    // An object mapping attribute names to values. The kind of\n    // attributes allowed and required are\n    // [determined](#model.NodeSpec.attrs) by the node type.\n    this.attrs = attrs\n\n    // :: Fragment\n    // A container holding the node's children.\n    this.content = content || Fragment.empty\n\n    // :: [Mark]\n    // The marks (things like whether it is emphasized or part of a\n    // link) applied to this node.\n    this.marks = marks || Mark.none\n  }\n\n  // text:: ?string\n  // For text nodes, this contains the node's text content.\n\n  // :: number\n  // The size of this node, as defined by the integer-based [indexing\n  // scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n  // amount of characters. For other leaf nodes, it is one. For\n  // non-leaf nodes, it is the size of the content plus two (the start\n  // and end token).\n  get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size }\n\n  // :: number\n  // The number of children that the node has.\n  get childCount() { return this.content.childCount }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raises an error when the\n  // index is out of range.\n  child(index) { return this.content.child(index) }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) { return this.content.maybeChild(index) }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) { this.content.forEach(f) }\n\n  // :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes recursively between\n  // the given two positions that are relative to start of this node's\n  // content. The callback is invoked with the node, its\n  // parent-relative position, its parent node, and its child index.\n  // When the callback returns false for a given node, that node's\n  // children will not be recursed over. The last parameter can be\n  // used to specify a starting position to count from.\n  nodesBetween(from, to, f, startPos = 0) {\n    this.content.nodesBetween(from, to, f, startPos, this)\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. Doesn't\n  // descend into a node when the callback returns `false`.\n  descendants(f) {\n    this.nodesBetween(0, this.content.size, f)\n  }\n\n  // :: string\n  // Concatenates all the text nodes found in this fragment and its\n  // children.\n  get textContent() { return this.textBetween(0, this.content.size, \"\") }\n\n  // :: (number, number, ?string, ?string) → string\n  // Get all text between positions `from` and `to`. When\n  // `blockSeparator` is given, it will be inserted whenever a new\n  // block node is started. When `leafText` is given, it'll be\n  // inserted for every non-text leaf node encountered.\n  textBetween(from, to, blockSeparator, leafText) {\n    return this.content.textBetween(from, to, blockSeparator, leafText)\n  }\n\n  // :: ?Node\n  // Returns this node's first child, or `null` if there are no\n  // children.\n  get firstChild() { return this.content.firstChild }\n\n  // :: ?Node\n  // Returns this node's last child, or `null` if there are no\n  // children.\n  get lastChild() { return this.content.lastChild }\n\n  // :: (Node) → bool\n  // Test whether two nodes represent the same piece of document.\n  eq(other) {\n    return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n  }\n\n  // :: (Node) → bool\n  // Compare the markup (type, attributes, and marks) of this node to\n  // those of another. Returns `true` if both have the same markup.\n  sameMarkup(other) {\n    return this.hasMarkup(other.type, other.attrs, other.marks)\n  }\n\n  // :: (NodeType, ?Object, ?[Mark]) → bool\n  // Check whether this node's markup correspond to the given type,\n  // attributes, and marks.\n  hasMarkup(type, attrs, marks) {\n    return this.type == type &&\n      compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n      Mark.sameSet(this.marks, marks || Mark.none)\n  }\n\n  // :: (?Fragment) → Node\n  // Create a new node with the same markup as this node, containing\n  // the given content (or empty, if no content is given).\n  copy(content = null) {\n    if (content == this.content) return this\n    return new this.constructor(this.type, this.attrs, content, this.marks)\n  }\n\n  // :: ([Mark]) → Node\n  // Create a copy of this node, with the given set of marks instead\n  // of the node's own marks.\n  mark(marks) {\n    return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n  }\n\n  // :: (number, ?number) → Node\n  // Create a copy of this node with only the content between the\n  // given positions. If `to` is not given, it defaults to the end of\n  // the node.\n  cut(from, to) {\n    if (from == 0 && to == this.content.size) return this\n    return this.copy(this.content.cut(from, to))\n  }\n\n  // :: (number, ?number) → Slice\n  // Cut out the part of the document between the given positions, and\n  // return it as a `Slice` object.\n  slice(from, to = this.content.size, includeParents = false) {\n    if (from == to) return Slice.empty\n\n    let $from = this.resolve(from), $to = this.resolve(to)\n    let depth = includeParents ? 0 : $from.sharedDepth(to)\n    let start = $from.start(depth), node = $from.node(depth)\n    let content = node.content.cut($from.pos - start, $to.pos - start)\n    return new Slice(content, $from.depth - depth, $to.depth - depth)\n  }\n\n  // :: (number, number, Slice) → Node\n  // Replace the part of the document between the given positions with\n  // the given slice. The slice must 'fit', meaning its open sides\n  // must be able to connect to the surrounding content, and its\n  // content nodes must be valid children for the node they are placed\n  // into. If any of this is violated, an error of type\n  // [`ReplaceError`](#model.ReplaceError) is thrown.\n  replace(from, to, slice) {\n    return replace(this.resolve(from), this.resolve(to), slice)\n  }\n\n  // :: (number) → ?Node\n  // Find the node directly after the given position.\n  nodeAt(pos) {\n    for (let node = this;;) {\n      let {index, offset} = node.content.findIndex(pos)\n      node = node.maybeChild(index)\n      if (!node) return null\n      if (offset == pos || node.isText) return node\n      pos -= offset + 1\n    }\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node after the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childAfter(pos) {\n    let {index, offset} = this.content.findIndex(pos)\n    return {node: this.content.maybeChild(index), index, offset}\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node before the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childBefore(pos) {\n    if (pos == 0) return {node: null, index: 0, offset: 0}\n    let {index, offset} = this.content.findIndex(pos)\n    if (offset < pos) return {node: this.content.child(index), index, offset}\n    let node = this.content.child(index - 1)\n    return {node, index: index - 1, offset: offset - node.nodeSize}\n  }\n\n  // :: (number) → ResolvedPos\n  // Resolve the given position in the document, returning an\n  // [object](#model.ResolvedPos) with information about its context.\n  resolve(pos) { return ResolvedPos.resolveCached(this, pos) }\n\n  resolveNoCache(pos) { return ResolvedPos.resolve(this, pos) }\n\n  // :: (number, number, MarkType) → bool\n  // Test whether a mark of the given type occurs in this document\n  // between the two given positions.\n  rangeHasMark(from, to, type) {\n    let found = false\n    if (to > from) this.nodesBetween(from, to, node => {\n      if (type.isInSet(node.marks)) found = true\n      return !found\n    })\n    return found\n  }\n\n  // :: bool\n  // True when this is a block (non-inline node)\n  get isBlock() { return this.type.isBlock }\n\n  // :: bool\n  // True when this is a textblock node, a block node with inline\n  // content.\n  get isTextblock() { return this.type.isTextblock }\n\n  // :: bool\n  // True when this node allows inline content.\n  get inlineContent() { return this.type.inlineContent }\n\n  // :: bool\n  // True when this is an inline node (a text node or a node that can\n  // appear among text).\n  get isInline() { return this.type.isInline }\n\n  // :: bool\n  // True when this is a text node.\n  get isText() { return this.type.isText }\n\n  // :: bool\n  // True when this is a leaf node.\n  get isLeaf() { return this.type.isLeaf }\n\n  // :: bool\n  // True when this is an atom, i.e. when it does not have directly\n  // editable content. This is usually the same as `isLeaf`, but can\n  // be configured with the [`atom` property](#model.NodeSpec.atom) on\n  // a node's spec (typically used when the node is displayed as an\n  // uneditable [node view](#view.NodeView)).\n  get isAtom() { return this.type.isAtom }\n\n  // :: () → string\n  // Return a string representation of this node for debugging\n  // purposes.\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    let name = this.type.name\n    if (this.content.size)\n      name += \"(\" + this.content.toStringInner() + \")\"\n    return wrapMarks(this.marks, name)\n  }\n\n  // :: (number) → ContentMatch\n  // Get the content match in this node at the given index.\n  contentMatchAt(index) {\n    let match = this.type.contentMatch.matchFragment(this.content, 0, index)\n    if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\")\n    return match\n  }\n\n  // :: (number, number, ?Fragment, ?number, ?number) → bool\n  // Test whether replacing the range between `from` and `to` (by\n  // child index) with the given replacement fragment (which defaults\n  // to the empty fragment) would leave the node's content valid. You\n  // can optionally pass `start` and `end` indices into the\n  // replacement fragment.\n  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n    let one = this.contentMatchAt(from).matchFragment(replacement, start, end)\n    let two = one && one.matchFragment(this.content, to)\n    if (!two || !two.validEnd) return false\n    for (let i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false\n    return true\n  }\n\n  // :: (number, number, NodeType, ?[Mark]) → bool\n  // Test whether replacing the range `from` to `to` (by index) with a\n  // node of the given type would leave the node's content valid.\n  canReplaceWith(from, to, type, marks) {\n    if (marks && !this.type.allowsMarks(marks)) return false\n    let start = this.contentMatchAt(from).matchType(type)\n    let end = start && start.matchFragment(this.content, to)\n    return end ? end.validEnd : false\n  }\n\n  // :: (Node) → bool\n  // Test whether the given node's content could be appended to this\n  // node. If that node is empty, this will only return true if there\n  // is at least one node type that can appear in both nodes (to avoid\n  // merging completely incompatible nodes).\n  canAppend(other) {\n    if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content)\n    else return this.type.compatibleContent(other.type)\n  }\n\n  // Unused. Left for backwards compatibility.\n  defaultContentType(at) {\n    return this.contentMatchAt(at).defaultType\n  }\n\n  // :: ()\n  // Check whether this node and its descendants conform to the\n  // schema, and raise error when they do not.\n  check() {\n    if (!this.type.validContent(this.content))\n      throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`)\n    this.content.forEach(node => node.check())\n  }\n\n  // :: () → Object\n  // Return a JSON-serializeable representation of this node.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    if (this.content.size)\n      obj.content = this.content.toJSON()\n    if (this.marks.length)\n      obj.marks = this.marks.map(n => n.toJSON())\n    return obj\n  }\n\n  // :: (Schema, Object) → Node\n  // Deserialize a node from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\")\n    let marks = null\n    if (json.marks) {\n      if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\")\n      marks = json.marks.map(schema.markFromJSON)\n    }\n    if (json.type == \"text\") {\n      if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\")\n      return schema.text(json.text, marks)\n    }\n    let content = Fragment.fromJSON(schema, json.content)\n    return schema.nodeType(json.type).create(json.attrs, content, marks)\n  }\n}\n\nexport class TextNode extends Node {\n  constructor(type, attrs, content, marks) {\n    super(type, attrs, null, marks)\n\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\")\n\n    this.text = content\n  }\n\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  }\n\n  get textContent() { return this.text }\n\n  textBetween(from, to) { return this.text.slice(from, to) }\n\n  get nodeSize() { return this.text.length }\n\n  mark(marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  }\n\n  withText(text) {\n    if (text == this.text) return this\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  }\n\n  cut(from = 0, to = this.text.length) {\n    if (from == 0 && to == this.text.length) return this\n    return this.withText(this.text.slice(from, to))\n  }\n\n  eq(other) {\n    return this.sameMarkup(other) && this.text == other.text\n  }\n\n  toJSON() {\n    let base = super.toJSON()\n    base.text = this.text\n    return base\n  }\n}\n\nfunction wrapMarks(marks, str) {\n  for (let i = marks.length - 1; i >= 0; i--)\n    str = marks[i].type.name + \"(\" + str + \")\"\n  return str\n}\n","import {Fragment} from \"./fragment\"\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nexport class ContentMatch {\n  constructor(validEnd) {\n    // :: bool\n    // True when this match state represents a valid end of the node.\n    this.validEnd = validEnd\n    this.next = []\n    this.wrapCache = []\n  }\n\n  static parse(string, nodeTypes) {\n    let stream = new TokenStream(string, nodeTypes)\n    if (stream.next == null) return ContentMatch.empty\n    let expr = parseExpr(stream)\n    if (stream.next) stream.err(\"Unexpected trailing text\")\n    let match = dfa(nfa(expr))\n    checkForDeadEnds(match, stream)\n    return match\n  }\n\n  // :: (NodeType) → ?ContentMatch\n  // Match a node type, returning a match after that node if\n  // successful.\n  matchType(type) {\n    for (let i = 0; i < this.next.length; i += 2)\n      if (this.next[i] == type) return this.next[i + 1]\n    return null\n  }\n\n  // :: (Fragment, ?number, ?number) → ?ContentMatch\n  // Try to match a fragment. Returns the resulting match when\n  // successful.\n  matchFragment(frag, start = 0, end = frag.childCount) {\n    let cur = this\n    for (let i = start; cur && i < end; i++)\n      cur = cur.matchType(frag.child(i).type)\n    return cur\n  }\n\n  get inlineContent() {\n    let first = this.next[0]\n    return first ? first.isInline : false\n  }\n\n  // :: ?NodeType\n  // Get the first matching node type at this match position that can\n  // be generated.\n  get defaultType() {\n    for (let i = 0; i < this.next.length; i += 2) {\n      let type = this.next[i]\n      if (!(type.isText || type.hasRequiredAttrs())) return type\n    }\n  }\n\n  compatible(other) {\n    for (let i = 0; i < this.next.length; i += 2)\n      for (let j = 0; j < other.next.length; j += 2)\n        if (this.next[i] == other.next[j]) return true\n    return false\n  }\n\n  // :: (Fragment, bool, ?number) → ?Fragment\n  // Try to match the given fragment, and if that fails, see if it can\n  // be made to match by inserting nodes in front of it. When\n  // successful, return a fragment of inserted nodes (which may be\n  // empty if nothing had to be inserted). When `toEnd` is true, only\n  // return a fragment if the resulting match goes to the end of the\n  // content expression.\n  fillBefore(after, toEnd = false, startIndex = 0) {\n    let seen = [this]\n    function search(match, types) {\n      let finished = match.matchFragment(after, startIndex)\n      if (finished && (!toEnd || finished.validEnd))\n        return Fragment.from(types.map(tp => tp.createAndFill()))\n\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i], next = match.next[i + 1]\n        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n          seen.push(next)\n          let found = search(next, types.concat(type))\n          if (found) return found\n        }\n      }\n    }\n\n    return search(this, [])\n  }\n\n  // :: (NodeType) → ?[NodeType]\n  // Find a set of wrapping node types that would allow a node of the\n  // given type to appear at this position. The result may be empty\n  // (when it fits directly) and will be null when no such wrapping\n  // exists.\n  findWrapping(target) {\n    for (let i = 0; i < this.wrapCache.length; i += 2)\n      if (this.wrapCache[i] == target) return this.wrapCache[i + 1]\n    let computed = this.computeWrapping(target)\n    this.wrapCache.push(target, computed)\n    return computed\n  }\n\n  computeWrapping(target) {\n    let seen = Object.create(null), active = [{match: this, type: null, via: null}]\n    while (active.length) {\n      let current = active.shift(), match = current.match\n      if (match.matchType(target)) {\n        let result = []\n        for (let obj = current; obj.type; obj = obj.via)\n          result.push(obj.type)\n        return result.reverse()\n      }\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i]\n        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n          active.push({match: type.contentMatch, type, via: current})\n          seen[type.name] = true\n        }\n      }\n    }\n  }\n\n  // :: number\n  // The number of outgoing edges this node has in the finite\n  // automaton that describes the content expression.\n  get edgeCount() {\n    return this.next.length >> 1\n  }\n\n  // :: (number) → {type: NodeType, next: ContentMatch}\n  // Get the _n_th outgoing edge from this node in the finite\n  // automaton that describes the content expression.\n  edge(n) {\n    let i = n << 1\n    if (i > this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`)\n    return {type: this.next[i], next: this.next[i + 1]}\n  }\n\n  toString() {\n    let seen = []\n    function scan(m) {\n      seen.push(m)\n      for (let i = 1; i < m.next.length; i += 2)\n        if (seen.indexOf(m.next[i]) == -1) scan(m.next[i])\n    }\n    scan(this)\n    return seen.map((m, i) => {\n      let out = i + (m.validEnd ? \"*\" : \" \") + \" \"\n      for (let i = 0; i < m.next.length; i += 2)\n        out += (i ? \", \" : \"\") + m.next[i].name + \"->\" + seen.indexOf(m.next[i + 1])\n      return out\n    }).join(\"\\n\")\n  }\n}\n\nContentMatch.empty = new ContentMatch(true)\n\nclass TokenStream {\n  constructor(string, nodeTypes) {\n    this.string = string\n    this.nodeTypes = nodeTypes\n    this.inline = null\n    this.pos = 0\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/)\n    if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop()\n    if (this.tokens[0] == \"\") this.tokens.unshift()\n  }\n\n  get next() { return this.tokens[this.pos] }\n\n  eat(tok) { return this.next == tok && (this.pos++ || true) }\n\n  err(str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") }\n}\n\nfunction parseExpr(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSeq(stream)) }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n}\n\nfunction parseExprSeq(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSubscript(stream)) }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  let expr = parseExprAtom(stream)\n  for (;;) {\n    if (stream.eat(\"+\"))\n      expr = {type: \"plus\", expr}\n    else if (stream.eat(\"*\"))\n      expr = {type: \"star\", expr}\n    else if (stream.eat(\"?\"))\n      expr = {type: \"opt\", expr}\n    else if (stream.eat(\"{\"))\n      expr = parseExprRange(stream, expr)\n    else break\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\")\n  let result = Number(stream.next)\n  stream.pos++\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  let min = parseNum(stream), max = min\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") max = parseNum(stream)\n    else max = -1\n  }\n  if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\")\n  return {type: \"range\", min, max, expr}\n}\n\nfunction resolveName(stream, name) {\n  let types = stream.nodeTypes, type = types[name]\n  if (type) return [type]\n  let result = []\n  for (let typeName in types) {\n    let type = types[typeName]\n    if (type.groups.indexOf(name) > -1) result.push(type)\n  }\n  if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\")\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    let expr = parseExpr(stream)\n    if (!stream.eat(\")\")) stream.err(\"Missing closing paren\")\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    let exprs = resolveName(stream, stream.next).map(type => {\n      if (stream.inline == null) stream.inline = type.isInline\n      else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\")\n      return {type: \"name\", value: type}\n    })\n    stream.pos++\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\")\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  let nfa = [[]]\n  connect(compile(expr, 0), node())\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    let edge = {term, to}\n    nfa[from].push(edge)\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(edge => edge.to = to) }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), [])\n    } else if (expr.type == \"seq\") {\n      for (let i = 0;; i++) {\n        let next = compile(expr.exprs[i], from)\n        if (i == expr.exprs.length - 1) return next\n        connect(next, from = node())\n      }\n    } else if (expr.type == \"star\") {\n      let loop = node()\n      edge(from, loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      let loop = node()\n      connect(compile(expr.expr, from), loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      let cur = from\n      for (let i = 0; i < expr.min; i++) {\n        let next = node()\n        connect(compile(expr.expr, cur), next)\n        cur = next\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur)\n      } else {\n        for (let i = expr.min; i < expr.max; i++) {\n          let next = node()\n          edge(cur, next)\n          connect(compile(expr.expr, cur), next)\n          cur = next\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return a - b }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  let result = []\n  scan(node)\n  return result.sort(cmp)\n\n  function scan(node) {\n    let edges = nfa[node]\n    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to)\n    result.push(node)\n    for (let i = 0; i < edges.length; i++) {\n      let {term, to} = edges[i]\n      if (!term && result.indexOf(to) == -1) scan(to)\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  let labeled = Object.create(null)\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    let out = []\n    states.forEach(node => {\n      nfa[node].forEach(({term, to}) => {\n        if (!term) return\n        let known = out.indexOf(term), set = known > -1 && out[known + 1]\n        nullFrom(nfa, to).forEach(node => {\n          if (!set) out.push(term, set = [])\n          if (set.indexOf(node) == -1) set.push(node)\n        })\n      })\n    })\n    let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1)\n    for (let i = 0; i < out.length; i += 2) {\n      let states = out[i + 1].sort(cmp)\n      state.next.push(out[i], labeled[states.join(\",\")] || explore(states))\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (let i = 0, work = [match]; i < work.length; i++) {\n    let state = work[i], dead = !state.validEnd, nodes = []\n    for (let j = 0; j < state.next.length; j += 2) {\n      let node = state.next[j], next = state.next[j + 1]\n      nodes.push(node.name)\n      if (dead && !(node.isText || node.hasRequiredAttrs())) dead = false\n      if (work.indexOf(next) == -1) work.push(next)\n    }\n    if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position\")\n  }\n}\n","import OrderedMap from \"orderedmap\"\n\nimport {Node, TextNode} from \"./node\"\nimport {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {ContentMatch} from \"./content\"\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  let defaults = Object.create(null)\n  for (let attrName in attrs) {\n    let attr = attrs[attrName]\n    if (!attr.hasDefault) return null\n    defaults[attrName] = attr.default\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  let built = Object.create(null)\n  for (let name in attrs) {\n    let given = value && value[name]\n    if (given === undefined) {\n      let attr = attrs[name]\n      if (attr.hasDefault) given = attr.default\n      else throw new RangeError(\"No value supplied for attribute \" + name)\n    }\n    built[name] = given\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  let result = Object.create(null)\n  if (attrs) for (let name in attrs) result[name] = new Attribute(attrs[name])\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nexport class NodeType {\n  constructor(name, schema, spec) {\n    // :: string\n    // The name the node type has in this schema.\n    this.name = name\n\n    // :: Schema\n    // A link back to the `Schema` the node type belongs to.\n    this.schema = schema\n\n    // :: NodeSpec\n    // The spec that this type is based on\n    this.spec = spec\n\n    this.groups = spec.group ? spec.group.split(\" \") : []\n    this.attrs = initAttrs(spec.attrs)\n\n    this.defaultAttrs = defaultAttrs(this.attrs)\n\n    // :: ContentMatch\n    // The starting match of the node type's content expression.\n    this.contentMatch = null\n\n    // : ?[MarkType]\n    // The set of marks allowed in this node. `null` means all marks\n    // are allowed.\n    this.markSet = null\n\n    // :: bool\n    // True if this node type has inline content.\n    this.inlineContent = null\n\n    // :: bool\n    // True if this is a block type\n    this.isBlock = !(spec.inline || name == \"text\")\n\n    // :: bool\n    // True if this is the text node type.\n    this.isText = name == \"text\"\n  }\n\n  // :: bool\n  // True if this is an inline type.\n  get isInline() { return !this.isBlock }\n\n  // :: bool\n  // True if this is a textblock type, a block that contains inline\n  // content.\n  get isTextblock() { return this.isBlock && this.inlineContent }\n\n  // :: bool\n  // True for node types that allow no content.\n  get isLeaf() { return this.contentMatch == ContentMatch.empty }\n\n  // :: bool\n  // True when this node is an atom, i.e. when it does not have\n  // directly editable content.\n  get isAtom() { return this.isLeaf || this.spec.atom }\n\n  hasRequiredAttrs(ignore) {\n    for (let n in this.attrs)\n      if (this.attrs[n].isRequired && (!ignore || !(n in ignore))) return true\n    return false\n  }\n\n  compatibleContent(other) {\n    return this == other || this.contentMatch.compatible(other.contentMatch)\n  }\n\n  computeAttrs(attrs) {\n    if (!attrs && this.defaultAttrs) return this.defaultAttrs\n    else return computeAttrs(this.attrs, attrs)\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a `Node` of this type. The given attributes are\n  // checked and defaulted (you can pass `null` to use the type's\n  // defaults entirely, if no required attributes exist). `content`\n  // may be a `Fragment`, a node, an array of nodes, or\n  // `null`. Similarly `marks` may be `null` to default to the empty\n  // set of marks.\n  create(attrs, content, marks) {\n    if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\")\n    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Like [`create`](#model.NodeType.create), but check the given content\n  // against the node type's content restrictions, and throw an error\n  // if it doesn't match.\n  createChecked(attrs, content, marks) {\n    content = Fragment.from(content)\n    if (!this.validContent(content))\n      throw new RangeError(\"Invalid content for node \" + this.name)\n    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n  // Like [`create`](#model.NodeType.create), but see if it is necessary to\n  // add nodes to the start or end of the given fragment to make it\n  // fit the node. If no fitting wrapping can be found, return null.\n  // Note that, due to the fact that required nodes can always be\n  // created, this will always succeed if you pass null or\n  // `Fragment.empty` as content.\n  createAndFill(attrs, content, marks) {\n    attrs = this.computeAttrs(attrs)\n    content = Fragment.from(content)\n    if (content.size) {\n      let before = this.contentMatch.fillBefore(content)\n      if (!before) return null\n      content = before.append(content)\n    }\n    let after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true)\n    if (!after) return null\n    return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n  }\n\n  // :: (Fragment) → bool\n  // Returns true if the given fragment is valid content for this node\n  // type with the given attributes.\n  validContent(content) {\n    let result = this.contentMatch.matchFragment(content)\n    if (!result || !result.validEnd) return false\n    for (let i = 0; i < content.childCount; i++)\n      if (!this.allowsMarks(content.child(i).marks)) return false\n    return true\n  }\n\n  // :: (MarkType) → bool\n  // Check whether the given mark type is allowed in this node.\n  allowsMarkType(markType) {\n    return this.markSet == null || this.markSet.indexOf(markType) > -1\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether the given set of marks are allowed in this node.\n  allowsMarks(marks) {\n    if (this.markSet == null) return true\n    for (let i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false\n    return true\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Removes the marks that are not allowed in this node from the given set.\n  allowedMarks(marks) {\n    if (this.markSet == null) return marks\n    let copy\n    for (let i = 0; i < marks.length; i++) {\n      if (!this.allowsMarkType(marks[i].type)) {\n        if (!copy) copy = marks.slice(0, i)\n      } else if (copy) {\n        copy.push(marks[i])\n      }\n    }\n    return !copy ? marks : copy.length ? copy : Mark.empty\n  }\n\n  static compile(nodes, schema) {\n    let result = Object.create(null)\n    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec))\n\n    let topType = schema.spec.topNode || \"doc\"\n    if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\")\n    if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\")\n    for (let _ in result.text.attrs) throw new RangeError(\"The text node type should not have attributes\")\n\n    return result\n  }\n}\n\n// Attribute descriptors\n\nclass Attribute {\n  constructor(options) {\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\")\n    this.default = options.default\n  }\n\n  get isRequired() {\n    return !this.hasDefault\n  }\n}\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nexport class MarkType {\n  constructor(name, rank, schema, spec) {\n    // :: string\n    // The name of the mark type.\n    this.name = name\n\n    // :: Schema\n    // The schema that this mark type instance is part of.\n    this.schema = schema\n\n    // :: MarkSpec\n    // The spec on which the type is based.\n    this.spec = spec\n\n    this.attrs = initAttrs(spec.attrs)\n\n    this.rank = rank\n    this.excluded = null\n    let defaults = defaultAttrs(this.attrs)\n    this.instance = defaults && new Mark(this, defaults)\n  }\n\n  // :: (?Object) → Mark\n  // Create a mark of this type. `attrs` may be `null` or an object\n  // containing only some of the mark's attributes. The others, if\n  // they have defaults, will be added.\n  create(attrs) {\n    if (!attrs && this.instance) return this.instance\n    return new Mark(this, computeAttrs(this.attrs, attrs))\n  }\n\n  static compile(marks, schema) {\n    let result = Object.create(null), rank = 0\n    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec))\n    return result\n  }\n\n  // :: ([Mark]) → [Mark]\n  // When there is a mark of this type in the given set, a new set\n  // without it is returned. Otherwise, the input set is returned.\n  removeFromSet(set) {\n    for (var i = 0; i < set.length; i++)\n      if (set[i].type == this)\n        return set.slice(0, i).concat(set.slice(i + 1))\n    return set\n  }\n\n  // :: ([Mark]) → ?Mark\n  // Tests whether there is a mark of this type in the given set.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (set[i].type == this) return set[i]\n  }\n\n  // :: (MarkType) → bool\n  // Queries whether a given mark type is\n  // [excluded](#model.MarkSpec.excludes) by this one.\n  excludes(other) {\n    return this.excluded.indexOf(other) > -1\n  }\n}\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nexport class Schema {\n  // :: (SchemaSpec)\n  // Construct a schema from a schema [specification](#model.SchemaSpec).\n  constructor(spec) {\n    // :: SchemaSpec\n    // The [spec](#model.SchemaSpec) on which the schema is based,\n    // with the added guarantee that its `nodes` and `marks`\n    // properties are\n    // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n    // (not raw objects).\n    this.spec = {}\n    for (let prop in spec) this.spec[prop] = spec[prop]\n    this.spec.nodes = OrderedMap.from(spec.nodes)\n    this.spec.marks = OrderedMap.from(spec.marks)\n\n    // :: Object<NodeType>\n    // An object mapping the schema's node names to node type objects.\n    this.nodes = NodeType.compile(this.spec.nodes, this)\n\n    // :: Object<MarkType>\n    // A map from mark names to mark type objects.\n    this.marks = MarkType.compile(this.spec.marks, this)\n\n    let contentExprCache = Object.create(null)\n    for (let prop in this.nodes) {\n      if (prop in this.marks)\n        throw new RangeError(prop + \" can not be both a node and a mark\")\n      let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks\n      type.contentMatch = contentExprCache[contentExpr] ||\n        (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes))\n      type.inlineContent = type.contentMatch.inlineContent\n      type.markSet = markExpr == \"_\" ? null :\n        markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n        markExpr == \"\" || !type.inlineContent ? [] : null\n    }\n    for (let prop in this.marks) {\n      let type = this.marks[prop], excl = type.spec.excludes\n      type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"))\n    }\n\n    this.nodeFromJSON = this.nodeFromJSON.bind(this)\n    this.markFromJSON = this.markFromJSON.bind(this)\n\n    // :: NodeType\n    // The type of the [default top node](#model.SchemaSpec.topNode)\n    // for this schema.\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"]\n\n    // :: Object\n    // An object for storing whatever values modules may want to\n    // compute and cache per schema. (If you want to store something\n    // in it, try to use property names unlikely to clash.)\n    this.cached = Object.create(null)\n    this.cached.wrappings = Object.create(null)\n  }\n\n  // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a node in this schema. The `type` may be a string or a\n  // `NodeType` instance. Attributes will be extended\n  // with defaults, `content` may be a `Fragment`,\n  // `null`, a `Node`, or an array of nodes.\n  node(type, attrs, content, marks) {\n    if (typeof type == \"string\")\n      type = this.nodeType(type)\n    else if (!(type instanceof NodeType))\n      throw new RangeError(\"Invalid node type: \" + type)\n    else if (type.schema != this)\n      throw new RangeError(\"Node type from different schema used (\" + type.name + \")\")\n\n    return type.createChecked(attrs, content, marks)\n  }\n\n  // :: (string, ?[Mark]) → Node\n  // Create a text node in the schema. Empty text nodes are not\n  // allowed.\n  text(text, marks) {\n    let type = this.nodes.text\n    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks))\n  }\n\n  // :: (union<string, MarkType>, ?Object) → Mark\n  // Create a mark with the given type and attributes.\n  mark(type, attrs) {\n    if (typeof type == \"string\") type = this.marks[type]\n    return type.create(attrs)\n  }\n\n  // :: (Object) → Node\n  // Deserialize a node from its JSON representation. This method is\n  // bound.\n  nodeFromJSON(json) {\n    return Node.fromJSON(this, json)\n  }\n\n  // :: (Object) → Mark\n  // Deserialize a mark from its JSON representation. This method is\n  // bound.\n  markFromJSON(json) {\n    return Mark.fromJSON(this, json)\n  }\n\n  nodeType(name) {\n    let found = this.nodes[name]\n    if (!found) throw new RangeError(\"Unknown node type: \" + name)\n    return found\n  }\n}\n\nfunction gatherMarks(schema, marks) {\n  let found = []\n  for (let i = 0; i < marks.length; i++) {\n    let name = marks[i], mark = schema.marks[name], ok = mark\n    if (mark) {\n      found.push(mark)\n    } else {\n      for (let prop in schema.marks) {\n        let mark = schema.marks[prop]\n        if (name == \"_\" || (mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1))\n          found.push(ok = mark)\n      }\n    }\n    if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\")\n  }\n  return found\n}\n","import {Fragment} from \"./fragment\"\nimport {Slice} from \"./replace\"\nimport {Mark} from \"./mark\"\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   propery's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return undefined to indicate that the match failed.)\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nexport class DOMParser {\n  // :: (Schema, [ParseRule])\n  // Create a parser that targets the given schema, using the given\n  // parsing rules.\n  constructor(schema, rules) {\n    // :: Schema\n    // The schema into which the parser parses.\n    this.schema = schema\n    // :: [ParseRule]\n    // The set of [parse rules](#model.ParseRule) that the parser\n    // uses, in order of precedence.\n    this.rules = rules\n    this.tags = []\n    this.styles = []\n\n    rules.forEach(rule => {\n      if (rule.tag) this.tags.push(rule)\n      else if (rule.style) this.styles.push(rule)\n    })\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Node\n  // Parse a document from the content of a DOM node.\n  parse(dom, options = {}) {\n    let context = new ParseContext(this, options, false)\n    context.addAll(dom, null, options.from, options.to)\n    return context.finish()\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Slice\n  // Parses the content of the given DOM node, like\n  // [`parse`](#model.DOMParser.parse), and takes the same set of\n  // options. But unlike that method, which produces a whole node,\n  // this one returns a slice that is open at the sides, meaning that\n  // the schema constraints aren't applied to the start of nodes to\n  // the left of the input and the end of nodes at the end.\n  parseSlice(dom, options = {}) {\n    let context = new ParseContext(this, options, true)\n    context.addAll(dom, null, options.from, options.to)\n    return Slice.maxOpen(context.finish())\n  }\n\n  matchTag(dom, context) {\n    for (let i = 0; i < this.tags.length; i++) {\n      let rule = this.tags[i]\n      if (matches(dom, rule.tag) &&\n          (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n          (!rule.context || context.matchesContext(rule.context))) {\n        if (rule.getAttrs) {\n          let result = rule.getAttrs(dom)\n          if (result === false) continue\n          rule.attrs = result\n        }\n        return rule\n      }\n    }\n  }\n\n  matchStyle(prop, value, context) {\n    for (let i = 0; i < this.styles.length; i++) {\n      let rule = this.styles[i]\n      if (rule.style.indexOf(prop) != 0 ||\n          rule.context && !context.matchesContext(rule.context) ||\n          // Test that the style string either precisely matches the prop,\n          // or has an '=' sign after the prop, followed by the given\n          // value.\n          rule.style.length > prop.length &&\n          (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n        continue\n      if (rule.getAttrs) {\n        let result = rule.getAttrs(value)\n        if (result === false) continue\n        rule.attrs = result\n      }\n      return rule\n    }\n  }\n\n  // : (Schema) → [ParseRule]\n  static schemaRules(schema) {\n    let result = []\n    function insert(rule) {\n      let priority = rule.priority == null ? 50 : rule.priority, i = 0\n      for (; i < result.length; i++) {\n        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority\n        if (nextPriority < priority) break\n      }\n      result.splice(i, 0, rule)\n    }\n\n    for (let name in schema.marks) {\n      let rules = schema.marks[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.mark = name\n      })\n    }\n    for (let name in schema.nodes) {\n      let rules = schema.nodes[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.node = name\n      })\n    }\n    return result\n  }\n\n  // :: (Schema) → DOMParser\n  // Construct a DOM parser using the parsing rules listed in a\n  // schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n  // [priority](#model.ParseRule.priority).\n  static fromSchema(schema) {\n    return schema.cached.domParser ||\n      (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n  }\n}\n\n// : Object<bool> The block-level tags in HTML5\nconst blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n}\n\n// : Object<bool> The tags that we normally ignore.\nconst ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n}\n\n// : Object<bool> List tags.\nconst listTags = {ol: true, ul: true}\n\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4\n\nfunction wsOptionsFor(preserveWhitespace) {\n  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0)\n}\n\nclass NodeContext {\n  constructor(type, attrs, marks, solid, match, options) {\n    this.type = type\n    this.attrs = attrs\n    this.solid = solid\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch)\n    this.options = options\n    this.content = []\n    this.marks = marks\n    this.activeMarks = Mark.none\n  }\n\n  findWrapping(node) {\n    if (!this.match) {\n      if (!this.type) return []\n      let fill = this.type.contentMatch.fillBefore(Fragment.from(node))\n      if (fill) {\n        this.match = this.type.contentMatch.matchFragment(fill)\n      } else {\n        let start = this.type.contentMatch, wrap\n        if (wrap = start.findWrapping(node.type)) {\n          this.match = start\n          return wrap\n        } else {\n          return null\n        }\n      }\n    }\n    return this.match.findWrapping(node.type)\n  }\n\n  finish(openEnd) {\n    if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n      let last = this.content[this.content.length - 1], m\n      if (last && last.isText && (m = /\\s+$/.exec(last.text))) {\n        if (last.text.length == m[0].length) this.content.pop()\n        else this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length))\n      }\n    }\n    let content = Fragment.from(this.content)\n    if (!openEnd && this.match)\n      content = content.append(this.match.fillBefore(Fragment.empty, true))\n    return this.type ? this.type.create(this.attrs, content, this.marks) : content\n  }\n}\n\nclass ParseContext {\n  // : (DOMParser, Object)\n  constructor(parser, options, open) {\n    // : DOMParser The parser we are using.\n    this.parser = parser\n    // : Object The options passed to this parse.\n    this.options = options\n    this.isOpen = open\n    this.pendingMarks = []\n    let topNode = options.topNode, topContext\n    let topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0)\n    if (topNode)\n      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true,\n                                   options.topMatch || topNode.type.contentMatch, topOptions)\n    else if (open)\n      topContext = new NodeContext(null, null, Mark.none, true, null, topOptions)\n    else\n      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions)\n    this.nodes = [topContext]\n    // : [Mark] The current set of marks\n    this.open = 0\n    this.find = options.findPositions\n    this.needsBlock = false\n  }\n\n  get top() {\n    return this.nodes[this.open]\n  }\n\n  // : (dom.Node)\n  // Add a DOM node to the content. Text is inserted as text node,\n  // otherwise, the node is passed to `addElement` or, if it has a\n  // `style` attribute, `addElementWithStyles`.\n  addDOM(dom) {\n    if (dom.nodeType == 3) {\n      this.addTextNode(dom)\n    } else if (dom.nodeType == 1) {\n      let style = dom.getAttribute(\"style\")\n      let marks = style ? this.readStyles(parseStyles(style)) : null\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.addPendingMark(marks[i])\n      this.addElement(dom)\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.removePendingMark(marks[i])\n    }\n  }\n\n  addTextNode(dom) {\n    let value = dom.nodeValue\n    let top = this.top\n    if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /\\S/.test(value)) {\n      if (!(top.options & OPT_PRESERVE_WS)) {\n        value = value.replace(/\\s+/g, \" \")\n        // If this starts with whitespace, and there is no node before it, or\n        // a hard break, or a text node that ends with whitespace, strip the\n        // leading space.\n        if (/^\\s/.test(value) && this.open == this.nodes.length - 1) {\n          let nodeBefore = top.content[top.content.length - 1]\n          let domNodeBefore = dom.previousSibling\n          if (!nodeBefore ||\n              (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n              (nodeBefore.isText && /\\s$/.test(nodeBefore.text)))\n            value = value.slice(1)\n        }\n      } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n        value = value.replace(/\\r?\\n|\\r/g, \" \")\n      }\n      if (value) this.insertNode(this.parser.schema.text(value))\n      this.findInText(dom)\n    } else {\n      this.findInside(dom)\n    }\n  }\n\n  // : (dom.Element)\n  // Try to find a handler for the given tag and use that to parse. If\n  // none is found, the element's content nodes are added directly.\n  addElement(dom) {\n    let name = dom.nodeName.toLowerCase()\n    if (listTags.hasOwnProperty(name)) normalizeList(dom)\n    let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) || this.parser.matchTag(dom, this)\n    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n      this.findInside(dom)\n    } else if (!rule || rule.skip) {\n      if (rule && rule.skip.nodeType) dom = rule.skip\n      let sync, top = this.top, oldNeedsBlock = this.needsBlock\n      if (blockTags.hasOwnProperty(name)) {\n        sync = true\n        if (!top.type) this.needsBlock = true\n      }\n      this.addAll(dom)\n      if (sync) this.sync(top)\n      this.needsBlock = oldNeedsBlock\n    } else {\n      this.addElementByRule(dom, rule)\n    }\n  }\n\n  // Run any style parser associated with the node's styles. Either\n  // return an array of marks, or null to indicate some of the styles\n  // had a rule with `ignore` set.\n  readStyles(styles) {\n    let marks = Mark.none\n    for (let i = 0; i < styles.length; i += 2) {\n      let rule = this.parser.matchStyle(styles[i], styles[i + 1], this)\n      if (!rule) continue\n      if (rule.ignore) return null\n      marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks)\n    }\n    return marks\n  }\n\n  // : (dom.Element, ParseRule) → bool\n  // Look up a handler for the given node. If none are found, return\n  // false. Otherwise, apply it, use its return value to drive the way\n  // the node's content is wrapped, and return true.\n  addElementByRule(dom, rule) {\n    let sync, nodeType, markType, mark\n    if (rule.node) {\n      nodeType = this.parser.schema.nodes[rule.node]\n      if (nodeType.isLeaf) this.insertNode(nodeType.create(rule.attrs))\n      else sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace)\n    } else {\n      markType = this.parser.schema.marks[rule.mark]\n      mark = markType.create(rule.attrs)\n      this.addPendingMark(mark)\n    }\n    let startIn = this.top\n\n    if (nodeType && nodeType.isLeaf) {\n      this.findInside(dom)\n    } else if (rule.getContent) {\n      this.findInside(dom)\n      rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node))\n    } else {\n      let contentDOM = rule.contentElement\n      if (typeof contentDOM == \"string\") contentDOM = dom.querySelector(contentDOM)\n      else if (typeof contentDOM == \"function\") contentDOM = contentDOM(dom)\n      if (!contentDOM) contentDOM = dom\n      this.findAround(dom, contentDOM, true)\n      this.addAll(contentDOM, sync)\n    }\n    if (sync) { this.sync(startIn); this.open-- }\n    if (mark) this.removePendingMark(mark)\n    return true\n  }\n\n  // : (dom.Node, ?NodeBuilder, ?number, ?number)\n  // Add all child nodes between `startIndex` and `endIndex` (or the\n  // whole node, if not given). If `sync` is passed, use it to\n  // synchronize after every block element.\n  addAll(parent, sync, startIndex, endIndex) {\n    let index = startIndex || 0\n    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n             end = endIndex == null ? null : parent.childNodes[endIndex];\n         dom != end; dom = dom.nextSibling, ++index) {\n      this.findAtPoint(parent, index)\n      this.addDOM(dom)\n      if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n        this.sync(sync)\n    }\n    this.findAtPoint(parent, index)\n  }\n\n  // Try to find a way to fit the given node type into the current\n  // context. May add intermediate wrappers and/or leave non-solid\n  // nodes that we're in.\n  findPlace(node) {\n    let route, sync\n    for (let depth = this.open; depth >= 0; depth--) {\n      let cx = this.nodes[depth]\n      let found = cx.findWrapping(node)\n      if (found && (!route || route.length > found.length)) {\n        route = found\n        sync = cx\n        if (!found.length) break\n      }\n      if (cx.solid) break\n    }\n    if (!route) return false\n    this.sync(sync)\n    for (let i = 0; i < route.length; i++)\n      this.enterInner(route[i], null, false)\n    return true\n  }\n\n  // : (Node) → ?Node\n  // Try to insert the given node, adjusting the context when needed.\n  insertNode(node) {\n    if (node.isInline && this.needsBlock && !this.top.type) {\n      let block = this.textblockFromContext()\n      if (block) this.enterInner(block)\n    }\n    if (this.findPlace(node)) {\n      this.closeExtra()\n      let top = this.top\n      this.applyPendingMarks(top)\n      if (top.match) top.match = top.match.matchType(node.type)\n      let marks = top.activeMarks\n      for (let i = 0; i < node.marks.length; i++)\n        if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n          marks = node.marks[i].addToSet(marks)\n      top.content.push(node.mark(marks))\n    }\n  }\n\n  applyPendingMarks(top) {\n    for (let i = 0; i < this.pendingMarks.length; i++) {\n      let mark = this.pendingMarks[i]\n      if ((!top.type || top.type.allowsMarkType(mark.type)) && !mark.isInSet(top.activeMarks)) {\n        top.activeMarks = mark.addToSet(top.activeMarks)\n        this.pendingMarks.splice(i--, 1)\n      }\n    }\n  }\n\n  // : (NodeType, ?Object) → bool\n  // Try to start a node of the given type, adjusting the context when\n  // necessary.\n  enter(type, attrs, preserveWS) {\n    let ok = this.findPlace(type.create(attrs))\n    if (ok) {\n      this.applyPendingMarks(this.top)\n      this.enterInner(type, attrs, true, preserveWS)\n    }\n    return ok\n  }\n\n  // Open a node of the given type\n  enterInner(type, attrs, solid, preserveWS) {\n    this.closeExtra()\n    let top = this.top\n    top.match = top.match && top.match.matchType(type, attrs)\n    let options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS)\n    if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) options |= OPT_OPEN_LEFT\n    this.nodes.push(new NodeContext(type, attrs, top.activeMarks, solid, null, options))\n    this.open++\n  }\n\n  // Make sure all nodes above this.open are finished and added to\n  // their parents\n  closeExtra(openEnd) {\n    let i = this.nodes.length - 1\n    if (i > this.open) {\n      for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd))\n      this.nodes.length = this.open + 1\n    }\n  }\n\n  finish() {\n    this.open = 0\n    this.closeExtra(this.isOpen)\n    return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n  }\n\n  sync(to) {\n    for (let i = this.open; i >= 0; i--) if (this.nodes[i] == to) {\n      this.open = i\n      return\n    }\n  }\n\n  addPendingMark(mark) {\n    this.pendingMarks.push(mark)\n  }\n\n  removePendingMark(mark) {\n    let found = this.pendingMarks.lastIndexOf(mark)\n    if (found > -1) {\n      this.pendingMarks.splice(found, 1)\n    } else {\n      let top = this.top\n      top.activeMarks = mark.removeFromSet(top.activeMarks)\n    }\n  }\n\n  get currentPos() {\n    this.closeExtra()\n    let pos = 0\n    for (let i = this.open; i >= 0; i--) {\n      let content = this.nodes[i].content\n      for (let j = content.length - 1; j >= 0; j--)\n        pos += content[j].nodeSize\n      if (i) pos++\n    }\n    return pos\n  }\n\n  findAtPoint(parent, offset) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == parent && this.find[i].offset == offset)\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findInside(parent) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findAround(parent, content, before) {\n    if (parent != content && this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n        let pos = content.compareDocumentPosition(this.find[i].node)\n        if (pos & (before ? 2 : 4))\n          this.find[i].pos = this.currentPos\n      }\n    }\n  }\n\n  findInText(textNode) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == textNode)\n        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset)\n    }\n  }\n\n  // : (string) → bool\n  // Determines whether the given [context\n  // string](#ParseRule.context) matches this context.\n  matchesContext(context) {\n    if (context.indexOf(\"|\") > -1)\n      return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this)\n\n    let parts = context.split(\"/\")\n    let option = this.options.context\n    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type)\n    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1)\n    let match = (i, depth) => {\n      for (; i >= 0; i--) {\n        let part = parts[i]\n        if (part == \"\") {\n          if (i == parts.length - 1 || i == 0) continue\n          for (; depth >= minDepth; depth--)\n            if (match(i - 1, depth)) return true\n          return false\n        } else {\n          let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type\n              : option && depth >= minDepth ? option.node(depth - minDepth).type\n              : null\n          if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n            return false\n          depth--\n        }\n      }\n      return true\n    }\n    return match(parts.length - 1, this.open)\n  }\n\n  textblockFromContext() {\n    let $context = this.options.context\n    if ($context) for (let d = $context.depth; d >= 0; d--) {\n      let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType\n      if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt\n    }\n    for (let name in this.parser.schema.nodes) {\n      let type = this.parser.schema.nodes[name]\n      if (type.isTextblock && type.defaultAttrs) return type\n    }\n  }\n}\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child)\n      child = prevItem\n    } else if (name == \"li\") {\n      prevItem = child\n    } else if (name) {\n      prevItem = null\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = []\n  while (m = re.exec(style)) result.push(m[1], m[2].trim())\n  return result\n}\n\nfunction copy(obj) {\n  let copy = {}\n  for (let prop in obj) copy[prop] = obj[prop]\n  return copy\n}\n","// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element. If the second\n// element is plain object, it is interpreted as a set of attributes\n// for the element. Any elements after that (including the 2nd if it's\n// not an attribute object) are interpreted as children of the DOM\n// elements, and must either be valid `DOMOutputSpec` values, or the\n// number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. It it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nexport class DOMSerializer {\n  // :: (Object<(node: Node) → DOMOutputSpec>, Object<?(mark: Mark, inline: bool) → DOMOutputSpec>)\n  // Create a serializer. `nodes` should map node names to functions\n  // that take a node and return a description of the corresponding\n  // DOM. `marks` does the same for mark names, but also gets an\n  // argument that tells it whether the mark's content is block or\n  // inline content (for typical use, it'll always be inline). A mark\n  // serializer may be `null` to indicate that marks of that type\n  // should not be serialized.\n  constructor(nodes, marks) {\n    // :: Object<(node: Node) → DOMOutputSpec>\n    // The node serialization functions.\n    this.nodes = nodes || {}\n    // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n    // The mark serialization functions.\n    this.marks = marks || {}\n  }\n\n  // :: (Fragment, ?Object) → dom.DocumentFragment\n  // Serialize the content of this fragment to a DOM fragment. When\n  // not in the browser, the `document` option, containing a DOM\n  // document, should be passed so that the serializer can create\n  // nodes.\n  serializeFragment(fragment, options = {}, target) {\n    if (!target) target = doc(options).createDocumentFragment()\n\n    let top = target, active = null\n    fragment.forEach(node => {\n      if (active || node.marks.length) {\n        if (!active) active = []\n        let keep = 0, rendered = 0\n        while (keep < active.length && rendered < node.marks.length) {\n          let next = node.marks[rendered]\n          if (!this.marks[next.type.name]) { rendered++; continue }\n          if (!next.eq(active[keep]) || next.type.spec.spanning === false) break\n          keep += 2; rendered++\n        }\n        while (keep < active.length) {\n          top = active.pop()\n          active.pop()\n        }\n        while (rendered < node.marks.length) {\n          let add = node.marks[rendered++]\n          let markDOM = this.serializeMark(add, node.isInline, options)\n          if (markDOM) {\n            active.push(add, top)\n            top.appendChild(markDOM.dom)\n            top = markDOM.contentDOM || markDOM.dom\n          }\n        }\n      }\n      top.appendChild(this.serializeNode(node, options))\n    })\n\n    return target\n  }\n\n  // :: (Node, ?Object) → dom.Node\n  // Serialize this node to a DOM node. This can be useful when you\n  // need to serialize a part of a document, as opposed to the whole\n  // document. To serialize a whole document, use\n  // [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n  // its [content](#model.Node.content).\n  serializeNode(node, options = {}) {\n    let {dom, contentDOM} =\n        DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node))\n    if (contentDOM) {\n      if (node.isLeaf)\n        throw new RangeError(\"Content hole not allowed in a leaf node spec\")\n      if (options.onContent)\n        options.onContent(node, contentDOM, options)\n      else\n        this.serializeFragment(node.content, options, contentDOM)\n    }\n    return dom\n  }\n\n  serializeNodeAndMarks(node, options = {}) {\n    let dom = this.serializeNode(node, options)\n    for (let i = node.marks.length - 1; i >= 0; i--) {\n      let wrap = this.serializeMark(node.marks[i], node.isInline, options)\n      if (wrap) {\n        ;(wrap.contentDOM || wrap.dom).appendChild(dom)\n        dom = wrap.dom\n      }\n    }\n    return dom\n  }\n\n  serializeMark(mark, inline, options = {}) {\n    let toDOM = this.marks[mark.type.name]\n    return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n  }\n\n  // :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n  // Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n  // the spec has a hole (zero) in it, `contentDOM` will point at the\n  // node with the hole.\n  static renderSpec(doc, structure) {\n    if (typeof structure == \"string\")\n      return {dom: doc.createTextNode(structure)}\n    if (structure.nodeType != null)\n      return {dom: structure}\n    let dom = doc.createElement(structure[0]), contentDOM = null\n    let attrs = structure[1], start = 1\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n      start = 2\n      for (let name in attrs) {\n        if (attrs[name] != null) dom.setAttribute(name, attrs[name])\n      }\n    }\n    for (let i = start; i < structure.length; i++) {\n      let child = structure[i]\n      if (child === 0) {\n        if (i < structure.length - 1 || i > start)\n          throw new RangeError(\"Content hole must be the only child of its parent node\")\n        return {dom, contentDOM: dom}\n      } else {\n        let {dom: inner, contentDOM: innerContent} = DOMSerializer.renderSpec(doc, child)\n        dom.appendChild(inner)\n        if (innerContent) {\n          if (contentDOM) throw new RangeError(\"Multiple content holes\")\n          contentDOM = innerContent\n        }\n      }\n    }\n    return {dom, contentDOM}\n  }\n\n  // :: (Schema) → DOMSerializer\n  // Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n  // properties in a schema's node and mark specs.\n  static fromSchema(schema) {\n    return schema.cached.domSerializer ||\n      (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n  }\n\n  // : (Schema) → Object<(node: Node) → DOMOutputSpec>\n  // Gather the serializers in a schema's node specs into an object.\n  // This can be useful as a base to build a custom serializer from.\n  static nodesFromSchema(schema) {\n    let result = gatherToDOM(schema.nodes)\n    if (!result.text) result.text = node => node.text\n    return result\n  }\n\n  // : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n  // Gather the serializers in a schema's mark specs into an object.\n  static marksFromSchema(schema) {\n    return gatherToDOM(schema.marks)\n  }\n}\n\nfunction gatherToDOM(obj) {\n  let result = {}\n  for (let name in obj) {\n    let toDOM = obj[name].spec.toDOM\n    if (toDOM) result[name] = toDOM\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n"],"names":["let","this","prototypeAccessors","const","p","n","prototypeAccessors$1","super","i","type","loop","next","states","prop","text","mark","rules","name"],"mappings":"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"}