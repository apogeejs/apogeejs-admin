{
	"fileType": "apogee app js workspace",
	"version": "0.60",
	"references": {
		"refEntries": []
	},
	"code": {
		"model": {
			"fileType": "apogee model",
			"version": 0.3,
			"name": "Function Programming",
			"children": {
				"Model": {
					"name": "Model",
					"type": "apogee.Folder",
					"children": {
						"genericValue": {
							"name": "genericValue",
							"type": "apogee.JsonTable",
							"updateData": {
								"data": {
									"a": true,
									"b": [
										1,
										2,
										3
									]
								}
							}
						},
						"bad3": {
							"name": "bad3",
							"type": "apogee.JsonTable",
							"updateData": {
								"argList": [],
								"functionBody": "genericValue = 34;\n\nreturn genericValue;",
								"supplementalCode": ""
							}
						},
						"error1": {
							"name": "error1",
							"type": "apogee.JsonTable",
							"updateData": {
								"argList": [],
								"functionBody": "//genericValue.b = false;\n\nreturn \"uncomment out the line of code to see the error\";",
								"supplementalCode": ""
							}
						},
						"potentialError2": {
							"name": "potentialError2",
							"type": "apogee.JsonTable",
							"updateData": {
								"argList": [],
								"functionBody": "//DON'T DO THIS:\n//let locaVariable = genericValue.b;\n//INSTEAD DO THIS:\nlet localVariable = apogeeutil.jsonCopy(genericValue.b);\n\nlocalVariable[1] = \"changed\"\n\nreturn localVariable;",
								"supplementalCode": ""
							}
						},
						"fixedValue1": {
							"name": "fixedValue1",
							"type": "apogee.JsonTable",
							"updateData": {
								"data": 1
							}
						},
						"fixedValue2": {
							"name": "fixedValue2",
							"type": "apogee.JsonTable",
							"updateData": {
								"data": 2
							}
						},
						"derivedValue2": {
							"name": "derivedValue2",
							"type": "apogee.JsonTable",
							"updateData": {
								"argList": [],
								"functionBody": "let localValue = fixedValue1 * 3;\n\n//here is the line where we use the messenger to set the value of cell fixedValue2\n//apogeeMessenger.dataUpdate(\"fixedValue2\",localValue);\n\nreturn localValue"
							}
						},
						"derivedValue1": {
							"name": "derivedValue1",
							"type": "apogee.JsonTable",
							"updateData": {
								"argList": [],
								"functionBody": "return fixedValue2 * 3;",
								"supplementalCode": ""
							}
						}
					}
				}
			}
		},
		"components": {
			"Model": {
				"type": "apogeeapp.app.FolderComponent",
				"treeState": null,
				"data": {
					"doc": {
						"type": "doc",
						"content": [
							{
								"type": "heading1",
								"content": [
									{
										"type": "text",
										"text": "Immutable Values, Functional Programming and the Messenger"
									}
								]
							},
							{
								"type": "heading2",
								"content": [
									{
										"type": "text",
										"text": "Immutability and Order of Operations"
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "Once a cell has a value set, this value is immutable. The purpose for this is to fix the order of operations. Apogee automatically updates a workspace if any cells are changed. To do this, it must calculate the values of the cells in the proper order. Furthermore, once a given value is calculated, it can not be modified, otherwise that could cause an inconsistency if the calculated value had already been used elsewhere."
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "This works the same way a spreadsheet works, which was in fact the motivation for Apogee."
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "The idea for Apogee is to make an easy-to-use programming environment. However, this also makes Apogee (and a spreadsheet) a form of functional programming. Generally functional programming is not considered easy for beginners, rather it is typically used by more advanced users. However, most people would admit functional programming makes some things much easier."
									}
								]
							},
							{
								"type": "heading2",
								"content": [
									{
										"type": "text",
										"text": "Immutable Variables Gotchas!"
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "Being immutable means you can't modify one cell from another cell. This must be kept in mind while using Apogee. We demonstrate this below."
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "Here is an example value we will use."
									}
								]
							},
							{
								"type": "apogeeComponent",
								"attrs": {
									"name": "genericValue",
									"id": 0,
									"state": ""
								}
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "Here we will try to modify it from another table."
									}
								]
							},
							{
								"type": "apogeeComponent",
								"attrs": {
									"name": "error1",
									"id": 0,
									"state": ""
								}
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "Here is another example of possibly accidentally trying to change immutable data. If you use part of an immutable value, genericValue.b below, and you want to change it then you have to make a copy. Here we use a copy function from the included apogee library. If you swap the commented line so the immutable value is not copied it should produce an error."
									}
								]
							},
							{
								"type": "apogeeComponent",
								"attrs": {
									"name": "potentialError2",
									"id": 0,
									"state": ""
								}
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "Below is a dangerous scenario, in that sense that it might not do what you think. Here I set the variable named genericValue to a different value. However, this is only changing the local version of that variable, not the value of the genericValue cell itself. "
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"marks": [
											{
												"type": "highlight",
												"attrs": {
													"color": "yellow"
												}
											}
										],
										"text": "DOH! Is the following OK? Or should I at least try to avoid this (I thought i did?)"
									}
								]
							},
							{
								"type": "apogeeComponent",
								"attrs": {
									"name": "bad3",
									"id": 0,
									"state": ""
								}
							},
							{
								"type": "heading2",
								"content": [
									{
										"type": "text",
										"text": "More on Functional Programming"
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "You can safely ignore this section is you are not interested in functional programming."
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "When people talk about pure functional programming, they think of more than immutable variables and no side effects. They also typically want pure functions, where all the variables used in the function are passed in as arguments, rather than using externally defined variables. The reason for this is they want the value of that function to always be the same for a given set of inputs. That can not be guaranteed if it is using some global or otherwise externally defined variable."
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "In Apogee (and in a spreadsheet) when we create a function to define the value of a cell, we can not force all values  in the cell to be passed in as argument. There are not arguments for that function. Instead you need to use global variables. The Apogee runtime enforces that the external value has a fixed value before it is used by any functions. So the function will have a well defined fixed value each time it is used so the system will be consistent."
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "This won't entirely satisfy the functional programming purists. Another benefit to passing in all values used in the function is that it is obvious what they are. You don't have to go looking for what something means in your entire codebase, even if you could enforce that it was a single well defined value. That's OK. Apogee is not trying to compete as an academic programming environment with Haskell. Apogee is aimed to include non-power programmers."
									}
								]
							},
							{
								"type": "heading2",
								"content": [
									{
										"type": "text",
										"text": "The Messenger"
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "There is something else that might bother the functional purists more than having global values, and that is the messenger. Apogee does enforce there are no side effects, for a specific definition of \"no side effects\"."
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "Apogee has something called "
									},
									{
										"type": "text",
										"marks": [
											{
												"type": "italic"
											}
										],
										"text": "the messenger"
									},
									{
										"type": "text",
										"text": ". This allows you to write to the value of another cell. This sounds like a side effect in a bad sense. By our definition and because of how it works however it is not. What we do enforce is that the workspace cells are all consistent, given their formulas."
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "We will set up a few cells below to illustrate this."
									}
								]
							},
							{
								"type": "heading3",
								"content": [
									{
										"type": "text",
										"text": "Messenger Example"
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "Here we have two cells with static values, fixedValue1 and fixedValue2. "
									}
								]
							},
							{
								"type": "apogeeComponent",
								"attrs": {
									"name": "fixedValue1",
									"id": 0,
									"state": ""
								}
							},
							{
								"type": "paragraph"
							},
							{
								"type": "apogeeComponent",
								"attrs": {
									"name": "fixedValue2",
									"id": 0,
									"state": ""
								}
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "We also have two cells with formulas, derivedValue1 and derivedValue2."
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "In the formula for the cell derivedValue1, it uses the messenger to set the cell fixedValue2 to a new value. This is the apparent side effect."
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"marks": [
											{
												"type": "italic"
											}
										],
										"text": "Note: To prevent the cell fixedValue2 from being changed to early and rendering the example uninteresting, we have that line commented out below. You can uncomment it to see what happens."
									}
								]
							},
							{
								"type": "apogeeComponent",
								"attrs": {
									"name": "derivedValue1",
									"id": 0,
									"state": ""
								}
							},
							{
								"type": "paragraph"
							},
							{
								"type": "apogeeComponent",
								"attrs": {
									"name": "derivedValue2",
									"id": 0,
									"state": ""
								}
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "What would not be good is for the cell derivedValue2 to be calculated based on the initial value of fixedValue2 and then for the table derivedValue2 to change the value of fixedValue2 so the relation between fixedValue2 and derivedValue1 is no longer correct. This does not happen."
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "The messenger does not immediately change the cell to which it is addressed. The following happens:"
									}
								]
							},
							{
								"type": "bulletList",
								"content": [
									{
										"type": "listItem",
										"content": [
											{
												"type": "text",
												"text": "The workspace has an initial state. Apogee determines the proper order of calculations so that all cells are consistent according to their formulas. Possibly, as in the case above, in one of the formulas the messenger is called to update another table. This does not change any table values, for now."
											}
										]
									},
									{
										"type": "listItem",
										"content": [
											{
												"type": "text",
												"text": "The workspace calculation as described above is completed and all cells are consistent."
											}
										]
									},
									{
										"type": "listItem",
										"content": [
											{
												"type": "text",
												"text": "After this, the messenger can update the state on tables. When it is finished, the workspace is in a new state. This is considered a completely new problem. The workspace calculation is once again done, completing with all tables being consistent according to their formulas."
											}
										]
									},
									{
										"type": "bulletList",
										"content": [
											{
												"type": "listItem",
												"content": [
													{
														"type": "text",
														"text": "This is "
													},
													{
														"type": "text",
														"marks": [
															{
																"type": "italic"
															}
														],
														"text": "as if"
													},
													{
														"type": "text",
														"text": " a person went in and edited those cells rather than using the messenger. In fact it is the same logic that allows a user to edit the cells as for the messenger to edit the cells. After all, the program would be very uninteresting if users were not allowed to edit the cells. "
													}
												]
											}
										]
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "There are scenarios where you can cause confusion about the end result, which is analogous to collisions of two people editing the document at the same time. Because of this, you shouldn't have two cells sending a message to the same third cell. So you can cause yourself trouble, however the result will always be a consistent result given the state of the system."
									}
								]
							},
							{
								"type": "paragraph",
								"content": [
									{
										"type": "text",
										"text": "The use of the messenger is discussed in more detail elsewhere in the tutorials."
									}
								]
							}
						]
					},
					"selection": {
						"type": "text",
						"anchor": 4063,
						"head": 4063
					}
				},
				"children": {
					"genericValue": {
						"type": "apogeeapp.app.JsonTableComponent",
						"windowState": {
							"views": {
								"Data": {
									"isViewActive": true,
									"height": 280
								},
								"Formula": {
									"isViewActive": false
								},
								"Private": {
									"isViewActive": false
								}
							}
						},
						"dataView": "Colorized"
					},
					"bad3": {
						"type": "apogeeapp.app.JsonTableComponent",
						"windowState": {
							"views": {
								"Data": {
									"isViewActive": true,
									"height": 280
								},
								"Formula": {
									"isViewActive": true,
									"height": 7000
								},
								"Private": {
									"isViewActive": false
								}
							}
						},
						"dataView": "Colorized"
					},
					"error1": {
						"type": "apogeeapp.app.JsonTableComponent",
						"windowState": {
							"views": {
								"Data": {
									"isViewActive": true,
									"height": 280
								},
								"Formula": {
									"isViewActive": true,
									"height": 7000
								},
								"Private": {
									"isViewActive": false
								}
							}
						},
						"dataView": "Colorized"
					},
					"potentialError2": {
						"type": "apogeeapp.app.JsonTableComponent",
						"windowState": {
							"views": {
								"Data": {
									"isViewActive": true,
									"height": 280
								},
								"Formula": {
									"isViewActive": true,
									"height": 7000
								},
								"Private": {
									"isViewActive": false
								}
							}
						},
						"dataView": "Colorized"
					},
					"fixedValue1": {
						"type": "apogeeapp.app.JsonTableComponent",
						"windowState": {
							"views": {
								"Data": {
									"isViewActive": true,
									"height": 280
								},
								"Formula": {
									"isViewActive": false
								},
								"Private": {
									"isViewActive": false
								}
							}
						},
						"dataView": "Colorized"
					},
					"fixedValue2": {
						"type": "apogeeapp.app.JsonTableComponent",
						"windowState": {
							"views": {
								"Data": {
									"isViewActive": true,
									"height": 280
								},
								"Formula": {
									"isViewActive": false
								},
								"Private": {
									"isViewActive": false
								}
							}
						},
						"dataView": "Colorized"
					},
					"derivedValue2": {
						"type": "apogeeapp.app.JsonTableComponent",
						"windowState": {
							"views": {
								"Data": {
									"isViewActive": true,
									"height": 280
								},
								"Formula": {
									"isViewActive": true,
									"height": 7000
								},
								"Private": {
									"isViewActive": false
								}
							}
						},
						"dataView": "Colorized"
					},
					"derivedValue1": {
						"type": "apogeeapp.app.JsonTableComponent",
						"windowState": {
							"views": {
								"Data": {
									"isViewActive": true,
									"height": 280
								},
								"Formula": {
									"isViewActive": true,
									"height": 7000
								},
								"Private": {
									"isViewActive": false
								}
							}
						},
						"dataView": "Colorized"
					}
				}
			}
		}
	}
}