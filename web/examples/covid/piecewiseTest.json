{"fileType":"apogee app js workspace","version":"0.50","references":{"refEntries":[{"url":"http://localhost:8888/applications/modules/chartjsmodule/Chart.min.js","nickname":"","entryType":"js link"},{"url":"http://localhost:8888/applications/modules/chartjsmodule/ChartJSComponentModule.js?r=4","nickname":"","entryType":"es module"}],"viewState":{"treeState":1,"lists":{"es module":{"treeState":-1},"js link":{"treeState":-1},"css link":{"treeState":0}}}},"code":{"model":{"fileType":"apogee model","version":0.2,"name":"SmoothingTestWorkspace","children":{"Model":{"name":"Model","type":"apogee.Folder","children":{"N":{"name":"N","type":"apogee.JsonTable","updateData":{"data":5}},"c1":{"name":"c1","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"let value = 0;\nfor(let n = 1; n < N; n++) {\n    value += Math.pow( (N-n)/N , 2 );\n}\n\nreturn value;","supplementalCode":""}},"c2":{"name":"c2","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"let value = 0;\nfor(let n = 1; n < N; n++) {\n    value += ((N-n) * n)/ (N*N)\n}\nreturn value;\n","supplementalCode":""}},"createBVector":{"name":"createBVector","type":"apogee.FunctionTable","updateData":{"argList":["data"],"functionBody":"let b = [];\nlet bLength = 1 + (data.length - 1) / N;\n\nfor(let bIndex = 0; bIndex < bLength; bIndex++) {\n    let bValue = 0;\n    for(let n = -N+1; n < N; n++) {\n        let dataIndex = bIndex * N + n;\n        if((dataIndex >= 0)&&(dataIndex < data.length)) {\n            bValue += (data[dataIndex] * (N-Math.abs(n))/N); \n        }\n    }\n    b.push(bValue);\n}\nreturn b;","supplementalCode":""}},"createTridiag":{"name":"createTridiag","type":"apogee.FunctionTable","updateData":{"argList":["dataLength"],"functionBody":"let A = [];\nlet ALength = 1 + (dataLength - 1) / N;\n//first row\nA.push([0,1+c1,c2]);\nfor(let index = 1; index < ALength-1; index++) {\n    A.push([c2,1+2*c1,c2]);\n}\n//last row\nA.push([c2,1+c1,0]);\nreturn A;","supplementalCode":""}},"tridiagSolver":{"name":"tridiagSolver","type":"apogee.FolderFunction","updateData":{"argList":["AMatrix","bVector"],"returnValue":"xVector"},"children":{"body":{"name":"body","type":"apogee.Folder","children":{"test":{"name":"test","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return tridiagMultiply(AMatrix,xVector);","supplementalCode":""}},"tridiagSolver":{"name":"tridiagSolver","type":"apogee.FunctionTable","updateData":{"argList":["A","b"],"functionBody":"//make sure out format is correct\nlet rows = A.length;\nif((A[0][0] != 0)||(A[rows-1][2] != 0)||(b.length != A.length)) throw new Error(\"Improper tridiag format\");\n\n//get in a solvable form\nlet ANew = [];\nlet bNew = [];\nlet curRow = A[0];\nlet curRowB = b[0];\nlet newRow;\nlet newRowB;\nfor(let r = 0; r < rows; r++) {\n    //scale this row so the diag value is one\n    let newRow = [0,1,curRow[2]/curRow[1]];\n    let newRowB = curRowB/curRow[1];\n    \n    //store these values\n    ANew.push(newRow);\n    prevRow = newRow;\n    bNew.push(newRowB);\n    prevRowB = newRowB;\n    \n    //subtract current from from next soit is upper diag\n    if(r < rows-1) {\n        let nextRow = A[r+1];\n        let nextRowB = b[r+1];\n        \n        let factor = nextRow[0];\n        curRow = [0,nextRow[1] - prevRow[2]*factor,nextRow[2]];\n        curRowB = nextRowB - prevRowB*factor;\n    }\n}\n\n//no wwe can solve starting with the last row\nxRev = [];\nxRowNext = 0; //this is the x value of the next row\nfor(let r = rows-1; r >= 0; r--) {\n    curRow = ANew[r];\n    curRowB = bNew[r];\n    let xRow = (curRowB - curRow[2] * xRowNext); //remember curRow[1] = 1 and curRow[0] = 0\n    xRev.push(xRow);\n    xRowNext = xRow;\n}\n\nreturn xRev.reverse();\n\n\n","supplementalCode":""}},"tridiagMultiply":{"name":"tridiagMultiply","type":"apogee.FunctionTable","updateData":{"argList":["A","x"],"functionBody":"let rows = A.length;\n\nlet b = [];\nfor(let r = 0; r < rows; r++) {\n    let row = A[r];\n    let value = 0;\n    if(r > 0) value += row[0] * x[r-1];\n    value += row[1] * x[r];\n    if(r < rows-1) value += row[2] * x[r+1];\n    b.push(value);\n}\n\nreturn b;","supplementalCode":""}},"bVector":{"name":"bVector","type":"apogee.JsonTable","updateData":{"data":[3,4,3]}},"AMatrix":{"name":"AMatrix","type":"apogee.JsonTable","updateData":{"data":[[0,1,1],[1,2,1],[1,2,0]]}},"xVector":{"name":"xVector","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return tridiagSolver(AMatrix,bVector);","supplementalCode":""}}}}}}}},"test":{"name":"test","type":"apogee.Folder","children":{"sampleDataArray":{"name":"sampleDataArray","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"//return sampleDataSetsClean[1].data;\nreturn sampleDataSetsDirty[0].data;\n","supplementalCode":""}},"modifiedInputData":{"name":"modifiedInputData","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"let goodLength = 1 + Math.floor( (sampleDataArray.length - 1) / Model.N) * Model.N;\nlet pointsToTruncate = sampleDataArray.length - goodLength;\n\nreturn sampleDataArray.slice(pointsToTruncate);","supplementalCode":""}},"test":{"name":"test","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return {\n    inputLength: sampleDataArray.length,\n    outputLength: modifiedInputData.length,\n    diff: sampleDataArray.length - modifiedInputData.length,\n    finalInputValue: sampleDataArray[sampleDataArray.length-1],\n    finalOutputValue: modifiedInputData[modifiedInputData.length-1]\n}\n    ","supplementalCode":""}},"AMatrix":{"name":"AMatrix","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return Model.createTridiag(modifiedInputData.length);","supplementalCode":""}},"bVector":{"name":"bVector","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return Model.createBVector(modifiedInputData);","supplementalCode":""}},"solutionVector":{"name":"solutionVector","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return Model.tridiagSolver(AMatrix,bVector);","supplementalCode":""}},"interpolatedData":{"name":"interpolatedData","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"let outData = [];\nlet previousShortValue;\nfor(let shortIndex = 0; shortIndex < solutionVector.length; shortIndex++) {\n    let currentShortValue = solutionVector[shortIndex];\n    if(previousShortValue !== undefined) {\n        //interpolate the intermediate points\n        for(let intermediateIndex = 1; intermediateIndex < Model.N; intermediateIndex++) {\n            let intermediateValue = previousShortValue + (currentShortValue - previousShortValue) * (intermediateIndex / Model.N);\n            outData.push(intermediateValue);\n        }\n    }\n    outData.push(currentShortValue);\n    previousShortValue = currentShortValue;\n}\nreturn outData;","supplementalCode":""}},"comparisonChart":{"name":"comparisonChart","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"\n    return {\n        \"chartType\": \"line\",\n        \"xValuesInputType\": \"common\",\n        \"commonXValueArray\": [],\n        \"datasets\": datasets,\n        \"generalOptions\": options,\n        \"storedData\": {\"chartType\":\"line\",\"xValuesInputType\":\"common\",\"commonXValueArray\":\"\",\"datasets\":\"datasets\",\"generalOptions\":\"options\"}\n    };","supplementalCode":""}},"datasets":{"name":"datasets","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return [\n    {\n        yArray: modifiedInputData,\n        datasetOptions: {\n            label: \"Input Data\",\n            fill: false,\n            borderColor: \"red\",\n            borderWidth: 1,\n            pointRadius: 0,\n            lineTension: 0\n        }\n    },\n    {\n        yArray: interpolatedData,\n        datasetOptions: {\n            label: \"Smoothed Data\",\n            fill: false,\n            borderColor: \"blue\",\n            borderWidth: 1,\n            pointRadius: 0,\n            lineTension: 0\n        }\n    },\n    {\n        yArray: bezierPoints,\n        datasetOptions: {\n            label: \"Bezier Smoothed Data\",\n            fill: false,\n            borderColor: \"green\",\n            borderWidth: 1,\n            pointRadius: 0,\n            lineTension: 0\n        }\n    },\n    {\n        yArray: altBezierPoints,\n        datasetOptions: {\n            label: \"Alt Bezier Smoothed Data\",\n            fill: false,\n            borderColor: \"orange\",\n            borderWidth: 1,\n            pointRadius: 0,\n            lineTension: 0\n        }\n    }\n];\n    ","supplementalCode":""}},"options":{"name":"options","type":"apogee.JsonTable","updateData":{"data":{"title":{"display":true,"text":"Smoothed Data Test"},"scales":{"xAxes":[{"type":"category","display":true}],"yAxes":[{"type":"linear","display":true}]}}}},"segmentInfo":{"name":"segmentInfo","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"let data = [];\nlet previousAnchor;\nlet currentAnchor = solutionVector[0];\nlet nextAnchor;\nfor(index = 0; index < solutionVector.length; index++) {\n    let entry = {};\n    entry.anchorPoint = currentAnchor;\n    entry.incomingDeltas = [];\n    data.push(entry);\n    \n    //get the delta from before the point\n    if(previousAnchor !== undefined) {\n        entry.incomingDeltas.push(currentAnchor - previousAnchor);\n    }\n    \n    //get the delta from after the point\n    if(index < solutionVector.length - 1) {\n        nextAnchor = solutionVector[index+1];\n        entry.incomingDeltas.push(nextAnchor - currentAnchor);\n    }\n\n    //get ready for next iteration\n    previousAnchor = currentAnchor;\n    currentAnchor = nextAnchor;\n}\nreturn data;","supplementalCode":""}},"bezierSegments":{"name":"bezierSegments","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"let data = [];\nlet currentSegment = {};\nlet previousSegment;\n//we ill have \nfor(let index = 0; index < segmentInfo.length; index++) {\n    let inEntry = segmentInfo[index];\n    \n    //get the anchor value\n    let anchorValue = inEntry.anchorPoint;\n    \n    //get the control point slope\n    let controlPointDelta;\n    if(inEntry.incomingDeltas.length == 2) controlPointDelta = (inEntry.incomingDeltas[0] + inEntry.incomingDeltas[1])/2\n    else controlPointDelta = inEntry.incomingDeltas[0];\n    \n    //add the previous control point\n    if(previousSegment) {\n        previousSegment.ctrlPoint2 = anchorValue - controlPointDelta/3;\n        previousSegment.nextAnchorPoint = anchorValue;\n    }\n    \n    //add the new segment, with the anchor and uif applicable, the next control point\n    currentSegment = {};\n    currentSegment.anchorPoint = anchorValue;\n    if(index < segmentInfo.length-1) {\n        currentSegment.ctrlPoint1 = anchorValue + controlPointDelta/3; \n    }\n    data.push(currentSegment);\n    \n    previousSegment = currentSegment;\n}\n\nreturn data;","supplementalCode":""}},"bezierInterpolatedData":{"name":"bezierInterpolatedData","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"let data = [];\n//add the points for each segment\nfor(let index = 0; index < (bezierSegments.length - 1); index++) {\n    let bezierInfo = bezierSegments[index];\n    //add the N points for this segment. The bezier parameter t is the fraction of the distance along the segment.\n    for(let n = 0; n < Model.N; n++) {\n        data.push({\n            point: _calculatePoint(bezierInfo,(n/Model.N)),\n            firstDeriv: _calculateFirstDeriv(bezierInfo,(n/Model.N)),\n            secondDeriv: _calculateSecondDeriv(bezierInfo,(n/Model.N))\n        })\n    }\n}\n//add the last point\ndata.push(bezierSegments[bezierSegments.length-1].anchorPoint);\nreturn data;","supplementalCode":"function _calculatePoint(bezierInfo,t) {\n    return Math.pow(1-t,3) * bezierInfo.anchorPoint + 3 * Math.pow(1-t,2) * t * bezierInfo.ctrlPoint1 +  3 * (1-t) * Math.pow(t,2) * bezierInfo.ctrlPoint2 + Math.pow(t,3) * bezierInfo.nextAnchorPoint;\n}\n\nfunction _calculateFirstDeriv(bezierInfo,t) {\n    return 3 * Math.pow(1-t,2) * (bezierInfo.ctrlPoint1 - bezierInfo.anchorPoint) + 6 * (1-t) * t * (bezierInfo.ctrlPoint2 - bezierInfo.ctrlPoint1) +  3 * Math.pow(t,2) * ( bezierInfo.nextAnchorPoint - bezierInfo.ctrlPoint2);\n}\n\nfunction _calculateSecondDeriv(bezierInfo,t) {\n    return 6 * (1-t) * (bezierInfo.ctrlPoint2 - 2 * bezierInfo.ctrlPoint1 + bezierInfo.anchorPoint) +  6 * t * ( bezierInfo.nextAnchorPoint - 2 * bezierInfo.ctrlPoint2 + bezierInfo.ctrlPoint1);\n}"}},"bezierPoints":{"name":"bezierPoints","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return bezierInterpolatedData.map(entry => entry.point);","supplementalCode":""}},"bezierFirstDeriv":{"name":"bezierFirstDeriv","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return bezierInterpolatedData.map(entry => entry.firstDeriv * (1/Model.N));","supplementalCode":""}},"bezierSecondDeriv":{"name":"bezierSecondDeriv","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return bezierInterpolatedData.map(entry => entry.secondDeriv * Math.pow(1/Model.N,2));","supplementalCode":""}},"getDeltaArray":{"name":"getDeltaArray","type":"apogee.FunctionTable","updateData":{"argList":["inArray"],"functionBody":"let previousValue = 0;\nreturn inArray.map( value => {\n    let delta = value - previousValue;\n    previousValue = value;\n    return delta;\n})","supplementalCode":""}},"inputDeltas":{"name":"inputDeltas","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return getDeltaArray(modifiedInputData);","supplementalCode":""}},"interpolatedDeltas":{"name":"interpolatedDeltas","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return getDeltaArray(interpolatedData);","supplementalCode":""}},"deltasChart":{"name":"deltasChart","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"\n    return {\n        \"chartType\": \"line\",\n        \"xValuesInputType\": \"common\",\n        \"commonXValueArray\": [],\n        \"datasets\": deltaDatasets,\n        \"generalOptions\": deltaOptions,\n        \"storedData\": {\"chartType\":\"line\",\"xValuesInputType\":\"common\",\"commonXValueArray\":\"\",\"datasets\":\"deltaDatasets\",\"generalOptions\":\"deltaOptions\"}\n    };","supplementalCode":""}},"deltaDatasets":{"name":"deltaDatasets","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return [\n/*{\n        yArray: inputDeltas,\n        datasetOptions: {\n            label: \"Input Deltas\",\n            fill: false,\n            borderColor: \"red\",\n            borderWidth: 1,\n            pointRadius: 0,\n            lineTension: 0\n        }\n    },*/\n    {\n        yArray: interpolatedDeltas,\n        datasetOptions: {\n            label: \"Smoothed Deltas\",\n            fill: false,\n            borderColor: \"blue\",\n            borderWidth: 1,\n            pointRadius: 0,\n            lineTension: 0\n        }\n    },\n/*    {\n        yArray: bezierDeltas,\n        datasetOptions: {\n            label: \"Bezier Smoothed Deltas\",\n            fill: false,\n            borderColor: \"green\",\n            borderWidth: 1,\n            pointRadius: 0,\n            lineTension: 0\n        }\n    },*/\n    {\n        yArray: bezierFirstDeriv,\n        datasetOptions: {\n            label: \"Bezier Derivative\",\n            fill: false,\n            borderColor: \"green\",\n            borderWidth: 1,\n            pointRadius: 0,\n            lineTension: 0\n        }\n    },\n    {\n        yArray: altBezierSlope,\n        datasetOptions: {\n            label: \"Alt Bezier Slope\",\n            fill: false,\n            borderColor: \"orange\",\n            borderWidth: 1,\n            pointRadius: 0,\n            lineTension: 0\n        }\n    }\n];","supplementalCode":""}},"deltaOptions":{"name":"deltaOptions","type":"apogee.JsonTable","updateData":{"data":{"title":{"display":true,"text":"Smoothed Data Deltas Test"},"scales":{"xAxes":[{"type":"category","display":true}],"yAxes":[{"type":"linear","display":true}]}}}},"bezierDeltas":{"name":"bezierDeltas","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return getDeltaArray(bezierPoints);","supplementalCode":""}},"sampleDataSetsDirty":{"name":"sampleDataSetsDirty","type":"apogee.JsonTable","updateData":{"data":[{"name":"Alabama","data":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.019745328801585,0.40789813152063403,0.8157962630412681,3.671083183685706,2.03949065760317,2.447388789123804,5.506624775528559,5.710573841288877,5.098726644007925,5.302675709768242,7.954013564652364,9.381657024974583,28.348920140684065,27.737072943403113,14.27643460322219,21.82255003635392,26.71732761460153,15.09223086626346,17.9475177869079,14.888281800503142,35.283188376534845,53.43465522920306,24.269938825477723,30.796308929807868,38.13847529717928,44.25694726998879,32.42790145589041,76.48089966011888,49.76357204551735,55.066247755285595,70.56637675306969,34.87529024501421,44.664845401509425,24.881786022758675]},{"name":"California","data":[0,0,0,0,0.050617248237336585,0,0,0,0,0.025308624118668292,0,0,0.07592587235600487,0,0,0,0,0,0,0,0.025308624118668292,0,0.025308624118668292,0,0,0,0,0,0,0,0.050617248237336585,0,0,0,0,0,0.025308624118668292,0,0.025308624118668292,0,0.22777761706801464,0.10123449647467317,0.25308624118668294,0.4049379858986927,0.20246899294934634,0.5567897306107025,0.3543207376613561,0.15185174471200974,1.0882708371027365,0.860493220034722,1.0882708371027365,1.5185174471200975,2.3030847947988144,0.025308624118668292,4.656786837834966,3.619133248969566,3.2395038871895414,4.4796264690042875,6.023452540243054,4.099997107224263,6.099378412599059,11.692584342824752,10.882708371027366,11.641967094587415,22.803070330920132,19.183937081950564,11.085177363976712,19.1586284578319,32.54689061660742,27.130845055212408,30.0919540770966,34.77404953905023,31.154916290080667,21.082083890850686,55.603047188714235,24.92899475688827,33.71108732606616,39.12713288746118,20.57591140847732,34.69812366669423,15.817890074167682,27.56109166522977,28.75059699880718,36.064789369102314,33.660470077828826]},{"name":"Mississippi","data":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.33600468256125615,1.6800234128062808,0,0,2.016028095367537,3.0240421430513056,4.36806087329633,5.376074920980098,10.080140476837684,20.160280953675368,22.512313731604163,14.112196667572759,23.85633246184919,19.1522669059916,36.28850571661567,31.584440160758078,28.224393335145518,32.25644952588059,29.56841206539054,30.240421430513052,45.69663682833084,34.94448698637064,60.816847543587365,32.59245420844184,61.48885690870988,33.600468256125616,59.47282881334234,29.56841206539054,86.35320341824283,70.22497865530254,58.128810083097314,46.704650876014604,54.09675389236224,48.72067897138214,91.72927833922293]},{"name":"North Carolina","data":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0953462996673177,0,0,0.0953462996673177,0,0,0,0.47673149833658846,0,0.7627703973385416,0.1906925993346354,0.7627703973385416,0.6674240976712239,0.6674240976712239,2.3836574916829423,2.6696963906848956,4.195237185361979,5.053353882367838,6.388202077710286,4.671968683698567,4.57662238403125,13.539174552759112,9.057898468395182,14.111252350763019,14.206598650430337,12.681057855753254,16.304217243111324,11.632248559412758,21.16687852614453,13.348481953424477,28.794582499529945,26.12488610884505,22.40638042181966,15.541446845772784,29.84339179587044,32.131702987886065,19.069259933463538,22.597073021154294,21.834302623815752,37.08971057058658,20.594800728140623,30.129430694872394,21.643610024481116,21.643610024481116]},{"name":"West Virginia","data":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.5579899416733114,0.5579899416733114,3.3479396500398684,2.2319597666932456,2.2319597666932456,0,3.3479396500398684,9.485829008446293,7.253869241753048,13.391758600159474,11.159798833466228,9.485829008446293,17.855678133545965,9.485829008446293,16.18170830852603,13.949748541832784,11.717788775139539,25.109547375299012,23.435577550279078,11.717788775139539,37.38532609211186,39.61728585880511,17.297688191872652,33.479396500398686,1.6739698250199342,8.927839066772982,10.043818950119604,16.18170830852603,34.595376383745304]}]}},"sampleDataSetsClean":{"name":"sampleDataSetsClean","type":"apogee.JsonTable","updateData":{"data":[{"name":"Alabama","data":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,7,11,29,39,51,78,106,131,157,196,242,381,517,587,694,825,899,987,1060,1233,1495,1614,1765,1952,2169,2328,2703,2947,3217,3563,3734,3953,4075,4345,4571,4712],"pop":4903185},{"name":"California","data":[0,0,0,0,2,2,2,2,2,3,3,3,6,6,6,6,6,6,6,6,7,7,8,8,8,8,8,8,8,8,10,10,10,10,10,10,11,11,12,12,21,25,35,51,59,81,95,101,144,178,221,281,372,373,557,700,828,1005,1243,1405,1646,2108,2538,2998,3899,4657,5095,5852,7138,8210,9399,10773,12004,12837,15034,16019,17351,18897,19710,21081,21706,22795,23931,25356,26686,27677,29157,30491],"pop":39512223},{"name":"New York","data":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,11,23,31,76,106,142,150,220,327,421,613,615,967,1578,3038,5704,8403,11727,15800,20884,25681,30841,37877,44876,52410,59648,66663,75833,83948,92506,102987,113833,123160,131815,139875,151061,161779,172348,181026,189033,195749,203020,214454,223691,230597,241712],"pop":19453561},{"name":"West Virginia","data":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,8,12,16,16,22,39,52,76,96,113,145,162,191,216,237,282,324,345,412,483,514,574,577,593,611,640,702,728,775,785],"pop":1792147}]}},"altSegmentInfo":{"name":"altSegmentInfo","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"let data = [];\nlet previousEndpoint;\nlet currentEndpoint;\nlet previousEntry;\nfor(index = 0; index < solutionVector.length+1; index++) {\n    //get the segment start and end\n    if(index < solutionVector.length) {\n        currentEndpoint = solutionVector[index];\n    }\n    else {\n        //project a new end point\n        currentEndpoint = previousEndpoint + previousEntry.startAnchorSlope * Model.N;\n    }\n    \n    if(!previousEndpoint) {\n        //oops - we are projecting back at zero slope\n        previousEndpoint = currentEndpoint;\n    }\n    \n    //get the anchor point and slope\n    let startX = (index - .5) * Model.N;\n    let startY = (previousEndpoint + currentEndpoint) / 2;\n    let startAnchor = [startX,startY];\n    startAnchorSlope = (currentEndpoint - previousEndpoint) / Model.N;\n    \n    //create current entry\n    let currentEntry = {};\n    currentEntry.startAnchor = startAnchor;\n    currentEntry.startAnchorSlope = startAnchorSlope;\n    data.push(currentEntry);\n    \n    //complete previous entry\n    if(previousEntry) {\n        previousEntry.endAnchor = startAnchor;\n        previousEntry.endAnchorSlope = startAnchorSlope;\n    }\n    \n    //if this is the last point, finish it, with projected data\n    if(index == solutionVector.length) {\n        currentEntry.endAnchor = [startAnchor[0] + Model.N,startAnchor[1] + startAnchorSlope * Model.N];\n        currentEntry.endAnchorSlope = startAnchorSlope;\n    }\n     \n    previousEndpoint = currentEndpoint;\n    previousEntry = currentEntry;\n}\nreturn data;","supplementalCode":""}},"altBezierInterpolatedData":{"name":"altBezierInterpolatedData","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"let data = [];\n//init bezier data\nlet bezierSegmentIndex = 0;\nlet bezierSegment = altBezierSegmentInfo[bezierSegmentIndex];\nlet getNextBezierSegment = () => {\n    bezierSegmentIndex++;\n    return altBezierSegmentInfo[bezierSegmentIndex];\n}\nlet dtdx = 1/Model.N;\n\n//get the bezier calculated values\nfor(let x = 0; x < modifiedInputData.length; x++) {\n     let entry = {};\n     entry.x = x;\n    \n    if(bezierSegment.p3[0] < x) bezierSegment = getNextBezierSegment();\n    let t = _getBezierT(bezierSegment,x);\n    \n    entry.y = _getBezierPointY(bezierSegment,t);\n    entry.dydx = _getBezierDerivativeY(bezierSegment,t) * dtdx;\n    data.push(entry);\n}\nreturn data;\n","supplementalCode":"function _getBezierT(bezierSegment,x) {\n    //here t is the fractional distance from start to end \n    return (x - bezierSegment.p0[0])/(bezierSegment.p3[0] - bezierSegment.p0[0]);\n}\n\nfunction _getBezierPointY(bezierSegment,t) {\n    return Math.pow(1-t,3) * bezierSegment.p0[1] + 3 * Math.pow(1-t,2) * t * bezierSegment.p1[1] +  3 * (1-t) * Math.pow(t,2) * bezierSegment.p2[1] + Math.pow(t,3) * bezierSegment.p3[1];\n}\n\nfunction _getBezierDerivativeY(bezierSegment,t) {\n    return 3 * Math.pow(1-t,2) * (bezierSegment.p1[1] - bezierSegment.p0[1]) + 6 * (1-t) * t * (bezierSegment.p2[1] - bezierSegment.p1[1]) +  3 * Math.pow(t,2) * ( bezierSegment.p3[1] - bezierSegment.p2[1]);\n}\n"}},"altBezierSegmentInfo":{"name":"altBezierSegmentInfo","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"//this is the distance between the anchor points and control points.\nlet deltaX = Model.N/3;\n\nreturn altSegmentInfo.map( inEntry => {\n    let outEntry = {};\n    outEntry.p0 = inEntry.startAnchor;\n    outEntry.p1 = _addToPoint(inEntry.startAnchor,inEntry.startAnchorSlope,deltaX);\n    outEntry.p2 = _addToPoint(inEntry.endAnchor,inEntry.endAnchorSlope,-deltaX);\n    outEntry.p3 = inEntry.endAnchor;\n    return outEntry;\n})","supplementalCode":"function _addToPoint(point,slope,deltaX) {\n    return [point[0] + deltaX, point[1] + slope * deltaX];\n}"}},"altBezierPoints":{"name":"altBezierPoints","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return altBezierInterpolatedData.map( entry => entry.y);","supplementalCode":""}},"altBezierSlope":{"name":"altBezierSlope","type":"apogee.JsonTable","updateData":{"argList":[],"functionBody":"return altBezierInterpolatedData.map( entry => entry.dydx);","supplementalCode":""}}}}}},"components":{"Model":{"type":"apogeeapp.app.FolderComponent","data":{"doc":{"type":"doc","content":[{"type":"heading1","content":[{"type":"text","text":"Smoothing Test Workspace"}]},{"type":"paragraph","content":[{"type":"text","text":"This workspace is a test of a piecewise linear approximation of out data. The basic idea is to place a reference point every N points of our input data, and fit the best set of these points. "}]},{"type":"paragraph","content":[{"type":"text","text":"Optionally, "},{"type":"text","marks":[{"type":"italic"}],"text":"after"},{"type":"text","text":" the linear fit, and cubic spline may be added to smooth the curve further, and give a continuous first and second derivitive, for the sake of better analyzing the curve."}]},{"type":"heading2","content":[{"type":"text","text":"Parameters"}]},{"type":"paragraph","content":[{"type":"text","text":"This is the spacing parameter for the piecewise curve creation."}]},{"type":"apogeeComponent","attrs":{"name":"N","id":0,"state":""}},{"type":"paragraph","content":[{"type":"text","text":"Doing a least squares fit of the data will create a tridiagonal system. The coefficients of the fitted parameters (the A matrix) do not depend on the data. The data is only present in the b Vector (in the equations b = Ax),"}]},{"type":"paragraph","content":[{"type":"text","text":"The following two parameters compose the tridiagonal matrix."}]},{"type":"apogeeComponent","attrs":{"name":"c1","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"c2","id":0,"state":""}},{"type":"paragraph","content":[{"type":"text","text":"Model Creation Functions"}]},{"type":"paragraph","content":[{"type":"text","text":"For now I will assume the data has a number of points so we don't have any odd sized segments."}]},{"type":"apogeeComponent","attrs":{"name":"createBVector","id":0,"state":""}},{"type":"paragraph","content":[{"type":"text","text":"We will model the tridiagonal A matrix by giving only the tridiagonal elements (so the dimensions of the matrix are m x 3)."}]},{"type":"apogeeComponent","attrs":{"name":"createTridiag","id":0,"state":""}},{"type":"heading2","content":[{"type":"text","text":"Tridiag Solver"}]},{"type":"paragraph","content":[{"type":"text","text":"This function solves a tridiagonal system of equations."}]},{"type":"apogeeComponent","attrs":{"name":"tridiagSolver","id":0,"state":""}},{"type":"paragraph"},{"type":"paragraph"},{"type":"paragraph"}]}},"children":{"N":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"isViewActive":false},"Private":{"isViewActive":false}}}}},"c1":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"isViewActive":true,"height":7000},"Private":{"isViewActive":false}}}}},"c2":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"isViewActive":true,"height":7000},"Private":{"isViewActive":false}}}}},"createBVector":{"type":"apogeeapp.app.FunctionComponent","viewState":{"childDisplayState":{"views":{"Code":{"isViewActive":true,"height":7000},"Private":{"isViewActive":false}}}}},"createTridiag":{"type":"apogeeapp.app.FunctionComponent","viewState":{"childDisplayState":{"views":{"Code":{"isViewActive":true,"height":7000},"Private":{"isViewActive":false}}}}},"tridiagSolver":{"type":"apogeeapp.app.FolderFunctionComponent","data":{"doc":{"type":"doc","content":[{"type":"heading1","content":[{"type":"text","text":"Tridiagonal Matrix Solver Folder Function"}]},{"type":"heading2","content":[{"type":"text","text":"Inputs"}]},{"type":"paragraph","content":[{"type":"text","text":"This is the input matrix. It should have dimensions of N x 3 and model a tridiagonal matrix."}]},{"type":"apogeeComponent","attrs":{"name":"AMatrix","id":0,"state":""}},{"type":"paragraph","content":[{"type":"text","text":"This is the b vector for the equation bVector = AMatrix * xVector;"}]},{"type":"apogeeComponent","attrs":{"name":"bVector","id":0,"state":""}},{"type":"paragraph","content":[{"type":"text","text":"This is the result vector from the input calculation"}]},{"type":"apogeeComponent","attrs":{"name":"xVector","id":0,"state":""}},{"type":"heading2","content":[{"type":"text","text":"Test"}]},{"type":"apogeeComponent","attrs":{"name":"test","id":0,"state":""}},{"type":"heading2","content":[{"type":"text","text":"Solution Functions"}]},{"type":"apogeeComponent","attrs":{"name":"tridiagSolver","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"tridiagMultiply","id":0,"state":""}},{"type":"paragraph"}]}},"children":{"test":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"height":7000,"isViewActive":true},"Private":{"isViewActive":false}}}}},"tridiagSolver":{"type":"apogeeapp.app.FunctionComponent","viewState":{"childDisplayState":{"views":{"Code":{"isViewActive":true,"height":7000},"Private":{"isViewActive":false}}}}},"tridiagMultiply":{"type":"apogeeapp.app.FunctionComponent","viewState":{"childDisplayState":{"views":{"Code":{"isViewActive":true,"height":7000},"Private":{"isViewActive":false,"height":7000}}}}},"bVector":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"isViewActive":false},"Private":{"isViewActive":false}}}}},"AMatrix":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"isViewActive":false},"Private":{"isViewActive":false}}}}},"xVector":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"height":7000,"isViewActive":true},"Private":{"isViewActive":false}}}}}},"viewState":{"treeState":-1,"tabOpened":true}}},"viewState":{"childDisplayState":null,"treeState":1,"tabOpened":true}},"test":{"type":"apogeeapp.app.FolderComponent","data":{"doc":{"type":"doc","content":[{"type":"heading1","content":[{"type":"text","text":"Modeling Test"}]},{"type":"paragraph","content":[{"type":"text","text":"TO DO:"}]},{"type":"bulletList","content":[{"type":"listItem","content":[{"type":"text","text":"I have two models for the bezier curve, one uses the line endpoints for the anchor points, the other uses the line center. Refine those and pick as good one. (The alt seems better but I could pull it in closer to the plain lines using stronger control points.)"}]},{"type":"listItem","content":[{"type":"text","text":"I currently am missing the last derivative point"}]},{"type":"listItem","content":[{"type":"text","text":"I need to check the first and second derivative results. They at least look reasonable."}]}]},{"type":"paragraph"},{"type":"paragraph","content":[{"type":"text","text":"Bug"}]},{"type":"bulletList","content":[{"type":"listItem","content":[{"type":"text","text":"NOTE - on the alt bezier, I project a virtual point back at the start. I assume the slope is 0! (it is often in this use case...)"}]}]},{"type":"heading2","content":[{"type":"text","text":"Test Data"}]},{"type":"paragraph","content":[{"type":"text","text":"This is a set of sample data."}]},{"type":"apogeeComponent","attrs":{"name":"sampleDataSetsDirty","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"sampleDataSetsClean","id":0,"state":""}},{"type":"paragraph","content":[{"type":"text","text":"This is a single data series from the sample data set."}]},{"type":"apogeeComponent","attrs":{"name":"sampleDataArray","id":0,"state":""}},{"type":"heading2","content":[{"type":"text","text":"Model Calculation"}]},{"type":"paragraph","content":[{"type":"text","text":"Our current calcualtion requires the proper number of points, so we will modify the sample data here by truncated extra points from the "},{"type":"text","marks":[{"type":"italic"}],"text":"front"},{"type":"text","text":" of the array (since that data is less interesting)."}]},{"type":"apogeeComponent","attrs":{"name":"modifiedInputData","id":0,"state":""}},{"type":"paragraph","content":[{"type":"text","text":"This is the tridiagonal matrix to find the solution"}]},{"type":"apogeeComponent","attrs":{"name":"AMatrix","id":0,"state":""}},{"type":"paragraph","content":[{"type":"text","text":"This is the b vector to find the solution."}]},{"type":"apogeeComponent","attrs":{"name":"bVector","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"solutionVector","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"interpolatedData","id":0,"state":""}},{"type":"heading2","content":[{"type":"text","text":"Alternate Interpolation - Cubic Bezier Curve"}]},{"type":"paragraph","content":[{"type":"text","text":"We can get an alternate interpolation between the fitted pionts using a quadratic bezier curve. The point of doing this is not to fit the data better, rather it is to smooth the curve more. The bezier curve added will be a function only of the calculated points and not otherwise depend on the original data. We will choose values to make continuous first and second derivatives, to allow us to have a smooth values for these differentiated quantities."}]},{"type":"paragraph","content":[{"type":"text","text":"We will ad the two control points at locations 1/3 and 2/3 from out calculated line endpoints (anchor points). We will make the slope of these control points match the average of the slope of the two lines entering the given anchor point."}]},{"type":"apogeeComponent","attrs":{"name":"segmentInfo","id":0,"state":""}},{"type":"paragraph","content":[{"type":"text","text":"Around each anchor point, we will place the control points on each side with equal distance and slope. This slope will be the average of the slopes of the segments before and after the anchor point. If there is no segment either before or after, we will just use the slop of the single neighboring line segment."}]},{"type":"apogeeComponent","attrs":{"name":"bezierSegments","id":0,"state":""}},{"type":"paragraph","content":[{"type":"text","text":"We can now do the interpolation with the bezier segments."}]},{"type":"apogeeComponent","attrs":{"name":"bezierInterpolatedData","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"bezierPoints","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"bezierFirstDeriv","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"bezierSecondDeriv","id":0,"state":""}},{"type":"heading2","content":[{"type":"text","text":"Alternate Bezier Interpolation"}]},{"type":"paragraph","content":[{"type":"text","text":"Here we will use anchor points centered on the line segments, rather than at the end of each line segment. (So the bezier segments aline with the line segments.) The control points will be along the path of the line segment."}]},{"type":"paragraph","content":[{"type":"text","text":"To handle the end points, we will extend the first segment back a half segment distance, and extend the last segment forward a half segment distance."}]},{"type":"apogeeComponent","attrs":{"name":"altSegmentInfo","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"altBezierSegmentInfo","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"altBezierInterpolatedData","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"altBezierPoints","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"altBezierSlope","id":0,"state":""}},{"type":"heading2","content":[{"type":"text","text":"Test Changes"}]},{"type":"apogeeComponent","attrs":{"name":"getDeltaArray","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"inputDeltas","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"interpolatedDeltas","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"bezierDeltas","id":0,"state":""}},{"type":"heading2","content":[{"type":"text","text":"Plotted Data"}]},{"type":"apogeeComponent","attrs":{"name":"comparisonChart","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"deltasChart","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"datasets","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"options","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"deltaDatasets","id":0,"state":""}},{"type":"paragraph"},{"type":"apogeeComponent","attrs":{"name":"deltaOptions","id":0,"state":""}},{"type":"heading2","content":[{"type":"text","text":"Development and Testing"}]},{"type":"apogeeComponent","attrs":{"name":"test","id":0,"state":""}},{"type":"paragraph"},{"type":"paragraph"}]}},"children":{"sampleDataArray":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":false,"height":280},"Formula":{"isViewActive":true,"height":7000},"Private":{"isViewActive":false}}}}},"modifiedInputData":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":false,"height":280},"Formula":{"isViewActive":false,"height":7000},"Private":{"isViewActive":false}}}}},"test":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":false,"height":280},"Formula":{"isViewActive":false,"height":7000},"Private":{"isViewActive":false}}}}},"AMatrix":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":false,"height":280},"Formula":{"isViewActive":false,"height":7000},"Private":{"isViewActive":false}}}}},"bVector":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":false,"height":280},"Formula":{"isViewActive":false,"height":7000},"Private":{"isViewActive":false}}}}},"solutionVector":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":false,"height":280},"Formula":{"isViewActive":false,"height":7000},"Private":{"isViewActive":false}}}}},"interpolatedData":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":false,"height":280},"Formula":{"isViewActive":false,"height":7000},"Private":{"isViewActive":false}}}}},"comparisonChart":{"type":"apogeeapp.app.ChartJSComponent","viewState":{"childDisplayState":{"views":{"Chart":{"isViewActive":true},"Input":{"isViewActive":false},"Config (Debug)":{"isViewActive":false}}}}},"datasets":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"height":280,"isViewActive":false},"Formula":{"height":7000,"isViewActive":false},"Private":{"isViewActive":false}}}}},"options":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"height":280,"isViewActive":false},"Formula":{"height":7000,"isViewActive":false},"Private":{"isViewActive":false}}}}},"segmentInfo":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"height":280,"isViewActive":true},"Formula":{"height":7000,"isViewActive":true},"Private":{"isViewActive":false}}}}},"bezierSegments":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"height":280,"isViewActive":false},"Formula":{"height":7000,"isViewActive":false},"Private":{"isViewActive":false}}}}},"bezierInterpolatedData":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":false,"height":280},"Formula":{"isViewActive":false,"height":7000},"Private":{"isViewActive":true,"height":7000}}}}},"bezierPoints":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"height":7000,"isViewActive":false},"Private":{"isViewActive":false}}}}},"bezierFirstDeriv":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"isViewActive":true,"height":7000},"Private":{"isViewActive":false}}}}},"bezierSecondDeriv":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"isViewActive":true,"height":7000},"Private":{"isViewActive":false}}}}},"getDeltaArray":{"type":"apogeeapp.app.FunctionComponent","viewState":{"childDisplayState":{"views":{"Code":{"height":7000,"isViewActive":true},"Private":{"isViewActive":false}}}}},"inputDeltas":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"isViewActive":true,"height":7000},"Private":{"isViewActive":false}}}}},"interpolatedDeltas":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"height":7000,"isViewActive":true},"Private":{"isViewActive":false}}}}},"deltasChart":{"type":"apogeeapp.app.ChartJSComponent","viewState":{"childDisplayState":{"views":{"Chart":{"isViewActive":true},"Input":{"isViewActive":false},"Config (Debug)":{"isViewActive":false}}}}},"deltaDatasets":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"height":280,"isViewActive":false},"Formula":{"height":7000,"isViewActive":true},"Private":{"isViewActive":false}}}}},"deltaOptions":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"height":280,"isViewActive":false},"Formula":{"isViewActive":false},"Private":{"isViewActive":false}}}}},"bezierDeltas":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"isViewActive":true,"height":7000},"Private":{"isViewActive":false}}}}},"sampleDataSetsDirty":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"isViewActive":false},"Private":{"isViewActive":false}}}}},"sampleDataSetsClean":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":true,"height":280},"Formula":{"isViewActive":false},"Private":{"isViewActive":false}}}}},"altSegmentInfo":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"height":280,"isViewActive":true},"Formula":{"height":7000,"isViewActive":true},"Private":{"isViewActive":false}}}}},"altBezierInterpolatedData":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"isViewActive":false,"height":280},"Formula":{"height":7000,"isViewActive":false},"Private":{"height":7000,"isViewActive":false}}}}},"altBezierSegmentInfo":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"height":280,"isViewActive":true},"Formula":{"height":7000,"isViewActive":false},"Private":{"height":7000,"isViewActive":false}}}}},"altBezierPoints":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"height":280,"isViewActive":false},"Formula":{"height":7000,"isViewActive":false},"Private":{"isViewActive":false}}}}},"altBezierSlope":{"type":"apogeeapp.app.JsonTableComponent","dataView":"Colorized","viewState":{"childDisplayState":{"views":{"Data":{"height":280,"isViewActive":true},"Formula":{"height":7000,"isViewActive":true},"Private":{"isViewActive":false}}}}}},"viewState":{"childDisplayState":null,"treeState":-1,"tabOpened":true,"tabShowing":true}},"viewState":{"treeState":1}}},"viewState":{"treeState":1}}