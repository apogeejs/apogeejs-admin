// File: apogeeWebApp.js
// Version: 1.0.0-p1
// Copyright (c) 2016-2020 Dave Sutter
// License: MIT

/** 
 * This namespace includes some utility functions available to the user.
 * @namespace
 */
let apogeeutil$1 = {};

/** None State - used by members. This indicates no state information is present. */
apogeeutil$1.STATE_NORMAL = "none";

/** Normal State - used by members */
apogeeutil$1.STATE_NORMAL = "normal";

/** Pending State - used by members */
apogeeutil$1.STATE_PENDING = "pending";

/** Error State - used by members */
apogeeutil$1.STATE_ERROR = "error";

/** Invalid State - used by members */
apogeeutil$1.STATE_INVALID = "invalid";

/** Standard dependency */
apogeeutil$1.NORMAL_DEPENDENCY = 1;

/** Pass through dependency */
apogeeutil$1.PASS_THROUGH_DEPENDENCY = 2;

/** This method creates a unique key for a field object target.  */
apogeeutil$1.createUniqueKey = function(targetType,targetId) {
    return targetType + targetId;
};

/** 
 * This value can be assigned to a data table to signify that data is not valid.
 * Any other member depending on this value will withhold the calcalation and also
 * return this invalid value.
 */
apogeeutil$1.INVALID_VALUE = {"apogeeValue":"INVALID VALUE"};

/**
 * This is a special throwable that is used to exit a function when the function definition depends
 * on another invalid value. I don't like to use exceptions for non-exceptional cases, which 
 * I consider this to be, but I couldn't figure out how else to exit the function.  */
apogeeutil$1.MEMBER_FUNCTION_INVALID_THROWABLE = {"apogeeException":"invalid"};

/**
 * This is a special throwable that is used to exit a function when the function definition depends
 * on another pending value. I don't like to use exceptions for non-exceptional cases, which 
 * I consider this to be, but I couldn't figure out how else to exit the function.  */
apogeeutil$1.MEMBER_FUNCTION_PENDING_THROWABLE = {"apogeeException":"pending"};

/** 
 * This function should be called from the body of a function table
 * to indicate the function will not return a valid value. (The actual invalid value
 * can not be returned since this typically will not have the desired effect.)
 */
apogeeutil$1.invalidFunctionReturn = function() {
    throw apogeeutil$1.MEMBER_FUNCTION_INVALID_THROWABLE;
};

/** This function reads any proeprty of the mixinObject and adds it
 * fo the prototypr of the destObject. This is intended to apend functions and
 * other properties to a cless directly without going through inheritance. 
 * Note this will overwrite and similarly named object in the dest class.*/
apogeeutil$1.mixin = function(destObject,mixinObject) {
    for(var key in mixinObject) {
        destObject.prototype[key] = mixinObject[key];
    }
};

/** 
 * This method creates an integer hash value for a string. 
 * 
 * @param {String} string - This is the string for which a hash number is desired.
 * @return {integer} This is the hash value for the string.
 */
apogeeutil$1.stringHash = function(string) {
    var HASH_SIZE = 0xffffffff;
    var hash = 0;
    var ch;
    for (var i = 0; i < string.length; i++) {
        ch = string.charCodeAt(i);
        hash = (31 * hash + ch) & HASH_SIZE;
    }
    return hash;
};

/** 
 * This method creates an integer hash value for a JSON object. 
 * 
 * @param {JSON} object - This is the json valued object for which a hash number is desired.
 * @return {integer} This is the hash value for the JSON.
 */
apogeeutil$1.objectHash = function(object) {
    //this is not real efficient. It should be implemented differently
    var string = JSON.stringify(object);
    return stringHash(string);
};

/**
 * @private
 */
apogeeutil$1.constructors = {
    "String": ("").constructor,
    "Number": (3).constructor,
    "Boolean": (true).constructor,
    "Date": (new Date()).constructor,
    "Object": ({}).constructor,
    "Array": ([]).constructor,
    "Function": (function(){}).constructor
};

/** This method returns the object type. The Allowed types are:
 * String, Number, Boolean, Date, Object, Array, Function, null, undefined.
 * @param {Object} object - This is the object for which the type is desired.
 * @returns {String} This is the type for the object. 
 */
apogeeutil$1.getObjectType = function(object) {
    if(object === null) return "null";
    if(object === undefined) return "undefined";
    
    var constructor = object.constructor;
    for(var key in apogeeutil$1.constructors) {
        if(constructor == apogeeutil$1.constructors[key]) {
            return key;
        }	
    }
    //not found
    return "Unknown";
};

/** This method creates a deep copy of an object, array or value. Note that
 * undefined is not a valid value in JSON. 
 * 
 * @param {JSON} data - This is a JSON valued object
 * @returns {JSON} A JSON object which is a deep copy of the input.
 */
apogeeutil$1.jsonCopy = function(data) {
    if(data === null) return null;
    if(data === undefined) return undefined;
    return JSON.parse(JSON.stringify(data));
};

/** This method takes a field which can be an object, 
 *array or other value. If it is an object or array it 
 *freezes that object and all of its children, recursively.
 * Warning - this does not check for cycles (which are not in JSON 
 * objects but can be in javascript objects)
 * Implementation from Mozilla */
apogeeutil$1.deepFreeze = function(obj) {
    if((obj === null)||(obj === undefined)) return;
    
    //retrieve the property names defined on obj
    var propNames = Object.getOwnPropertyNames(obj);

    //freeze properties before freezing self
    propNames.forEach(function(name) {
        var prop = obj[name];

        //freeze prop if it is an object
        if(typeof prop == 'object' && prop !== null) apogeeutil$1.deepFreeze(prop);
    });

    //freeze self (no-op if already frozen)
    return Object.freeze(obj);
};

/** This method does format string functionality. Text should include
 * {i} to insert the ith string argument passed. 
 *  @param {String} format - This is a format string to format the output.
 *  @param {Array} stringArgs - These are the values which should be placed into the format string.
 *  @returns {String} The format string with the proper inserted values is returned.  
 */
apogeeutil$1.formatString = function(format,stringArgs) {
    var formatParams = arguments;
    return format.replace(/{(\d+)}/g, function(match,p1) {
        var index = Number(p1) + 1;
        return formatParams[index]; 
    });
};

/** This method reads the query string from a url
 * 
 *  @param {String} field - This is the field that should be read from the url query string
 *  @param {String} url - This is the url from which we read the query string
 *  @returns {String} The value associated with the query string key passed in. 
 */
apogeeutil$1.readQueryField = function(field,url) {
    var href = url ? url : window.location.href;
    var reg = new RegExp( '[?&]' + field + '=([^&#]*)', 'i' );
    var string = reg.exec(href);
    return string ? string[1] : null;
};

/** 
 * This is a not-so-efficient equals for json objects. For JSON objects it
 * does not require order matching of the keys. For JSON arrays it does require
 * order matching of the array values.
 * 
 *  @param {JSON} json1 - This is a JSON valued object 
 *  @param {JSON} json1 - This is a JSON valued object 
 *  @returns {Boolean}  - Returns whether or not the objects are equal
 */
apogeeutil$1.jsonEquals = function(json1,json2) {
    var string1 = JSON.stringify(apogeeutil$1.getNormalizedCopy(json1));
    var string2 = JSON.stringify(apogeeutil$1.getNormalizedCopy(json2));
    return (string1 == string2);
};

/** 
 * This method returns a copied json that has the order in all JSON objects/"maps" normalized to alphabetical. 
 * The order of JSON arrays is NOT modified.
 * This is intended for the purpose of comparing json objects. 
 * 
 *  @param {JSON} json1 - This is a JSON valued object 
 *  @returns {Boolean}  - Returns whether or not the objects are equal
 */  
apogeeutil$1.getNormalizedCopy = function(json) {
    var copiedJson;

    var objectType = apogeeutil$1.getObjectType(json);
    
    switch(objectType) {
        case "Object":
            copiedJson = apogeeutil$1.getNormalizedObjectCopy(json);
            break;
            
        case "Array": 
            copiedJson = apogeeutil$1.getNormalizedArrayCopy(json);
            break;
            
        default:
            copiedJson = json;
    }
    
    return copiedJson;
};

/** this orders the keys apphabetically, since order is not important in a json object 
 * @private
 */
apogeeutil$1.getNormalizedObjectCopy = function(json) {
    var copiedJson = {};
    
    var keys = [];
    var key;
    for(key in json) {
        keys.push(key);
    }
    
    keys.sort();
    
    for(var i = 0; i < keys.length; i++) {
        key = keys[i];
        copiedJson[key] = apogeeutil$1.getNormalizedCopy(json[key]);
    }
    return copiedJson;
};

/** This method counts the properties in a object. */
apogeeutil$1.jsonObjectLength = function(jsonObject) {
    var count = 0;

    for(var key in jsonObject) {
        count++;
    }

    return count;
};

/** This makes a copy of with any contained objects normalized. 
 * @private 
 */
apogeeutil$1.getNormalizedArrayCopy = function(json) {
    var copiedJson = [];
    for(var i = 0; i < json.length; i++) {
        var element = json[i];
        copiedJson.push(apogeeutil$1.getNormalizedCopy(element));
    }
    return copiedJson;
};

//=============================
// Field Update Info Methods
//=============================
    
// }
//This is a version 
apogeeutil$1.isFieldUpdated = function(updateInfo,fieldName) {
    return updateInfo[fieldName] ? true : false;
};

//=================
// Some other generic utils
//=================

/** This methdo parses an arg list string to make an arg list array. It is
 * also used outisde this class. */
apogeeutil$1.parseStringArray = function(argListString) {
    var argList = argListString.split(",");
    for(var i = 0; i < argList.length; i++) {
        argList[i] = argList[i].trim();
    }
    return argList;
};

//=================
// Network request utils
//=================


/** 
 * This method does a standard callback request. It includes the following options:
 * - "method" - HTTP method, default value is "GET"
 * - "body" - HTTP body for the request
 * - "header" - HTTP headers, example: {"Content-Type":"text/plain","other-header":"xxx"}
 * @param {String} url - This is the url to be requested
 * @param {function} onSuccess - This is a callback that will be called if the request succeeds. It should take a String request body argument.
 * @param {function} onError - This is the callback that will be called it the request fails. It should take a String error message argument. 
 * @param {Object} options - These are options for the request.
 */
apogeeutil$1.callbackRequest = function(url,onSuccess,onError,options) {
    
    var xmlhttp=new XMLHttpRequest();

    xmlhttp.onreadystatechange=function() {
        var msg;
        if(xmlhttp.readyState==4) {
            if(xmlhttp.status==200) {
                try {
                    onSuccess(xmlhttp.responseText);
                }
                catch(error) {
                    onError(error.message);
                }

            }
            else if(xmlhttp.status >= 400)  {
                msg = "Error in http request. Status: " + xmlhttp.status;
                onError(msg);
            }
            else if(xmlhttp.status == 0) {
                msg = "Preflight error in request. See console";
                onError(msg);
            }
        }
    };

    if(!options) options = {};
    
    var method = options.method ? options.method : "GET";
    xmlhttp.open(method,url,true);
    
    if(options.header) {
        for(var key in options.header) {
            xmlhttp.setRequestHeader(key,options.header[key]);
        }
    }
    
    xmlhttp.send(options.body);
};

/** 
 * This method returns a promise object for an HTTP request. The promist object
 * returns the text body of the URL if it resolves successfully.
 *  
 * @param {String} url - This is the url to be requested
 * @param {Object} options - These are options for the request. See {@link apogeeutil.callbackRequest} for the options definition.
 * @return {Promise} This method returns a promise object with the URL body as text.
 */
apogeeutil$1.textRequest = function(url,options) {
    return new Promise(function(onSuccess,onError) {
        apogeeutil$1.callbackRequest(url,onSuccess,onError,options);
    });
};

/** 
 * This method returns a promise object for an HTTP request. The promist object
 * returns the JSON body of the URL if it resolves successfully.
 *  
 * @param {String} url - This is the url to be requested
 * @param {Object} options - These are options for the request. See {@link apogeeutil.callbackRequest} for the options definition.
 * @return {Promise} This method returns a promise object with the URL body as text.
 */
apogeeutil$1.jsonRequest = function(url,options) {
    return apogeeutil$1.textRequest(url,options).then(JSON.parse);
};

/* 
 * This is a mixin to give event functionality.
 */
var EventManager = {};
    
/** This serves as the constructor. */
EventManager.eventManagerMixinInit = function() {
     /** This field holds the event listeners
    * @private */
    this.listenerTable = {};
    
    /** This field holds the event handlers
    * @private */
    this.handlerTable = {};
};

/** This method adds a listener for the given event. */
EventManager.addListener = function(eventName, callback) {
    var callbackList = this.listenerTable[eventName];
    if(!callbackList) {
        callbackList = [];
        this.listenerTable[eventName] = callbackList;
    }
    //make sure the object is not already in the list
    for(var i = 0; i < callbackList.length; i++) {
        var c = callbackList[i];
        if(c == callback) {
            return;
        }
    }
    //add to the list
    callbackList.push(callback);
};

/** This method removes a listener for the event. */
EventManager.removeListener = function(eventName, callback) {
    var callbackList = this.listenerTable[eventName];
    if(callbackList) {
        var index = callbackList.indexOf(callback);
        if(index >= 0) {
            callbackList.splice(index,1);
        }
    }
};

/** THis method dispatches an event. */
EventManager.hasListeners = function(eventName) {
    return this.listenerTable[eventName] ? true : false;
};

/** THis method dispatches an event. */
EventManager.dispatchEvent = function(eventName, eventData) {
    var callbackList = this.listenerTable[eventName];
    if(callbackList) {
        for(var i = 0; i < callbackList.length; i++) {
            var callback = callbackList[i];
            callback.call(null,eventData);
        }
    }
};


/** This method adds a handler. */
EventManager.addHandler = function(handlerName, callback) {
    this.handlerTable[handlerName] = callback;
};

/** This method clears a handler. */
EventManager.removeHandler = function(handlerName) {
    delete this.handlerTable[handlerName];
};

/** This method calls a handler by name and returns the result. If no 
 * handler is found undefined is returned. */
EventManager.callHandler = function(handlerName, handlerData) {
    var callback = this.handlerTable[handlerName];
    if(callback) {
        return callback(handlerData)
    }
    else {
        return undefined;
    }
};

/** This resets all the listeners and handlers */
EventManager.clearListenersAndHandlers = function() {
    this.listenerTable = {};
    this.handlerTable = {};
};

/** This is a class for the field object formalism. It is used to store fields
 * and track modifications. It allows you to lock the object so that no more changes
 * can be made. */
class FieldObject {

    /** constructor.
     * - objectType - a text only string giving the name of the object type. This
     * is used in the id string.
     * - instanceToCopy - if this argument is defined, the created instance will be a shallow copy
     * of the this passed instance. By default it will have the updated fields flag cleared, but this
     * can be changed with the "keepUpdatedFixed" flag The new instance will be unlocked.
     * - keepUpdatedFixed - This should only be used when an instance is copied. If this is true
     * the copied instance will keep the same fields updated flags. Otherwise they will be cleared.
     * - specialCaseIdValue - This can be set if you wnt to create a new instance with a specific ID value. 
     * This should be done only in special circumstances. One example is "redo" creation of an object (after an undo)
     * subsequent commands for this object will reference its original ID. This is a way to set the ID of the recreaeted
     * object to match the original.
     */
    constructor(objectType,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        if(!instanceToCopy) {
            if(specialCaseIdValue) {
                this.id = specialCaseIdValue;
            }
            else {
                this.id = _createId(objectType);
            }
            this.objectType = objectType;
        }
        else {
            this.id = instanceToCopy.id;
            this.objectType = instanceToCopy.objectType;

        }

        this.fieldMap = {};
        if(instanceToCopy) {
            Object.assign(this.fieldMap,instanceToCopy.fieldMap);
        }

        this.updated = {};
        if(keepUpdatedFixed) {
            Object.assign(this.updated,instanceToCopy.updated);
        }

        this.isLocked = false;
    }

    /** This sets a field value. It will throw an exception if the object is locked. */
    setField(name,value) {
        if(this.isLocked) {
            throw new Error("Attempting to set a value on a locked object.");
        }

        this.fieldMap[name] = value;
        this.updated[name] = true;
    }

    /** This will clear the value of a field. */
    clearField(name) {
        if(this.fieldMap[name] !== undefined) {
            delete this.fieldMap[name];
            this.updated[name] = true;
        }
    }

    /** This ges a field value, by name. */
    getField(name) {
        return this.fieldMap[name];
    }

    /** This method locks the object. On instantiation the object is unlocked and
     * fields can be set. Once it it locked the fields can not be changed. */
    lock() {
        this.isLocked = true;
    }

    getIsLocked() {
        return this.isLocked;
    }

    /** This returns a map of the updated fields for this object.  */
    getUpdated() {
        return this.updated;
    }

    /** This returns true if the given field is updated. */
    isFieldUpdated(field) {
        return this.updated[field] ? true : false;
    }

    /** This returns true if any fields in the give list have been updated. */
    areAnyFieldsUpdated(fieldList) {
        return fieldList.some( field => this.updated[field]);
    }

    /** This method should be implemented for any object using this mixin. 
     * This should give a unique identifier for all objects of the given object type, below.
     * A unique id may optionally be generated using the statid FieldObject method createId. */
    getId() {
        return this.id;
    }

    /** Thie method should be implemented for any object using this method. 
     * It identifies the type of object. */
    getType() {
        return this.objectType;
    }

    /** This static functions returns the type of an object given the ID. */
    static getTypeFromId(id) {
        let typeEnd = id.indexOf("|");
        if(typeEnd < 0) {
            throw new Error("Invalid ID");
        }
        else {
            return id.substr(0,typeEnd);
        }
    }

    /** This static function indicates if the given ID is an object of the given type. */
    static idIsTypeOf(id,type) {
        return id.startsWith(type + "|");
    }

    /** This loads the current field object to have a copy of the data from the given field object.
     * The update field is however cleared. This method will throw an exception is you try to copy 
     * into a loacked object. */
    copyFromFieldsObject(otherFieldObject) {
        if(this.isLocked) {
            throw new Error("Attempting to copy fields into a locked object.");
        }

        for(name in otherFieldObject.fieldMap) {
            this.fieldMap[name] = otherFieldObject.fieldMap[name];
        }
        this.updated = {};
    }

    //================================
    // Static Methods
    //================================

    

}

/** This function generates a ID that is unique over the span of this application execution (until the 
 * integers wrap). This is suitable for creating the field object ID for an instance.
 * At some point we shouldhandle wrapping, and the three cases it can cause - negative ids, 0 id, and most seriously,
 * a reused id.
 * 
 * Currently planned future solution to wrapping: make this an operation issue. And event can be issued when we 
 * have reached given id values. Then it is the responsibility of the operator to restart the sytems. This is probably safer
 * than trying to com eup with some clever remapping solution. */
function _createId(objectType) {
    return objectType + "|" + nextId++;
}

/** This is used for Id generation.
 * @private */
let nextId = 1;

/** This class manages variable scope for the user code. It is used to look up 
 * variables both to find dependencies in member code or to find the value for
 * member code execution.
 * 
 * It has two lookup functions. "getMember" looks up members and is used to 
 * find dependencies. "getValue" looks up member values, for evaluating member values.
 * 
 * When a lookup is done, the named member/value is looked up in the local member scope. If it is not found,
 * the search is then done in the parent of the member. This chain continues until we reach a "root" object,
 * an example of which is the model object itself.
 * 
 * The root object has a lookup like the other context manager objects, however, if a lookup fails
 * to fins something, it does a lookup on global javascript variables. (Any filtering on this is TBD)
 * 
 * In the local scope for each context holder there is a context list, that allows for a number of entries. 
 * Currently the only one type of entry - parent entry. It looks up children of the current object.
 * 
 * In the future we can add imports for the local scope, and potentially other lookup types. 
 * */
function ContextManager(contextHolder) {
    this.contextHolder = contextHolder;

    this.contextList = [];
}

ContextManager.prototype.addToContextList = function(entry) {
    this.contextList.push(entry);
};

ContextManager.prototype.removeFromContextList = function(entry) {
    var index = this.contextList.indexOf(entry);
    if(index >= 0) {
        this.contextList.splice(index,1);
    }
};

ContextManager.prototype.clearContextList = function() {
    this.contextList = [];
};

ContextManager.prototype.getValue = function(model,varName) {
    var data = this.lookupValue(model,varName);
    
    //if the name is not in this context, check with the parent context
    if(data === undefined) {
        if((this.contextHolder)&&(!this.contextHolder.getIsScopeRoot())) {
            var parent = this.contextHolder.getParent(model);
            if(parent) {
                var parentContextManager = parent.getContextManager();
                data = parentContextManager.getValue(model,varName);
            }
        }
    }
    
    return data;
};

ContextManager.prototype.getMember = function(model,pathArray,optionalParentMembers) {
    let index = 0;
    var impactor = this.lookupMember(model,pathArray,index,optionalParentMembers);
    
    //if the object is not in this context, check with the parent context
    if(!impactor) {
        if((this.contextHolder)&&(!this.contextHolder.getIsScopeRoot())) {
            var parent = this.contextHolder.getParent(model);
            if(parent) {
                var parentContextManager = parent.getContextManager();
                impactor = parentContextManager.getMember(model,pathArray,optionalParentMembers);
            }
        }
    }
    
    return impactor;
};

//==================================
// Private Methods
//==================================

/** Check each entry of the context list to see if the data is present. */
ContextManager.prototype.lookupValue = function(model,varName) {
    var data;
    let childFound = false;
    for(var i = 0; i < this.contextList.length; i++) {
        var entry = this.contextList[i];        
        if(entry.contextHolderAsParent) {
            //for parent entries, look up the child and read the data
            var child = this.contextHolder.lookupChild(model,varName);
            if(child) {
                data = child.getData();
                childFound = true;
            }
        }
        
        if(childFound) return data;
    }

    if(this.contextHolder.getIsScopeRoot()) {
        data = this.getValueFromGlobals(varName);

        if(data != undefined) {
            return data;
        }
    }
    
    return undefined;
};

ContextManager.prototype.lookupMember = function(model,pathArray,index,optionalParentMembers) {
    var impactor;
    for(var i = 0; i < this.contextList.length; i++) {
        var entry = this.contextList[i];        
        if(entry.contextHolderAsParent) {
            //for parent entries, look up the child and read the data
            impactor = this.contextHolder.lookupChild(model,pathArray[index]);

            if((impactor)&&(impactor.isContextHolder)) {
                let childImpactor = impactor.getContextManager().lookupMember(model,pathArray,index+1);
                if(childImpactor) {
                    if(optionalParentMembers) {
                        optionalParentMembers.push(impactor);
                    }
                    impactor = childImpactor;
                }
            }

        }
        //no lookup in data entries
        
        if(impactor) return impactor;
    }
    
    return undefined;
};

ContextManager.prototype.getValueFromGlobals = function(varName) {
    //for now don't do any filtering
    //in the future we may want to do something so people don't deine their own globals - TBD
    return __globals__[varName];
};

/** This component encapsulates an object that has a context manager.
 * 
 * This is a mixin and not a class. It is used for the prototype of the objects that inherit from it.
 * 
 * COMPONENT DEPENDENCIES:
 */
let ContextHolder = {};

/** This initializes the component */
ContextHolder.contextHolderMixinInit = function(isScopeRoot) {
    this.isScopeRoot = isScopeRoot;

    //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
    //What kind of field is this? Dependent?
    //will be set on demand
    this.contextManager = null;
    //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
};

ContextHolder.isContextHolder = true;

/** This method retrieves the context manager. */
ContextHolder.getContextManager = function() {
    if(!this.contextManager) {
        //set the context manager
        this.contextManager = this.createContextManager();
    }
    
    return this.contextManager;
};

ContextHolder.getIsScopeRoot = function() {
    return this.isScopeRoot;
};

//this method must be implemneted in extending classes
///** This method retrieve creates the loaded context manager. */
//ContextHolder.createContextManager = function();

/** This component encapsulates an parent object that is a member and contains children members, creating  a 
 * hierarchical structure in the model. Each child has a name and this name
 * forms the index of the child into its parent. (I guess that means it doesn't
 * have to be a string, in the case we made an ArrayFolder, which would index the
 * children by integer.)
 * 
 * This is a mixin and not a class. It is used for the prototype of the objects that inherit from it.
 */
let Parent = {};

/** This initializes the component.
 * - isCopy - this should be set to true (or another value that evaluates to true) if this parent is being initialized
 * as a copy of aother instance.
 */
Parent.parentMixinInit = function(isCopy) {
    //default value. Can be reconfigured
    this.childrenWriteable = true;

    if(!isCopy) {
        //initialize the child mape
        this.setField("childIdMap",{});
    }
};

Parent.isParent = true;

/** This method returns the map of the children. */
Parent.getChildIdMap = function() {
    return this.getField("childIdMap");
};

/** This method looks up a child from this parent.  */
Parent.lookupChildId = function(name) {
    //check look for object in this folder
    let childIdMap = this.getField("childIdMap");
    return childIdMap[name];
};

/** This method looks up a child from this parent.  */
Parent.lookupChild = function(model,name) {
    let childId = this.lookupChildId(name);
    if(childId) {
        return model.lookupMemberById(childId);
    }
    else {
        return null;
    }
};

/** This method allows the UI to decide if the user can add children to it. This
 * value defaults to true. */
Parent.getChildrenWriteable = function() {
    return this.childrenWriteable;
};

/** This method sets the writeable property for adding child members. This value of
 * the method is not enforced (since children must be added one way or another). */
Parent.setChildrenWriteable = function(writeable) {
    this.childrenWriteable = writeable; 
};

/** This method adds a table to the folder. It also sets the folder for the
 *table object to this folder. It will fail if the name already exists.  */
Parent.addChild = function(model,child) {
    
    //check if it exists first
    let name = child.getName();
    let childIdMap = this.getField("childIdMap");
    if(childIdMap[name]) {
        //already exists! not fatal since it is not added to the model yet,
        throw new Error("There is already an object with the given name.");
    }

    //make a copy of the child map to modify
    let newChildIdMap = {};
    Object.assign(newChildIdMap,childIdMap);

    //add object
    newChildIdMap[name] = child.getId();
    this.setField("childIdMap",newChildIdMap);
    
    //set all children as dependents
    if(this.onAddChild) {
        this.onAddChild(model,child);
    }
};

//This method should optionally be implemented for any additional actions when a Child is added.
//Parent.onAddChild(model,child);

/** This method removes a table from the folder. */
Parent.removeChild = function(model,child) {
    //make sure this is a child of this object
    var parent = child.getParent(model);
    if((!parent)||(parent !== this)) return;
    
    //remove from folder
    var name = child.getName();
    let childIdMap = this.getField("childIdMap");
    //make a copy of the child map to modify
    let newChildIdMap = {};
    Object.assign(newChildIdMap,childIdMap);
    
    delete(newChildIdMap[name]);
    this.setField("childIdMap",newChildIdMap);
    
    //set all children as dependents
    if(this.onRemoveChild) {
        this.onRemoveChild(model,child);
    }
};

//This method should optionally be implemented for any additional actions when a Child is removed.
//Parent.onRemoveChild(model,child);

///** This method is called when the model is closed. 
//* It should do any needed cleanup for the object. */
Parent.onClose = function(model) {
    let childIdMap = this.getField("childIdMap");
    for(var key in childIdMap) {
        var childId = childIdMap[key];
        let child = model.lookupMemberById(childId);
        if((child)&&(child.onClose)) child.onClose(model);
    }

    if(this.onCloseAddition) {
        this.onCloseAddition();
    }
};

//This method should optionally be implemented if there are any additional actions when the parent is closed.
//This method will be called after all children have been closed.
//Parent.onCloseAddition();

//This method should be implemented to give the base name the children inherit for the full name. */
//Parent.getPossesionNameBase = function(model);

/** This method returns the full name in dot notation for this object. */
Parent.getChildFullName = function(model,childName) {
    return this.getPossesionNameBase(model) + childName;
};

/** This method looks up a member by its full name. */
Parent.getMemberByFullName = function(model,fullName) {
    var path = fullName.split(".");
    return this.lookupChildFromPathArray(model,path);
};

/** This method looks up a child using an arry of names corresponding to the
 * path from this folder to the object.  The argument startElement is an optional
 * index into the path array for fodler below the root folder. 
 * The optional parentMemberList argument can be passed in to load the parent members 
 * for the given member looked up. */
Parent.lookupChildFromPathArray = function(model,path,startElement,optionalParentMemberList) {
    if(startElement === undefined) startElement = 0;
    
    var childMember = this.lookupChild(model,path[startElement]);
    if(!childMember) return undefined;
    
    if(startElement < path.length-1) {
        if(childMember.isParent) {
            let grandChildMember = childMember.lookupChildFromPathArray(model,path,startElement+1,optionalParentMemberList);
            //record the parent path, if requested
            if((grandChildMember)&&(optionalParentMemberList)) {
                optionalParentMemberList.push(childMember);
            }
            return grandChildMember;
        }
        else {
            return childMember;
        }
    }
    else {
        return childMember;
    }
};

/** This is the model. 
 * -instanceToCopy - if the new instance should be a copy of an existing instance, this
 * argument should be populated. The copy will have the same field values but it will be unlocked 
 * and by default the update fields will be cleared. The event listeners are also cleared.
 * - keepUpdatedFixed - If this argument is set to true, the updated field values will be maintained.
 * */
class Model extends FieldObject {

    constructor(runContext,instanceToCopy,keepUpdatedFixed) {
        //base init
        super("model",instanceToCopy,keepUpdatedFixed);

        //mixin initialization
        this.eventManagerMixinInit();
        //this is a root for the context
        this.contextHolderMixinInit(true);
        this.parentMixinInit(instanceToCopy);

        this.runContext = runContext;

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            this.setField("name",Model.DEFAULT_MODEL_NAME);
            this.setField("impactsMap",{});
            //create the member map, with the model included
            let memberMap = {};
            memberMap[this.getId()] = this;
            this.setField("memberMap",memberMap);
        }

        //==============
        //Working variables
        //==============
        this.workingImpactsMap = null;
        this.workingMemberMap = null;
        this.workingChangeMap = {};

        //add a change map entry for this object
        this.workingChangeMap[this.getId()] = {action: instanceToCopy ? "updated" : "created", instance: this};

        // This is a queue to hold actions while one is in process.
        this.actionInProgress = false;
        this.messengerActionList = [];
        this.consecutiveActionCount = 0;
        this.activeConsecutiveActionLimit = Model.CONSECUTIVE_ACTION_INITIAL_LIMIT;
    }

    /** This method returns a mutable copy of this instance. If the instance is already mutable
     * it will be returned rather than making a new one.  */
    getMutableModel() {
        if(this.getIsLocked()) {
            //create a new instance that is a copy of this one
            let newModel = new Model(this.runContext,this);

            //update the member map for the new model
            let newMemberMap = {};
            let oldMemberMap = newModel.getField("memberMap");
            Object.assign(newMemberMap,oldMemberMap);
            newMemberMap[newModel.getId()] = newModel;
            newModel.setField("memberMap",newMemberMap);

            return newModel;
        }
        else {
            //return this instance since it si already unlocked
            return this;
        }
    }

    /** This gets a copy of the model where any unlocked members are replaced with new instance copies.
     * This ensures if we look up a mutable member from here we get a different instance from what was 
     * in our original model instance. */
    getCleanCopy(newRunContext) {
        let newModel = new Model(newRunContext,this);

        //update the member map for the new model
        let oldMemberMap = this.getField("memberMap");

        newModel._populateWorkingMemberMap();
        newModel.workingMemberMap[newModel.getId()] = newModel;

        for(let memberId in oldMemberMap) {
            let member = oldMemberMap[memberId];
            if((member != this)&&(!member.getIsLocked())) {
                //create a new copy of the member and register it.
                let newMember = new member.constructor(member.getName(),member.getParentId(),member);
                newModel.workingMemberMap[newMember.getId()] = newMember;
            }
        }

        return newModel;
    }

    /** This method locks all member instances and the model instance. */
    lockAll() {
        //clear up working fields
        this.workingChangeMap = null;

        //make sure the other working fields have been saved
        if(this.workingImpactsMap) this.finalizeImpactsMap();
        if(this.workingMemberMap) this.finalizeMemberMap();

        //member map includes all members and the model
        let memberMap = this.getField("memberMap");
        for(let id in memberMap) {
            //this will lock the model too
            //we maybe shouldn't be modifying the members in place, but we will do it anyway
            memberMap[id].lock();
        }
    }

    /** This shoudl be called after all dependencies have been updated to store the
     * impacts map (We kept a mutable working copy during construction for efficiency)  */
    finalizeImpactsMap() {
        if(this.workingImpactsMap) {
            this.setField("impactsMap",this.workingImpactsMap);
            this.workingImpactsMap = null;
        } 
    }

    finalizeMemberMap() {
        if(this.workingMemberMap) {
            this.setField("memberMap",this.workingMemberMap);
            this.workingMemberMap = null;
        }
    }

    /** This returns a map of the changes to the model. It is only valid while the 
     * model instance is unlocked. */
    getChangeMap() {
        return this.workingChangeMap;
    }

    /** This function should be used to execute any action that is run asynchronously with the current
     * action. The action is run on a model and it is uncertain whether the existing model will still be 
     * current when this new action is run. An example of when this is used is to populate a data table in
     * response to a json request completing.  */
    doFutureAction(actionData) {
        //run this action asynchronously
        this.runContext.doAsynchActionCommand(this.getId(),actionData);
    }

    /** This method returns the root object - implemented from RootHolder.  */
    setName(name) {
        this.setField("name",name);
    }

    /** This method returns the root object - implemented from RootHolder.  */
    getName() {
        return this.getField("name");
    }

    /** This method updates the dependencies of any children
     * based on an object being added. */
    updateDependeciesForModelChange(additionalUpdatedMembers) {
        //call update in children
        let childIdMap = this.getChildIdMap();
        for(var name in childIdMap) {
            var childId = childIdMap[name];
            let child = this.lookupMemberById(childId);
            if((child)&&(child.isDependent)) {
                child.updateDependeciesForModelChange(this,additionalUpdatedMembers);
            }
        }
    }

    //------------------------------
    // Queded Action Methods
    //------------------------------

    /** This function triggers the action for the queued action to be run when the current thread exits. */
    isActionInProgress() {
        return this.actionInProgress;
    }

    setActionInProgress(inProgress) {
        this.actionInProgress = inProgress;
    }

    saveMessengerAction(actionInfo) {
        this.messengerActionList.push(actionInfo);
    }

    getSavedMessengerAction() {
        if(this.messengerActionList.length > 0) {
            var actionData = {};
            actionData.action = "compoundAction";
            actionData.actions = this.messengerActionList;
            this.messengerActionList = [];
            return actionData;
        }
        else {
            return null;
        }
    }

    /** This method should be called for each consecutive queued action. It checks it if there are 
     * too many. If so, it returns true. In so doing, it also backs of the consecutive queued 
     * action count so next time it will take longer. Any call to clearConsecutiveQueuedActionCount
     * will return it to the default initial value.
     */
    checkConsecutiveQueuedActionLimitExceeded() {
        this.consecutiveActionCount++;
        
        //check the limit
        var exceedsLimit = (this.consecutiveActionCount > this.activeConsecutiveActionLimit);
        if(exceedsLimit) {
            //back off limit for next time
            this.activeConsecutiveActionLimit *= 2;
        }
        
        return exceedsLimit;
    }

    /** This should be called wo abort any queued actions. */
    setCalculationCanceled() {
        //reset queued action variables
        this.clearCommandQueue();
        
        alert("The tables are left in improper state because the calculation was aborted. :( ");
    }

    /** This should be called when there is not a queued action. */
    clearConsecutiveQueuedTracking() {
        this.consecutiveActionCount = 0;
        this.activeConsecutiveActionLimit = Model.CONSECUTIVE_ACTION_INITIAL_LIMIT;
    }

    /** This method resets the command queue */
    clearCommandQueue() {
        //reset queued action variables
        this.messengerActionList = [];
        this.clearConsecutiveQueuedTracking();
    }


    //------------------------------
    // Parent Methods
    //------------------------------

    /** this method gets the hame the children inherit for the full name. */
    getPossesionNameBase(model) {
        //the name starts over at a new model
        return "";
    }

    //------------------------------
    //ContextHolder methods
    //------------------------------

    /** This method retrieve creates the loaded context manager. */
    createContextManager() {
        //set the context manager
        var contextManager = new ContextManager(this);

        //add an entry for this folder. This is for multiple folders in the model base
        //which as of the time of this comment we don't have but plan on adding
        //(at which time this comment will probably be left in by accident...)
        var myEntry = {};
        myEntry.contextHolderAsParent = true;
        contextManager.addToContextList(myEntry);
        
        return contextManager;
    }

    //============================
    // MemberMap Functions
    //============================

    lookupMemberById(memberId) {
        let memberMap = this._getMemberMap();
        return memberMap[memberId];
    }

    /** This method returns a mutable member for the given ID. If the member is already unlocked, that member will be
     * returned. Otherwise a copy of the member will be made and stored as the active instance for the member ID.  */
    getMutableMember(memberId) {
        if(this.getIsLocked()) throw new Error("The model must be unlocked to get a mutable member.");

        let member = this.lookupMemberById(memberId);
        if(member) {
            if(member.getIsLocked()) {
                //create a unlocked copy of the member
                let newMember = new member.constructor(member.getName(),member.getParentId(),member);

                //update the saved copy of this member in the member map
                this.registerMember(newMember);
                return newMember;
            }
            else {
                return member;
            }
        }
        else {
            return null;
        }
    }

    registerMember(member) {
        if(!this.workingMemberMap) {
            this._populateWorkingMemberMap();
        }

        let memberId = member.getId();

        //update the change map for this member change
        let changeMapEntry = this.workingChangeMap[memberId];
        if(!changeMapEntry) {
            //if it already existed we don't need to change it (that means it was a create and we want to keep that)
            //otherwise add a new entry
            if(this.workingMemberMap[memberId]) {
                //this is an update
                this.workingChangeMap[memberId] = {action: "updated", instance: member};
            }
            else {
                //this is a create
                this.workingChangeMap[memberId] = {action: "created", instance: member};
            }
        }

        //add or update the member in the working member map
        this.workingMemberMap[memberId] = member;
    }

    unregisterMember(member) {
        if(!this.workingMemberMap) {
            this._populateWorkingMemberMap();
        }

        let memberId = member.getId();

        //update the change map for this member change
        let changeMapEntry = this.workingChangeMap[memberId];
        if(changeMapEntry) {
            if(changeMapEntry.action == "updated") {
                changeMapEntry.action = "deleted";
            }
            else if(changeMapEntry.action == "created") {
                //these cancel! however, we will keep the entry around and label
                //it as "transient", in case we get another entry for this member
                //I don't think we should get on after delete, but just in case
                changeMapEntry.action = "transient";
            }
            else if(changeMapEntry.action == "transient") ;
            else {
                //this shouldn't happen. We will just mark it as delete
                changeMapEntry.action = "deleted";
            }
        }
        else {
            changeMapEntry = {action: "deleted", instance: member};
            this.workingChangeMap[memberId] = changeMapEntry;
        }

        //remove the member entry
        delete this.workingMemberMap[memberId];
    }

    _getMemberMap() {
        return this.workingMemberMap ? this.workingMemberMap : this.getField("memberMap");
    }

    /** This method makes a mutable copy of the member map, and places it in the working member map. */
    _populateWorkingMemberMap() {
        let memberMap = this.getField("memberMap");
        let newMemberMap = {};
        Object.assign(newMemberMap,memberMap);
        this.workingMemberMap = newMemberMap;
    }

    //============================
    // Impact List Functions
    //============================

    /** This returns an array of members this member impacts. */
    getImpactsList(member) {
        let impactsMap = this.getField("impactsMap");
        let impactsList = impactsMap[member.getId()];
        if(!impactsList) impactsList = [];
        return impactsList;
    }
    
    /** This method adds a data member to the imapacts list for this node.
     * The return value is true if the member was added and false if it was already there. 
     * NOTE: the member ID can be a string or integer. This dependentMemberId should be an int. */
    addToImpactsList(depedentMemberId,memberId) {
        //don't let a member impact itself
        if(memberId === depedentMemberId) return;

        let workingMemberImpactsList = this.getWorkingMemberImpactsList(memberId);

        //add to the list iff it is not already there
        if(workingMemberImpactsList.indexOf(depedentMemberId) === -1) {
            workingMemberImpactsList.push(depedentMemberId);
            return true;
        }
        else {
            return false;
        }
    }

    /** This method removes a data member from the imapacts list for this node. */
    removeFromImpactsList(depedentMemberId,memberId) {

        let workingMemberImpactsList = this.getWorkingMemberImpactsList(memberId);

        //it should appear only once
        for(var i = 0; i < workingMemberImpactsList.length; i++) {
            if(workingMemberImpactsList[i] == depedentMemberId) {
                workingMemberImpactsList.splice(i,1);
                return;
            }
        }
    }
    
    /** This gets a edittable copy of a member impacts list.  */
    getWorkingMemberImpactsList(memberId) {
        //make sure our working impacts map is populated
        //we will use this wile buildign the impacts map and then set the impacts map field
        if(!this.workingImpactsMap) {
            this._populateWorkingImpactsMap();
        }

        let memberImpactsList = this.workingImpactsMap[memberId];
        if(!memberImpactsList) {
            memberImpactsList = [];
            this.workingImpactsMap[memberId] = memberImpactsList;
        }

        return memberImpactsList;
    }

    /** This method will load a mutable copy of the impacts map field to be used
     * when we update the impacts map. We use a working variable since the reconstruction
     * spans many calls to the add/remove function. In the copy, it makes a shallow copy of 
     * each impacts list in the map. */
    _populateWorkingImpactsMap() {
        let impactsMap = this.getField("impactsMap");
        let newImpactsMap = {};
        for(let idString in impactsMap) {
            let impactsList = impactsMap[idString];
            //shallow copy each array
            newImpactsMap[idString] = [...impactsList];
        }
        this.workingImpactsMap = newImpactsMap;
    }

    //============================
    // Save and Load Functions
    //============================

    /** This saves the model */
    toJson() {
        let json = {};
        json.fileType = Model.SAVE_FILE_TYPE;
        json.version = Model.SAVE_FILE_VERSION;

        json.name = this.getField("name");
        json.children = {};
        let childIdMap = this.getField("childIdMap");
        for(var name in childIdMap) {
            var childId = childIdMap[name];
            let child = this.lookupMemberById(childId);
            if(child) {
                json.children[name] = child.toJson(this);
            }
        }

        return json;
    }

    /** This method creates a headless model json from a folder json. It
     * is used in the folder function. */
    static createModelJsonFromFolderJson(name,folderJson) {
        let json = {};
        json.fileType = Model.SAVE_FILE_TYPE;
        json.version = Model.SAVE_FILE_VERSION;

        //let the workspace inherit the folder name
        json.name = name;
        json.children = {};

        //attach a single child named main
        json.children[folderJson.name] = folderJson;

        return json
    }

    //================================
    // Member generator functions
    //================================

    /** This methods retrieves the member generator for the given type. */
    static getMemberGenerator(type) {
        return memberGenerators[type];
    }

    /** This method registers the member generator for a given named type. */
    static addMemberGenerator(generator) {
        memberGenerators[generator.type] = generator;
    }

}

//add mixins to this class
apogeeutil$1.mixin(Model,EventManager);
apogeeutil$1.mixin(Model,ContextHolder);
apogeeutil$1.mixin(Model,Parent);

let memberGenerators = {};

Model.DEFAULT_MODEL_NAME = "Workspace";
Model.ROOT_FOLDER_NAME = "main";

/** This is the supported file type. */
Model.SAVE_FILE_TYPE = "apogee model";

/** This is the supported file version. */
Model.SAVE_FILE_VERSION = 0.3;

Model.CONSECUTIVE_ACTION_INITIAL_LIMIT = 500;

Model.EMPTY_MODEL_JSON = {
    "fileType": Model.SAVE_FILE_TYPE,
    "version": Model.SAVE_FILE_VERSION,
    "name": Model.DEFAULT_MODEL_NAME,
    "children": {
        "main": {
            "name": Model.ROOT_FOLDER_NAME,
            "type": "apogee.Folder"
        }
    }
};

/** This module contains functions to process an update to an member
 * which inherits from the FunctionBase component. */


/** This moethod should be called on an member (impactor or dependent) that changes.
 * This will allow for any Dependents to be recaculated. */
function addToRecalculateList(model,recalculateList,member) {
    //if it is in the list, return
    if(recalculateList.indexOf(member) >= 0) return;
     
    //add this member to recalculate list if it needs to be executed
    if((member.isDependent)&&(member.memberUsesRecalculation())) {
        recalculateList.push(member);
        member.prepareForCalculate();
    }
        
    addDependsOnToRecalculateList(model,recalculateList,member);
}

function addDependsOnToRecalculateList(model,recalculateList,member) {
    //add any member that depends on this one  
    var impactsList = model.getImpactsList(member);
    for(var i = 0; i < impactsList.length; i++) {
        let dependent = model.getMutableMember(impactsList[i]);
        addToRecalculateList(model,recalculateList,dependent);
    }
}



/** This calls execute for each member in the recalculate list. The return value
 * is false if there are any errors. */
function callRecalculateList(model,recalculateList) {
    var dependent;
    var i;
    var success = true;
    for(i = 0; i < recalculateList.length; i++) {
        dependent = recalculateList[i];
        if(dependent.getCalcPending()) {
            dependent.calculate(model);   
        }
    }
    
    return success;
}

/**
 * Action Module
 * An action is an operation on the data model. A mutable (unlocked) model must be passed in. 
 * After the action is completed, the model will be locked, and represent immutable data state.
 * 
 * The code in this module handles
 * the generic parts of the action process, and the action specific code is placed
 * elsewhere.
 * 
 * Generic Action:
 * - The action is represented by a data object "actionData". 
 * - The method doAction is called to exectue the action.
 * - Available actions are registered through the method addActionInfo.
 *   this allows the doAction method to dispatch the actionData to the proper
 *   action specific code.
 * - Included in doing that action is any updates to dependent tables and the 
 * firing of any events for the changes.
 *   
 * Registering a specific action:
 * To register a specific action, addActionInfo must be called with 
 * the name of the action and the function taht executes the action. The function
 * should be of the form: 
 * actionResult = function actionFunction(model,actionData)
 * 
 * Action Data Format:
 * The action data is used to pass data into the action specific code, Format:
 * actionData format: {
 *   "action": (The name of the action to execute),
 *   "member": (The data object that is acted upon , if applicable),
 *   (other, multiple): (Specific data for the action)
 * }
 * 
 * ChangeResult:
 * The return value of the doAction function is a change result. This is a listing of all data objects whcih changed, in the success case.
 * The format is as follows:
 * Format: {
 *  actionDone: (true/false)
 *  actionPending: (Rather than actionDone, actionPending will be returned if doAction is called while another action is in
 *      process. This should only happen for actions being called by the messenger.)
 *  errorMsg: (An error message in the case actionDone is false.)
 *  model: (The model object which was acted on.)
 *  changeList: (An array of changed objects:)
 *      - event: (the change to the object: created/updated/deleted)
 *      - model: (the model, if the object was the model)
 *      - member: (the member, if the object was a member)
 * }
 *  *   "actionPending": (This flag is returned if the action is a queued action and will be run after the
 *                  current action completes.)
 * 
 * ActionResult:
 * The return value of the an action function (not the doAction function) is an ActionResult struct, with the data below. The function should return
 * an action result for each member/model that changes. There should be a single top level action result and then there can be 
 * child action results, in the childActionResults field. An important function of the action result is to tell the doAction function
 * how to calculate updates to the model based on changes to specific members. The flags recalculateMember, recalculateDependsOnMember,
 * updateMemberDependencies and updateModelDependencies serve this purpose and are described below.
 * Format: {
 *   "actionDone": (If this is returned true the action was done. This does not mean it was error free, rather
 *                  if means the action completed and can be undone. For example, it may be setting code in a member
 *                  and the code may be invalid. That is OK. It is displayed in the UI as an error and "actionDone" = true.
 *                  ActionDone should be false there was an error such that the state of the program is compromised and the 
 *                  action can not be undone. In this case, the program will keep the original state rather than adopting 
 *                  the new state the results from the action.
 *   "actionPending": (This flag is returned if the action is a queued action and will be run after the
 *                  current action completes.)
 *   "model": (The model on which the action is acting)
 *   "member": (The object modified in the action, if it is a member. Another option is a model update, in which 
 *                  case this field is left undefined, but a model event will be included. It is also possible that
 *                  there is no member listed because the action result does not corrspond to an action on a member of 
 *                  the model. This is true on the top level result of a compound action.)
 *   "event": (This is the event that should be fired as a result of this action/actionResult. The options are:
 *                  "created", "updated" and "deleted".)
 *   "errorMsg": (This is the error message for is the actionDone is false)
 *   "childActionResults" - (This is a list of action results if there are additional child actions done with this
 *                  action. Examples where this is used are on creating, moving or deleting a folder that has chilren.)
 *   "recalculateMember" - (This is an optional action flag. The is set of the member is a dependent and it must be recalculated.)
 *   "recalculateDependsOnMember" - (This is an optional action flag. This is set if the member has its value changed, but the 
 *                  member does not need to be recalculated. The members that depend on this do however need to be recalculated.)
 *   "updateMemberDependencies" - (This is an optional action flag. The is set of the member is a dependent and it must have its dependencies
 *                  recalculated, such as if the code changes.)
 *   "updateModelDepedencies" - (This is an optional action flag. The is set of the member is a dependent and it is created, deleted or moved.
 *                  In this case, all members in the model should be checked to see if they have any dependency changes.)
 * }
 * 
 */ 

/** This structure holds the processing information for all the actions. It is set by each action. 
 * @private */
let actionInfoMap = {
};

/** This method is used to execute an action for the data model. The model object passed in should be _unlocked_.
 * At the completion of the action, before returning, the model will be locked, meaning it can not longer be changed. */
function doAction(model,actionData) {
    
    //only allow one action at a time
    if(model.isActionInProgress()) {
        //this is a messenger action - we will save it and execute it after this computation cycle is complete
        model.saveMessengerAction(actionData);
        
        //mark command as pending
        let changeResult = {};
        changeResult.actionPending = true;
        return changeResult;
    }
    
    //execute the main action
    let {success, errorMsg} = internalDoAction(model,actionData);
    if(!success) {
        model.clearCommandQueue();
        model.lockAll();

        let changeResult = {};
        changeResult.actionDone = false;
        changeResult.model = model;
        changeResult.errorMsg = errorMsg;
        return changeResult;
    }
    
    //trigger any pending actions
    //these will be done asynchronously
    var savedMessengerAction;
    while(savedMessengerAction = model.getSavedMessengerAction()) {
        var runQueuedAction = true;

        if(model.checkConsecutiveQueuedActionLimitExceeded()) {
            //ask user if about continueing
            var doContinue = confirm("The calculation is taking a long time. Continue?");
            if(!doContinue) {
                model.setCalculationCanceled();
                model.lockAll();

                let changeResult = {};
                changeResult.actionDone = false;
                changeResult.model = model;
                changeResult.errorMsg = "The calculation was canceled";
                return changeResult;         
            }
        }

        if(runQueuedAction) {
            //this action is run synchronously
            let {success, errorMsg} = internalDoAction(model,savedMessengerAction);
            if(!success) {
                model.clearCommandQueue();
                model.lockAll();

                let changeResult = {};
                changeResult.actionDone = false;
                changeResult.model = model;
                changeResult.errorMsg = errorMsg;
                return changeResult;
            }
        }
    }
    
    model.clearConsecutiveQueuedTracking(); 
    
    //fire the events
    let changeList = changeMapToChangeList(model.getChangeMap());
    fireEvents(model,changeList);

    //lock the model
    model.lockAll();

    //return result
    let changeResult = {};
    changeResult.actionDone = true;
    changeResult.model = model;
    changeResult.changeList = changeList;
    return changeResult;
}

/** This function is used to register an action. */
function addActionInfo(actionName,actionFunction) {
    actionInfoMap[actionName] = actionFunction;
}

//=======================================
// Internal Methods
//=======================================

/** This method executes a single action function, */
function internalDoAction(model,actionData) {

    let success, errorMsg;

    //flag action in progress
    model.setActionInProgress(true);  

    try {

        //do the action
        let actionResult = callActionFunction(model,actionData); 
        
        //flatten action result tree into a list of objects modified in the action
        var {actionModifiedMembers, actionDone, errorMsgList} = flattenActionResult(actionResult);

        //return in the failure case
        if(actionDone) {
            //this list will be additional modified members - from dependency changes
            //due to adding and deleting members (This happens when a new remote member is referenced
            //a member formula because of creating or deleting. This is not a common event, but it does happen)
            var additionalUpdatedMembers = [];
            
            //figure out other objects that need to be updated
            //also update dependencies (and the inverse - impacts)
            var updateAllDep = checkUpdateAllDep(actionModifiedMembers);
            if(updateAllDep) {
                //update entire model - see conditions bewlo
                model.updateDependeciesForModelChange(additionalUpdatedMembers);
            }
            else {
                updateDependenciesFromAction(model,actionModifiedMembers);
            }

            //commit the updated impacts map (inverse of dependency map) 
            model.finalizeImpactsMap();
            model.finalizeMemberMap();

            //populate recalc list
            let recalculateList = createRecalculateList(model,actionModifiedMembers,additionalUpdatedMembers);
            
            //recalculate all needed objects
            callRecalculateList(model,recalculateList);

            success = true;
        }
        else {
            success = false;
            errorMsg = errorMsgList.join("; ");
        }

    }
	catch(error) {
        if(error.stack) console.error(error.stack);
        success = false;
        errorMsg = "Unknown error updating model: " + error.message;
    }

    //flag action in progress
    model.setActionInProgress(false);

    return {success, errorMsg};
}

/** This function looks up the proper function for an action and executes it. */
function callActionFunction(model,actionData) {

    let actionResult;

    //do the action
    var actionFunction = actionInfoMap[actionData.action];
    if(actionFunction) {
        actionResult = actionFunction(model,actionData);
    }
    else {
        actionResult = {};
        actionResult.actionDone = false;
        actionResult.errorMsg = "Unknown action: " + actionData.action;
    }  

    return actionResult;
}

/** This method makes sure the member dependencies in the model are properly updated. 
 * @private */
function updateDependenciesFromAction(model,actionModifiedMembers) {
    //upate dependencies on table with updated code
    actionModifiedMembers.forEach(actionResult => {
        if((actionResult.member)&&(actionResult.member.isCodeable)&&(actionResult.updateMemberDependencies)) {
            actionResult.member.initializeDependencies(model);
        }
    });
}

/** This method takes the members that are updated (either by code or value) and
 * adds them to the list of members that need to be recalculated. To do this, we must
 * first have all dependencies updated, sicne it relies on the impacts list. */
function createRecalculateList(model,actionModifiedMembers,additionalUpdatedMembers) {
    let recalculateList = [];

    //add members from each action and/or fields they impact, if applicable
    actionModifiedMembers.forEach( actionResult => {
        //update the recalc list
        if(actionResult.recalculateMember) {
            addToRecalculateList(model,recalculateList,actionResult.member);            
        }
        else if(actionResult.recalculateDependsOnMembers) {
            addDependsOnToRecalculateList(model,recalculateList,actionResult.member);                         
        }
    });

    //add any other modified members to the racalculate list
    additionalUpdatedMembers.forEach(member => addToRecalculateList(model,recalculateList,member));

    return recalculateList;
}

/** This function fires the proper events for the  It combines events to 
 * fire a single event for each member.
 * @private */
function fireEvents(model,changeList) {
    changeList.forEach(changeListEntry => {
        model.dispatchEvent(changeListEntry.event,changeListEntry.instance);
    });
}

function changeMapToChangeList(changeMap) {
    let changeList = [];
    for(let id in changeMap) {
        let changeMapEntry = changeMap[id];

        //ignore the transient objects
        if(changeMapEntry.action == "transient") continue;

        let changeListEntry = {};
        changeListEntry.event = changeMapEntry.instance.getType() + "_" + changeMapEntry.action;
        changeListEntry.instance = changeMapEntry.instance;
        changeList.push(changeListEntry);
    }
    return changeList;
}

/** This method determines if updating all dependencies is necessary. Our dependency 
 * tracking may be in error if a new member is created, a member is deleted or
 * a member is moved. In these actions we flag that the entire model should be
 * updated.*/
function checkUpdateAllDep(completedResults) {
    //return true if any results have the updateModelDependencies flag set
    return completedResults.some(result => result.updateModelDependencies)
}

/** This method unpacks the actionResult and its child reponse into an array of actionResult. */
function flattenActionResult(actionResult) {
    let actionResultInfo = {};
    actionResultInfo.actionModifiedMembers = [];
    actionResultInfo.actionDone = true;
    actionResultInfo.errorMsgList = [];

    addToCompletedResultList(actionResultInfo,actionResult);

    return actionResultInfo;
}

function addToCompletedResultList(actionResultInfo,actionResult) {
    actionResultInfo.actionModifiedMembers.push(actionResult);
    if(!actionResult.actionDone) actionResultInfo.actionDone = false;
    if(actionResult.errorMsgList) actionResultInfo.errorMsgList.push(actionResult.errorMsg);

    if(actionResult.childActionResults) {
        actionResult.childActionResults.forEach( childActionResult => {
            addToCompletedResultList(actionResultInfo,childActionResult);
        });
    }
}

//============================================
// Compound Action
//============================================

/** The compound action is automatically imported when the action module is imported.
 *
 * Action Data format:
 * {
 *  "action": "compoundAction",
 *  "actions": (list of actions in this compound action),
 * }
 */


/** This method is the action function for a compound action. */
function compoundActionFunction(model,actionData) {

    let actionResult = {};

    var actionList = actionData.actions;
    actionResult.childActionResults = [];
    for(var i = 0; i < actionList.length; i++) {
        let childActionData = actionList[i];
        let childActionResult = callActionFunction(model,childActionData);
        actionResult.childActionResults.push(childActionResult);   
    }
    actionResult.actionDone = true;
    return actionResult;
}

//This line of code registers the action 
addActionInfo("compoundAction",compoundActionFunction);

/*
  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//-----------------------------------------
// ES6 Module Conversion - Added to execute this UMD module as CommonJS and use "exports" as the export.
// Additional code appears at the bottom of the file.
let module = {};
module.exports = {};
let exports = module.exports;
//------------------------------------------

(function (root, factory) {

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(undefined, function (exports) {

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PlaceHolders,
        Messages,
        Regex,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        hasLineTerminator,
        lastIndex,
        lastLineNumber,
        lastLineStart,
        startIndex,
        startLineNumber,
        startLineStart,
        scanning,
        length,
        lookahead,
        state,
        extra,
        isBindingElement,
        isAssignmentTarget,
        firstCoverInitializedNameError;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9,
        Template: 10
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';
    TokenName[Token.Template] = 'Template';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForOfStatement: 'ForOfStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchCase: 'SwitchCase',
        SwitchStatement: 'SwitchStatement',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    PlaceHolders = {
        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedTemplate: 'Unexpected quasi %0',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode',
        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
        DefaultRestParameter: 'Unexpected token =',
        ObjectPatternAsRestParameter: 'Unexpected token {',
        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
        ConstructorSpecialMethod: 'Class constructor may not be an accessor',
        DuplicateConstructor: 'A class may only have one constructor',
        StaticPrototype: 'Classes may not have static property named prototype',
        MissingFromClause: 'Unexpected token',
        NoAsAfterImportNamespace: 'Unexpected token',
        InvalidModuleSpecifier: 'Unexpected token',
        IllegalImportDeclaration: 'Unexpected token',
        IllegalExportDeclaration: 'Unexpected token',
        DuplicateBinding: 'Duplicate binding %0'
    };

    // See also tools/generate-unicode-regex.js.
    Regex = {
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,

        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 0x30 && ch <= 0x39);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }

    function octalToDecimal(ch) {
        // \0 is not octal escape sequence
        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);

        if (index < length && isOctalDigit(source[index])) {
            octal = true;
            code = code * 8 + '01234567'.indexOf(source[index++]);

            // 3 digits are only allowed when string starts
            // with 0, 1, 2, 3
            if ('0123'.indexOf(ch) >= 0 &&
                    index < length &&
                    isOctalDigit(source[index])) {
                code = code * 8 + '01234567'.indexOf(source[index++]);
            }
        }

        return {
            code: code,
            octal: octal
        };
    }

    // ECMA-262 11.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // ECMA-262 11.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // ECMA-262 11.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        return (cp < 0x10000) ? String.fromCharCode(cp) :
            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
            String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
    }

    function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch)));
    }

    // ECMA-262 11.6.2.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'enum':
        case 'export':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // ECMA-262 11.6.2.1 Keywords

    function isKeyword(id) {
        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // ECMA-262 11.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment;

        assert(typeof start === 'number', 'Comment must have valid position');

        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
        if (extra.tokenize) {
            comment.type = comment.type + 'Comment';
            if (extra.delegate) {
                comment = extra.delegate(comment);
            }
            extra.tokens.push(comment);
        }
    }

    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;

        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                hasLineTerminator = true;
                ++lineNumber;
                ++index;
                lineStart = index;
            } else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        // Ran off the end of the file - the whole thing is a comment
        if (extra.comments) {
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            comment = source.slice(start + 2, index);
            addComment('Block', comment, start, index, loc);
        }
        tolerateUnexpectedToken();
    }

    function skipComment() {
        var ch, start;
        hasLineTerminator = false;

        start = (index === 0);
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                ++index;
                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 0x2F) { // U+002F is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                } else if (ch === 0x2A) {  // U+002A is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 0x2D) { // U+002D is '-'
                // U+003E is '>'
                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                } else {
                    break;
                }
            } else if (ch === 0x3C) { // U+003C is '<'
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment(4);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanUnicodeCodePointEscape() {
        var ch, code;

        ch = source[index];
        code = 0;

        // At least, one hex digit is required.
        if (ch === '}') {
            throwUnexpectedToken();
        }

        while (index < length) {
            ch = source[index++];
            if (!isHexDigit(ch)) {
                break;
            }
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
        }

        if (code > 0x10FFFF || ch !== '}') {
            throwUnexpectedToken();
        }

        return fromCodePoint(code);
    }

    function codePointAt(i) {
        var cp, first, second;

        cp = source.charCodeAt(i);
        if (cp >= 0xD800 && cp <= 0xDBFF) {
            second = source.charCodeAt(i + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) {
                first = cp;
                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
        }

        return cp;
    }

    function getComplexIdentifier() {
        var cp, ch, id;

        cp = codePointAt(index);
        id = fromCodePoint(cp);
        index += id.length;

        // '\u' (U+005C, U+0075) denotes an escaped character.
        if (cp === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwUnexpectedToken();
            }
            ++index;
            if (source[index] === '{') {
                ++index;
                ch = scanUnicodeCodePointEscape();
            } else {
                ch = scanHexEscape('u');
                cp = ch.charCodeAt(0);
                if (!ch || ch === '\\' || !isIdentifierStart(cp)) {
                    throwUnexpectedToken();
                }
            }
            id = ch;
        }

        while (index < length) {
            cp = codePointAt(index);
            if (!isIdentifierPart(cp)) {
                break;
            }
            ch = fromCodePoint(cp);
            id += ch;
            index += ch.length;

            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (cp === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwUnexpectedToken();
                }
                ++index;
                if (source[index] === '{') {
                    ++index;
                    ch = scanUnicodeCodePointEscape();
                } else {
                    ch = scanHexEscape('u');
                    cp = ch.charCodeAt(0);
                    if (!ch || ch === '\\' || !isIdentifierPart(cp)) {
                        throwUnexpectedToken();
                    }
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getComplexIdentifier();
            } else if (ch >= 0xD800 && ch < 0xDFFF) {
                // Need to handle surrogate pairs.
                index = start;
                return getComplexIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (U+005C) starts an escaped character.
        id = (source.charCodeAt(index) === 0x5C) ? getComplexIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }


    // ECMA-262 11.7 Punctuators

    function scanPunctuator() {
        var token, str;

        token = {
            type: Token.Punctuator,
            value: '',
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: index,
            end: index
        };

        // Check for most common single-character punctuators.
        str = source[index];
        switch (str) {

        case '(':
            if (extra.tokenize) {
                extra.openParenToken = extra.tokenValues.length;
            }
            ++index;
            break;

        case '{':
            if (extra.tokenize) {
                extra.openCurlyToken = extra.tokenValues.length;
            }
            state.curlyStack.push('{');
            ++index;
            break;

        case '.':
            ++index;
            if (source[index] === '.' && source[index + 1] === '.') {
                // Spread operator: ...
                index += 2;
                str = '...';
            }
            break;

        case '}':
            ++index;
            state.curlyStack.pop();
            break;
        case ')':
        case ';':
        case ',':
        case '[':
        case ']':
        case ':':
        case '?':
        case '~':
            ++index;
            break;

        default:
            // 4-character punctuator.
            str = source.substr(index, 4);
            if (str === '>>>=') {
                index += 4;
            } else {

                // 3-character punctuators.
                str = str.substr(0, 3);
                if (str === '===' || str === '!==' || str === '>>>' ||
                    str === '<<=' || str === '>>=') {
                    index += 3;
                } else {

                    // 2-character punctuators.
                    str = str.substr(0, 2);
                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
                        str === '++' || str === '--' || str === '<<' || str === '>>' ||
                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
                        str === '<=' || str === '>=' || str === '=>') {
                        index += 2;
                    } else {

                        // 1-character punctuators.
                        str = source[index];
                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
                            ++index;
                        }
                    }
                }
            }
        }

        if (index === token.start) {
            throwUnexpectedToken();
        }

        token.end = index;
        token.value = str;
        return token;
    }

    // ECMA-262 11.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanBinaryLiteral(start) {
        var ch, number;

        number = '';

        while (index < length) {
            ch = source[index];
            if (ch !== '0' && ch !== '1') {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            // only 0b or 0B
            throwUnexpectedToken();
        }

        if (index < length) {
            ch = source.charCodeAt(index);
            /* istanbul ignore else */
            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                throwUnexpectedToken();
            }
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 2),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanOctalLiteral(prefix, start) {
        var number, octal;

        if (isOctalDigit(prefix)) {
            octal = true;
            number = '0' + source[index++];
        } else {
            octal = false;
            ++index;
            number = '';
        }

        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (!octal && number.length === 0) {
            // only 0o or 0O
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function isImplicitOctalLiteral() {
        var i, ch;

        // Implicit octal, unless there is a non-octal digit.
        // (Annex B.1.1 on Numeric Literals)
        for (i = index + 1; i < length; ++i) {
            ch = source[i];
            if (ch === '8' || ch === '9') {
                return false;
            }
            if (!isOctalDigit(ch)) {
                return true;
            }
        }

        return true;
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            // Octal number in ES6 starts with '0o'.
            // Binary number in ES6 starts with '0b'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (ch === 'b' || ch === 'B') {
                    ++index;
                    return scanBinaryLiteral(start);
                }
                if (ch === 'o' || ch === 'O') {
                    return scanOctalLiteral(ch, start);
                }

                if (isOctalDigit(ch)) {
                    if (isImplicitOctalLiteral()) {
                        return scanOctalLiteral(ch, start);
                    }
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwUnexpectedToken();
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, unescaped, octToDec, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } else {
                            unescaped = scanHexEscape(ch);
                            if (!unescaped) {
                                throw throwUnexpectedToken();
                            }
                            str += unescaped;
                        }
                        break;
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;
                    case '8':
                    case '9':
                        str += ch;
                        tolerateUnexpectedToken();
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            octToDec = octalToDecimal(ch);

                            octal = octToDec.octal || octal;
                            str += String.fromCharCode(octToDec.code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            index = start;
            throwUnexpectedToken();
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: startLineNumber,
            lineStart: startLineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.6 Template Literal Lexical Components

    function scanTemplate() {
        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;

        terminated = false;
        tail = false;
        start = index;
        head = (source[index] === '`');
        rawOffset = 2;

        ++index;

        while (index < length) {
            ch = source[index++];
            if (ch === '`') {
                rawOffset = 1;
                tail = true;
                terminated = true;
                break;
            } else if (ch === '$') {
                if (source[index] === '{') {
                    state.curlyStack.push('${');
                    ++index;
                    terminated = true;
                    break;
                }
                cooked += ch;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        cooked += '\n';
                        break;
                    case 'r':
                        cooked += '\r';
                        break;
                    case 't':
                        cooked += '\t';
                        break;
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            cooked += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                cooked += unescaped;
                            } else {
                                index = restore;
                                cooked += ch;
                            }
                        }
                        break;
                    case 'b':
                        cooked += '\b';
                        break;
                    case 'f':
                        cooked += '\f';
                        break;
                    case 'v':
                        cooked += '\v';
                        break;

                    default:
                        if (ch === '0') {
                            if (isDecimalDigit(source.charCodeAt(index))) {
                                // Illegal: \01 \02 and so on
                                throwError(Messages.TemplateOctalLiteral);
                            }
                            cooked += '\0';
                        } else if (isOctalDigit(ch)) {
                            // Illegal: \1 \2
                            throwError(Messages.TemplateOctalLiteral);
                        } else {
                            cooked += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                ++lineNumber;
                if (ch === '\r' && source[index] === '\n') {
                    ++index;
                }
                lineStart = index;
                cooked += '\n';
            } else {
                cooked += ch;
            }
        }

        if (!terminated) {
            throwUnexpectedToken();
        }

        if (!head) {
            state.curlyStack.pop();
        }

        return {
            type: Token.Template,
            value: {
                cooked: cooked,
                raw: source.slice(start + 1, index - rawOffset)
            },
            head: head,
            tail: tail,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.5 Regular Expression Literals

    function testRegExp(pattern, flags) {
        // The BMP character to use as a replacement for astral symbols when
        // translating an ES6 "u"-flagged pattern to an ES5-compatible
        // approximation.
        // Note: replacing with '\uFFFF' enables false positives in unlikely
        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
        // pattern that would not be detected by this substitution.
        var astralSubstitute = '\uFFFF',
            tmp = pattern;

        if (flags.indexOf('u') >= 0) {
            tmp = tmp
                // Replace every Unicode escape sequence with the equivalent
                // BMP character or a constant ASCII code point in the case of
                // astral symbols. (See the above note on `astralSubstitute`
                // for more information.)
                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
                    var codePoint = parseInt($1 || $2, 16);
                    if (codePoint > 0x10FFFF) {
                        throwUnexpectedToken(null, Messages.InvalidRegExp);
                    }
                    if (codePoint <= 0xFFFF) {
                        return String.fromCharCode(codePoint);
                    }
                    return astralSubstitute;
                })
                // Replace each paired surrogate with a single ASCII symbol to
                // avoid throwing on regular expressions that are only valid in
                // combination with the "u" flag.
                .replace(
                    /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                    astralSubstitute
                );
        }

        // First, detect invalid regular expressions.
        try {
            RegExp(tmp);
        } catch (e) {
            throwUnexpectedToken(null, Messages.InvalidRegExp);
        }

        // Return a regular expression object for this pattern-flag pair, or
        // `null` in case the current environment doesn't support the flags it
        // uses.
        try {
            return new RegExp(pattern, flags);
        } catch (exception) {
            /* istanbul ignore next */
            return null;
        }
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwUnexpectedToken(null, Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwUnexpectedToken(null, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;

        str = '';
        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    tolerateUnexpectedToken();
                } else {
                    str += '\\';
                    tolerateUnexpectedToken();
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        return {
            value: flags,
            literal: str
        };
    }

    function scanRegExp() {
        var start, body, flags, value;
        scanning = true;

        lookahead = null;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);
        scanning = false;
        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                regex: {
                    pattern: body.value,
                    flags: flags.value
                },
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        return {
            literal: body.literal + flags.literal,
            value: value,
            regex: {
                pattern: body.value,
                flags: flags.value
            },
            start: start,
            end: index
        };
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = scanRegExp();

        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        /* istanbul ignore next */
        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                regex: regex.regex,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    // Using the following algorithm:
    // https://github.com/mozilla/sweet.js/wiki/design

    function advanceSlash() {
        var regex, previous, check;

        function testKeyword(value) {
            return value && (value.length > 1) && (value[0] >= 'a') && (value[0] <= 'z');
        }

        previous = extra.tokenValues[extra.tokenValues.length - 1];
        regex = (previous !== null);

        switch (previous) {
        case 'this':
        case ']':
            regex = false;
            break;

        case ')':
            check = extra.tokenValues[extra.openParenToken - 1];
            regex = (check === 'if' || check === 'while' || check === 'for' || check === 'with');
            break;

        case '}':
            // Dividing a function by anything makes little sense,
            // but we have to check for that.
            regex = false;
            if (testKeyword(extra.tokenValues[extra.openCurlyToken - 3])) {
                // Anonymous function, e.g. function(){} /42
                check = extra.tokenValues[extra.openCurlyToken - 4];
                regex = check ? (FnExprTokens.indexOf(check) < 0) : false;
            } else if (testKeyword(extra.tokenValues[extra.openCurlyToken - 4])) {
                // Named function, e.g. function f(){} /42/
                check = extra.tokenValues[extra.openCurlyToken - 5];
                regex = check ? (FnExprTokens.indexOf(check) < 0) : true;
            }
        }

        return regex ? collectRegex() : scanPunctuator();
    }

    function advance() {
        var cp, token;

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }

        cp = source.charCodeAt(index);

        if (isIdentifierStart(cp)) {
            token = scanIdentifier();
            if (strict && isStrictModeReservedWord(token.value)) {
                token.type = Token.Keyword;
            }
            return token;
        }

        // Very common: ( and ) and ;
        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
            return scanPunctuator();
        }

        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (cp === 0x27 || cp === 0x22) {
            return scanStringLiteral();
        }

        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (cp === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(cp)) {
            return scanNumericLiteral();
        }

        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize && cp === 0x2F) {
            return advanceSlash();
        }

        // Template literals start with ` (U+0060) for template head
        // or } (U+007D) for template middle or template tail.
        if (cp === 0x60 || (cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {
            return scanTemplate();
        }

        // Possible identifier start in a surrogate pair.
        if (cp >= 0xD800 && cp < 0xDFFF) {
            cp = codePointAt(index);
            if (isIdentifierStart(cp)) {
                return scanIdentifier();
            }
        }

        return scanPunctuator();
    }

    function collectToken() {
        var loc, token, value, entry;

        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            entry = {
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            };
            if (token.regex) {
                entry.regex = {
                    pattern: token.regex.pattern,
                    flags: token.regex.flags
                };
            }
            if (extra.tokenValues) {
                extra.tokenValues.push((entry.type === 'Punctuator' || entry.type === 'Keyword') ? entry.value : null);
            }
            if (extra.tokenize) {
                if (!extra.range) {
                    delete entry.range;
                }
                if (!extra.loc) {
                    delete entry.loc;
                }
                if (extra.delegate) {
                    entry = extra.delegate(entry);
                }
            }
            extra.tokens.push(entry);
        }

        return token;
    }

    function lex() {
        var token;
        scanning = true;

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        skipComment();

        token = lookahead;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        scanning = false;
        return token;
    }

    function peek() {
        scanning = true;

        skipComment();

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        scanning = false;
    }

    function Position() {
        this.line = startLineNumber;
        this.column = startIndex - startLineStart;
    }

    function SourceLocation() {
        this.start = new Position();
        this.end = null;
    }

    function WrappingSourceLocation(startToken) {
        this.start = {
            line: startToken.lineNumber,
            column: startToken.start - startToken.lineStart
        };
        this.end = null;
    }

    function Node() {
        if (extra.range) {
            this.range = [startIndex, 0];
        }
        if (extra.loc) {
            this.loc = new SourceLocation();
        }
    }

    function WrappingNode(startToken) {
        if (extra.range) {
            this.range = [startToken.start, 0];
        }
        if (extra.loc) {
            this.loc = new WrappingSourceLocation(startToken);
        }
    }

    WrappingNode.prototype = Node.prototype = {

        processComment: function () {
            var lastChild,
                innerComments,
                leadingComments,
                trailingComments,
                bottomRight = extra.bottomRightStack,
                i,
                comment,
                last = bottomRight[bottomRight.length - 1];

            if (this.type === Syntax.Program) {
                if (this.body.length > 0) {
                    return;
                }
            }
            /**
             * patch innnerComments for properties empty block
             * `function a() {/** comments **\/}`
             */

            if (this.type === Syntax.BlockStatement && this.body.length === 0) {
                innerComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (this.range[1] >= comment.range[1]) {
                        innerComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                        extra.trailingComments.splice(i, 1);
                    }
                }
                if (innerComments.length) {
                    this.innerComments = innerComments;
                    //bottomRight.push(this);
                    return;
                }
            }

            if (extra.trailingComments.length > 0) {
                trailingComments = [];
                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
                    comment = extra.trailingComments[i];
                    if (comment.range[0] >= this.range[1]) {
                        trailingComments.unshift(comment);
                        extra.trailingComments.splice(i, 1);
                    }
                }
                extra.trailingComments = [];
            } else {
                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
                    trailingComments = last.trailingComments;
                    delete last.trailingComments;
                }
            }

            // Eating the stack.
            while (last && last.range[0] >= this.range[0]) {
                lastChild = bottomRight.pop();
                last = bottomRight[bottomRight.length - 1];
            }

            if (lastChild) {
                if (lastChild.leadingComments) {
                    leadingComments = [];
                    for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {
                        comment = lastChild.leadingComments[i];
                        if (comment.range[1] <= this.range[0]) {
                            leadingComments.unshift(comment);
                            lastChild.leadingComments.splice(i, 1);
                        }
                    }

                    if (!lastChild.leadingComments.length) {
                        lastChild.leadingComments = undefined;
                    }
                }
            } else if (extra.leadingComments.length > 0) {
                leadingComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (comment.range[1] <= this.range[0]) {
                        leadingComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                    }
                }
            }


            if (leadingComments && leadingComments.length > 0) {
                this.leadingComments = leadingComments;
            }
            if (trailingComments && trailingComments.length > 0) {
                this.trailingComments = trailingComments;
            }

            bottomRight.push(this);
        },

        finish: function () {
            if (extra.range) {
                this.range[1] = lastIndex;
            }
            if (extra.loc) {
                this.loc.end = {
                    line: lastLineNumber,
                    column: lastIndex - lastLineStart
                };
                if (extra.source) {
                    this.loc.source = extra.source;
                }
            }

            if (extra.attachComment) {
                this.processComment();
            }
        },

        finishArrayExpression: function (elements) {
            this.type = Syntax.ArrayExpression;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrayPattern: function (elements) {
            this.type = Syntax.ArrayPattern;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrowFunctionExpression: function (params, defaults, body, expression) {
            this.type = Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishAssignmentExpression: function (operator, left, right) {
            this.type = Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishAssignmentPattern: function (left, right) {
            this.type = Syntax.AssignmentPattern;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBinaryExpression: function (operator, left, right) {
            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBlockStatement: function (body) {
            this.type = Syntax.BlockStatement;
            this.body = body;
            this.finish();
            return this;
        },

        finishBreakStatement: function (label) {
            this.type = Syntax.BreakStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishCallExpression: function (callee, args) {
            this.type = Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishCatchClause: function (param, body) {
            this.type = Syntax.CatchClause;
            this.param = param;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassBody: function (body) {
            this.type = Syntax.ClassBody;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassDeclaration: function (id, superClass, body) {
            this.type = Syntax.ClassDeclaration;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassExpression: function (id, superClass, body) {
            this.type = Syntax.ClassExpression;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this;
        },

        finishConditionalExpression: function (test, consequent, alternate) {
            this.type = Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishContinueStatement: function (label) {
            this.type = Syntax.ContinueStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishDebuggerStatement: function () {
            this.type = Syntax.DebuggerStatement;
            this.finish();
            return this;
        },

        finishDoWhileStatement: function (body, test) {
            this.type = Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
            this.finish();
            return this;
        },

        finishEmptyStatement: function () {
            this.type = Syntax.EmptyStatement;
            this.finish();
            return this;
        },

        finishExpressionStatement: function (expression) {
            this.type = Syntax.ExpressionStatement;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishForStatement: function (init, test, update, body) {
            this.type = Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
            this.finish();
            return this;
        },

        finishForOfStatement: function (left, right, body) {
            this.type = Syntax.ForOfStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.finish();
            return this;
        },

        finishForInStatement: function (left, right, body) {
            this.type = Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
            this.finish();
            return this;
        },

        finishFunctionDeclaration: function (id, params, defaults, body, generator) {
            this.type = Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.finish();
            return this;
        },

        finishFunctionExpression: function (id, params, defaults, body, generator) {
            this.type = Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.finish();
            return this;
        },

        finishIdentifier: function (name) {
            this.type = Syntax.Identifier;
            this.name = name;
            this.finish();
            return this;
        },

        finishIfStatement: function (test, consequent, alternate) {
            this.type = Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishLabeledStatement: function (label, body) {
            this.type = Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
            this.finish();
            return this;
        },

        finishLiteral: function (token) {
            this.type = Syntax.Literal;
            this.value = token.value;
            this.raw = source.slice(token.start, token.end);
            if (token.regex) {
                this.regex = token.regex;
            }
            this.finish();
            return this;
        },

        finishMemberExpression: function (accessor, object, property) {
            this.type = Syntax.MemberExpression;
            this.computed = accessor === '[';
            this.object = object;
            this.property = property;
            this.finish();
            return this;
        },

        finishMetaProperty: function (meta, property) {
            this.type = Syntax.MetaProperty;
            this.meta = meta;
            this.property = property;
            this.finish();
            return this;
        },

        finishNewExpression: function (callee, args) {
            this.type = Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishObjectExpression: function (properties) {
            this.type = Syntax.ObjectExpression;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishObjectPattern: function (properties) {
            this.type = Syntax.ObjectPattern;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishPostfixExpression: function (operator, argument) {
            this.type = Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = false;
            this.finish();
            return this;
        },

        finishProgram: function (body, sourceType) {
            this.type = Syntax.Program;
            this.body = body;
            this.sourceType = sourceType;
            this.finish();
            return this;
        },

        finishProperty: function (kind, key, computed, value, method, shorthand) {
            this.type = Syntax.Property;
            this.key = key;
            this.computed = computed;
            this.value = value;
            this.kind = kind;
            this.method = method;
            this.shorthand = shorthand;
            this.finish();
            return this;
        },

        finishRestElement: function (argument) {
            this.type = Syntax.RestElement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishReturnStatement: function (argument) {
            this.type = Syntax.ReturnStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSequenceExpression: function (expressions) {
            this.type = Syntax.SequenceExpression;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishSpreadElement: function (argument) {
            this.type = Syntax.SpreadElement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSwitchCase: function (test, consequent) {
            this.type = Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
            this.finish();
            return this;
        },

        finishSuper: function () {
            this.type = Syntax.Super;
            this.finish();
            return this;
        },

        finishSwitchStatement: function (discriminant, cases) {
            this.type = Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
            this.finish();
            return this;
        },

        finishTaggedTemplateExpression: function (tag, quasi) {
            this.type = Syntax.TaggedTemplateExpression;
            this.tag = tag;
            this.quasi = quasi;
            this.finish();
            return this;
        },

        finishTemplateElement: function (value, tail) {
            this.type = Syntax.TemplateElement;
            this.value = value;
            this.tail = tail;
            this.finish();
            return this;
        },

        finishTemplateLiteral: function (quasis, expressions) {
            this.type = Syntax.TemplateLiteral;
            this.quasis = quasis;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishThisExpression: function () {
            this.type = Syntax.ThisExpression;
            this.finish();
            return this;
        },

        finishThrowStatement: function (argument) {
            this.type = Syntax.ThrowStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishTryStatement: function (block, handler, finalizer) {
            this.type = Syntax.TryStatement;
            this.block = block;
            this.guardedHandlers = [];
            this.handlers = handler ? [handler] : [];
            this.handler = handler;
            this.finalizer = finalizer;
            this.finish();
            return this;
        },

        finishUnaryExpression: function (operator, argument) {
            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
            this.finish();
            return this;
        },

        finishVariableDeclaration: function (declarations) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = 'var';
            this.finish();
            return this;
        },

        finishLexicalDeclaration: function (declarations, kind) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
            this.finish();
            return this;
        },

        finishVariableDeclarator: function (id, init) {
            this.type = Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
            this.finish();
            return this;
        },

        finishWhileStatement: function (test, body) {
            this.type = Syntax.WhileStatement;
            this.test = test;
            this.body = body;
            this.finish();
            return this;
        },

        finishWithStatement: function (object, body) {
            this.type = Syntax.WithStatement;
            this.object = object;
            this.body = body;
            this.finish();
            return this;
        },

        finishExportSpecifier: function (local, exported) {
            this.type = Syntax.ExportSpecifier;
            this.exported = exported || local;
            this.local = local;
            this.finish();
            return this;
        },

        finishImportDefaultSpecifier: function (local) {
            this.type = Syntax.ImportDefaultSpecifier;
            this.local = local;
            this.finish();
            return this;
        },

        finishImportNamespaceSpecifier: function (local) {
            this.type = Syntax.ImportNamespaceSpecifier;
            this.local = local;
            this.finish();
            return this;
        },

        finishExportNamedDeclaration: function (declaration, specifiers, src) {
            this.type = Syntax.ExportNamedDeclaration;
            this.declaration = declaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this;
        },

        finishExportDefaultDeclaration: function (declaration) {
            this.type = Syntax.ExportDefaultDeclaration;
            this.declaration = declaration;
            this.finish();
            return this;
        },

        finishExportAllDeclaration: function (src) {
            this.type = Syntax.ExportAllDeclaration;
            this.source = src;
            this.finish();
            return this;
        },

        finishImportSpecifier: function (local, imported) {
            this.type = Syntax.ImportSpecifier;
            this.local = local || imported;
            this.imported = imported;
            this.finish();
            return this;
        },

        finishImportDeclaration: function (specifiers, src) {
            this.type = Syntax.ImportDeclaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this;
        },

        finishYieldExpression: function (argument, delegate) {
            this.type = Syntax.YieldExpression;
            this.argument = argument;
            this.delegate = delegate;
            this.finish();
            return this;
        }
    };


    function recordError(error) {
        var e, existing;

        for (e = 0; e < extra.errors.length; e++) {
            existing = extra.errors[e];
            // Prevent duplicated error.
            /* istanbul ignore next */
            if (existing.index === error.index && existing.message === error.message) {
                return;
            }
        }

        extra.errors.push(error);
    }

    function constructError(msg, column) {
        var error = new Error(msg);
        try {
            throw error;
        } catch (base) {
            /* istanbul ignore else */
            if (Object.create && Object.defineProperty) {
                error = Object.create(base);
                Object.defineProperty(error, 'column', { value: column });
            }
        } finally {
            return error;
        }
    }

    function createError(line, pos, description) {
        var msg, column, error;

        msg = 'Line ' + line + ': ' + description;
        column = pos - (scanning ? lineStart : lastLineStart) + 1;
        error = constructError(msg, column);
        error.lineNumber = line;
        error.description = description;
        error.index = pos;
        return error;
    }

    // Throw an exception

    function throwError(messageFormat) {
        var args, msg;

        args = Array.prototype.slice.call(arguments, 1);
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        throw createError(lastLineNumber, lastIndex, msg);
    }

    function tolerateError(messageFormat) {
        var args, msg, error;

        args = Array.prototype.slice.call(arguments, 1);
        /* istanbul ignore next */
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        error = createError(lineNumber, lastIndex, msg);
        if (extra.errors) {
            recordError(error);
        } else {
            throw error;
        }
    }

    // Throw an exception because of the token.

    function unexpectedTokenError(token, message) {
        var value, msg = message || Messages.UnexpectedToken;

        if (token) {
            if (!message) {
                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :
                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :
                    Messages.UnexpectedToken;

                if (token.type === Token.Keyword) {
                    if (isFutureReservedWord(token.value)) {
                        msg = Messages.UnexpectedReserved;
                    } else if (strict && isStrictModeReservedWord(token.value)) {
                        msg = Messages.StrictReservedWord;
                    }
                }
            }

            value = (token.type === Token.Template) ? token.value.raw : token.value;
        } else {
            value = 'ILLEGAL';
        }

        msg = msg.replace('%0', value);

        return (token && typeof token.lineNumber === 'number') ?
            createError(token.lineNumber, token.start, msg) :
            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
    }

    function throwUnexpectedToken(token, message) {
        throw unexpectedTokenError(token, message);
    }

    function tolerateUnexpectedToken(token, message) {
        var error = unexpectedTokenError(token, message);
        if (extra.errors) {
            recordError(error);
        } else {
            throw error;
        }
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpectedToken(token);
        }
    }

    /**
     * @name expectCommaSeparator
     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
     * to <code>expect(value)</code>
     * @since 2.0
     */
    function expectCommaSeparator() {
        var token;

        if (extra.errors) {
            token = lookahead;
            if (token.type === Token.Punctuator && token.value === ',') {
                lex();
            } else if (token.type === Token.Punctuator && token.value === ';') {
                lex();
                tolerateUnexpectedToken(token);
            } else {
                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
            }
        } else {
            expect(',');
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpectedToken(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token matches the specified contextual keyword
    // (where an identifier is sometimes a keyword depending on the context)

    function matchContextualKeyword(keyword) {
        return lookahead.type === Token.Identifier && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {
            lex();
            return;
        }

        if (hasLineTerminator) {
            return;
        }

        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
        lastIndex = startIndex;
        lastLineNumber = startLineNumber;
        lastLineStart = startLineStart;

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpectedToken(lookahead);
        }
    }

    // Cover grammar support.
    //
    // When an assignment expression position starts with an left parenthesis, the determination of the type
    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
    //
    // There are three productions that can be parsed in a parentheses pair that needs to be determined
    // after the outermost pair is closed. They are:
    //
    //   1. AssignmentExpression
    //   2. BindingElements
    //   3. AssignmentTargets
    //
    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
    // binding element or assignment target.
    //
    // The three productions have the relationship:
    //
    //   BindingElements  AssignmentTargets  AssignmentExpression
    //
    // with a single exception that CoverInitializedName when used directly in an Expression, generates
    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
    //
    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
    // the CoverInitializedName check is conducted.
    //
    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
    // pattern. The CoverInitializedName check is deferred.
    function isolateCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        if (firstCoverInitializedNameError !== null) {
            throwUnexpectedToken(firstCoverInitializedNameError);
        }
        isBindingElement = oldIsBindingElement;
        isAssignmentTarget = oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
        return result;
    }

    function inheritCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        isBindingElement = isBindingElement && oldIsBindingElement;
        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
        return result;
    }

    // ECMA-262 13.3.3 Destructuring Binding Patterns

    function parseArrayPattern(params, kind) {
        var node = new Node(), elements = [], rest, restNode;
        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                if (match('...')) {
                    restNode = new Node();
                    lex();
                    params.push(lookahead);
                    rest = parseVariableIdentifier(kind);
                    elements.push(restNode.finishRestElement(rest));
                    break;
                } else {
                    elements.push(parsePatternWithDefault(params, kind));
                }
                if (!match(']')) {
                    expect(',');
                }
            }

        }

        expect(']');

        return node.finishArrayPattern(elements);
    }

    function parsePropertyPattern(params, kind) {
        var node = new Node(), key, keyToken, computed = match('['), init;
        if (lookahead.type === Token.Identifier) {
            keyToken = lookahead;
            key = parseVariableIdentifier();
            if (match('=')) {
                params.push(keyToken);
                lex();
                init = parseAssignmentExpression();

                return node.finishProperty(
                    'init', key, false,
                    new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, true);
            } else if (!match(':')) {
                params.push(keyToken);
                return node.finishProperty('init', key, false, key, false, true);
            }
        } else {
            key = parseObjectPropertyKey();
        }
        expect(':');
        init = parsePatternWithDefault(params, kind);
        return node.finishProperty('init', key, computed, init, false, false);
    }

    function parseObjectPattern(params, kind) {
        var node = new Node(), properties = [];

        expect('{');

        while (!match('}')) {
            properties.push(parsePropertyPattern(params, kind));
            if (!match('}')) {
                expect(',');
            }
        }

        lex();

        return node.finishObjectPattern(properties);
    }

    function parsePattern(params, kind) {
        if (match('[')) {
            return parseArrayPattern(params, kind);
        } else if (match('{')) {
            return parseObjectPattern(params, kind);
        } else if (matchKeyword('let')) {
            if (kind === 'const' || kind === 'let') {
                tolerateUnexpectedToken(lookahead, Messages.UnexpectedToken);
            }
        }

        params.push(lookahead);
        return parseVariableIdentifier(kind);
    }

    function parsePatternWithDefault(params, kind) {
        var startToken = lookahead, pattern, previousAllowYield, right;
        pattern = parsePattern(params, kind);
        if (match('=')) {
            lex();
            previousAllowYield = state.allowYield;
            state.allowYield = true;
            right = isolateCoverGrammar(parseAssignmentExpression);
            state.allowYield = previousAllowYield;
            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);
        }
        return pattern;
    }

    // ECMA-262 12.2.5 Array Initializer

    function parseArrayInitializer() {
        var elements = [], node = new Node(), restSpread;

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else if (match('...')) {
                restSpread = new Node();
                lex();
                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));

                if (!match(']')) {
                    isAssignmentTarget = isBindingElement = false;
                    expect(',');
                }
                elements.push(restSpread);
            } else {
                elements.push(inheritCoverGrammar(parseAssignmentExpression));

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        lex();

        return node.finishArrayExpression(elements);
    }

    // ECMA-262 12.2.6 Object Initializer

    function parsePropertyFunction(node, paramInfo, isGenerator) {
        var previousStrict, body;

        isAssignmentTarget = isBindingElement = false;

        previousStrict = strict;
        body = isolateCoverGrammar(parseFunctionSourceElements);

        if (strict && paramInfo.firstRestricted) {
            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
        }
        if (strict && paramInfo.stricted) {
            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
        }

        strict = previousStrict;
        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);
    }

    function parsePropertyMethodFunction() {
        var params, method, node = new Node(),
            previousAllowYield = state.allowYield;

        state.allowYield = false;
        params = parseParams();
        state.allowYield = previousAllowYield;

        state.allowYield = false;
        method = parsePropertyFunction(node, params, false);
        state.allowYield = previousAllowYield;

        return method;
    }

    function parseObjectPropertyKey() {
        var token, node = new Node(), expr;

        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        switch (token.type) {
        case Token.StringLiteral:
        case Token.NumericLiteral:
            if (strict && token.octal) {
                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
            }
            return node.finishLiteral(token);
        case Token.Identifier:
        case Token.BooleanLiteral:
        case Token.NullLiteral:
        case Token.Keyword:
            return node.finishIdentifier(token.value);
        case Token.Punctuator:
            if (token.value === '[') {
                expr = isolateCoverGrammar(parseAssignmentExpression);
                expect(']');
                return expr;
            }
            break;
        }
        throwUnexpectedToken(token);
    }

    function lookaheadPropertyName() {
        switch (lookahead.type) {
        case Token.Identifier:
        case Token.StringLiteral:
        case Token.BooleanLiteral:
        case Token.NullLiteral:
        case Token.NumericLiteral:
        case Token.Keyword:
            return true;
        case Token.Punctuator:
            return lookahead.value === '[';
        }
        return false;
    }

    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.
    // This can only be determined after we consumed up to the left parentheses.
    //
    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
    // is responsible to visit other options.
    function tryParseMethodDefinition(token, key, computed, node) {
        var value, options, methodNode, params,
            previousAllowYield = state.allowYield;

        if (token.type === Token.Identifier) {
            // check for `get` and `set`;

            if (token.value === 'get' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
                expect('(');
                expect(')');

                state.allowYield = false;
                value = parsePropertyFunction(methodNode, {
                    params: [],
                    defaults: [],
                    stricted: null,
                    firstRestricted: null,
                    message: null
                }, false);
                state.allowYield = previousAllowYield;

                return node.finishProperty('get', key, computed, value, false, false);
            } else if (token.value === 'set' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
                expect('(');

                options = {
                    params: [],
                    defaultCount: 0,
                    defaults: [],
                    firstRestricted: null,
                    paramSet: {}
                };
                if (match(')')) {
                    tolerateUnexpectedToken(lookahead);
                } else {
                    state.allowYield = false;
                    parseParam(options);
                    state.allowYield = previousAllowYield;
                    if (options.defaultCount === 0) {
                        options.defaults = [];
                    }
                }
                expect(')');

                state.allowYield = false;
                value = parsePropertyFunction(methodNode, options, false);
                state.allowYield = previousAllowYield;

                return node.finishProperty('set', key, computed, value, false, false);
            }
        } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {
            computed = match('[');
            key = parseObjectPropertyKey();
            methodNode = new Node();

            state.allowYield = true;
            params = parseParams();
            state.allowYield = previousAllowYield;

            state.allowYield = false;
            value = parsePropertyFunction(methodNode, params, true);
            state.allowYield = previousAllowYield;

            return node.finishProperty('init', key, computed, value, true, false);
        }

        if (key && match('(')) {
            value = parsePropertyMethodFunction();
            return node.finishProperty('init', key, computed, value, true, false);
        }

        // Not a MethodDefinition.
        return null;
    }

    function parseObjectProperty(hasProto) {
        var token = lookahead, node = new Node(), computed, key, maybeMethod, proto, value;

        computed = match('[');
        if (match('*')) {
            lex();
        } else {
            key = parseObjectPropertyKey();
        }
        maybeMethod = tryParseMethodDefinition(token, key, computed, node);
        if (maybeMethod) {
            return maybeMethod;
        }

        if (!key) {
            throwUnexpectedToken(lookahead);
        }

        // Check for duplicated __proto__
        if (!computed) {
            proto = (key.type === Syntax.Identifier && key.name === '__proto__') ||
                (key.type === Syntax.Literal && key.value === '__proto__');
            if (hasProto.value && proto) {
                tolerateError(Messages.DuplicateProtoProperty);
            }
            hasProto.value |= proto;
        }

        if (match(':')) {
            lex();
            value = inheritCoverGrammar(parseAssignmentExpression);
            return node.finishProperty('init', key, computed, value, false, false);
        }

        if (token.type === Token.Identifier) {
            if (match('=')) {
                firstCoverInitializedNameError = lookahead;
                lex();
                value = isolateCoverGrammar(parseAssignmentExpression);
                return node.finishProperty('init', key, computed,
                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);
            }
            return node.finishProperty('init', key, computed, key, false, true);
        }

        throwUnexpectedToken(lookahead);
    }

    function parseObjectInitializer() {
        var properties = [], hasProto = {value: false}, node = new Node();

        expect('{');

        while (!match('}')) {
            properties.push(parseObjectProperty(hasProto));

            if (!match('}')) {
                expectCommaSeparator();
            }
        }

        expect('}');

        return node.finishObjectExpression(properties);
    }

    function reinterpretExpressionAsPattern(expr) {
        var i;
        switch (expr.type) {
        case Syntax.Identifier:
        case Syntax.MemberExpression:
        case Syntax.RestElement:
        case Syntax.AssignmentPattern:
            break;
        case Syntax.SpreadElement:
            expr.type = Syntax.RestElement;
            reinterpretExpressionAsPattern(expr.argument);
            break;
        case Syntax.ArrayExpression:
            expr.type = Syntax.ArrayPattern;
            for (i = 0; i < expr.elements.length; i++) {
                if (expr.elements[i] !== null) {
                    reinterpretExpressionAsPattern(expr.elements[i]);
                }
            }
            break;
        case Syntax.ObjectExpression:
            expr.type = Syntax.ObjectPattern;
            for (i = 0; i < expr.properties.length; i++) {
                reinterpretExpressionAsPattern(expr.properties[i].value);
            }
            break;
        case Syntax.AssignmentExpression:
            expr.type = Syntax.AssignmentPattern;
            reinterpretExpressionAsPattern(expr.left);
            break;
        }
    }

    // ECMA-262 12.2.9 Template Literals

    function parseTemplateElement(option) {
        var node, token;

        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
            throwUnexpectedToken();
        }

        node = new Node();
        token = lex();

        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);
    }

    function parseTemplateLiteral() {
        var quasi, quasis, expressions, node = new Node();

        quasi = parseTemplateElement({ head: true });
        quasis = [quasi];
        expressions = [];

        while (!quasi.tail) {
            expressions.push(parseExpression());
            quasi = parseTemplateElement({ head: false });
            quasis.push(quasi);
        }

        return node.finishTemplateLiteral(quasis, expressions);
    }

    // ECMA-262 12.2.10 The Grouping Operator

    function parseGroupExpression() {
        var expr, expressions, startToken, i, params = [];

        expect('(');

        if (match(')')) {
            lex();
            if (!match('=>')) {
                expect('=>');
            }
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [],
                rawParams: []
            };
        }

        startToken = lookahead;
        if (match('...')) {
            expr = parseRestElement(params);
            expect(')');
            if (!match('=>')) {
                expect('=>');
            }
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [expr]
            };
        }

        isBindingElement = true;
        expr = inheritCoverGrammar(parseAssignmentExpression);

        if (match(',')) {
            isAssignmentTarget = false;
            expressions = [expr];

            while (startIndex < length) {
                if (!match(',')) {
                    break;
                }
                lex();

                if (match('...')) {
                    if (!isBindingElement) {
                        throwUnexpectedToken(lookahead);
                    }
                    expressions.push(parseRestElement(params));
                    expect(')');
                    if (!match('=>')) {
                        expect('=>');
                    }
                    isBindingElement = false;
                    for (i = 0; i < expressions.length; i++) {
                        reinterpretExpressionAsPattern(expressions[i]);
                    }
                    return {
                        type: PlaceHolders.ArrowParameterPlaceHolder,
                        params: expressions
                    };
                }

                expressions.push(inheritCoverGrammar(parseAssignmentExpression));
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }


        expect(')');

        if (match('=>')) {
            if (expr.type === Syntax.Identifier && expr.name === 'yield') {
                return {
                    type: PlaceHolders.ArrowParameterPlaceHolder,
                    params: [expr]
                };
            }

            if (!isBindingElement) {
                throwUnexpectedToken(lookahead);
            }

            if (expr.type === Syntax.SequenceExpression) {
                for (i = 0; i < expr.expressions.length; i++) {
                    reinterpretExpressionAsPattern(expr.expressions[i]);
                }
            } else {
                reinterpretExpressionAsPattern(expr);
            }

            expr = {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
            };
        }
        isBindingElement = false;
        return expr;
    }


    // ECMA-262 12.2 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr, node;

        if (match('(')) {
            isBindingElement = false;
            return inheritCoverGrammar(parseGroupExpression);
        }

        if (match('[')) {
            return inheritCoverGrammar(parseArrayInitializer);
        }

        if (match('{')) {
            return inheritCoverGrammar(parseObjectInitializer);
        }

        type = lookahead.type;
        node = new Node();

        if (type === Token.Identifier) {
            if (state.sourceType === 'module' && lookahead.value === 'await') {
                tolerateUnexpectedToken(lookahead);
            }
            expr = node.finishIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            isAssignmentTarget = isBindingElement = false;
            if (strict && lookahead.octal) {
                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
            }
            expr = node.finishLiteral(lex());
        } else if (type === Token.Keyword) {
            if (!strict && state.allowYield && matchKeyword('yield')) {
                return parseNonComputedProperty();
            }
            if (!strict && matchKeyword('let')) {
                return node.finishIdentifier(lex().value);
            }
            isAssignmentTarget = isBindingElement = false;
            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
            if (matchKeyword('this')) {
                lex();
                return node.finishThisExpression();
            }
            if (matchKeyword('class')) {
                return parseClassExpression();
            }
            throwUnexpectedToken(lex());
        } else if (type === Token.BooleanLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = (token.value === 'true');
            expr = node.finishLiteral(token);
        } else if (type === Token.NullLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = null;
            expr = node.finishLiteral(token);
        } else if (match('/') || match('/=')) {
            isAssignmentTarget = isBindingElement = false;
            index = startIndex;

            if (typeof extra.tokens !== 'undefined') {
                token = collectRegex();
            } else {
                token = scanRegExp();
            }
            lex();
            expr = node.finishLiteral(token);
        } else if (type === Token.Template) {
            expr = parseTemplateLiteral();
        } else {
            throwUnexpectedToken(lex());
        }

        return expr;
    }

    // ECMA-262 12.3 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [], expr;

        expect('(');

        if (!match(')')) {
            while (startIndex < length) {
                if (match('...')) {
                    expr = new Node();
                    lex();
                    expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));
                } else {
                    expr = isolateCoverGrammar(parseAssignmentExpression);
                }
                args.push(expr);
                if (match(')')) {
                    break;
                }
                expectCommaSeparator();
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token, node = new Node();

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpectedToken(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = isolateCoverGrammar(parseExpression);

        expect(']');

        return expr;
    }

    // ECMA-262 12.3.3 The new Operator

    function parseNewExpression() {
        var callee, args, node = new Node();

        expectKeyword('new');

        if (match('.')) {
            lex();
            if (lookahead.type === Token.Identifier && lookahead.value === 'target') {
                if (state.inFunctionBody) {
                    lex();
                    return node.finishMetaProperty('new', 'target');
                }
            }
            throwUnexpectedToken(lookahead);
        }

        callee = isolateCoverGrammar(parseLeftHandSideExpression);
        args = match('(') ? parseArguments() : [];

        isAssignmentTarget = isBindingElement = false;

        return node.finishNewExpression(callee, args);
    }

    // ECMA-262 12.3.4 Function Calls

    function parseLeftHandSideExpressionAllowCall() {
        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;

        startToken = lookahead;
        state.allowIn = true;

        if (matchKeyword('super') && state.inFunctionBody) {
            expr = new Node();
            lex();
            expr = expr.finishSuper();
            if (!match('(') && !match('.') && !match('[')) {
                throwUnexpectedToken(lookahead);
            }
        } else {
            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
        }

        for (;;) {
            if (match('.')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (match('(')) {
                isBindingElement = false;
                isAssignmentTarget = false;
                args = parseArguments();
                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
            } else if (match('[')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (lookahead.type === Token.Template && lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } else {
                break;
            }
        }
        state.allowIn = previousAllowIn;

        return expr;
    }

    // ECMA-262 12.3 Left-Hand-Side Expressions

    function parseLeftHandSideExpression() {
        var quasi, expr, property, startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');

        startToken = lookahead;

        if (matchKeyword('super') && state.inFunctionBody) {
            expr = new Node();
            lex();
            expr = expr.finishSuper();
            if (!match('[') && !match('.')) {
                throwUnexpectedToken(lookahead);
            }
        } else {
            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
        }

        for (;;) {
            if (match('[')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (match('.')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (lookahead.type === Token.Template && lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } else {
                break;
            }
        }
        return expr;
    }

    // ECMA-262 12.4 Postfix Expressions

    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;

        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);

        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {
            if (match('++') || match('--')) {
                // ECMA-262 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    tolerateError(Messages.StrictLHSPostfix);
                }

                if (!isAssignmentTarget) {
                    tolerateError(Messages.InvalidLHSInAssignment);
                }

                isAssignmentTarget = isBindingElement = false;

                token = lex();
                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
            }
        }

        return expr;
    }

    // ECMA-262 12.5 Unary Operators

    function parseUnaryExpression() {
        var token, expr, startToken;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            // ECMA-262 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                tolerateError(Messages.StrictLHSPrefix);
            }

            if (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false;
        } else if (match('+') || match('-') || match('~') || match('!')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false;
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                tolerateError(Messages.StrictDelete);
            }
            isAssignmentTarget = isBindingElement = false;
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;
        }

        return prec;
    }

    // ECMA-262 12.6 Multiplicative Operators
    // ECMA-262 12.7 Additive Operators
    // ECMA-262 12.8 Bitwise Shift Operators
    // ECMA-262 12.9 Relational Operators
    // ECMA-262 12.10 Equality Operators
    // ECMA-262 12.11 Binary Bitwise Operators
    // ECMA-262 12.12 Binary Logical Operators

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = lookahead;
        left = inheritCoverGrammar(parseUnaryExpression);

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        isAssignmentTarget = isBindingElement = false;
        token.prec = prec;
        lex();

        markers = [marker, lookahead];
        right = isolateCoverGrammar(parseUnaryExpression);

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = isolateCoverGrammar(parseUnaryExpression);
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // ECMA-262 12.13 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;

        startToken = lookahead;

        expr = inheritCoverGrammar(parseBinaryExpression);
        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = isolateCoverGrammar(parseAssignmentExpression);
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = isolateCoverGrammar(parseAssignmentExpression);

            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
            isAssignmentTarget = isBindingElement = false;
        }

        return expr;
    }

    // ECMA-262 14.2 Arrow Function Definitions

    function parseConciseBody() {
        if (match('{')) {
            return parseFunctionSourceElements();
        }
        return isolateCoverGrammar(parseAssignmentExpression);
    }

    function checkPatternParam(options, param) {
        var i;
        switch (param.type) {
        case Syntax.Identifier:
            validateParam(options, param, param.name);
            break;
        case Syntax.RestElement:
            checkPatternParam(options, param.argument);
            break;
        case Syntax.AssignmentPattern:
            checkPatternParam(options, param.left);
            break;
        case Syntax.ArrayPattern:
            for (i = 0; i < param.elements.length; i++) {
                if (param.elements[i] !== null) {
                    checkPatternParam(options, param.elements[i]);
                }
            }
            break;
        case Syntax.YieldExpression:
            break;
        default:
            assert(param.type === Syntax.ObjectPattern, 'Invalid type');
            for (i = 0; i < param.properties.length; i++) {
                checkPatternParam(options, param.properties[i].value);
            }
            break;
        }
    }
    function reinterpretAsCoverFormalsList(expr) {
        var i, len, param, params, defaults, defaultCount, options, token;

        defaults = [];
        defaultCount = 0;
        params = [expr];

        switch (expr.type) {
        case Syntax.Identifier:
            break;
        case PlaceHolders.ArrowParameterPlaceHolder:
            params = expr.params;
            break;
        default:
            return null;
        }

        options = {
            paramSet: {}
        };

        for (i = 0, len = params.length; i < len; i += 1) {
            param = params[i];
            switch (param.type) {
            case Syntax.AssignmentPattern:
                params[i] = param.left;
                if (param.right.type === Syntax.YieldExpression) {
                    if (param.right.argument) {
                        throwUnexpectedToken(lookahead);
                    }
                    param.right.type = Syntax.Identifier;
                    param.right.name = 'yield';
                    delete param.right.argument;
                    delete param.right.delegate;
                }
                defaults.push(param.right);
                ++defaultCount;
                checkPatternParam(options, param.left);
                break;
            default:
                checkPatternParam(options, param);
                params[i] = param;
                defaults.push(null);
                break;
            }
        }

        if (strict || !state.allowYield) {
            for (i = 0, len = params.length; i < len; i += 1) {
                param = params[i];
                if (param.type === Syntax.YieldExpression) {
                    throwUnexpectedToken(lookahead);
                }
            }
        }

        if (options.message === Messages.StrictParamDupe) {
            token = strict ? options.stricted : options.firstRestricted;
            throwUnexpectedToken(token, options.message);
        }

        if (defaultCount === 0) {
            defaults = [];
        }

        return {
            params: params,
            defaults: defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseArrowFunctionExpression(options, node) {
        var previousStrict, previousAllowYield, body;

        if (hasLineTerminator) {
            tolerateUnexpectedToken(lookahead);
        }
        expect('=>');

        previousStrict = strict;
        previousAllowYield = state.allowYield;
        state.allowYield = true;

        body = parseConciseBody();

        if (strict && options.firstRestricted) {
            throwUnexpectedToken(options.firstRestricted, options.message);
        }
        if (strict && options.stricted) {
            tolerateUnexpectedToken(options.stricted, options.message);
        }

        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
    }

    // ECMA-262 14.4 Yield expression

    function parseYieldExpression() {
        var argument, expr, delegate, previousAllowYield;

        argument = null;
        expr = new Node();
        delegate = false;

        expectKeyword('yield');

        if (!hasLineTerminator) {
            previousAllowYield = state.allowYield;
            state.allowYield = false;
            delegate = match('*');
            if (delegate) {
                lex();
                argument = parseAssignmentExpression();
            } else {
                if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {
                    argument = parseAssignmentExpression();
                }
            }
            state.allowYield = previousAllowYield;
        }

        return expr.finishYieldExpression(argument, delegate);
    }

    // ECMA-262 12.14 Assignment Operators

    function parseAssignmentExpression() {
        var token, expr, right, list, startToken;

        startToken = lookahead;
        token = lookahead;

        if (!state.allowYield && matchKeyword('yield')) {
            return parseYieldExpression();
        }

        expr = parseConditionalExpression();

        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
            isAssignmentTarget = isBindingElement = false;
            list = reinterpretAsCoverFormalsList(expr);

            if (list) {
                firstCoverInitializedNameError = null;
                return parseArrowFunctionExpression(list, new WrappingNode(startToken));
            }

            return expr;
        }

        if (matchAssign()) {
            if (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }

            // ECMA-262 12.1.1
            if (strict && expr.type === Syntax.Identifier) {
                if (isRestrictedWord(expr.name)) {
                    tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
                }
                if (isStrictModeReservedWord(expr.name)) {
                    tolerateUnexpectedToken(token, Messages.StrictReservedWord);
                }
            }

            if (!match('=')) {
                isAssignmentTarget = isBindingElement = false;
            } else {
                reinterpretExpressionAsPattern(expr);
            }

            token = lex();
            right = isolateCoverGrammar(parseAssignmentExpression);
            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
            firstCoverInitializedNameError = null;
        }

        return expr;
    }

    // ECMA-262 12.15 Comma Operator

    function parseExpression() {
        var expr, startToken = lookahead, expressions;

        expr = isolateCoverGrammar(parseAssignmentExpression);

        if (match(',')) {
            expressions = [expr];

            while (startIndex < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expressions.push(isolateCoverGrammar(parseAssignmentExpression));
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }

        return expr;
    }

    // ECMA-262 13.2 Block

    function parseStatementListItem() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'export':
                if (state.sourceType !== 'module') {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
                }
                return parseExportDeclaration();
            case 'import':
                if (state.sourceType !== 'module') {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
                }
                return parseImportDeclaration();
            case 'const':
                return parseLexicalDeclaration({inFor: false});
            case 'function':
                return parseFunctionDeclaration(new Node());
            case 'class':
                return parseClassDeclaration();
            }
        }

        if (matchKeyword('let') && isLexicalDeclaration()) {
            return parseLexicalDeclaration({inFor: false});
        }

        return parseStatement();
    }

    function parseStatementList() {
        var list = [];
        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            list.push(parseStatementListItem());
        }

        return list;
    }

    function parseBlock() {
        var block, node = new Node();

        expect('{');

        block = parseStatementList();

        expect('}');

        return node.finishBlockStatement(block);
    }

    // ECMA-262 13.3.2 Variable Statement

    function parseVariableIdentifier(kind) {
        var token, node = new Node();

        token = lex();

        if (token.type === Token.Keyword && token.value === 'yield') {
            if (strict) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } if (!state.allowYield) {
                throwUnexpectedToken(token);
            }
        } else if (token.type !== Token.Identifier) {
            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } else {
                if (strict || token.value !== 'let' || kind !== 'var') {
                    throwUnexpectedToken(token);
                }
            }
        } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {
            tolerateUnexpectedToken(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseVariableDeclaration(options) {
        var init = null, id, node = new Node(), params = [];

        id = parsePattern(params, 'var');

        // ECMA-262 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (match('=')) {
            lex();
            init = isolateCoverGrammar(parseAssignmentExpression);
        } else if (id.type !== Syntax.Identifier && !options.inFor) {
            expect('=');
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseVariableDeclarationList(options) {
        var opt, list;

        opt = { inFor: options.inFor };
        list = [parseVariableDeclaration(opt)];

        while (match(',')) {
            lex();
            list.push(parseVariableDeclaration(opt));
        }

        return list;
    }

    function parseVariableStatement(node) {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList({ inFor: false });

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations);
    }

    // ECMA-262 13.3.1 Let and Const Declarations

    function parseLexicalBinding(kind, options) {
        var init = null, id, node = new Node(), params = [];

        id = parsePattern(params, kind);

        // ECMA-262 12.2.1
        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (kind === 'const') {
            if (!matchKeyword('in') && !matchContextualKeyword('of')) {
                expect('=');
                init = isolateCoverGrammar(parseAssignmentExpression);
            }
        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {
            expect('=');
            init = isolateCoverGrammar(parseAssignmentExpression);
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseBindingList(kind, options) {
        var list = [parseLexicalBinding(kind, options)];

        while (match(',')) {
            lex();
            list.push(parseLexicalBinding(kind, options));
        }

        return list;
    }


    function tokenizerState() {
        return {
            index: index,
            lineNumber: lineNumber,
            lineStart: lineStart,
            hasLineTerminator: hasLineTerminator,
            lastIndex: lastIndex,
            lastLineNumber: lastLineNumber,
            lastLineStart: lastLineStart,
            startIndex: startIndex,
            startLineNumber: startLineNumber,
            startLineStart: startLineStart,
            lookahead: lookahead,
            tokenCount: extra.tokens ? extra.tokens.length : 0
        };
    }

    function resetTokenizerState(ts) {
        index = ts.index;
        lineNumber = ts.lineNumber;
        lineStart = ts.lineStart;
        hasLineTerminator = ts.hasLineTerminator;
        lastIndex = ts.lastIndex;
        lastLineNumber = ts.lastLineNumber;
        lastLineStart = ts.lastLineStart;
        startIndex = ts.startIndex;
        startLineNumber = ts.startLineNumber;
        startLineStart = ts.startLineStart;
        lookahead = ts.lookahead;
        if (extra.tokens) {
            extra.tokens.splice(ts.tokenCount, extra.tokens.length);
        }
    }

    function isLexicalDeclaration() {
        var lexical, ts;

        ts = tokenizerState();

        lex();
        lexical = (lookahead.type === Token.Identifier) || match('[') || match('{') ||
            matchKeyword('let') || matchKeyword('yield');

        resetTokenizerState(ts);

        return lexical;
    }

    function parseLexicalDeclaration(options) {
        var kind, declarations, node = new Node();

        kind = lex().value;
        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');

        declarations = parseBindingList(kind, options);

        consumeSemicolon();

        return node.finishLexicalDeclaration(declarations, kind);
    }

    function parseRestElement(params) {
        var param, node = new Node();

        lex();

        if (match('{')) {
            throwError(Messages.ObjectPatternAsRestParameter);
        }

        params.push(lookahead);

        param = parseVariableIdentifier();

        if (match('=')) {
            throwError(Messages.DefaultRestParameter);
        }

        if (!match(')')) {
            throwError(Messages.ParameterAfterRestParameter);
        }

        return node.finishRestElement(param);
    }

    // ECMA-262 13.4 Empty Statement

    function parseEmptyStatement(node) {
        expect(';');
        return node.finishEmptyStatement();
    }

    // ECMA-262 12.4 Expression Statement

    function parseExpressionStatement(node) {
        var expr = parseExpression();
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
    }

    // ECMA-262 13.6 If statement

    function parseIfStatement(node) {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return node.finishIfStatement(test, consequent, alternate);
    }

    // ECMA-262 13.7 Iteration Statements

    function parseDoWhileStatement(node) {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return node.finishDoWhileStatement(body, test);
    }

    function parseWhileStatement(node) {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return node.finishWhileStatement(test, body);
    }

    function parseForStatement(node) {
        var init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations,
            body, oldInIteration, previousAllowIn = state.allowIn;

        init = test = update = null;
        forIn = true;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var')) {
                init = new Node();
                lex();

                state.allowIn = false;
                declarations = parseVariableDeclarationList({ inFor: true });
                state.allowIn = previousAllowIn;

                if (declarations.length === 1 && matchKeyword('in')) {
                    init = init.finishVariableDeclaration(declarations);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
                    init = init.finishVariableDeclaration(declarations);
                    lex();
                    left = init;
                    right = parseAssignmentExpression();
                    init = null;
                    forIn = false;
                } else {
                    init = init.finishVariableDeclaration(declarations);
                    expect(';');
                }
            } else if (matchKeyword('const') || matchKeyword('let')) {
                init = new Node();
                kind = lex().value;

                if (!strict && lookahead.value === 'in') {
                    init = init.finishIdentifier(kind);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else {
                    state.allowIn = false;
                    declarations = parseBindingList(kind, {inFor: true});
                    state.allowIn = previousAllowIn;

                    if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {
                        init = init.finishLexicalDeclaration(declarations, kind);
                        lex();
                        left = init;
                        right = parseExpression();
                        init = null;
                    } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
                        init = init.finishLexicalDeclaration(declarations, kind);
                        lex();
                        left = init;
                        right = parseAssignmentExpression();
                        init = null;
                        forIn = false;
                    } else {
                        consumeSemicolon();
                        init = init.finishLexicalDeclaration(declarations, kind);
                    }
                }
            } else {
                initStartToken = lookahead;
                state.allowIn = false;
                init = inheritCoverGrammar(parseAssignmentExpression);
                state.allowIn = previousAllowIn;

                if (matchKeyword('in')) {
                    if (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInForIn);
                    }

                    lex();
                    reinterpretExpressionAsPattern(init);
                    left = init;
                    right = parseExpression();
                    init = null;
                } else if (matchContextualKeyword('of')) {
                    if (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInForLoop);
                    }

                    lex();
                    reinterpretExpressionAsPattern(init);
                    left = init;
                    right = parseAssignmentExpression();
                    init = null;
                    forIn = false;
                } else {
                    if (match(',')) {
                        initSeq = [init];
                        while (match(',')) {
                            lex();
                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
                        }
                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);
                    }
                    expect(';');
                }
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = isolateCoverGrammar(parseStatement);

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
                node.finishForStatement(init, test, update, body) :
                forIn ? node.finishForInStatement(left, right, body) :
                    node.finishForOfStatement(left, right, body);
    }

    // ECMA-262 13.8 The continue statement

    function parseContinueStatement(node) {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(startIndex) === 0x3B) {
            lex();

            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (hasLineTerminator) {
            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError(Messages.IllegalContinue);
        }

        return node.finishContinueStatement(label);
    }

    // ECMA-262 13.9 The break statement

    function parseBreakStatement(node) {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(lastIndex) === 0x3B) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (hasLineTerminator) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }
        } else if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError(Messages.IllegalBreak);
        }

        return node.finishBreakStatement(label);
    }

    // ECMA-262 13.10 The return statement

    function parseReturnStatement(node) {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            tolerateError(Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(lastIndex) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return node.finishReturnStatement(argument);
            }
        }

        if (hasLineTerminator) {
            // HACK
            return node.finishReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return node.finishReturnStatement(argument);
    }

    // ECMA-262 13.11 The with statement

    function parseWithStatement(node) {
        var object, body;

        if (strict) {
            tolerateError(Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return node.finishWithStatement(object, body);
    }

    // ECMA-262 13.12 The switch statement

    function parseSwitchCase() {
        var test, consequent = [], statement, node = new Node();

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (startIndex < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatementListItem();
            consequent.push(statement);
        }

        return node.finishSwitchCase(test, consequent);
    }

    function parseSwitchStatement(node) {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return node.finishSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError(Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return node.finishSwitchStatement(discriminant, cases);
    }

    // ECMA-262 13.14 The throw statement

    function parseThrowStatement(node) {
        var argument;

        expectKeyword('throw');

        if (hasLineTerminator) {
            throwError(Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return node.finishThrowStatement(argument);
    }

    // ECMA-262 13.15 The try statement

    function parseCatchClause() {
        var param, params = [], paramMap = {}, key, i, body, node = new Node();

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpectedToken(lookahead);
        }

        param = parsePattern(params);
        for (i = 0; i < params.length; i++) {
            key = '$' + params[i].value;
            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                tolerateError(Messages.DuplicateBinding, params[i].value);
            }
            paramMap[key] = true;
        }

        // ECMA-262 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            tolerateError(Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return node.finishCatchClause(param, body);
    }

    function parseTryStatement(node) {
        var block, handler = null, finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handler = parseCatchClause();
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (!handler && !finalizer) {
            throwError(Messages.NoCatchOrFinally);
        }

        return node.finishTryStatement(block, handler, finalizer);
    }

    // ECMA-262 13.16 The debugger statement

    function parseDebuggerStatement(node) {
        expectKeyword('debugger');

        consumeSemicolon();

        return node.finishDebuggerStatement();
    }

    // 13 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            node;

        if (type === Token.EOF) {
            throwUnexpectedToken(lookahead);
        }

        if (type === Token.Punctuator && lookahead.value === '{') {
            return parseBlock();
        }
        isAssignmentTarget = isBindingElement = true;
        node = new Node();

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement(node);
            case '(':
                return parseExpressionStatement(node);
            }
        } else if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement(node);
            case 'continue':
                return parseContinueStatement(node);
            case 'debugger':
                return parseDebuggerStatement(node);
            case 'do':
                return parseDoWhileStatement(node);
            case 'for':
                return parseForStatement(node);
            case 'function':
                return parseFunctionDeclaration(node);
            case 'if':
                return parseIfStatement(node);
            case 'return':
                return parseReturnStatement(node);
            case 'switch':
                return parseSwitchStatement(node);
            case 'throw':
                return parseThrowStatement(node);
            case 'try':
                return parseTryStatement(node);
            case 'var':
                return parseVariableStatement(node);
            case 'while':
                return parseWhileStatement(node);
            case 'with':
                return parseWithStatement(node);
            }
        }

        expr = parseExpression();

        // ECMA-262 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return node.finishLabeledStatement(expr, labeledBody);
        }

        consumeSemicolon();

        return node.finishExpressionStatement(expr);
    }

    // ECMA-262 14.1 Function Definition

    function parseFunctionSourceElements() {
        var statement, body = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody,
            node = new Node();

        expect('{');

        while (startIndex < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;

        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            body.push(parseStatementListItem());
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;

        return node.finishBlockStatement(body);
    }

    function validateParam(options, param, name) {
        var key = '$' + name;
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet[key] = true;
    }

    function parseParam(options) {
        var token, param, params = [], i, def;

        token = lookahead;
        if (token.value === '...') {
            param = parseRestElement(params);
            validateParam(options, param.argument, param.argument.name);
            options.params.push(param);
            options.defaults.push(null);
            return false;
        }

        param = parsePatternWithDefault(params);
        for (i = 0; i < params.length; i++) {
            validateParam(options, params[i], params[i].value);
        }

        if (param.type === Syntax.AssignmentPattern) {
            def = param.right;
            param = param.left;
            ++options.defaultCount;
        }

        options.params.push(param);
        options.defaults.push(def);

        return !match(')');
    }

    function parseParams(firstRestricted) {
        var options;

        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            firstRestricted: firstRestricted
        };

        expect('(');

        if (!match(')')) {
            options.paramSet = {};
            while (startIndex < length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        if (options.defaultCount === 0) {
            options.defaults = [];
        }

        return {
            params: options.params,
            defaults: options.defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseFunctionDeclaration(node, identifierIsOptional) {
        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict,
            isGenerator, previousAllowYield;

        previousAllowYield = state.allowYield;

        expectKeyword('function');

        isGenerator = match('*');
        if (isGenerator) {
            lex();
        }

        if (!identifierIsOptional || !match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        state.allowYield = !isGenerator;
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }


        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }

        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp,
            params = [], defaults = [], body, previousStrict, node = new Node(),
            isGenerator, previousAllowYield;

        previousAllowYield = state.allowYield;

        expectKeyword('function');

        isGenerator = match('*');
        if (isGenerator) {
            lex();
        }

        state.allowYield = !isGenerator;
        if (!match('(')) {
            token = lookahead;
            id = (!strict && !isGenerator && matchKeyword('yield')) ? parseNonComputedProperty() : parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishFunctionExpression(id, params, defaults, body, isGenerator);
    }

    // ECMA-262 14.5 Class Definitions

    function parseClassBody() {
        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;

        classBody = new Node();

        expect('{');
        body = [];
        while (!match('}')) {
            if (match(';')) {
                lex();
            } else {
                method = new Node();
                token = lookahead;
                isStatic = false;
                computed = match('[');
                if (match('*')) {
                    lex();
                } else {
                    key = parseObjectPropertyKey();
                    if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {
                        token = lookahead;
                        isStatic = true;
                        computed = match('[');
                        if (match('*')) {
                            lex();
                        } else {
                            key = parseObjectPropertyKey();
                        }
                    }
                }
                method = tryParseMethodDefinition(token, key, computed, method);
                if (method) {
                    method['static'] = isStatic; // jscs:ignore requireDotNotation
                    if (method.kind === 'init') {
                        method.kind = 'method';
                    }
                    if (!isStatic) {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {
                            if (method.kind !== 'method' || !method.method || method.value.generator) {
                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
                            }
                            if (hasConstructor) {
                                throwUnexpectedToken(token, Messages.DuplicateConstructor);
                            } else {
                                hasConstructor = true;
                            }
                            method.kind = 'constructor';
                        }
                    } else {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {
                            throwUnexpectedToken(token, Messages.StaticPrototype);
                        }
                    }
                    method.type = Syntax.MethodDefinition;
                    delete method.method;
                    delete method.shorthand;
                    body.push(method);
                } else {
                    throwUnexpectedToken(lookahead);
                }
            }
        }
        lex();
        return classBody.finishClassBody(body);
    }

    function parseClassDeclaration(identifierIsOptional) {
        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
        strict = true;

        expectKeyword('class');

        if (!identifierIsOptional || lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        return classNode.finishClassDeclaration(id, superClass, classBody);
    }

    function parseClassExpression() {
        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
        strict = true;

        expectKeyword('class');

        if (lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        return classNode.finishClassExpression(id, superClass, classBody);
    }

    // ECMA-262 15.2 Modules

    function parseModuleSpecifier() {
        var node = new Node();

        if (lookahead.type !== Token.StringLiteral) {
            throwError(Messages.InvalidModuleSpecifier);
        }
        return node.finishLiteral(lex());
    }

    // ECMA-262 15.2.3 Exports

    function parseExportSpecifier() {
        var exported, local, node = new Node(), def;
        if (matchKeyword('default')) {
            // export {default} from 'something';
            def = new Node();
            lex();
            local = def.finishIdentifier('default');
        } else {
            local = parseVariableIdentifier();
        }
        if (matchContextualKeyword('as')) {
            lex();
            exported = parseNonComputedProperty();
        }
        return node.finishExportSpecifier(local, exported);
    }

    function parseExportNamedDeclaration(node) {
        var declaration = null,
            isExportFromIdentifier,
            src = null, specifiers = [];

        // non-default export
        if (lookahead.type === Token.Keyword) {
            // covers:
            // export var f = 1;
            switch (lookahead.value) {
                case 'let':
                case 'const':
                    declaration = parseLexicalDeclaration({inFor: false});
                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
                case 'var':
                case 'class':
                case 'function':
                    declaration = parseStatementListItem();
                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
            }
        }

        expect('{');
        while (!match('}')) {
            isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
            specifiers.push(parseExportSpecifier());
            if (!match('}')) {
                expect(',');
                if (match('}')) {
                    break;
                }
            }
        }
        expect('}');

        if (matchContextualKeyword('from')) {
            // covering:
            // export {default} from 'foo';
            // export {foo} from 'foo';
            lex();
            src = parseModuleSpecifier();
            consumeSemicolon();
        } else if (isExportFromIdentifier) {
            // covering:
            // export {default}; // missing fromClause
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        } else {
            // cover
            // export {foo};
            consumeSemicolon();
        }
        return node.finishExportNamedDeclaration(declaration, specifiers, src);
    }

    function parseExportDefaultDeclaration(node) {
        var declaration = null,
            expression = null;

        // covers:
        // export default ...
        expectKeyword('default');

        if (matchKeyword('function')) {
            // covers:
            // export default function foo () {}
            // export default function () {}
            declaration = parseFunctionDeclaration(new Node(), true);
            return node.finishExportDefaultDeclaration(declaration);
        }
        if (matchKeyword('class')) {
            declaration = parseClassDeclaration(true);
            return node.finishExportDefaultDeclaration(declaration);
        }

        if (matchContextualKeyword('from')) {
            throwError(Messages.UnexpectedToken, lookahead.value);
        }

        // covers:
        // export default {};
        // export default [];
        // export default (1 + 2);
        if (match('{')) {
            expression = parseObjectInitializer();
        } else if (match('[')) {
            expression = parseArrayInitializer();
        } else {
            expression = parseAssignmentExpression();
        }
        consumeSemicolon();
        return node.finishExportDefaultDeclaration(expression);
    }

    function parseExportAllDeclaration(node) {
        var src;

        // covers:
        // export * from 'foo';
        expect('*');
        if (!matchContextualKeyword('from')) {
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        }
        lex();
        src = parseModuleSpecifier();
        consumeSemicolon();

        return node.finishExportAllDeclaration(src);
    }

    function parseExportDeclaration() {
        var node = new Node();
        if (state.inFunctionBody) {
            throwError(Messages.IllegalExportDeclaration);
        }

        expectKeyword('export');

        if (matchKeyword('default')) {
            return parseExportDefaultDeclaration(node);
        }
        if (match('*')) {
            return parseExportAllDeclaration(node);
        }
        return parseExportNamedDeclaration(node);
    }

    // ECMA-262 15.2.2 Imports

    function parseImportSpecifier() {
        // import {<foo as bar>} ...;
        var local, imported, node = new Node();

        imported = parseNonComputedProperty();
        if (matchContextualKeyword('as')) {
            lex();
            local = parseVariableIdentifier();
        }

        return node.finishImportSpecifier(local, imported);
    }

    function parseNamedImports() {
        var specifiers = [];
        // {foo, bar as bas}
        expect('{');
        while (!match('}')) {
            specifiers.push(parseImportSpecifier());
            if (!match('}')) {
                expect(',');
                if (match('}')) {
                    break;
                }
            }
        }
        expect('}');
        return specifiers;
    }

    function parseImportDefaultSpecifier() {
        // import <foo> ...;
        var local, node = new Node();

        local = parseNonComputedProperty();

        return node.finishImportDefaultSpecifier(local);
    }

    function parseImportNamespaceSpecifier() {
        // import <* as foo> ...;
        var local, node = new Node();

        expect('*');
        if (!matchContextualKeyword('as')) {
            throwError(Messages.NoAsAfterImportNamespace);
        }
        lex();
        local = parseNonComputedProperty();

        return node.finishImportNamespaceSpecifier(local);
    }

    function parseImportDeclaration() {
        var specifiers = [], src, node = new Node();

        if (state.inFunctionBody) {
            throwError(Messages.IllegalImportDeclaration);
        }

        expectKeyword('import');

        if (lookahead.type === Token.StringLiteral) {
            // import 'foo';
            src = parseModuleSpecifier();
        } else {

            if (match('{')) {
                // import {bar}
                specifiers = specifiers.concat(parseNamedImports());
            } else if (match('*')) {
                // import * as foo
                specifiers.push(parseImportNamespaceSpecifier());
            } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {
                // import foo
                specifiers.push(parseImportDefaultSpecifier());
                if (match(',')) {
                    lex();
                    if (match('*')) {
                        // import foo, * as foo
                        specifiers.push(parseImportNamespaceSpecifier());
                    } else if (match('{')) {
                        // import foo, {bar}
                        specifiers = specifiers.concat(parseNamedImports());
                    } else {
                        throwUnexpectedToken(lookahead);
                    }
                }
            } else {
                throwUnexpectedToken(lex());
            }

            if (!matchContextualKeyword('from')) {
                throwError(lookahead.value ?
                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
            }
            lex();
            src = parseModuleSpecifier();
        }

        consumeSemicolon();
        return node.finishImportDeclaration(specifiers, src);
    }

    // ECMA-262 15.1 Scripts

    function parseScriptBody() {
        var statement, body = [], token, directive, firstRestricted;

        while (startIndex < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (startIndex < length) {
            statement = parseStatementListItem();
            /* istanbul ignore if */
            if (typeof statement === 'undefined') {
                break;
            }
            body.push(statement);
        }
        return body;
    }

    function parseProgram() {
        var body, node;

        peek();
        node = new Node();

        body = parseScriptBody();
        return node.finishProgram(body, state.sourceType);
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (entry.regex) {
                token.regex = {
                    pattern: entry.regex.pattern,
                    flags: entry.regex.flags
                };
            }
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function tokenize(code, options, delegate) {
        var toString,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            allowYield: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: []
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenValues = [];
        extra.tokenize = true;
        extra.delegate = delegate;

        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    lex();
                } catch (lexError) {
                    if (extra.errors) {
                        recordError(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            tokens = extra.tokens;
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            allowYield: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: [],
            sourceType: 'script'
        };
        strict = false;

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
            if (options.sourceType === 'module') {
                // very restrictive condition for now
                state.sourceType = options.sourceType;
                strict = true;
            }
        }

        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '2.7.3';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
    /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

//=================================
//Additional code to convert to ES6 module
if(exports != module.exports) exports = module.exports;
//=================================

/** This function parses the code and returns a table that gives the variable use
 * in the passed function. The var info table has the following content
 * - it is a map with an entry for each variable accessed. (This refers just to
 * a variable and not to field access on that variable.
 * - the key for an entry is the name of the variable
 * - for each entry there is an array of usages. Each usage as the following info:
 * -- nameUse.path: an array of names constructing the field accessed.
   -- nameUse.scope: a reference to a scope object
   -- nameUse.node: the AST node that identifies this variable
   -- nameUse.isLocal: true if this is a reference to a local variable
   -- nameUse.decalredScope: for local variables only, gives the scope in which the lcoal variable is declared.
 * - additionally, there is a flag indicating if all uses of a name are local variables
 * -- isLocal: true if all uses of a varaible entry are local variables
 **/ 

/** Syntax for AST, names from Esprima.
 * Each entry is a list of nodes inside a node of a given type. the list
 * contains entries with the given fields:
 * {
 *     name:[the name of the field in the node]
 *     list:[true if the field is a list of nodes]
 *     declaration:[boolean indicating if the field corrsponds to a field declaration]
 * @private */
const syntax = {
    AssignmentExpression: [{name:'left'},{name:'right'}],
    ArrayExpression: [{name:'elements',list:true}],
    ArrayPattern: [{name:'elements',list:true}],
    ArrowFunctionExpression: [{name:'params',list:true,declaration:true},{name:'body'},{name:'defaults',list:true}],
    BlockStatement: [{name:'body',list:true}],
    BinaryExpression: [
        {name:'left'},
        {name:'right'}
        //I'm not sure I know all of these. Some may modify the object but we will skip that check here
    ],         
    BreakStatement: [],
    CallExpression: [{name:'callee'},{name:'arguments',list:true}],
    CatchClause: [
        {name:'param',declaration:true},
        {name:'body'}
        //guards omitted - moz specific
    ],
    ConditionalExpression: [{name:'test'},{name:'alternate'},{name:'consequent'}],
    ContinueStatement: [],
    DoWhileStatement: [{name:'body'},{name:'test',list:true}],
    EmptyStatement: [],
    ExpressionStatement: [{name:'expression'}],
    ForStatement: [{name:'init'},{name:'test'},{name:'update',list:true},{name:'body'}],
    ForOfStatement: [{name:'left'},{name:'right'},{name:'body'}],
    ForInStatement: [{name:'left'},{name:'right'},{name:'body'}],
    FunctionDeclaration: [
        {name:'id',declaration:true},
        {name:'params',list:true,declaration:true},
        {name:'body'}
        //no supporting default functions values
    ],
    FunctionExpression: [
        {name:'id',declaration:true},
        {name:'params',list:true,declaration:true},
        {name:'body'}
        //no supporting default functions values
    ],
    Identifier: [], //this is handled specially
    IfStatement: [{name:'test'},{name:'consequent'},{name:'alternate'}],
    Literal: [],
    LabeledStatement: [{name:'body'}],
    LogicalExpression: [{name:'left'},{name:'right'}],
    MemberExpression: [], //this handled specially
    NewExpression: [{name:'callee'},{name:'arguments',list:true}],
    Program: [{name:'body',list:true}],
    Property: [{name:'key'},{name:'value'}], //this is handled specially
    ReturnStatement: [{name:'argument'}],
    RestElement: [{name:'argument'}],
    SequenceExpression: [{name:'expressions',list:true}],
    ObjectExpression: [{name:'properties',list:true}], //this is handled specially 
    ObjectPattern: [{name:'properties',list:true}], 
    SpreadElement: [{name:'argument'}],
    SwitchCase: [{name:'test'},{name:'consequent',list:true}],
    SwitchStatement: [{name:'discriminant'},{name:'cases',list:true}],
    TemplateElement: [],
    TemplateLiteral: [{name:'quasis',list:true},{name:'expressions',list:true}],
    ThisExpression: [],
    ThrowStatement: [{name:'argument'}],
    TryStatement: [
        {name:'block'},
        {name:'handler'},
        {name:'finalizer',list:true}
        //guards omitted, moz specific
    ],
    UnaryExpression: [
        {name:'argument'}
        //the delete operator modifies, but we will skip that error check here
        //"-" | "+" | "!" | "~" | "typeof" | "void" | "delete"
    ],
    UpdateExpression: [{identifierNode:'argument'}],
    VariableDeclaration: [{name:'declarations',list:true,declaration:true}],
    VariableDeclarator: [{name:'id',declaration:true},{name:'init'}],
    WhileStatement: [{name:'body'},{name:'test',list:true}],
    WithStatement: [{name:'object'},{name:'body'}],
    YieldExpression: [
        {name:'argument'}
        //moz spidermonkey specific
    ],

    

    //no support
    AssignmentPattern: null,
    ClassBody: null,
    ClassDeclaration: null,
    ClassExpression: null,
    DebuggerStatement: null,
    ExportAllDeclaration: null,
    ExportDefaultDeclaration: null,
    ExportNamedDeclaration: null,
    ExportSpecifier: null,
    ImportDeclaration: null,
    ImportDefaultSpecifier: null,
    ImportNamespaceSpecifier: null,
    ImportSpecifier: null,
    MetaProperty: null,
    MethodDefinition: null,
    Super: null,
    TaggedTemplateExpression: null

    //if we allowed module import, it would look like this I think
    //but we can not do this in a function, only a module
    //as of the time of this writing, esprima did not support parsing dynamic es6 imports
    // ImportDeclaration: [{name:'specifiers',list:true},{name:'source'}],
    // ImportDefaultSpecifier: [{name:'local'}],
    // ImportNamespaceSpecifier: [{name:'local'}],
    // ImportSpecifier: [{name:'local'},{name:'imported'}],
    
};

/** These are javascript keywords */
const KEYWORDS = {
	"abstract": true,
	"arguments": true,
	"boolean": true,
	"break": true,
	"byte": true,
	"case": true,
	"catch": true,
	"char": true,
	"class": true,
	"const": true,
	"continue": true,
	"debugger": true,
	"default": true,
	"delete": true,
	"do": true,
	"double": true,
	"else": true,
	"enum": true,
	"eval": true,
	"export": true,
	"extends": true,
	"false": true,
	"final": true,
	"finally": true,
	"float": true,
	"for": true,
	"function": true,
	"goto": true,
	"if": true,
	"implements": true,
	"import": true,
	"in": true,
	"instanceof": true,
	"int": true,
	"interface": true,
	"let": true,
	"long": true,
	"native": true,
	"new": true,
	"null": true,
	"package": true,
	"private": true,
	"protected": true,
	"public": true,
	"return": true,
	"short": true,
	"static": true,
	"super": true,
	"switch": true,
	"synchronized": true,
	"this": true,
	"throw": true,
	"throws": true,
	"transient": true,
	"true": true,
	"try": true,
	"typeof": true,
	"var": true,
	"void": true,
	"volatile": true,
	"while": true,
	"with": true,
	"yield": true,
};

/** These are variable names we will not call out in setting the context.
 * NOTE - it is OK if we do not exclude a global variable. It will still work. */
const EXCLUSION_NAMES = {
    "undefined": true,
    "Infinity": true,
    "NaN": true,
    
    "String": true,
    "Number": true,
    "Math": true,
    "Date": true,
    "Array": true,
    "Boolean": true,
    "Error": true,
    "RegExp": true,
    
    "console": true
};

////////////////////////////////////////////////////////////////////////////////
/** This method returns the error list for this formula. It is only valid
 * after a failed call to analyzeCode. 
 *
 *  Error format: (some fields may not be present)
 *  {
 *      "description":String, //A human readable description of the error
 *      "lineNumber":Integer, //line of error, with line 0 being the function declaration, and line 1 being the start of the formula
 *      "index":Integer, //the character number of the error, including the function declaration:  "function() {\n" 
 *      "column":Integer, //the column of the error
 *      "stack":String, //an error stack
 *  }
 * */
////////////////////////////////////////////////////////////////////////////////

/** This method parses the code and returns a list of variabls accessed. It throws
 * an exception if there is an error parsing.
 **/
function analyzeCode(functionText) {

    var returnValue = {};
    
    try {
        var ast = exports.parse(functionText, { tolerant: true, loc: true });
    
        //check for errors in parsing
        if((ast.errors)&&(ast.errors.length > 0)) {
            returnValue.success = false;
            returnValue.errors = ast.errors;
            return returnValue;
        }
        
        //get the variable list
        var varInfo = getVariableInfo(ast);

        //return the variable info
        returnValue.success = true;
        returnValue.varInfo = varInfo;
        return returnValue;
    }
    catch(exception) {
        returnValue.errors = [];
        returnValue.errors.push(exception);
        return returnValue;
    }
}

/** This method analyzes the AST to find the variabls accessed from the formula.
 * This is done to find the dependencies to determine the order of calculation. 
 * 
 * - The tree is composed of nodes. Each nodes has a type which correspondds to
 * a specific statement or other program syntax element. In particular, some
 * nodes correspond to variables, which we are collecting here.
 * - The variables are in two types of nodes, a simple Identifier node or a
 * MemberExpression, which is a sequence of Identifers.
 * - If the variable is a table, then this table is stored in the "depends on map"
 * - In addition to determining which variables a fucntion depends on, some modifiers
 * are also collected for how the variable is used. 
 * -- is declaration - this node should contain an identifier that is a declaration
 * of a local variable
 * @private */
function getVariableInfo(ast) {
    
    //create the var to hold the parse data
    var processInfo = {};
    processInfo.nameTable = {};
    processInfo.scopeTable = {};
    
    //create the base scope
    var scope = startScope(processInfo);

    //traverse the tree, recursively
    processTreeNode(processInfo,ast,false);
    
    //finish the base scope
    endScope(processInfo);
    
    //finish analyzing the accessed variables
    markLocalVariables(processInfo);
    
    //return the variable names accessed
    return processInfo.nameTable;
}
    
/** This method starts a new loca variable scope, it should be called
 * when a function starts. 
 * @private */
function startScope(processInfo) {
    //initailize id gerneator
    if(processInfo.scopeIdGenerator === undefined) {
        processInfo.scopeIdGenerator = 0;
    }
    
    //create scope
    var scope = {};
    scope.id = String(processInfo.scopeIdGenerator++);
    scope.parent = processInfo.currentScope;
    scope.localVariables ={};
    
    //save this as the current scope
    processInfo.scopeTable[scope.id] = scope;
    processInfo.currentScope = scope;
}

/** This method ends a local variable scope, reverting to the parent scope.
 * It should be called when a function exits. 
 * @private */
function endScope(processInfo) {
    var currentScope = processInfo.currentScope;
    if(!currentScope) return;
    
    //set the scope to the parent scope.
    processInfo.currentScope = currentScope.parent;
}

/** This method analyzes the AST (abstract syntax tree). 
 * @private */
function processTreeNode(processInfo,node,isDeclaration) {
    
    //process the node type
    if((node.type == "Identifier")||(node.type == "MemberExpression")) {
        //process a variable
        processVariable(processInfo,node,isDeclaration);
    } 
    else if((node.type == "FunctionDeclaration")||(node.type == "FunctionExpression")) {
        //process the functoin
        processFunction(processInfo,node);
        
    }
    else if((node.type === "NewExpression")&&(node.callee.type === "Function")) {
        //we currently do not support the function constructor
        //to add it we need to add the local variables and parse the text body
        throw createParsingError("Function constructor not currently supported!",node.loc); 
    }
    else {
        //process some other node
        processGenericNode(processInfo,node);
    }
}
   
/** This method process nodes that are not variabls identifiers. This traverses 
 * down the syntax tree.
 * @private */
function processGenericNode(processInfo,node) {
    //load the syntax node info list for this node
    var nodeInfoList = syntax[node.type];
    
    //process this list
    if(nodeInfoList === undefined) {
        //node not found
        throw createParsingError("Syntax Tree Node not found: " + node.type,node.loc);
    }
    else if(nodeInfoList === null) {
        //node not supported
        throw createParsingError("Syntax node not supported: " + node.type,node.loc);
    }
    else {
        //this is a good node - process it

        //-------------------------
        // process the node list
        //-------------------------
        for(var i = 0; i < nodeInfoList.length; i++) {
            //get node info
            var nodeInfo = nodeInfoList[i];
            
            //check if this field exists in node
            var childField = node[nodeInfo.name];
            if(childField) {
                
                if(nodeInfo.list) {
                    //this is a list of child nodes
                    for(var j = 0; j < childField.length; j++) {
                        processTreeNode(processInfo,childField[j],nodeInfo.declaration);
                    }
                }
                else {
                    //this is a single node
                    processTreeNode(processInfo,childField,nodeInfo.declaration);
                }
            }
        }
    }
}

/** This method processes nodes that are function. For functions a new scope is created 
 * for the body of the function.
 * @private */
function processFunction(processInfo,node) {
    var nodeType = node.type;
    var idNode = node.id;
    var params = node.params;
    var body = node.body;
    
    //difference here between the declaration and expression
    // - in declaration the name of the function is a variable in the parent scope
    // - in expression the name is typically left of. But it can be included, in which case
    //   it is a variable only in the child (function) scope. This lets the function call
    //   itself.
    
    if((nodeType === "FunctionDeclaration")&&(idNode)) {
        //parse id node (variable name) in the parent scope
        processTreeNode(processInfo,idNode,true);
    }
    
    //create a new scope for this function
    var scope = startScope(processInfo);
    
    if((nodeType === "FunctionExpression")&&(idNode)) {
        //parse id node (variable name) in the parent scope
        processTreeNode(processInfo,idNode,true);
    }
    
    //process the variable list
    for(var i = 0; i < params.length; i++) {
        processTreeNode(processInfo,params[i],true);
    }
    
    //process the function body
    processTreeNode(processInfo,body,false);
    
    //end the scope for this function
    endScope(processInfo);
}

/** This method processes nodes that are variables (identifiers and member expressions), adding
 * them to the list of variables which are used in tehe formula.
 * @private */
function processVariable(processInfo,node,isDeclaration) {
    
    //get the variable path and the base name
    var namePath = getVariableDotPath(processInfo,node);
    if(!namePath) return;
    
    var baseName = namePath[0];
    
    //check if it is an excluded name - such as a variable name used by javascript
    if(EXCLUSION_NAMES[baseName]) {
        return;
    }
    
    //add to the name table
    var nameEntry = processInfo.nameTable[baseName];
    if(!nameEntry) {
        nameEntry = {};
        nameEntry.name = baseName;
        nameEntry.uses = [];
        
        processInfo.nameTable[baseName] = nameEntry;
    }
    
    //add a name use entry
    var nameUse = {};
    nameUse.path = namePath;
    nameUse.scope = processInfo.currentScope;
    nameUse.node = node;
    
    nameEntry.uses.push(nameUse);
    
    //if this is a declaration store it as a local varaible
    if(isDeclaration) {
        //store this in the local variables for this scope
        var scopeLocalVariables = processInfo.currentScope.localVariables;
        if(!scopeLocalVariables[baseName]) {
            scopeLocalVariables[baseName] = true;
        }
    }
}

/** This method returns the variable and its fields which are given by the node.
 * It may return null, meaning there is no variable to add to the dependency.  
 * See notes embedded in the code. It is possible to fool this into making a
 * dependecne on a parent (and all children) when all that is required is a 
 * single child. 
 * @private */
function getVariableDotPath(processInfo,node) {
    if(node.type == "Identifier") {
        //read the identifier name
        return [node.name];
    }
    else if(node.type == "MemberExpression") {
        if((node.object.type == "MemberExpression")||(node.object.type == "Identifier")) {
            //MEMBER EXPRESSION OR IDENTIFIER - variable name and/or path
            var variable = getVariableDotPath(processInfo,node.object);

            if(node.computed) {
                //COMPUTED CASE
                //We will not try to figure out what the child is. We will only make a dependence on 
                //the parent. This should work but it is too strong. For example
                //we may be including dependence on a while folder when really we depend
                //on a single child in the folder.
                processTreeNode(processInfo,node.property,false);
            }
            else {
                //append the member expression property to it
                variable.push(node.property.name);
            }

            return variable;
        }
        else {
            //something other than a variable as the object for the member expressoin
            //ignore the variable path after the call. We will set a dependence
            //on the parent which should work but is too strong. For example
            //we may be including dependence on a while folder when really we depend
            //on a single child in the folder.
            processTreeNode(processInfo,node.object,false);
            
            return null;
        }
    }
    else {
        //this shouldn't happen. If it does we didn't code the syntax tree right
        throw createParsingError("Unknown application error: expected a variable identifier node.",node.loc);
    }
}

/** This method annotates the variable usages that are local variables. 
 * @private */
function markLocalVariables(processInfo) {
    for(var key in processInfo.nameTable) {
        var nameEntry = processInfo.nameTable[key];
        var name = nameEntry.name;
        var existNonLocal = false;
        for(var i = 0; i < nameEntry.uses.length; i++) {
            var nameUse = nameEntry.uses[i];
            var scope = nameUse.scope;
            //check if this name is a local variable in this scope or a parent scope
            var varScope = null;
            for(var testScope = scope; testScope; testScope = testScope.parent) {
                if(testScope.localVariables[name]) {
                    varScope = testScope;
                    break;
                }
            }
            if(varScope) {
                //this is a local variable
                nameUse.isLocal = true;
                nameUse.declarationScope = varScope;
            }
            else {
                existNonLocal = true;
            }
        }
        //add a flag to the name enry if all uses are local
        if(!existNonLocal) {
            nameEntry.isLocal = true;
        }
    }
}


/** This method creates an error object. 
 * format:
 * {
 *     description:[string description],
 *     lineNumber:[integer line number, including function declaration line prepended to formula],
 *     column;[integer column on line number]
 * }
 * @private */
function createParsingError(errorMsg,location) {
    var error = new Error(errorMsg);
    if(location) {
        error.lineNumber = location.start.line;
        error.column = location.start.column;
    }
    return error;
}

/** @private */
const APOGEE_FORBIDDEN_NAMES = {
    "apogeeMessenger": true,
    "__initializer": true,
    "__memberFunction": true,
    "__memberGenerator": true,
    "__memberFunctionDebugHook": true
};

/** @private */
const NAME_PATTERN = /[a-zA-Z_$][0-9a-zA-Z_$]*/;

/** This function validates a table name. It returns 
 * [valid,errorMsg]. */
function validateTableName(name) {
    var nameResult = {};

    //check if it is a keyword
    if(KEYWORDS[name]) {
        nameResult.errorMessage = "Illegal name: " + name + " - Javascript reserved keyword";
        nameResult.valid = false;
    }  
    else if(EXCLUSION_NAMES[name]) {
        nameResult.errorMessage = "Illegal name: " + name + " - Javascript variable or value name";
        nameResult.valid = false;
    }
    else if(APOGEE_FORBIDDEN_NAMES[name]) {
        nameResult.errorMessage = "Illegal name: " + name + " - Apogee reserved keyword";
        nameResult.valid = false;
    }
    else {
        //check the pattern
        var nameResult = NAME_PATTERN.exec(name);
        if((!nameResult)||(nameResult[0] !== name)) {
            if(!nameResult) nameResult = {};
            nameResult.errorMessage = "Illegal name format: " + name;
            nameResult.valid = false;
        }
        else {
            nameResult.valid = true;
        }
    }
    return nameResult;
}

/** This method analyzes the code and creates the object function and dependencies. 
 * The results are loaded into the passed object processedCodeData. */
function processCode(argList,functionBody,supplementalCode,codeLabel) {
    
    //analyze the code
    var combinedFunctionBody = createCombinedFunctionBody(argList,functionBody,supplementalCode,codeLabel);
        
    //get the accessed variables
    //
    //parse the code and get variable dependencies
    var effectiveCombinedFunctionBody = MEMBER_LOCALS_TEXT + combinedFunctionBody;
    var analyzeOutput = analyzeCode(effectiveCombinedFunctionBody);
    
    var compiledInfo = {};
    
    if(analyzeOutput.success) {
        compiledInfo.varInfo = analyzeOutput.varInfo;
    }
    else {
        compiledInfo.errors = analyzeOutput.errors;
        compiledInfo.valid = false;
        return compiledInfo;
    }

    //create and execute the generator function to get the member function generator
    //and the memberFunctionContextInitializer
    var generatorFunction = createGeneratorFunction(compiledInfo.varInfo, combinedFunctionBody);
    try {
        //get the generated fucntion
        var generatedFunctions = generatorFunction();
        compiledInfo.memberFunctionGenerator = generatedFunctions.memberGenerator;
        compiledInfo.memberFunctionContextInitializer = generatedFunctions.initializer;  
        compiledInfo.valid = true;                     
    }
    catch(ex) {
        compiledInfo.errors = [ex];
        compiledInfo.valid = false;
    }
    
    return compiledInfo;   
}


/** This method creates the user code object function body. 
 * @private */
function createCombinedFunctionBody(argList,
        functionBody, 
        supplementalCode,
        codeLabel) {
    
    var argListString = argList.join(",");
    
    //create the code body
    var combinedFunctionBody = apogeeutil$1.formatString(
        MEMBER_FUNCTION_FORMAT_TEXT,
		codeLabel,
        argListString,
        functionBody,
        supplementalCode
    );
        
    return combinedFunctionBody;
}

/** This method creates (1) a closure function that returns another generator function
 * which makes the member function and (2) a function that initializes any external 
 * variables needed in the member function.
 * This closure wraps the variables that are external to this member, meaning other
 * members in the model.
 * This initializer function allows the code to be compiled once and then used with different
 * values for other data in the model.
 * The generator that makes the member function is a closure to wrap the member private
 * code and any other needed data with the member function.
 * @private */
function createGeneratorFunction(varInfo, combinedFunctionBody) {
    
    var contextDeclarationText = "";
    var initializerBody = "";

    //add the messenger as a local variable
    contextDeclarationText += "var apogeeMessenger\n";
    initializerBody += "apogeeMessenger = __messenger\n";
    
    //set the context - here we only defined the variables that are actually used.
	for(var baseName in varInfo) {        
        var baseNameInfo = varInfo[baseName];
        
        //do not add context variable for local or "returnValue", which is explicitly defined
        if((baseName === "returnValue")||(baseNameInfo.isLocal)) continue;
        
        //add a declaration
        contextDeclarationText += "var " + baseName + ";\n";
        
        //add to the context setter
        initializerBody += baseName + ' = __contextManager.getValue(__model,"' + baseName + '");\n';
    }
    
    //create the generator for the object function
    var generatorBody = apogeeutil$1.formatString(
        GENERATOR_FUNCTION_FORMAT_TEXT,
		contextDeclarationText,
        initializerBody,
        combinedFunctionBody
    );
        
    var generatorFunction = new Function(generatorBody);
    return generatorFunction;    
}


/** This is the format string to create the code body for the object function
 * Input indices:
 * 0: unique member name
 * 1: function argument list with parentheses
 * 2: member formula text
 * 3: supplemental code text
 * 
 * @private
 */
const MEMBER_FUNCTION_FORMAT_TEXT = [
"//{0}",
"",
"//supplemental code--------------",
"{3}",
"//end supplemental code----------",
"",
"//member function----------------",
"function __memberFunction({1}) {",
"//overhead code",
"__memberFunctionDebugHook('{0}');",
"",
"//user code",
"{2}",
"};",
"//end member function------------",
   ].join("\n");
   
/** This line is added when getting the dependencies to account for some local 
 * variables in the member function.
 * @private */
const MEMBER_LOCALS_TEXT = "var apogeeMessenger, __memberFunction, __memberFunctionDebugHook;";
   
/** This is the format string to create the code body for the object function
 * Input indices:
 * 0: context declaration text
 * 1: context setter body
 * 2: object function body
 * @private
 */
const GENERATOR_FUNCTION_FORMAT_TEXT = [
"'use strict'",
"//declare context variables",
"{0}",
"//context setter",
"function __initializer(__model,__contextManager,__messenger) {",
"{1}};",
"",
"//user code",
"function __memberGenerator() {",
"{2}",
"return __memberFunction",
"}",
"return {",
"'memberGenerator': __memberGenerator,",
"'initializer': __initializer",
"};"
   ].join("\n");

/** This is a messenger class for sending action messages. 
 * If the send fails, and exception will be thrown. */
class Messenger {
    
    constructor(model,fromMember) {
        this.model = model;
        this.contextManager = fromMember.getContextManager();
        this.fromMember = fromMember;
    }

    /** This is a convenience method to set a member to a given value.
     * updateMemberName - This is a member name as it would be accessed from the local code
     * data - This is the data to set on the given member. Aside from a JSON value, additional 
     * options are a Promise, to do an asynchronous update, a Error, to send an error to 
     * that table, or apogeeutil.INVALID_VALUE to send the invalid value.
     * These updates are applied after the current calculation is completed. See documentation
     * for more information on the messenger. */
    dataUpdate(updateMemberName,data) {
        
        var member = this._getMemberObject(updateMemberName);
        if(!member) {
            throw new Error("Error calling messenger - member not fond: " + updateMemberName);
        }
        
        //set the data for the table, along with triggering updates on dependent tables.
        var actionData = {};
        actionData.action = "updateData";
        actionData.memberId = member.getId();
        actionData.data = data;
        
        //return is handled above asynchronously
        if(this.model.getIsLocked()) {
            //the messenger would work improperly here
            throw new Error("Error: Messenger must only be called during member formula calculation.");
        }
        else {
            doAction(this.model,actionData);
        }
    }

    /** This is similar to dataUpdate except is allows multiple values to be set.
     * The argument update info is an array with each element representing an individual
     * data update. Each element shoudl be a 2-element array with the first entry being
     * the table name and the second being the data value. */
    compoundDataUpdate(updateInfo) { 
        
        //make the action list
        var actionList = [];
        for(var i = 0; i < updateInfo.length; i++) {
            let updateEntry = updateInfo[i];
            let subActionData = {};
            
            let member = this._getMemberObject(updateEntry[0]);
            if(!member) {
                throw new Error("Error calling messenger - member not fond: " + updateMemberName);
            }
            let data = updateEntry[1];
            
            subActionData.action = "updateData";
            subActionData.memberId = member.getId();
            subActionData.data = data;
            actionList.push(subActionData);
        }
        
        //create the single compound action
        var actionData = {};
        actionData.action = "compoundAction";
        actionData.actions = actionList;
        
        //return is handled above asynchronously
        if(this.model.getIsLocked()) {
            //the messenger would work improperly here
            throw new Error("Error: Messenger must only be called during member formula calculation.");
        }
        else {
            doAction(this.model,actionData);
        }
    }
    
    //=====================
    // Private Functions
    //=====================
    
    
    /** This method returns the member instance for a given local member name,
     * as defined from the source object context. */
    _getMemberObject(localMemberName) { 
        var pathArray = localMemberName.split(".");
        var member = this.contextManager.getMember(this.model,pathArray);
        return member;
    }
}

/** This method takes the varInfo table from the code analysis and returns
 * a lit of member objects which this member depends on.
 */
function getDependencyInfo(varInfo,model,contextManager) {
	var dependsOnMap = {};
	
	//cycle through the variables used
	for(var baseName in varInfo) {
			
        //for each use of this name that is not local, find the referenced object
        var nameEntry = varInfo[baseName];
        for(var i = 0; i < nameEntry.uses.length; i++) {
            var nameUse = nameEntry.uses[i];
            if(!nameUse.isLocal) {
                //look up the object
                var namePath = nameUse.path;

                //lookup this object, along with the passthrough dependencies
                let passThroughDependencies = [];
                var impactor = contextManager.getMember(model,namePath,passThroughDependencies);

                //add the impactor to the dependency map
                if(impactor) {
                    //add as dependent
                    var memberId = impactor.getId();
                    if(dependsOnMap[memberId] != apogeeutil$1.NORMAL_DEPENDENCY) {
                        dependsOnMap[memberId] = apogeeutil$1.NORMAL_DEPENDENCY;
                    }
                }

                //add the pass through members to the dependency map (give precedence to normal dependencies)
                passThroughDependencies.forEach(passThroughMember => {
                    var memberId = passThroughMember.getId();
                    if(dependsOnMap[memberId] == undefined) {
                        dependsOnMap[memberId] = apogeeutil$1.PASS_THROUGH_DEPENDENCY;
                    }
                });
            }
		}
	}
	
	return dependsOnMap;
}

/** This component encapsulates the member functionality for objects in the model.
 * 
 * This is a mixin and not a class. It is used for the prototype of the objects that inherit from it.
 *  
 * COMPONENT DEPENDENCIES:
 * 
 * FIELD NAMES (from update event):
 * - data
 * - name
 * - parent
 * 
 * This class represents a member object. 
 * The parent should be the parent member that holds this member or the object that holds
 * the hierarchy (maybe the model). */
class Member extends FieldObject {

    constructor(name,parentId,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super("member",instanceToCopy,keepUpdatedFixed,specialCaseIdValue);
        
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            this.setField("name",name);
            this.setField("parentId",parentId);
            //"data"
            //"pendingPromise"
            //"state"
        }
    }

    /** This property tells if this object is a member. */
    get isMember() {
        return true;
    }

    /** this method gets the name. */
    getName() {
        return this.getField("name");
    }

    /** This method returns the full name in dot notation for this object. */
    getFullName(model) {
        let name = this.getField("name");
        let parentId = this.getField("parentId");
        if(parentId) {
            let parent = model.lookupMemberById(parentId);
            if(parent) {
                return parent.getChildFullName(model,name);
            }
        }
        
        //if we get here there is no parent
        return name;
    }

    /** This returns true if the full name changes. */
    isFullNameUpdated(model) {
        if(this.areAnyFieldsUpdated(["name","parentId"])) {
            return true;
        }
        else {
            let parent = this.getParent(model);
            if((parent)&&(parent.isMember)) {
                return parent.isFullNameUpdated(model); 
            } 
            else {
                //if the parent is the model, we don't need to check the full name 
                return false;
            }
        }
    }

    getParentId() {
        return this.getField("parentId");
    }

    /** This returns the parent for this member. */
    getParent(model) {
        let parentId = this.getField("parentId");
        return model.lookupMemberById(parentId);
    }

    /** This returns the parent for this member. For the root folder
     * this value is null. */
    getParentMember(model) {
        let parentId = this.getField("parentId");
        if(parentId) {
            let parent = model.lookupMemberById(parentId);
            if((parent)&&(parent instanceof Member)) {
                return parent;
            }
        }

        //if we get here, there is no parent
        return null;
    }

    //================================================
    // Serialization Methods
    //================================================

    /** This method writes the child to a json. */
    toJson(model) {
        var json = {};
        json.name = this.getField("name");
        json.type = this.constructor.generator.type;
        if(this.addToJson) {
            this.addToJson(model,json);
        }
        
        if(this.getUpdateData) {
            var updateData = this.getUpdateData();
            json.updateData = updateData;
        }
        return json;
    }

    ///** This method creates a member from a json. IT should be implemented as a static
    // * function in extending objects. */ 
    //fromJson(parent,json,childrenJsonOutputList) {
    //}

    //=======================================
    // Data/State getting functions
    //=======================================

    /** This returns the state struct for the member. */
    getState() {
        let stateStruct = this.getField("state");
        if(stateStruct) { 
            return stateStruct.state;
        }
        else {
            //If this happens, we will just make it state normal 
            return apogeeutil$1.STATE_NORMAL;
        }
    }

    /** this method gets the data map. */
    getData() {
        return this.getField("data");
    }

    /** This returns true if this member accepts setting the data. */
    getSetDataOk() {
        return this.constructor.generator.setDataOk;
    }

    /** This returns the pre calc error. */
    getErrors() {
        let stateStruct = this.getField("state");
        let errorList;
        if(stateStruct) {
            //If this happens, we will just make it state normal
            errorList = stateStruct.errorList;
        }
        if(!errorList) {
            //just return an emptylist
            errorList = [];
        }
        return errorList;
    }

    getErrorMsg() {
        let stateStruct = this.getField("state");
        let errorMsg;
        if(stateStruct) {
            //If this happens, we will just make it state normal
            errorMsg = stateStruct.errorMsg;
        }
        if(!errorMsg) {
            //just return an emptylist
            errorMsg = UNKNOWN_ERROR_MSG_PREFIX + this.getName();
        }
        return errorMsg;
    }

    /** This returns true if the member is not up to date, typically
     * do to waiting on an asynchronous operation. */
    getPendingPromise() {
        return this.getField("pendingPromise");
    }

    /** This returns true if the pending token matches. */
    pendingPromiseMatches(promise) {
        return (this.getPendingPromise() === promise);
    }

    //=======================================
    // Update Data/State functions
    //=======================================

    /** This method clears the state field. */
    clearState() {
        this.clearField("state");
    }

    /** This method sets the data for this object. This is the object used by the 
     * code which is identified by this name, for example the JSON object associated
     * with a JSON table. Besides hold the data object, this updates the parent data map. */
    setData(data) {
        this.setField("data",data);
        this._setState(apogeeutil$1.STATE_NORMAL,data);
    }

    /** This method adds an error for this member. It will be valid for the current round of calculation of
     * this member. The error may be a javascript Error object of string (or any other object really). 
     * The optional data value should typically be undefined unless there is a specifc data value that should be
     * set with the error state. */
    setError(error) {
        this._setState(apogeeutil$1.STATE_ERROR,undefined,[error]);
    }

    /** This method sets the pre calc error for this dependent. 
     * The optional data value should typically be undefined unless there is a specifc data value that should be
     * set with the error state. */
    setErrors(errorList) {
        this._setState(apogeeutil$1.STATE_ERROR,undefined,errorList);
    }

    /** This sets the result pending flag. If there is a promise setting this member to pending, it should
     * be passed as an arg. In this case the field will be updated only if the reolving promise matches this
     * set promise. Otherwise it is assumed the promise had been superceded. In the case this member is pending
     * because it depends on a remote pending member, then no promise should be passed in to this function. 
     * The optional data value should typically be undefined unless there is a specifc data value that should be
     * set with the pending state. */
    setResultPending(promise) {
        this._setState(apogeeutil$1.STATE_PENDING);
        if(promise) {
            this.setField("pendingPromise",promise);
        }
    }

    /** This sets the result invalid flag. If the result is invalid, any
     * table depending on this will also have an invalid value. 
     * The optional data value should typically be undefined unless there is a specifc data value that should be
     * set with the invalid state. */
    setResultInvalid() {
        this._setState(apogeeutil$1.STATE_INVALID);
    }

    /** This methos sets the data, where the data can be a generalized value
     *  include data, apogeeutil.INVALID_VALUE, a Promis or an Error. Also, an explitict
     * errorList can be passed in, includgin either Error or String objects. 
     * This method does not however apply the asynchrnous data, it only flags the member as pending.
     * the asynchronous data is set separately (also) using applyAsynchData, whcih requires access
     * to the model object. */
    applyData(data,errorList) {

        //handle four types of data inputs
        if((errorList)&&(errorList.length > 0)) {
            this.setErrors(errorList);
        }
        else if(data instanceof Promise) {
            //data is a promise - flag this a pending
            this.setResultPending(data);
        }
        else if(data instanceof Error) {
            //data is an error
            this.setError(data);
        }
        else if(data === apogeeutil$1.INVALID_VALUE) {
            //data is an invalid value
            this.setResultInvalid();
        }
        else {
            //normal data update (poosibly from an asynchronouse update)
            this.setData(data);
        }
    }

    /** This method implements setting asynchronous data on the member using a promise. */
    applyAsynchData(model,promise) {

        //kick off the asynch update
        var asynchCallback = memberValue => {
            //set the data for the table, along with triggering updates on dependent tables.
            let actionData = {};
            actionData.action = "updateData";
            actionData.memberId = this.getId();
            actionData.sourcePromise = promise;
            actionData.data = memberValue;
            model.doFutureAction(actionData);
        };
        var asynchErrorCallback = errorMsg => {
            let actionData = {};
            actionData.action = "updateData";
            actionData.memberId = this.getId();
            actionData.sourcePromise = promise;
            actionData.data = new Error(errorMsg);
            model.doFutureAction(actionData);
        };

        //call appropriate action when the promise completes
        promise.then(asynchCallback).catch(asynchErrorCallback);
    }

    /** This method can be called to set data without setting the state. It is intended to be
     * used by the folder to set the data value when an error, pending or invalid state is present. This
     * data value is used for pass-through dependenceis. */
    forceUpdateDataWithoutStateChange(data) {
        this.setField("data",data);
    }

    //========================================
    // Move Functions
    //=========================================

    /** This method should be used to rename and/or change 
     * the parent of this member. */
    move(newName,newParent) {
        //update the name if needed
        if(newName != this.getField("name")) {
            this.setField("name",newName);
        }
        
        //update the parent if needed
        let currentParentId = this.getField("parentId");
        if(currentParentId != newParent.getId()) {
            this.setField("parentId",newParent.getId());
        }
    }

    //========================================
    // "Protected" Methods
    //========================================

    /** This method is called when the member is deleted. If necessary the implementation
     * can extend this function, but it should call this base version of the function
     * if it does.  
     * @protected */
    onDeleteMember(model) {
    }

    ///** This method is called when the model is closed and also when an object
    // * is deleted. It should do any needed cleanup for the object.  
    // * @protected */
    //onClose();

    //Implement this method if there is data to add to this member. Otherwise it may
    //be omitted
    ///** This method adds any additional data to the json saved for this member. 
    // * @protected */
    //addToJson(model,json) {
    //}

    //Implement this method if there is update data for this json. otherwise it may
    //be omitted
    ///** This gets an update structure to upsate a newly instantiated member
    //* to match the current object. It may return "undefined" if there is no update
    //* data needed. 
    //* @protected */
    //getUpdateData() {
    //}

    //----------------------------------
    // State setting methods
    //----------------------------------

    /** This updates the state. For state NORMAL, the data should be set. 
     * For any state other than NORMAL, the data will be set to INVALID, regardless of 
     * what argument is given for data.
     * For state ERROR, an error list should be set. */
    _setState(state,data,errorList) {
        let newStateStruct = {};
        let oldStateStruct = this.getField("state");

        //don't update state if it is the same value (unless it is error, then we will update it
        //becuase I don't feel like comparing the error messages)
        if((oldStateStruct)&&(oldStateStruct.state == state)&&(state != apogeeutil$1.STATE_ERROR)) {
            return;
        }

        //do some safety checks on the error list
        if(state == apogeeutil$1.STATE_ERROR) {
            //make sure there is an error list
            if(!errorList) errorList = [];

            newStateStruct.state = apogeeutil$1.STATE_ERROR;
            newStateStruct.errorList = errorList;
            if(errorList.length > 0) {
                newStateStruct.errorMsg = errorList.join("\n");
            }
            else {
                newStateStruct.errorMsg = UNKNOWN_ERROR_MSG_PREFIX + this.getName();
            }
        }
        else {
            //here we ignore the error list if there was one (there shouldn't be)
            newStateStruct.state = state;
        }

        

        //set the data if we passed it in, regardless of state
        this.setField("state",newStateStruct);
        this.setField("data",data);
        if(state == apogeeutil$1.STATE_NORMAL) {
            if(data !== undefined) {
                this.setField("data",data);
            }
            else {
                this.clearField("data");
            }
        }
        else { 
            this.setField("data",apogeeutil$1.INVALID_VALUE);
        }
        
        //clear the pending promise, if we are not in pending state
        //note that the pending promise must be set elsewhere
        if(state != apogeeutil$1.STATE_PENDING) {
            if(this.getField("pendingPromise")) {
                this.clearField("pendingPromise");
            }
        }
    }


}

//add mixins to this class
apogeeutil$1.mixin(Member,FieldObject);

let UNKNOWN_ERROR_MSG_PREFIX = "Unknown error in member ";

/** This mixin encapsulates an member whose value depends on on another
 * member. The dependent allows for a recalculation based on an update of the 
 * objects it depends on.
 * 
 * This is a mixin and not a class. It is used for the prototype of the objects that inherit from it.
 * 
 * COMPONENT DEPENDENCIES:
 * 
 */
class DependentMember extends Member {

    /** This initializes the component */
    constructor(name,parentId,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super(name,parentId,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //this is the list of dependencies
            this.setField("dependsOnMap",{});
        }

        //==============
        //Working variables
        //==============
        this.calcPending = false;
    }

    /** This property tells if this object is a dependent.
     * This property should not be implemented on non-dependents. */
    get isDependent() {
        return true;
    }

    /** This returns a list of the members that this member depends on. */
    getDependsOn() {
        return this.getField("dependsOnMap");
    }

    /** This returns the calc pending flag.  */
    getCalcPending() {
        return this.calcPending;
    }

    /** This sets the calc pending flag to false. It should be called when the 
     * calcultion is no longer needed.  */
    clearCalcPending() {
        this.calcPending = false;
    }

    //Must be implemented in extending object
    ///** This method udpates the dependencies if needed because
    // *a variable was added or removed from the model. Any member that has its dependencies udpated
    // * should be added to the additionalUpdatedObjects list. */
    //updateDependeciesForModelChange(model,additionalUpdatedMembers);

    ///** This is a check to see if the object should be checked for dependencies 
    // * for recalculation. It is safe for this method to always return false and
    // allow the calculation to happen. 
    // * @private */
    //memberUsesRecalculation();

    /** This does any init needed for calculation.  */
    prepareForCalculate() {
        this.calcPending = true;
        //clear any errors, and other state info
        this.clearState();
    }

    ///** This updates the member based on a change in a dependency.  */
    //calculate(model);

    /** This method makes sure any impactors are set. It sets a dependency 
     * error if one or more of the dependencies has a error. */
    initializeImpactors(model) {
        var errorDependencies = [];
        var resultPending = false;
        var resultInvalid = false;
        
        //make sure dependencies are up to date
        let dependsOnMap = this.getField("dependsOnMap");
        for(var idString in dependsOnMap) {
            let dependsOnType = dependsOnMap[idString];
            let impactor = model.lookupMemberById(idString);
            if((impactor.isDependent)&&(impactor.getCalcPending())) {
                impactor.calculate(model);
            }

            //inherit the the state of the impactor only if it is a normal dependency, as oppose to a pass through dependency
            if(dependsOnType == apogeeutil$1.NORMAL_DEPENDENCY) {
                let impactorState = impactor.getState();
                if(impactorState == apogeeutil$1.STATE_ERROR) {
                    errorDependencies.push(impactor);
                } 
                else if(impactorState == apogeeutil$1.STATE_PENDING) {
                    resultPending = true;
                }
                else if(impactorState == apogeeutil$1.STATE_INVALID) {
                    resultInvalid = true;
                }
            }
        }

        if(errorDependencies.length > 0) {
            this.createDependencyError(model,errorDependencies);
        }
        else if(resultPending) {
            this.setResultPending();
        }
        else if(resultInvalid) {
            this.setResultInvalid();
        }
    }

    /** This method removes this dependent from the model impacts map. */
    onDeleteMember(model) {
        super.onDeleteMember(model);

        //remove this dependent from the impactor
        let dependsOnMap = this.getField("dependsOnMap");
        for(var remoteMemberIdString in dependsOnMap) {
            //remove from imacts list
            model.removeFromImpactsList(this.getId(),remoteMemberIdString);
        }
    }
    //===================================
    // Private Functions
    //===================================

    /** This sets the dependencies based on the code for the member. */
    updateDependencies(model,newDependsOnMap) {
        let dependenciesUpdated = false;

        let oldDependsOnMap = this.getField("dependsOnMap");
        for(var idString in newDependsOnMap) {
            if(newDependsOnMap[idString] != oldDependsOnMap[idString]) {
                dependenciesUpdated = true;
                if(!oldDependsOnMap[idString]) model.addToImpactsList(this.getId(),idString);
            }
        }
        for(var idString in oldDependsOnMap) {
            if(newDependsOnMap[idString] != oldDependsOnMap[idString]) {
                dependenciesUpdated = true;
                if(!newDependsOnMap[idString]) model.removeFromImpactsList(this.getId(),idString);
            }
        }

        if(dependenciesUpdated) {
            this.setField("dependsOnMap",newDependsOnMap);
//            this.calcPending = true;
        }

        return dependenciesUpdated;
    }

    /** This method creates an dependency error, given a list of impactors that have an error. 
     * @private */
    createDependencyError(model,errorDependencies) {
            //dependency error found
            var message = "Error in dependency: ";
            for(var i = 0; i < errorDependencies.length; i++) {
                if(i > 0) message += ", ";
                message += errorDependencies[i].getFullName(model);
            }
            this.setError(message);   
    }
}

/** This mixin encapsulates an object in that can be coded. It contains a function
 * and supplemental code. Object that are codeable should also be a member and
 * dependent.
 * 
 * This is a mixin and not a class. It is used in the prototype of the objects that inherit from it.
 * 
 * COMPONENT DEPENDENCIES: 
 * - A Codeable must be ContextHolder
 * 
 * FIELD NAMES (from update event):
 * - argList
 * - functionBody
 * - private
 */
class CodeableMember extends DependentMember {

    /** This initializes the component. argList is the arguments for the object function. */
    constructor(name,parentId,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super(name,parentId,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);

        //mixin init where needed. This is not a scoep root. Parent scope is inherited in this object
        this.contextHolderMixinInit(false);
        
        //this should be set to true by any extending class that supresses the messenger
        //see the supressMessenger function for details.
        this.doSupressMessenger = false;
        
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //arguments of the member function
            this.setField("argList",[]);
            //"functionBody";
            //"supplementalCode";
            //"compiledInfo"
        }
        
        //==============
        //Working variables
        //==============
        this.dependencyInitInProgress = false;
    }

    /** This property tells if this object is a codeable.
     * This property should not be implemented on non-codeables. */
    get isCodeable() {
        return true;
    } 

    getSetCodeOk() {
        return this.constructor.generator.setCodeOk;
    }

    /** This method returns the argument list.  */
    getArgList() {
        return this.getField("argList");
    }

    /** This method returns the fucntion body for this member.  */
    getFunctionBody() {
        return this.getField("functionBody");
    }

    /** This method returns the supplemental code for this member.  */
    getSupplementalCode() {
        return this.getField("supplementalCode");
    }

    /** This is a helper method that compiles the code as needed for setCodeInfo.*/
    applyCode(argList,functionBody,supplementalCode) {

        //save the code
        if(this.getField("argList").toString() != argList.toString()) {
            this.setField("argList",argList);
        }
        
        if(this.getField("functionBody") != functionBody) {
            this.setField("functionBody",functionBody);
        }
        
        if(this.getField("supplementalCode") != supplementalCode) {
            this.setField("supplementalCode",supplementalCode);
        }
        
        //process the code text into javascript code
        var codeLabel = this.getName();
        var compiledInfo = processCode(argList,functionBody,supplementalCode,codeLabel);
        this.setField("compiledInfo",compiledInfo);
    }

    /** This method clears the function body and supplemental code, and
     * updates any associated variables, including the dependencies.  */
    clearCode(model) {
        if(this.getField("functionBody") != "") {
            this.setField("functionBody","");
        }
        if(this.getField("supplementalCode") != "") {
            this.setField("supplementalCode","");
        }
        this.clearField("compiledInfo");
        
        this.clearCalcPending();

        this.updateDependencies(model,[]);
    }

    /** This method returns the formula for this member.  */
    initializeDependencies(model) {

        let compiledInfo = this.getField("compiledInfo");
        
        if((this.hasCode())&&(compiledInfo.valid)) {
            //set the dependencies
            var dependsOnMap = getDependencyInfo(compiledInfo.varInfo,model,this.getContextManager());
            this.updateDependencies(model,dependsOnMap);
            
        }
        else {
            //will not be calculated - has no dependencies
            this.updateDependencies(model,{});
        }
    }

    /** This method udpates the dependencies if needed because
     *the passed variable was added.  */
    updateDependeciesForModelChange(model,additionalUpdatedMembers) {
        let compiledInfo = this.getField("compiledInfo");
        if((compiledInfo)&&(compiledInfo.valid)) {
                    
            //calculate new dependencies
            let oldDependsOnMap = this.getDependsOn();
            let newDependsOnMap = getDependencyInfo(compiledInfo.varInfo,model,this.getContextManager());

            if(!apogeeutil$1.jsonEquals(oldDependsOnMap,newDependsOnMap)) {
                //if dependencies changes, make a new mutable copy and add this to 
                //the updated values list
                let mutableMemberCopy = model.getMutableMember(this.getId());
                mutableMemberCopy.updateDependencies(model,newDependsOnMap);
                additionalUpdatedMembers.push(mutableMemberCopy);
            }
        }
    }

    /** This method returns the formula for this member.  */
    hasCode() {
        return this.getField("compiledInfo") ? true : false;
    }

    /** If this is true the member is ready to be executed. */
    memberUsesRecalculation() {
        return this.hasCode();
    }

    /** This method sets the data object for the member.  */
    calculate(model) {
        let compiledInfo = this.getField("compiledInfo");
        if(!compiledInfo) {
            this.setError("Code not found for member: " + this.getName());
            this.clearCalcPending();
            return;
        }
        else if(!compiledInfo.valid) {
            this.setErrors(compiledInfo.errors);
            this.clearCalcPending();
            return;
        }

//temporary - re create the initializer
let memberFunctionInitializer = this.createMemberFunctionInitializer(model);
      
        try {
            this.processMemberFunction(model,memberFunctionInitializer,compiledInfo.memberFunctionGenerator);
        }
        catch(error) {
            
            if(error == apogeeutil$1.MEMBER_FUNCTION_INVALID_THROWABLE) {
                //This is not an error. I don't like to throw an error
                //for an expected condition, but I didn't know how else
                //to do this. See notes where this is thrown.
                this.setResultInvalid();
            }
            else if(error == apogeeutil$1.MEMBER_FUNCTION_PENDING_THROWABLE) {
                //This is not an error. I don't like to throw an error
                //for an expected condition, but I didn't know how else
                //to do this. See notes where this is thrown.
                this.setResultPending();
            }
            //--------------------------------------
            else {
                //normal error in member function execution
            
                //this is an error in the code
                if(error.stack) {
                    console.error(error.stack);
                }

                this.setError(error);
            }
        }
        
        this.clearCalcPending();
    }

    //------------------------------
    // Member Methods
    //------------------------------

    /** This gets an update structure to upsate a newly instantiated member
    /* to match the current object. */
    getUpdateData() {
        var updateData = {};
        if(this.hasCode()) {
            updateData.argList = this.getArgList();
            updateData.functionBody = this.getFunctionBody();
            updateData.supplementalCode = this.getSupplementalCode();
        }
        else {
            let state = this.getState();

            //handle the possible data value cases
            if(state == apogeeutil$1.STATE_INVALID) {
                //invalid valude
                updateData.invalidValue = true;
            }
            else if(state == apogeeutil$1.STATE_PENDING) {
                //pending value - we can't do anything with this
                alert("There is a pending result in a field being saved. This may not be saved properly.");
                updateData.data = "<unknown pending value>";
            }
            else if(state == apogeeutil$1.STATE_ERROR) {
                //save the errors as strings only
                updateData.errorList = this.getErrors().map(error => error.toString());
            }
            else {
                //save the data value
                updateData.data = this.getData();
            }
        }
        return updateData;
    }

    //------------------------------
    //ContextHolder methods
    //------------------------------

    /** This method retrieve creates the loaded context manager. */
    createContextManager() {
        return new ContextManager(this);
    }

    //===================================
    // Protected Functions
    //===================================

    /** This method is used to remove access to the messenger from the formula for
     * this member. This should be done if the data from the member includes user runnable
     * code. The messenger should only be called in creating a data result for the member.
     * (Specifically, calling the messenger is only valid while the member is being calculated.
     * If it is called after that it will throw an error.) One place this supression is done is
     * in a FunctionMember.
     */
    supressMessenger(doSupressMessenger) {
        this.doSupressMessenger = doSupressMessenger;
    }

    //===================================
    // Private Functions
    //===================================

    //implementations must implement this function
    //This method takes the object function generated from code and processes it
    //to set the data for the object. (protected)
    //processMemberFunction 
    
    /** This makes sure user code of object function is ready to execute.  */
    createMemberFunctionInitializer(model) {
        //we want to hold these as closure variables
        let functionInitialized = false;
        let functionInitializedSuccess = false;

        let memberFunctionInitializer = () => {
            
            if(functionInitialized) return functionInitializedSuccess;
            
            //make sure this in only called once
            if(this.dependencyInitInProgress) {
                this.setError("Circular reference error");
                //clear calc in progress flag
                this.dependencyInitInProgress = false;
                functionInitialized = true;
                functionInitializedSuccess = false;
                return functionInitializedSuccess;
            }
            this.dependencyInitInProgress = true;
            
            try {
                //make sure the data is set in each impactor
                this.initializeImpactors(model);
                let state = this.getState();
                if((state == apogeeutil$1.STATE_ERROR)||(state == apogeeutil$1.STATE_PENDING)||(state == apogeeutil$1.STATE_INVALID)) {
                    this.dependencyInitInProgress = false;
                    functionInitialized = true;
                    functionInitializedSuccess = false;
                    return functionInitializedSuccess;
                }
                
                //set the context
                let compiledInfo = this.getField("compiledInfo");
                let messenger = this.doSupressMessenger ? undefined : new Messenger(model,this);
                compiledInfo.memberFunctionContextInitializer(model,this.getContextManager(),messenger);
                
                functionInitializedSuccess = true;
            }
            catch(error) {
                //this is an error in the code
                if(error.stack) {
                    console.error(error.stack);
                }

                this.setError(error);
                functionInitializedSuccess = false;
            }
            
            this.dependencyInitInProgress = false;
            functionInitialized = true;
            return functionInitializedSuccess;
        };

        return memberFunctionInitializer;

    }


}

//add components to this class
apogeeutil$1.mixin(CodeableMember,ContextHolder);

/** This class encapsulatees a data table for a JSON object */
class JsonTable extends CodeableMember {

    constructor(name,parentId,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super(name,parentId,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);
    }

    //------------------------------
    // Codeable Methods
    //------------------------------

    /** This method returns the argument list. We override it because
     * for JsonTable it gets cleared when data is set. However, whenever code
     * is used we want the argument list to be this value. */
    getArgList() {
        return [];
    }
        
    processMemberFunction(model,memberFunctionInitializer,memberGenerator) {
        let initialized = memberFunctionInitializer();
        if(initialized) {
            //the data is the output of the function
            let memberFunction = memberGenerator();
            let data = memberFunction();
            this.applyData(data);

            //we must separately apply the asynch data set promise if there is one
            if((data)&&(data instanceof Promise)) {
                this.applyAsynchData(model,data);
            }
        } 
    }

    /** This is an optional method that, when present will allow the member data to be set if the 
     * member function is cleared. */
    getDefaultDataValue() {
        return "";
    }

    //------------------------------
    // Member Methods
    //------------------------------

    /** This method extends set data from member. It also
     * freezes the object so it is immutable. (in the future we may
     * consider copying instead, or allowing a choice)*/
    setData(data) {
        
        //make this object immutable
        apogeeutil$1.deepFreeze(data);

        //store the new object
        return super.setData(data);
    }

    /** This method creates a member from a json. It should be implemented as a static
     * method in a non-abstract class. */ 
    static fromJson(parentId,json) {
        let member = new JsonTable(json.name,parentId,null,null,json.specialIdValue);

        //set initial data
        let initialData = json.updateData;
        if(!initialData) {
            //default initail value
            initialData = {};
            initialData.data = "";
        }  

        //apply the initial data
        if(initialData.functionBody !== undefined) {
            //apply initial code
            member.applyCode(initialData.argList,
                initialData.functionBody,
                initialData.supplementalCode);
        }
        else {
            //apply initial data
            let data;
            let errorList;

            if(initialData.errorList) errorList = initialData.errorList;
            else if(initialData.invalidError) data = apogeeutil$1.INVALID_VALUE;
            else if(initialData.data !== undefined) data = initialData.data;
            else data = "";

            //apply the initial data
            //note for now this can not be a promise, so we do not need to also call applyAsynchData.
            member.applyData(data,errorList);

            //set the code fields to empty strings
            member.setField("functionBody","");
            member.setField("supplementalCode","");
        }

        return member;
    }
}

//============================
// Static methods
//============================

JsonTable.generator = {};
JsonTable.generator.displayName = "JSON Member";
JsonTable.generator.type = "apogee.JsonMember";
JsonTable.generator.createMember = JsonTable.fromJson;
JsonTable.generator.setDataOk = true;
JsonTable.generator.setCodeOk = true;

//register this member
Model.addMemberGenerator(JsonTable.generator);

/** This is a function. */
class FunctionTable extends CodeableMember {

    constructor(name,parentId,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super(name,parentId,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);
        
        //The messenger should not be available from the formula for this member
        //see details in the CodeableMember function below.
        this.supressMessenger(true);
    }

    //------------------------------
    // Codeable Methods
    //------------------------------

    processMemberFunction(model,memberFunctionInitializer,memberGenerator) {
        var memberFunction = this.getLazyInitializedMemberFunction(memberFunctionInitializer,memberGenerator);
        this.setData(memberFunction);
    }

    getLazyInitializedMemberFunction(memberFunctionInitializer,memberGenerator) {

        //create init member function for lazy initialization
        //we need to do this for recursive functions, or else we will get a circular reference
        var initMember = () => {
            var impactorSuccess = memberFunctionInitializer();
            if(impactorSuccess) {
                return memberGenerator();
            }
            else {
                //error handling
                let issue;
                let state = this.getState();

                //in the case of "result invalid" or "result pending" this is 
                //NOT an error. But I don't know
                //how else to stop the calculation other than throwing an error, so 
                //we do that here. It should be handled by anyone calling a function.
                if(state == apogeeutil$1.STATE_ERROR) {
                    issue = new Error("Error in dependency: " + this.getName());
                }
                else if(state == apogeeutil$1.STATE_PENDING) {
                    issue = apogeeutil$1.MEMBER_FUNCTION_PENDING_THROWABLE;
                }
                else if(state == apogeeutil$1.STATE_INVALID) {
                    issue = apogeeutil$1.MEMBER_FUNCTION_INVALID_THROWABLE;
                }
                else {
                    issue = new Error("Unknown problem in initializing: " + this.getName());
                }
                
                throw issue;
            } 
        };

        //this is called from separate code to make debugging more readable
        return __functionTableWrapper(initMember);
    }

    /** Add to the base lock function - The function is lazy initialized so it can call itself without a 
     * ciruclar reference. The initialization happens on the first actual call. This is OK if we are doing the
     * model calculation. but if it is first called _AFTER_ the model has completed being calculated, such as
     * externally, then we will get a locked error when the lazy initialization happens. Instead, we will
     * complete the lazy initialization before the lock is done. At this point we don't need to worry about
     * circular refernce anyway, since the model has already completed its calculation. */
    lock() {
        //check if the function is initialized
        let memberFunction = this.getData();
        if((memberFunction)&&(memberFunction.initializeIfNeeded)) {
            try {
                memberFunction.initializeIfNeeded();
            }
            catch(error) {
                //handle potential error cases!!!:
                
                if(error == apogeeutil$1.MEMBER_FUNCTION_INVALID_THROWABLE) {
                    //This is not an error. I don't like to throw an error
                    //for an expected condition, but I didn't know how else
                    //to do this. See notes where this is thrown.
                    this.setResultInvalid();
                }
                else if(error == apogeeutil$1.MEMBER_FUNCTION_PENDING_THROWABLE) {
                    //This is not an error. I don't like to throw an error
                    //for an expected condition, but I didn't know how else
                    //to do this. See notes where this is thrown.
                    this.setResultPending();
                }
                //--------------------------------------
                else {
                    //normal error in member function execution
                
                    //this is an error in the code
                    if(error.stack) {
                        console.error(error.stack);
                    }
    
                    this.setError(error);
                }
            }

        }
        super.lock();
    }

    //------------------------------
    // Member Methods
    //------------------------------

    /** This method creates a member from a json. It should be implemented as a static
     * method in a non-abstract class. */ 
    static fromJson(parentId,json) {
        let member = new FunctionTable(json.name,parentId,null,null,json.specialIdValue);

        //set initial data
        let initialData = json.updateData;

        var argList = initialData.argList ? initialData.argList : [];
        var functionBody = initialData.functionBody ? initialData.functionBody : "";
        var supplementalCode = initialData.supplementalCode ? initialData.supplementalCode : "";
        member.applyCode(argList,functionBody,supplementalCode);

        return member;
    }

    /** This method extends the base method to get the property values
     * for the property editting. */
    static readProperties(member,values) {
        var argList = member.getArgList();
        var argListString = argList.toString();
        values.argListString = argListString;
        return values;
    }

    /** This method executes a property update. */
    static getPropertyUpdateAction(member,newValues) {
        if((newValues.updateData)&&(newValues.updateData.argList !== undefined)) {
            var actionData = {};
            actionData.action = "updateCode";
            actionData.memberId = member.getId();
            actionData.argList = newValues.updateData.argList;
            actionData.functionBody = member.getFunctionBody();
            actionData.supplementalCode = member.getSupplementalCode();
            return actionData;
        }
        else {
            return null;
        }
    }

}

//============================
// Static methods
//============================

FunctionTable.generator = {};
FunctionTable.generator.displayName = "Function";
FunctionTable.generator.type = "apogee.FunctionMember";
FunctionTable.generator.createMember = FunctionTable.fromJson;
FunctionTable.generator.readProperties = FunctionTable.readProperties;
FunctionTable.generator.getPropertyUpdateAction = FunctionTable.getPropertyUpdateAction;
FunctionTable.generator.setDataOk = false;
FunctionTable.generator.setCodeOk = true;

//register this member
Model.addMemberGenerator(FunctionTable.generator);

/** This is a folder. */
class Folder extends DependentMember {

    constructor(name,parent,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super(name,parent,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);

        //mixin init where needed
        //This is not a root. Scope is inherited from the parent.
        this.contextHolderMixinInit(false);
        this.parentMixinInit(instanceToCopy);

        //initialize data value if this is a new folder
        if(!instanceToCopy) {
            let dataMap = {};
            Object.freeze(dataMap);
            this.setData(dataMap);
        }
    }

    //------------------------------
    // Parent Methods
    //------------------------------

    onAddChild(model,child) {
        //set all children as dependents
        let dependsOnMap = this.calculateDependents(model);
        this.updateDependencies(model,dependsOnMap);
    }

    onRemoveChild(model,child) {
        //set all children as dependents
        let dependsOnMap = this.calculateDependents(model);
        this.updateDependencies(model,dependsOnMap);
    }

    /** this method gets the hame the children inherit for the full name. */
    getPossesionNameBase(model) {
        return this.getFullName(model) + ".";
    }

    //------------------------------
    // Dependent Methods
    //------------------------------

    /** There is no calculation for the folder base on dependents. */
    memberUsesRecalculation() {
        return true;
    }

    /** Calculate the data.  */
    calculate(model) {
        //make sure impactors are calculated
        this.initializeImpactors(model);
        
        //folders work slightly different because of pass thorugh dependencies. We will set the folder data
        //value regardless of the state, meaning if the state is error or pending or invalid, we still set
        //the data, along with maintaining the current state.

        //make an immutable map of the data for each child
        let childIdMap = this.getChildIdMap();
        let dataMap = {};
        for(let name in childIdMap) {
            let childId = childIdMap[name];
            let child = model.lookupMemberById(childId);
            if(child) {
                dataMap[name] = child.getData();
            }
        }
        Object.freeze(dataMap);

        let state = this.getState();
        if((state != apogeeutil$1.STATE_ERROR)&&(state != apogeeutil$1.STATE_PENDING)&&(state != apogeeutil$1.STATE_INVALID)) {
            //set the data state if there is no child error or other exceptional case
            this.setData(dataMap);
        }
        else {
            //if there is a child exceptional case, still set the data for the sake of pass through dependencies
            this.forceUpdateDataWithoutStateChange(dataMap);
        }
        
        //clear calc pending flag
        this.clearCalcPending();
    }

    /** This method updates the dependencies of any children
     * based on an object being added. */
    updateDependeciesForModelChange(model,additionalUpdatedMembers) {

        //update dependencies of this folder
        let oldDependsOnMap = this.getDependsOn();
        let newDependsOnMap = this.calculateDependents(model);
        if(!apogeeutil$1.jsonEquals(oldDependsOnMap,newDependsOnMap)) {
            //if dependencies changes, make a new mutable copy and add this to 
            //the updated values list
            let mutableMemberCopy = model.getMutableMember(this.getId());
            mutableMemberCopy.updateDependencies(model,newDependsOnMap);
            additionalUpdatedMembers.push(mutableMemberCopy);
        }

        //call update in children
        let childIdMap = this.getChildIdMap();
        for(var name in childIdMap) {
            let childId = childIdMap[name];
            var child = model.lookupMemberById(childId);
            if((child)&&(child.isDependent)) {
                child.updateDependeciesForModelChange(model,additionalUpdatedMembers);
            }
        }
    }

    //------------------------------
    // Member Methods
    //------------------------------

    /** This method creates a member from a json. It should be implemented as a static
     * method in a non-abstract class. */ 
    static fromJson(parentId,json) {
        var folder = new Folder(json.name,parentId,null,null,json.specialIdValue);

        if(json.childrenNotWriteable) {
            folder.setChildrenWriteable(false);
        }

        return folder;
    }

    /** This method adds any additional data to the json to save for this member. 
     * @protected */
    addToJson(model,json) {
        json.children = {};
        
        if(!this.getChildrenWriteable()) {
            json.childrenNotWriteable = true;
        }
        
        let childIdMap = this.getChildIdMap();
        for(var name in childIdMap) {
            let childId = childIdMap[name];
            let child = model.lookupMemberById(childId);
            json.children[name] = child.toJson(model);
        }
    }

    //------------------------------
    // context holder Methods
    //------------------------------

    /** This method retrieve creates the loaded context manager. */
    createContextManager() {
        //set the context manager
        var contextManager = new ContextManager(this);
        
        //add an entry for this folder
        var myEntry = {};
        myEntry.contextHolderAsParent = true;
        contextManager.addToContextList(myEntry);
        
        return contextManager;
    }

    //============================
    // Private methods
    //============================

    /** This method calculates the dependencies for this folder. 
     * @private */
    calculateDependents(model) {
        let dependsOnMap = [];
        let childIdMap = this.getChildIdMap();
        for(var name in childIdMap) {
            var childId = childIdMap[name];
            dependsOnMap[childId] = apogeeutil$1.NORMAL_DEPENDENCY;
        }
        return dependsOnMap;
    }
}

//add components to this class                     
apogeeutil$1.mixin(Folder,ContextHolder);
apogeeutil$1.mixin(Folder,Parent);

//============================
// Static methods
//============================


Folder.generator = {};
Folder.generator.displayName = "Folder";
Folder.generator.type = "apogee.Folder";
Folder.generator.createMember = Folder.fromJson;
Folder.generator.setDataOk = false;
Folder.generator.setCodeOk = false;

//register this member
Model.addMemberGenerator(Folder.generator);

/** This is a folderFunction, which is basically a function
 * that is expanded into data objects. */
class FolderFunction extends DependentMember {

    constructor(name,parentId,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super(name,parentId,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);

        //mixin init where needed
        this.contextHolderMixinInit();
        this.parentMixinInit(instanceToCopy);

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //set to an empty function
            this.setData(function(){});

            //this field is used to disable the calculation of the value of this function
            //It is used in the "virtual model" to prevent any unnecessary downstream calculations
            this.setField("sterilized",false);
        }

        //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        this.temporaryVirtualModelRunContext = {
            doAsynchActionCommand: function(modelId,actionData) {
                let msg = "NOT IPLEMENTED: Asynchronous actions in folder function!";
                alert(msg);
                throw new Error(msg);
            }
        };
        //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    }

    /** This gets the internal forlder for the folderFunction. */
    getInternalFolder(model) {
        return this.lookupChild(model,"body");
    }

    /** This gets the name of the return object for the folderFunction function. */
    getReturnValueString() {
        return this.getField("returnValue");
    }

    /** This gets the arg list of the folderFunction function. */
    getArgList() {
        return this.getField("argList");
    }

    //------------------------------
    // Member Methods
    //------------------------------

    /** This method creates a member from a json. It should be implemented as a static
     * method in a non-abstract class. */ 
    static fromJson(parentId,json) {
        let member = new FolderFunction(json.name,parentId,null,null,json.specialIdValue);

        //set initial data
        let initialData = json.updateData;
        let argList = ((initialData)&&(initialData.argList !== undefined)) ? initialData.argList : [];
        member.setField("argList",argList);
        let returnValueString = ((initialData)&&(initialData.returnValue !== undefined)) ? initialData.returnValue : [];
        member.setField("returnValue",returnValueString);
        
        return member;
    }

    /** This method adds any additional data to the json saved for this member. 
     * @protected */
    addToJson(model,json) {
        json.updateData = {};
        json.updateData.argList = this.getField("argList");
        json.updateData.returnValue = this.getField("returnValue");
        json.children = {};
        let childIdMap = this.getChildIdMap();
        for(var name in childIdMap) {
            var childId = childIdMap[name];
            let child = model.lookupMemberById(childId);
            if(child) {
                json.children[name] = child.toJson(model);
            }
        }
    }

    /** This method extends the base method to get the property values
     * for the property editting. */
    static readProperties(member,values) {
        var argList = member.getArgList();
        var argListString = argList.toString();
        values.argListString = argListString;
        values.returnValueString = member.getReturnValueString();
        return values;
    }

    /** This method executes a property update. */
    static getPropertyUpdateAction(folderFunction,newValues) {
        let updateData = newValues.updateData;
        if((updateData)&&((updateData.argList !== undefined)||(updateData.returnValue !== undefined))) {

            var argList = updateData.argList ? updateData.argList : folderFunction.getArgList();
            var returnValueString = updateData.returnValue ? updateData.returnValue : folderFunction.getReturnValueString();
    
            var actionData = {};
            actionData.action = "updateFolderFunction";
            actionData.memberId = folderFunction.getId();
            actionData.argList = argList;
            actionData.returnValueString = returnValueString;
            return actionData;
        }    
        else {
            return null;
        }
    }

    //-------------------------------
    // Dependent Methods
    //-------------------------------
        

    /** If this is true the member must be executed. */
    memberUsesRecalculation() {
        return true;
    }

    /** This updates the member data based on the function. It returns
     * true for success and false if there is an error.  */
    calculate(model) {  

        //if this function is sterilized, we will just set the value to invalid value.
        //This prevents any object which calls this function from updating. It is inended to be 
        //used in the virtual workspace assoicated with this folder function
        if(this.getField("sterilized")) {
            this.setResultInvalid();
            this.clearCalcPending();
            return;
        }

        //make sure the data is set in each impactor
        this.initializeImpactors(model);

        let state = this.getState();
        if((state != apogeeutil$1.STATE_ERROR)&&(state != apogeeutil$1.STATE_PENDING)&&(state != apogeeutil$1.STATE_INVALID)) {
            //check for code errors, if so set a data error
            try {
                var folderFunctionFunction = this.getFolderFunctionFunction(model);
                this.setData(folderFunctionFunction);
            }
            catch(error) {
                if(error.stack) console.error(error.stack);
                
                //error in calculation
                this.setError(error);
            }
        }
        
        this.clearCalcPending();
    }

    /** This method updates the dependencies of any children
     * based on an object being added. */
    updateDependeciesForModelChange(model,additionalUpdatedMembers) {

        //update dependencies of this folder
        let oldDependsOnMap = this.getDependsOn();
        let newDependsOnMap = this.calculateDependents(model);
        if(!apogeeutil$1.jsonEquals(oldDependsOnMap,newDependsOnMap)) {
            //if dependencies changes, make a new mutable copy and add this to 
            //the updated values list
            let mutableMemberCopy = model.getMutableMember(this.getId());
            mutableMemberCopy.updateDependencies(model,newDependsOnMap);
            additionalUpdatedMembers.push(mutableMemberCopy);
        }

        //call update in children
        let childIdMap = this.getChildIdMap();
        for(var name in childIdMap) {
            var childId = childIdMap[name];
            let child = model.lookupMemberById(childId);
            if((child)&&(child.isDependent)) {
                child.updateDependeciesForModelChange(model,additionalUpdatedMembers);
            }
        }
    }

    //------------------------------
    //ContextHolder methods
    //------------------------------

    /** This method retrieve creates the loaded context manager. */
    createContextManager() {
        //set the context manager
        var contextManager = new ContextManager(this);
        
        //add an entry for this folder
        var myEntry = {};
        myEntry.contextHolderAsParent = true;
        contextManager.addToContextList(myEntry);
        
        return contextManager;
    }

    //------------------------------
    //Parent methods
    //------------------------------

    onAddChild(model,child) {
        //set all children as dependents
        let dependsOnMap = this.calculateDependents(model);
        this.updateDependencies(model,dependsOnMap);
    }

    onRemoveChild(model,child) {
        //set all children as dependents
        let dependsOnMap = this.calculateDependents(model);
        this.updateDependencies(model,dependsOnMap);
    }

    /** this method gets the hame the children inherit for the full name. */
    getPossesionNameBase(model) {
        return this.getFullName(model) + ".";
    }

    //============================
    // Private methods
    //============================

    /** This method updates the table data object in the folder data map. 
     * @private */
    calculateDependents(model) {
        let dependsOnMap = [];
        let childIdMap = this.getChildIdMap();
        for(var name in childIdMap) {
            var childId = childIdMap[name];
            dependsOnMap[childId] = apogeeutil$1.NORMAL_DEPENDENCY;
        }
        return dependsOnMap;
    }

    /** This is called from the update action. It should not be called externally. */
    setReturnValueString(returnValueString) {
        let existingRVS = this.getField("returnValue");
        if(existingRVS != returnValueString) {
            this.setField("returnValue",returnValueString);
        }
    }

    /** This is called from the update action. It should not be called externally. */
    setArgList(argList) {
        let existingArgList = this.getField("argList");
        if(existingArgList != argList) {
            this.setField("argList",argList);
        }
    }

    /** This method creates the folderFunction function. It is called from the update action 
     * and should not be called externally. 
     * @private */
    getFolderFunctionFunction(model) {

        //create a copy of the model to do the function calculation - we don't update the UI display version
        var virtualModel;
        var inputMemberIdArray;
        var returnValueMemberId; 
        
        var initialized = false;
        
        var folderFunctionFunction = (...argumentArray) => {
            
            if(!initialized) {
                //get the ids of the inputs and outputs. We can use the real instance to look these up since they don't change.
                let internalFolder = this.getInternalFolder(model);
                inputMemberIdArray = this.loadInputElementIds(model,internalFolder);
                returnValueMemberId = this.loadOutputElementId(model,internalFolder); 

                //prepare the virtual function
                //this is a copy of the original model, but with any member that is unlocked replaced.
                //to prevent us from modifying an object in use by our current real model calculation.
                virtualModel = model.getCleanCopy(this.temporaryVirtualModelRunContext);

                //we want to set the folder function as "sterilized" - this prevents any downstream work from the folder function updating
                let commandData = {};
                commandData.action = "setField";
                commandData.memberId = this.getId();
                commandData.fieldName = "sterilized";
                commandData.fieldValue = "true";
                let actionResult = doAction(virtualModel,commandData);

                //we should do something with the action result
                if(!actionResult.actionDone) {
                    throw new Error("Error calculating folder function");
                }
                
                initialized = true;
            }
            
            //create an update array to set the table values for the input elements  
            var updateActionList = [];
            for(var i = 0; i < inputMemberIdArray.length; i++) {
                var entry = {};
                entry.action = "updateData";
                entry.memberId = inputMemberIdArray[i];
                entry.data = argumentArray[i];
                updateActionList.push(entry);
            }
            
            var actionData = {};
            actionData.action = "compoundAction";
            actionData.actions = updateActionList;

            //apply the update
            let workingVirtualModel = virtualModel.getMutableModel();
            var actionResult = doAction(workingVirtualModel,actionData);        
            if(actionResult.actionDone) {
                //retrieve the result
                if(returnValueMemberId) {
                    let returnValueMember = workingVirtualModel.lookupMemberById(returnValueMemberId);
                    
                    if(returnValueMember.getState() == apogeeutil$1.STATE_PENDING) {
                        throw new Error("A folder function must not be asynchronous: " + this.getFullName(workingVirtualModel));
                    }
                    
                    //get the resulting output
                    return returnValueMember.getData();
                }
                else {
                    //no return value found
                    return undefined;
                }
            }
            else {
                let errorMsg = actionResult.errorMsg ? actionResult.errorMsg : "Unknown error evaluating Folder Function " + this.getName();
                throw new Error(errorMsg);
            }
        };
        
        return folderFunctionFunction;    
    }

    /** This method loads the input argument members from the virtual model. 
     * @private */
    loadInputElementIds(model,internalFolder) {
        let argMembers = [];
        let argList = this.getField("argList");
        for(var i = 0; i < argList.length; i++) {
            var argName = argList[i];
            var argMember = internalFolder.lookupChild(model,argName);
            if(argMember) {
                argMembers.push(argMember.getId());
            }     
        }
        return argMembers;
    }

    /** This method loads the output member from the virtual model. 
     * @private  */
    loadOutputElementId(model,internalFolder) {
        let returnValueString = this.getField("returnValue");
        var returnValueMember = internalFolder.lookupChild(model,returnValueString);
        return returnValueMember.getId();
    }
}

//add components to this class
apogeeutil$1.mixin(FolderFunction,ContextHolder);
apogeeutil$1.mixin(FolderFunction,Parent);

FolderFunction.INTERNAL_FOLDER_NAME = "body";

        
//============================
// Static methods
//============================

FolderFunction.generator = {};
FolderFunction.generator.displayName = "Folder Function";
FolderFunction.generator.type = "apogee.FolderFunction";
FolderFunction.generator.createMember = FolderFunction.fromJson;
FolderFunction.generator.readProperties = FolderFunction.readProperties;
FolderFunction.generator.getPropertyUpdateAction = FolderFunction.getPropertyUpdateAction;
FolderFunction.generator.setDataOk = false;
FolderFunction.generator.setCodeOk = false;

//register this member
Model.addMemberGenerator(FolderFunction.generator);

/** This class encapsulatees a table with no specific functionality. It
 * is intended to be used as a placeholder when a table generator is not found. */
class ErrorTable extends Member {

    constructor(name,parentId,instanceToCopy,keepUpdatedFixed,specialCaseIdValue) {
        super(name,parentId,instanceToCopy,keepUpdatedFixed,specialCaseIdValue);

        var dummyData = "";
        this.setData(dummyData);
    }

    //------------------------------
    // Member Methods
    //------------------------------

    /** This method extends set data from member. It also
     * freezes the object so it is immutable. (in the future we may
     * consider copying instead, or allowing a choice)*/
    setData(data) {
        
        //make this object immutable
        apogeeutil$1.deepFreeze(data);

        //store the new object
        return super.setData(data);
    }

    /** This overrides the commplete json to just pass back the entire json sent in. */
    toJson(model) {
        return this.getField("completeJson");
    }

    /** This method creates a member from a json. It should be implemented as a static
     * method in a non-abstract class. */ 
    static fromJson(parentId,json) {
        //note - we send in the complete JSON so we can return is on saving
        let member = new ErrorTable(json.name,parentId,null,null,json.specialIdValue);

        //set the initial data
        member.setField("completeJson",json);

        return member;
    }

    //------------------------------
    // Dependent Methods
    //------------------------------

    /** This method udpates the dependencies if needed because
     *a variable was added or removed from the model.  */
    updateDependeciesForModelChange(model,additionalUpdatedMembers) {
        //no action
    }

    /** This is a check to see if the object should be checked for dependencies 
     * for recalculation. It is safe for this method to always return false and
     allow the calculation to happen.  */
   memberUsesRecalculation() {
        return false;
    }

}
//============================
// Static methods
//============================

ErrorTable.generator = {};
ErrorTable.generator.displayName = "Error Member";
ErrorTable.generator.type = "apogee.ErrorMember";
ErrorTable.generator.createMember = ErrorTable.fromJson;
ErrorTable.generator.setDataOk = false;

//register this member
Model.addMemberGenerator(ErrorTable.generator);

/** This is self installing command module. This must be imported to install the command.
 * Note that this module also contains an export, unlike most command modules. 
 * The export us used so other actions can load child members. 
 *
 * Action Data format:
 * {
 *  "action": "createMember",
 *  "parentId": (parent for new member),
 *  "name": (name of the new member),
 *  "createData": 
 *      - name
 *      - unique table type name
 *      - additional table specific data
 *      - specialIdValue (this is only to be used in special cases, to set the ID of the created object)
 *  
 * }
 *
 * MEMBER CREATED EVENT: "created"
 * Event member format:
 * {
 *  "member": (member)
 * }
 */


/** This is the action function to create a member. 
 * @private */
function createMemberAction(model,actionData) {
    
    let parent;
    if(actionData.modelIsParent) {
        //the parent is the model (It should already be mutable)
        parent = model;
    }
    else {
        //get the parent, as a new mutable instance
        parent = model.getMutableMember(actionData.parentId);

        if(!parent) {
            let actionResult = {};
            actionResult.actionDone = false;
            actionResult.errorMsg = "Parent not found for created member";
            return actionResult;
        }
    }

    let memberJson = actionData.createData;
    let actionResult = createMember(model,parent,memberJson);
    return actionResult;
}

/** This function creates a member and any children for that member, returning an action result for
 * the member. This is exported so create member can be used by other actions, such as load model. */
function createMember(model,parent,memberJson) {

    let member;
    let actionResult = {};
    actionResult.event = ACTION_EVENT;
    
    //create member
    let generator;
    if(memberJson) {
        generator = Model.getMemberGenerator(memberJson.type);
    }

    if(generator) {
        member = generator.createMember(parent.getId(),memberJson); 

        //this codde attempts to write  the member ID into the command that created the member.
        //We want this in our stored commands so we can use it for "redo" and have a member created
        //with the same ID. That way subsequent redo commands will correctly access the replacement member.
        //This doesn't seem like an optimal way to add this info to the input command. 
        //However, for now this is the earliest peice of code that actually touches each create action.
        //An alternative is to place a predetermined ID in the command before it is executed, in the 
        //command code. However, I didn't do that for now because there is not a one-to-one map from 
        //commands to actions. A single command often creates a hierarchy of members, all of which we 
        //would want to "modify". 
        try {
            if(!memberJson.specialIdValue) {
                memberJson.specialIdValue = member.getId();
            }
        }
        catch(error) {
            //we couldn't write into the command. It may be immutable
            //downstream redo commands won't work, but we'll cleanly handle that case then
            //with a failed redo.
        }

        //pass this child to the parent
        parent.addChild(model,member);

        //register member with model
        model.registerMember(member);

        //set action flags for successfull new member
        actionResult.updateModelDependencies = true;
        if((member.hasCode)&&(member.hasCode())) {
            actionResult.recalculateMember = true;
        }
        else {
            actionResult.recalculateDependsOnMembers = true;
        }

        //instantiate children if there are any
        if(memberJson.children) {
            actionResult.childActionResults = [];
            for(let childName in memberJson.children) {
                let childJson = memberJson.children[childName];
                let childActionResult = createMember(model,member,childJson);
                actionResult.childActionResults.push(childActionResult);
            }
        }
    }
    else {
        //type not found! - create a dummy object and add an error to it
        let errorTableGenerator = Model.getMemberGenerator("apogee.ErrorMember");
        member = errorTableGenerator.createMember(parent,memberJson);
        member.setError("Member type not found: " + memberJson.type);
        
        //store an error message, but this still counts as command done.
        actionResult.errorMsg = "Error creating member: member type not found: " + memberJson.type;
    }

    actionResult.member = member;
    actionResult.actionDone = true;

    return actionResult;
}

let ACTION_EVENT = "created";

//This line of code registers the action 
addActionInfo("createMember",createMemberAction);

/** This is self installing command module. It has no exports
 * but it must be imported to install the command. 
 *
 * Action Data format:
 * {
 *  "action": "updateData",
 *  "memberId": (member to update),
 *  "data": (new value for the table)
 *  "sourcePromise": (OPTIONAL - If this is the completion of an asynchronous action, the
 *      source promise shoudl be included to make sure it has not been overwritten with a
 *      more recent operation.)
 *  "promiseRefresh": (OPTIONAL - If this action reinstates a previously set promise,
 *      this flag will prevent setting additional then/catch statements on the promise)
 * }
 * 
 * Action Data format:
 * {
 *  "action": "updateCode",
 *  "memberId": (member to update),
 *  "argList": (arg list for the table)
 *  "functionBody": (function body for the table)
 *  "supplementalCode": (supplemental code for the table)
 * }
 */


/** member UPDATED EVENT: "updated"
 * Event member format:
 * {
 *  "member": (member)
 * }
 */


/** Update code action function. */
function updateCode(model,actionData) {

    let actionResult = {};
    actionResult.event = ACTION_EVENT$1;
    
    var member = model.getMutableMember(actionData.memberId);
    if(!member) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "Member not found for update member code";
        return actionResult;
    }
    actionResult.member = member;

    if((!member.isCodeable)||(!member.getSetCodeOk())) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "can not set code on member: " + member.getFullName(model);
        return actionResult;
    }
          
    member.applyCode(actionData.argList,
        actionData.functionBody,
        actionData.supplementalCode);
        
    actionResult.actionDone = true;
    actionResult.updateMemberDependencies = true;
    actionResult.recalculateMember = true;

    return actionResult;
}

/** Update data action function. */
function updateData(model,actionData) {

    let actionResult = {};
    actionResult.event = ACTION_EVENT$1;
    
    var member = model.getMutableMember(actionData.memberId);
    if(!member) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "Member not found for update member data";
        return actionResult;
    }
    actionResult.member = member;
    
    if(!member.getSetDataOk()) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "Can not set data on member: " + member.getFullName(model);
        return actionResult;
    }
        
    var data = actionData.data;

    //see if there were any dependents, to know if we need to update them
    //on setting data there will be none.
    let hadDependents = ((member.getDependsOn)&&(apogeeutil$1.jsonObjectLength(member.getDependsOn()) > 0));
    
    //if this is the resolution (or rejection) of a previously set promise
    //make sure the source promise matches the pending promise. Otherwise
    //we just ignore it (it is out of date)
    if(actionData.sourcePromise) {
        if(!member.pendingPromiseMatches(actionData.sourcePromise)) {
            //no action - this is from an asynch action that has been overwritten. Ignore this command.
            actionResult.actionDone = true;
            return actionResult;
        }
    }
    
    //some cleanup for new data
    if((member.isCodeable)&&(actionData.sourcePromise === undefined)) {
        //clear the code - so the data is used
        //UNLESS this is a delayed set date from a promise, in what case we want to keep the code.
        member.clearCode(model);
    }

    //apply the data
    member.applyData(data);

    //if the data is a promise, we must also initiate the asynchronous setting of the data
    if((data)&&(data instanceof Promise)) {
        member.applyAsynchData(model,data);
    }
    
    actionResult.actionDone = true;
    if(hadDependents) {
        actionResult.updateMemberDependencies = true;
    }
    actionResult.recalculateDependsOnMembers = true;

    return actionResult;
}

let ACTION_EVENT$1 = "updated";

//The following code registers the actions
addActionInfo("updateCode",updateCode);
addActionInfo("updateData",updateData);

/** This is self installing command module. It has no exports
 * but it must be imported to install the command. 
 *
 * Action Data format:
 * {
 *  "action": "moveMember",
 *  "member": (member to move),
 *  "targetName": (optional new name for the member - defaults to no new name)
 *  "targetParentId": (optiona new parent id - defaults to old parent id)
 *  
 *  \
 * }
 */

/** Move member action function */
function moveMember(model,actionData) {

    let actionResult = {};
    actionResult.event = ACTION_EVENT$2;
        
    var member = model.getMutableMember(actionData.memberId);
    if(!member) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "Member not found for move member";
        return;
    }
    actionResult.member = member;

    //get the name
    let targetName;
    if(actionData.targetName) {
        targetName = actionData.targetName;
    }
    else {
        targetName = member.getName();
    }

    //get the parent
    let targetParentId;
    if(actionData.targetParentId) {
        targetParentId = actionData.targetParentId;
    }
    else {
        targetParentId = member.getParentId();
    }
    var targetParent = model.getMutableMember(targetParentId);
    if(!targetParent) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "Parent not found for move member";
        return actionResult;
    }

    //if the parent changes, remove this child from the parent
    //remove from old named object from the new or old parent - if it stays, we still have the new name
    let currentParentId = member.getParentId();
    let currentParent = model.getMutableMember(currentParentId);
    if(currentParent.isParent) {
        currentParent.removeChild(model,member);
    }
        
    //appl the move to the member
    member.move(targetName,targetParent);

    //set the member in the new/old parent (rest in old parent to handle a name change)
    if(targetParent.isParent) {
        targetParent.addChild(model,member);
    }

    //create the action result
    actionResult.actionDone = true;
    actionResult.updateModelDependencies = true;
    actionResult.recalculateDependsOnMembers = true;
    
    //add the child action results
    let childActionResults = addChildResults(model,member);
    if(childActionResults) {
        actionResult.childActionResults = childActionResults;
    }
    
    return actionResult;
}

function addChildResults(model,member) {
    let childActionResults = [];
    
    if((member.isParent)||(member.isRootHolder)) {  
        var childIdMap = member.getChildIdMap();
        for(var childName in childIdMap) {
            var childId = childIdMap[childName];
            let child = model.lookupMemberById(childId);
            if(child) {
                let childActionResult = {};
                childActionResult.actionDone = true;
                childActionResult.member = child;
                childActionResult.event = ACTION_EVENT$2;
                childActionResult.updateModelDependencies = true;
                
                childActionResults.push(childActionResult);
                
                //add results for children to this member
                let grandchildActionResults = addChildResults(model,child);
                if(grandchildActionResults) {
                    childActionResult.childActionResults = grandchildActionResults;
                }
            }
        }
    }

    if(childActionResults.length > 0) {
        return childActionResults;
    }
    else {
        return null;
    }
}

let ACTION_EVENT$2 = "updated";


//This line of code registers the action 
addActionInfo("moveMember",moveMember);

/** This is self installing command module. It has no exports
 * but it must be imported to install the command. 
 *
 * Action Data format:
 * {
 *  "action": "deleteMember",
 *  "member": (member to delete),
 *  
 *  "eventInfo": (OUTPUT - event info for the associated delete event)
 * }
 *
 * MEMBER DELETED EVENT: "deleted"
 * Event object Format:
 * {
 *  "member": (member),
 *  }
 */


/** Delete member action function */
function deleteMember(model,actionData) {
    
    //get a new instance in case any changes are made during delete
    let member = model.lookupMemberById(actionData.memberId);
    if(!member) {
        let actionResult = {};
        actionResult.actionDone = false;
        actionResult.errorMsg = "Member not found for delete member";
        return actionResult;
    }
    
    let actionResult = doDelete(model, member);

    //remove the top-most deleted member from its parent
    let parentId = member.getParentId();
    let parent = model.getMutableMember(parentId);
    if(parent) {
        parent.removeChild(model,member);
    }

    return actionResult;
    
}


/** Here we take any actions for deleting the member and its children,
 * except "remove from parent", which we will do only for the top deleted member. 
 * @private */
function doDelete(model, member) {

    let actionResult = {};
    actionResult.member = member;
    actionResult.event = ACTION_EVENT$3;
    
    //delete children first
    if((member.isParent)||(member.isRootHolder)) {
        actionResult.childActionResults = [];
        
        //standard children for parent
        var childIdMap = member.getChildIdMap();
        for(var childName in childIdMap) {
            let childId = childIdMap[childName];
            let child = model.lookupMemberById(childId);
            if(child) {
                let childActionResult = doDelete(model, child);
                actionResult.childActionResults.push(childActionResult);
            }
        }
    }

    //delete member actions
    member.onDeleteMember(model);
    model.unregisterMember(member);
    
    actionResult.actionDone = true;
    actionResult.updateModelDependencies = true;

    return actionResult;
}

let ACTION_EVENT$3 = "deleted";


//This line of code registers the action 
addActionInfo("deleteMember",deleteMember);

/** This is self installing command module. It has no exports
 * but it must be imported to install the command. 
 *
 * Action Data format:
 * {
 *  "action": "updateFolderFunction",
 *  "member": (member to move),
 *  "argList": (argument list, as an array of strings)
 *  "returnValueString": (name of the return value table)
 *  
 *  "eventInfo": (OUTPUT - event info for the associated delete event)
 * }
 */

/** Update folder function action function */
function updateProperties(model,actionData) { 

    let actionResult = {};
    actionResult.event = ACTION_EVENT$4;
    
    var folderFunction = model.getMutableMember(actionData.memberId);
    if(!folderFunction) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "Member not found for update member code";
        return;
    }
    actionResult.member = folderFunction;
    
    folderFunction.setArgList(actionData.argList);
    folderFunction.setReturnValueString(actionData.returnValueString);
    
    actionResult.actionDone = true;
    actionResult.recalculateMember = true;

    return actionResult;
}

let ACTION_EVENT$4 = "updated";

//This line of code registers the action 
addActionInfo("updateFolderFunction",updateProperties);

/** This is self installing command module. It has no exports
 * but it must be imported to install the command. 
 *
 * Action Data format:
 * {
 *  "action": "loadModel",
 *  
 *  "modelJson": model json
 *  
 * }
 *
 * MEMBER CREATED EVENT: "modelUpdated"
 * Event member format:
 * {
 *  "member": (member)
 * }
 */


/** This method instantiates a member, without setting the update data. 
 *@private */
function loadModel(model,actionData) {

    let actionResult = {};
    actionResult.event = ACTION_EVENT$5;

    let modelJson = actionData.modelJson;
    
    //check the file format
    var fileType = modelJson.fileType;
    if(fileType !== Model.SAVE_FILE_TYPE) {
        throw new Error("Bad file format.");
    }
    if(modelJson.version !== Model.SAVE_FILE_VERSION) {
        throw new Error("Incorrect file version. CHECK APOGEEJS.COM FOR VERSION CONVERTER.");
    }

    //set the model name
    if(modelJson.name !== undefined) {
        model.setName(modelJson.name);
    }

    //load the model members (root folder and its children)
    actionResult.childActionResults = [];
    for(let childName in modelJson.children) {
        let childJson = modelJson.children[childName];
        let memberActionResult = createMember(model,model,childJson);
        actionResult.childActionResults.push(memberActionResult);
    }

    actionResult.actionDone = true;
    
    return actionResult;
}

let ACTION_EVENT$5 = "updated";

//This line of code registers the action 
addActionInfo("loadModel",loadModel);

/** This is self installing command module. It has no exports
 * but it must be imported to install the command. 
 *
 * Action Data format:
 * {
 *  "action": "updated",
 *  "model": (model to update),
 *  "properties": (properties to set) //currently only "name"
 * }
 *
 * member UPDATED EVENT: "modelUpdated"
 * Event member format:
 * {
 *  "member": (member)
 * }
 */

/** Update code action function. */
function updateModel(model,actionData) { 

    let actionResult = {};
    actionResult.event = ACTION_EVENT$6;
    
    var properties = actionData.properties;
    if(properties) {
        if(properties.name) model.setName(properties.name);
    }
    
    actionResult.actionDone = true;

    return actionResult;
}

let ACTION_EVENT$6 = "updated";

//The following code registers the actions
addActionInfo("updateModel",updateModel);

/** This is self installing command module. It has no exports
 * but it must be imported to install the command. 
 * 
 * This sets a field value on a member.
 *
 * Action Data format:
 * {
 *  "action": "setField",
 *  "memberId": (member to update),
 *  "fieldName": (the name of the field to update)
 *  "fieldValue": (the new field value)
 * }
 */


/** member UPDATED EVENT: "updated"
 * Event member format:
 * {
 *  "member": (member)
 * }
 */


/** Update code action function. */
function setField(model,actionData) {

    let actionResult = {};
    actionResult.event = ACTION_EVENT$7;
    
    var member = model.getMutableMember(actionData.memberId);
    if(!member) {
        actionResult.actionDone = false;
        actionResult.errorMsg = "Member not found for update member code";
        return;
    }
    actionResult.member = member;
          
    member.setField(actionData.fieldName,actionData.fieldValue);
        
    actionResult.actionDone = true;
    actionResult.recalculateMember = true;

    return actionResult;
}

let ACTION_EVENT$7 = "updated";

//The following code registers the actions
addActionInfo("setField",setField);

//This module exports the public interface to the Apogee Core Library

var apogee = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Model: Model,
    doAction: doAction,
    validateTableName: validateTableName,
    Messenger: Messenger
});

/* 
 * This class manages the command history for undo/redo.
 * 
 * Commands that can be undone are stored in a circular queue with a length that is optionally 
 * settable at startup. (Otherwise a default len this used.)
 * 
 * Some rules for the undo/redo queue:
 * - only a max number of commands are stored
 * - when a command is undone or redone, the next undo and redo position is updated
 * - new commands are inserted replacing the next redo command (if there is one, otherwise they areput at the end)
 * - once the max number of commands are reached, additional added commands replace he oldeest command in the queue
 * 
 * The command manager fires an event each time the command history is updated.
 */
class CommandHistory {
    constructor(commandManager, eventManager, optionalUndoCommandCount) {
        this.commandManager = commandManager;
        this.eventManager = eventManager;
        this.undoCommandCount = (optionalUndoCommandCount !== undefined) ? optionalUndoCommandCount : CommandHistory.DEFAULT_UNDO_COMMAND_COUNT;
        this.clearHistory();
    }
    
    /** This method executes the given command and, if applicable, adds it to the queue. */
    addToHistory(undoCommand,redoCommand,description) {
        
        if((!undoCommand)||(!redoCommand)) {
            alert("Both the undo command and redo command must be provided");
            return;
        }
        
        var command = {};
        command.redoCmd = redoCommand;
        command.undoCmd = undoCommand;
        command.desc = description;
        
        this._saveCommand(command);

        //set workspace dirty whenever a command is added to history (description as argument thrown in gratuitiously, or now)
        this.eventManager.dispatchEvent("workspaceDirty",command.desc);
    }
    
    /** This method clears the undo/redo history. */
    clearHistory() {
        //set a fixed size array for our circular queue
        this.undoQueue = new Array(this.undoCommandCount);
        
        //we will keep cmd index values that DO NOT wrap.
        //we will assume we do not overflow the integers for now
        //to get an array index, we convert from cmd index to array index with a function using modulo
        
        //this where we will put the next added command
        this.nextInsertCmdIndex = 0;
        //this is last index that has a valid command, but only if it is greater than or equal to our first cmd index
        this.lastUsedCmdIndex = -1;
        //this is the first command index that has a valid command, but only if it is less than or equal to the last command index.
        this.firstUsedCmdIndex = 0;
        
        if(this.eventManager) {
            this.eventManager.dispatchEvent("historyUpdate",this);
        }
        
    }
    
    /** If there is an undo command, this method will return the description if there
     * is one or an empty string. If there is no undo command, this method will return
     * the value null. */
    getNextUndoDesc() {
        let command = this._getNextUndoCommand(false);
        if(command) {
            if(command.desc) {
                return command.desc
            }
            else {
                return "";
            }
        }
        else {
            return null;
        }
    }
    
    /** If there is an redo command, this method will return the description if there
     * is one or an empty string. If there is no undo command, this method will return
     * the value null.*/
    getNextRedoDesc() {
        let command = this._getNextRedoCommand(false);
        if(command) {
            if(command.desc) {
                return command.desc
            }
            else {
                return "";
            }
        }
        else {
            return null;
        }
    }
    
    /** This method undoes the next command to be undone. */
    undo() {
        let command = this._getNextUndoCommand(true);
        if((command)&&(command.undoCmd)) {
            let commandSuccess = this.commandManager.executeCommand(command.undoCmd,true);
            if(!commandSuccess) {
                this._commandUndoneFailed();
            }
        }
        else {
            //the ui should not let us get here
            alert("There is not command to undo");
        }  
    }
    
    /** This method redones the next command to be redone. */
    redo() {
        let command = this._getNextRedoCommand(true);
        if((command)&&(command.redoCmd)) {
            let commandSuccess = this.commandManager.executeCommand(command.redoCmd,true);
            if(!commandSuccess) {
                this._commandRedoneFailed();
            }
        }
        else {
            //the ui should not let us get here
            alert("There is not command to redo");
        }  
    }
    
    //=================================
    // Private Methods
    //=================================

    //-------------------------
    // These functions manage the undo queue
    //-------------------------
    
    _saveCommand(command) {
        let oldNextCmdIndex = this.nextInsertCmdIndex;
        let oldLastCmdIndex = this.lastUsedCmdIndex;
        let oldFirstCmdIndex = this.firstUsedCmdIndex;
        
        let insertArrayIndex = this._getArrayIndex(this.nextInsertCmdIndex);
        this.undoQueue[insertArrayIndex] = command;
        
        //update cmd index vlues
        // -last used index is the one just added
        this.lastUsedCmdIndex = this.nextInsertCmdIndex;
        // -next insert index is one more than the previous (wrapping is NOT done in the cmd index values, only in the array index values)
        this.nextInsertCmdIndex++;
        
        // -set the first used index
        if(oldFirstCmdIndex > oldLastCmdIndex) {
            //we need to set a valid value
            this.firstUsedCmdIndex == oldNextCmdIndex;
        }
        else {
            //check for wrapping commands
            let oldFirstArrayIndex = this._getArrayIndex(oldFirstCmdIndex);
            if(insertArrayIndex == oldFirstArrayIndex) {
                this.firstUsedCmdIndex++;
            }
        }
        
        //clear out any now unreachable redo commands
        if(this.nextInsertCmdIndex <= oldLastCmdIndex) {
            this._clearCommands(this.nextInsertCmdIndex,oldLastCmdIndex);
        }    
    }
    
    _getNextUndoCommand(doQueuePositionUpdate) {
        if((this.nextInsertCmdIndex - 1 >= this.firstUsedCmdIndex)&&(this.nextInsertCmdIndex - 1 <= this.lastUsedCmdIndex)) {
            let undoArrayIndex = this._getArrayIndex(this.nextInsertCmdIndex - 1);
            
            //update the queue positions, if requested
            if(doQueuePositionUpdate) {
                this.nextInsertCmdIndex--;
                
                //notify of change to command history
                if(this.eventManager) {
                    this.eventManager.dispatchEvent("historyUpdate",this);
                }
                
            }
            
            return this.undoQueue[undoArrayIndex];
        }
        else {
            //no available command
            return null;
        }
    }
    
    _getNextRedoCommand(doQueuePositionUpdate) {
        if((this.nextInsertCmdIndex >= this.firstUsedCmdIndex)&&(this.nextInsertCmdIndex <= this.lastUsedCmdIndex)) {
            let redoArrayIndex = this._getArrayIndex(this.nextInsertCmdIndex);
            
            //update the queue positions, if requested
            if(doQueuePositionUpdate) {
                this.nextInsertCmdIndex++;
                
                //notify of change to command history
                if(this.eventManager) {
                    this.eventManager.dispatchEvent("historyUpdate",this);
                }
            }
            
            return this.undoQueue[redoArrayIndex];
        }
        else {
            return null;
        }
    }
    
    _commandUndoneFailed() {
        //clear the undone command so it can not be redone (at the current position this.nextInsertCmdIndex)
        //and clear all commands previous to this one
        this._clearCommands(this.firstUsedCmdIndex,this.nextInsertCmdIndex);
        this.firstUsedCmdIndex = this.nextInsertCmdIndex;
        //we also need to update the last used index if it was the cmd we just failed to undo
        if(this.lastUsedCmdIndex === this.nextInsertCmdIndex) {
            this.lastUsedCmdIndex--;
        }
        
        //notify of change to command history
        if(this.eventManager) {
            this.eventManager.dispatchEvent("historyUpdate",this);
        }
    }
    
    _commandRedoneFailed() {
        //clear the redone command so it can not be undone (at the current position this.nextInsertCmdIndex-1)
        //and clear all commands after to this one
        this._clearCommands(this.nextInsertCmdIndex-1,this.lastUsedCmdIndex);
        this.lastUsedCmdIndex = this.nextInsertCmdIndex-1;
        //we also need to update the first used index if it was the cmd we just failed to redo
        if(this.firstUsedCmdIndex === this.nextInsertCmdIndex-1) {
            this.firstUsedCmdIndex++;
        }
        
        //notify of change to command history
        if(this.eventManager) {
            this.eventManager.dispatchEvent("historyUpdate",this);
        }
    }
    
    _getArrayIndex(cmdIndex) {
        return cmdIndex % this.undoCommandCount;
    }
    
    _clearCommands(startCmdIndex,endCmdIndex) {
        for(var cmdIndex = startCmdIndex; cmdIndex <= endCmdIndex; cmdIndex++) {
            let arrayIndex = this._getArrayIndex(cmdIndex);
            this.undoQueue[arrayIndex] = undefined;
        }
    }
}

/** This is the default number of stored undo/redo commands */
CommandHistory.DEFAULT_UNDO_COMMAND_COUNT = 50;

/* 
 * This class manages executing commands and storign and operating the command history for undo/redo.
 * It provides standarde error handling for the commands in addition to managing undo/redo or commands.
 * 
 * Command Structure:
 * {
 *      type - This is a string giving the command type. This will be used to dispatch
 *      the command to the proper execution function. The string should correspond to 
 *      a command that was registered with the regiter command function.  
 *     
 *     ?: setsDirty?
 *     
 *     ?: noUndo?
 *     
 *     (everything else depends on the specific command)
 * }
 * 
 * Command Object - Should be registered with "registerFunction". It should contain the following things:
 * - function executeCommand(workspaceManager,commandData,optionalAsynchOnComplete) = This exectues the command and return a commandResult object.
 * - function createUnfoCommand(workspceUI,commandData) - This creates an undo command json from the given command json.
 * - object commandInfo - This is metadata for the command:
 *      - type - A string giving the name of the command type
 *      - targetType - This identifies the type of the command target (what the command acts on) This may be missing if there is no event.
 *      - event - This is the name of the event the command will fire. (It should be "created", "updated", "deleted" or missing if there is no event) 
 *
 * Command functions should throw an error if they fail to execute. If there is no error thrown it is assumed the command completed 
 * successfully.
 */
class CommandManager {
    constructor(app) {
        this.app = app;

        this.commandHistory = new CommandHistory(this,app);

        this.commandInProgress = false;
        this.commandQueue = [];
    }
    
    /** This method executes the given command and, if applicable, adds it to the queue. 
     * Supress history does not add this command to the history. It is used by the history for
     * undo commands/redo commands.
    */
    executeCommand(command,suppressFromHistory) {

        //make sure we only exectue one command at a time. For now just give up if this happens
        if(this.commandInProgress) {
            alert("Command ettempted while another in progress. Ignored");
            return false;
        }

        //get a mutable workspace manager instance
        let oldWorkspaceManager = this.app.getWorkspaceManager();
        let newWorkspaceManager;
        if(oldWorkspaceManager) {
            newWorkspaceManager = oldWorkspaceManager.getMutableWorkspaceManager();
        }
        else {
            //instantiate a new empty workspace manager
            newWorkspaceManager = this.app.createWorkspaceManager();
        }

        var commandObject = CommandManager.getCommandObject(command.type);
        let undoCommand;
        let description;

        let undoError = false;
        let undoErrorMsg;
        let commandError = false;
        let commandErrrorMsg;

        if(commandObject) {
            //create the undo command - handle this error separately from command error
            try {
                //create undo command before doing command (since it may depend on current state)
                if((!suppressFromHistory)&&(commandObject.createUndoCommand)) {   
                    undoCommand = commandObject.createUndoCommand(newWorkspaceManager,command);  
                }

            }
            catch(error) {
                if(error.stack) console.error(error.stack);

                undoError = true;
                undoErrorMsg = error.toString();
            }

            //execute the command
            try {
                //read the desrition (this needs to be improved)
                description = commandObject.commandInfo.type;

                //execute the command
                commandObject.executeCommand(newWorkspaceManager,command);
            }
            catch(error) {
                if(error.stack) console.error(error.stack);

                commandError = true;
                commandErrrorMsg = error.toString();
            }
        }
        else {
            commandError = true;
            commandErrrorMsg = "Command type not found: " + command.type;
        }

        //--------------------------
        // Accept or reject update
        //--------------------------

        //if the command succceeded, update the workspace manager instance
        let commandDone;
        if(!commandError) {
            //success - commit accept change - set (or clear) the workspace
            if(newWorkspaceManager.getIsClosed()) {
                this.app.clearWorkspaceManager();
            }
            else {
                this.app.setWorkspaceManager(newWorkspaceManager);
            }

            //add to history if the command was done and there is an undo command
            if(undoCommand) {   
                this.commandHistory.addToHistory(undoCommand,command,description);
            }

            //fire events!!
            let changeMap = newWorkspaceManager.getChangeMap();
            let changeList = this._changeMapToChangeList(changeMap);

            newWorkspaceManager.lockAll();

            this._publishEvents(changeList);

            if(undoError) {
                //process an error on creating the history - clear the current history
                this.commandHistory.clearHistory();
                alert("The command was succesful but there was an error in the history. Undo is not available. Error: " + undoErrorMsg);
            }

            commandDone = true;
        }
        else {
            //failure - keep the old workspace 
            alert("Command failed: " + commandErrrorMsg);

            commandDone = false;
        }

        this.commandInProgress = false;
        return commandDone;
    }

    /** This returns the command history. */
    getCommandHistory() {
        return this.commandHistory;
    }

    //=========================================
    // Private Methods
    //=========================================

    _changeMapToChangeList(changeMap) {
        let changeList = [];
        for(let id in changeMap) {
            let changeMapEntry = changeMap[id];
            if(changeMapEntry.action != "transient") {
                let changeListEntry = {};
                changeListEntry.target = changeMapEntry.instance;
                changeListEntry.eventName = changeMapEntry.action;
                changeList.push(changeListEntry);
            }
        }
        return changeList;
    }

    /** This fires all the necessary events for the given command result */
    _publishEvents(changeList) {
        changeList.forEach( changeEntry => {
            //fire event
            if(changeEntry.eventName) {
                this.app.dispatchEvent(changeEntry.eventName,changeEntry.target);
            } 
        });
    }

    //=========================================
    // Static Methods
    //=========================================
    
    /** This message does a standard error alert for the user. If the error is
     * fatal, meaning the application is not in a stable state, the flag isFatal
     * should be set to true. Otherwise it can be omitted or set to false.  */
    static errorAlert(errorMsg) {
        alert(errorMsg);
    }
    
    /** This registers a command. The command object should hold two functions,
     * executeCommand(workspaceManager,commandData,optionalAsynchOnComplete) and, if applicable, createUndoCommand(workspaceManager,commandData)
     * and it should have the metadata commandInfo.
     */
    static registerCommand(commandObject) {
        
        //repeat warning
        let existingCommandObject = CommandManager.commandMap[commandObject.commandInfo.type];
        if(existingCommandObject) {
            alert("The given command already exists in the command manager: " + commandObject.commandInfo.type + ". It will be replaced with the new command");
        }
        
        CommandManager.commandMap[commandObject.commandInfo.type] = commandObject;
    }
    
    static getCommandObject(commandType) {
        return CommandManager.commandMap[commandType];
    }
    
}

/** This is a map of commands accessibly to the command manager. */
CommandManager.commandMap = {};

/** This class manages links and other reference entries, loading the references and
 * creating the UI tree elements for display of the references.
 * 
 * Any links needed for the page are managed externally by the Link Loader, which
 * allows multiple users to request the same link.
 */
class ReferenceManager extends FieldObject {

    constructor(app,instanceToCopy,keepUpdatedFixed) {
        super("referenceManager",instanceToCopy,keepUpdatedFixed);

        this.app = app;
        
        let referenceClassArray = ReferenceManager.getReferenceClassArray();
        this.referenceClassMap = {};
        referenceClassArray.forEach(referenceClass => {
            this.referenceClassMap[referenceClass.REFERENCE_TYPE] = referenceClass;
        });

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //create empty reference map
            this.setField("referenceEntryMap",{});
        }

        //==============
        //Working variables
        //==============
        this.viewStateCallback = null;
        this.cachedViewState = null;

        this.workingChangeMap = {};

        //add a change map entry for this object
        this.workingChangeMap[this.getId()] = {action: instanceToCopy ? "referenceManager_updated" : "referenceManager_created", instance: this};
    }

    //====================================
    // Methods
    //====================================

    getApp() {
        return this.app;
    }

    //====================================
    // Reference Lifecycle Methods
    //====================================

    
    /** This method creates a reference entry. This does nto however load it, to 
     * do that ReferenceEntry.loadEntry() method must be called.  */
    createEntry(entryCommandData) {
        let oldEntryMap = this.getField("referenceEntryMap");
        //check if we already have this reference entry. Do not re-load it if we do.
        let entryKey = this._getEntryKey(entryCommandData.entryType,entryCommandData.url);
        let referenceEntry = oldEntryMap[entryKey];
        if(!referenceEntry) {
            //load the entry
            let referenceEntryClass = this.referenceClassMap[entryCommandData.entryType];
            if(!referenceEntryClass) throw new Error("Entry type nopt found: " + entryCommandData.entryType);
            referenceEntry = new referenceEntryClass(entryCommandData);
            this.registerRefEntry(referenceEntry);
        }
        return referenceEntry;
    }

    // updateEntry(entryType,url,entryData) {
    //     let refEntryId = this.lookupRefEntryId(entryType,url);
    //     if(!refEntryId) throw new Error("Reference entry not found. " + entryType + ":" + url);

    //     let referenceEntry = this.getMutableRefEntryById(refEntryId);
    //     if(!referenceEntry) throw new Error("Reference entry not found. refEntryId: " + refEntryId);

    //     //update entry
    //     let targetUrl = (entryData.newUrl !== undefined) ? entryData.newUrl : referenceEntry.getUrl();
    //     let targetNickname = (entryData.newNickname !== undefined) ? entryData.newNickname : referenceEntry.getNickname();
    //     referenceEntry.updateData(this.workspaceManager,targetUrl,targetNickname);

    //     this.registerRefEntry(referenceEntry);

    // }

    // removeEntry(entryType,url) {
    //     let refEntryId = this.lookupRefEntryId(entryType,url);
    //     if(!refEntryId) throw new Error("Reference entry not found. " + entryType + ":" + url);

    //     let referenceEntry = getMutableRefEntryById(refEntryId);
    //     if(!referenceEntry) throw new Error("Reference entry not found. refEntryId: " + refEntryId);

    //     referenceEntry.remove();

    //     this.unregisterRefEntry(referenceEntry);

    // }

    /** This method should be called when the parent is closed. It removes all links. */
    close() {
        let entryMap = this.getField("referenceEntryMap");
        for(let key in entryMap) {
            let referenceEntry = entryMap[key];
            referenceEntry.removeEntry();
        }
    }

    //====================================
    // Reference Owner Functionality
    //====================================

    /** The change map lists the changes to the referenceEntrys and model. This will only be
     * valid when the ReferenceManager is unlocked */
    getChangeMap() {
        return this.workingChangeMap;
    }

    /** This method locks the reference manager and all reference entries. */
    lockAll() {
        this.workingChangeMap = null;

        let referenceEntryMap = this.getField("referenceEntryMap");
        for(let id in referenceEntryMap) {
            referenceEntryMap[id].lock();
        }
        this.lock();
    }

    getRefEntryById(refEntryId) {
        return this.getField("referenceEntryMap")[refEntryId];
    }

    /** This method gets a mutable ref entry. If the current ref entry is mutable it returns
     * that. If not, it creates a mutable copy and registers the new mutable copy. It returns
     * null if the reference entry ID is not found. */
    getMutableRefEntryById(refEntryId) {
        let oldRefEntryMap = this.getField("referenceEntryMap");
        var oldRefEntry = oldRefEntryMap[refEntryId];
        if(oldRefEntry) {
            if(oldRefEntry.getIsLocked()) {
                //create an unlocked instance of the ref entry
                let newRefEntry = new oldRefEntry.constructor(null,oldRefEntry);

                //register this instance
                this.registerRefEntry(newRefEntry);

                return newRefEntry;
            }
            else {
                return oldRefEntry;
            }
        }
        else {
            return null;
        }
    }

    /** This method returns the ref entry ID for a given entry type and url. */
    lookupRefEntryId(entryType,url) {
        let urlMap = this.getField("urlMap");
        let entryKey = this._getEntryKey(entryType,url);
        return urlMap[entryKey];
    }

    /** This method returns the ref entry for a given entry type and url. */
    lookupEntry(entryType,url) {
        let refEntryId = this.lookupRefEntryId(entryType,url);
        if(refEntryId) {
            return this.getRefEntryById(refEntryId);
        }
        else {
            return null;
        }
    }

    /** This method stores the reference entry instance. It must be called when a
     * new reference entry is created and when a reference entry instance is replaced. */
    registerRefEntry(referenceEntry) {
        let refEntryId = referenceEntry.getId();
        let oldRefEntryMap = this.getField("referenceEntryMap");
        let oldRefEntry = oldRefEntryMap[refEntryId];

        //create the udpated map
        let newRefEntryMap = {};
        Object.assign(newRefEntryMap,oldRefEntryMap);
        newRefEntryMap[refEntryId] = referenceEntry;
        this.setField("referenceEntryMap",newRefEntryMap);

        //update the url map for this entry
        let oldUrlMap = this.getField("urlMap");
        let newUrlMap = {};
        Object.assign(newUrlMap,oldUrlMap);
        let newUrlKey = this._getEntryKey(referenceEntry.getEntryType(),referenceEntry.getUrl());
        if(oldRefEntry) {
            let oldUrlKey = this._getEntryKey(referenceEntry.getEntryType(),referenceEntry.getUrl());
            //delete the old entry id the key changed
            if(oldUrlKey != newUrlKey) {
                delete newUrlMap[oldUrlKey];
            }
        }
        newUrlMap[newUrlKey] = refEntryId;
        this.setField("urlMap",newUrlMap);

        //update the change map
        let oldChangeEntry = this.workingChangeMap[refEntryId];  
        let newAction; 
        if(oldChangeEntry) {
            //we will assume the events come in order
            //the only scenarios assuming order are:
            //created then updated => keep action as created
            //updated then updated => no change
            //we will just update the referenceEntry
            newAction = oldChangeEntry.action;
        }
        else {
            //new action will depend on if we have the ref entry in our old ref entry map
            newAction = oldRefEntryMap[refEntryId] ? "referenceEntry_updated" : "referenceEntry_created"; 
        }
        this.workingChangeMap[refEntryId] = {action: newAction, instance: referenceEntry};
    }

    /** This method takes the local actions needed when a referenceEntry is deleted. It is called internally. */
    unregisterRefEntry(referenceEntry) {
        let refEntryId = referenceEntry.getId();

        //update the referenceEntry map
        let oldRefEntryMap = this.getField("referenceEntryMap");
        let newRefEntryMap = {};
        Object.assign(newRefEntryMap,oldRefEntryMap);
        //remove the given referenceEntry
        delete newRefEntryMap[refEntryId];
        //save the updated map
        this.setField("referenceEntryMap",newRefEntryMap);

        //update the url map
        let oldUrlMap = this.getField("urlMap");
        let newUrlMap = {};
        Object.assign(newUrlMap,oldUrlMap);
        for(let urlKey in newUrlMap) {
            let urlRefEntryId = newUrlMap[urlKey];
            if(urlRefEntryId == refEntryId) {
                delete newUrlMap[urlKey];
            }
        }
        this.setField("urlMap",newUrlMap);

        //update the change map
        let oldChangeEntry = this.workingChangeMap[refEntryId];
        let newChangeEntry;
        if(oldChangeEntry) {
            //handle the case of an existing change entry
            if(oldChangeEntry.action == "referenceEntry_created") {
                //referenceEntry created and deleted during this action - flag it as transient
                newChangeEntry = {action: "transient", instance: referenceEntry};
            }
            else if(oldChangeEntry.action == "referenceEntry_updated") {
                newChangeEntry = {action: "referenceEntry_deleted", instance: referenceEntry};
            }
            else {
                //this shouldn't happen. If it does there is no change to the action
                //we will just update the referenceEntry
                newChangeEntry = {action: oldChangeEntry.action, instance: referenceEntry};
            }
        }
        else {
            //add a new change entry
            newChangeEntry = {action: "referenceEntry_deleted", instance: referenceEntry};
        }
        this.workingChangeMap[refEntryId] = newChangeEntry;  
    }


    //====================================
    // open and save methods
    //====================================

    setViewStateCallback(viewStateCallback) {
        this.viewStateCallback = viewStateCallback;
    }

    getCachedViewState() {
        return this.cachedViewState;
    }

    /** This method opens the reference entries. An on references load callback 
     * can be passed and it will be a called when all references are loaded, with the
     * load completion command result for each. The return value for this function is the
     * initial command result for starting the refernce loading.
     */
    load(workspaceManager,json) {

        let entryLoadedPromises = [];
        
        //load the reference entries
        if(json.refEntries) {

            //construct the load function
            let loadRefEntry = refEntryJson => {
                //create the entry (this does not actually load it)
                let referenceEntry = this.createEntry(refEntryJson);

                //load the entry - this will be asynchronous
                let loadEntryPromise = referenceEntry.loadEntry(workspaceManager);
                entryLoadedPromises.push(loadEntryPromise);
            };

            //load each entry
            json.refEntries.forEach(loadRefEntry);
        }

        //set the view state
        if(json.viewState !== undefined) {
            this.cachedViewState = json.viewState;
        }

        //create the return promise
        let referencesLoadedPromise;
        if(entryLoadedPromises.length > 0) {
            referencesLoadedPromise = Promise.all(entryLoadedPromises);
        }
        else {
            referencesLoadedPromise = Promise.resolve();
        }
        return referencesLoadedPromise;
    }

    /** This method opens the reference entries, from the structure returned from
     * the save call. It returns a promise that
     * resolves when all entries are loaded. 
     */
    toJson() {
        let json = {};
        let entryMap = this.getField("referenceEntryMap");
        let entriesJson = [];
        for(let key in entryMap) {
            let refEntry = entryMap[key];
            entriesJson.push(refEntry.toJson());
        }
        if(entriesJson.length > 0) {
            json.refEntries = entriesJson;
        }
    
        //set the view state
        if(this.viewStateCallback) {
            this.cachedViewState = this.viewStateCallback();
            if(this.cachedViewState) json.viewState = this.cachedViewState;
        }

        return json;
    }

    //=================================
    // Private
    //=================================

    _getEntryKey(entryType,url) {
        return entryType + "|"  + url;
    }

    /** This method returns the reference entry type classes which will be used in the app. */
    static getReferenceClassArray() {
        return ReferenceManager.referenceClassArray;
    }

    /** This method sets the reference entry type classes. */
    static setReferenceClassArray(referenceClassArray) {
        ReferenceManager.referenceClassArray = referenceClassArray;
    }
    
}

/** This is the base functionality for a component. */
class Component extends FieldObject {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        super("component",instanceToCopy,keepUpdatedFixed);

        //inheriting objects can pass functions here to be called on cleanup, save, etc
        this.cleanupActions = [];
        
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            modelManager.registerComponent(this);
            this.setField("member",member);
            modelManager.registerMember(member.getId(),this,true);
        }

        //==============
        //Working variables
        //==============
        this.viewStateCallback = null;
        this.cachedViewState = null;
    }

    /** If an extending object has any cleanup actions, a callback should be passed here.
     * The callback will be executed in the context of the current object. */
    addCleanupAction(cleanupFunction) {
        this.cleanupActions.push(cleanupFunction);
    }

    //==============================
    // Public Instance Methods
    //==============================

    /** This method returns the base member for this component. To see if this
     * field has been updated, check the "member" field of the component.  
     * To access other child members for compound components, use the access those fields using
     * the getField method. The field name is the "member." + the variable name of the field. */
    getMember() {
        return this.getField("member");
    }

    /** This method returns true if the data from a given named member field has changed. */
    isMemberDataUpdated(memberFieldName) {
        return this.isMemberFieldUpdated(memberFieldName,"data");
    }

    /** This method returns true if the given member field has been updated. */
    isMemberFieldUpdated(memberFieldName,memberFieldFieldName) {
        if(this.isFieldUpdated(memberFieldName)) {
            let member = this.getField(memberFieldName);
            return member.isFieldUpdated(memberFieldFieldName);
        }
        else {
            return false;
        }
    }

    /** This method returns true if the given member field has been updated. */
    areAnyMemberFieldsUpdated(memberFieldName,memberFieldFieldNameList) {
        if(this.isFieldUpdated(memberFieldName)) {
            let member = this.getField(memberFieldName);
            return member.areAnyFieldsUpdated(memberFieldFieldNameList);
        }
        else {
            return false;
        }
    }
    
    /** This method returns the ID for the field. It is fixed for the duration of the application.
     * it is not persistent between running the application different time. */
    getMemberId() {
        return this.getField("member").getId();
    }

    /** This method returns the name of the component. To see if the value has been updated, check 
     * the component field name "member" and the member field name "name".
     */
    getName() {
        return this.getField("member").getName();
    }

    /** This method returns the name of the member including the full path.
     * To check if the full name has changed, use the isFullNameChanged method of the member. */
    getFullName(modelManager) {
        return this.getField("member").getFullName(modelManager.getModel());
    }

    /** This method returns a display name for the member object. */
    getDisplayName(useFullPath,modelManagerForFullPathOnly) {
        if(useFullPath) {
            return this.getFullName(modelManagerForFullPathOnly);
        }
        else {
            return this.getName();
        }
    }

    /** This method returns true if the display name field is updated. This method exists because
     * display name is potentially a compound field and this is a systematic way to see if it has changed.
     * Components modifying the getDisplayName method should also update this method.
     * Note this method only applies when useFullPath = false. If you are using useFullPath = true, also
     * check if the fullName has changed. */
    isDisplayNameUpdated() {
        return this.isMemberFieldUpdated("member","name");
    }

    getParentComponent(modelManager) {
        let model = modelManager.getModel();
        let parent = this.getField("member").getParentMember(model);
        if(parent) {
            let componentId = modelManager.getComponentIdByMemberId(parent.getId());
            return modelManager.getComponentByComponentId(componentId);
        }
        else {
            return null;
        }
    }

    setViewStateCallback(viewStateCallback) {
        this.viewStateCallback = viewStateCallback;
    }

    getCachedViewState() {
        return this.cachedViewState;
    }

    //------------------
    // serialization
    //------------------

    /** This serializes the component. */
    toJson(modelManager) {
        var json = {};
        json.type = this.constructor.uniqueName;

        //TO DO 

        if(this.displayState) {
            json.displayState = this.displayState;
        }
        
        //allow the specific component implementation to write to the json
        if(this.writeToJson) {
            this.writeToJson(json,modelManager);
        }

        if(this.viewStateCallback) {
            this.cachedViewState = this.viewStateCallback();
            if(this.cachedViewState) json.viewState = this.cachedViewState;
        }
        
        return json;
    }

    /** This is used to deserialize the component. */
    loadStoredData(json) {
        if(!json) json = {};
        
        //take any immediate needed actions
        
        //set the tree state
        if(json.viewState !== undefined) {
            this.cachedViewState = json.viewState;
        }
        
        //allow the component implemnetation ro read from the json
        if(this.readDataFromJson) {
            this.readDataFromJson(json);
        }

        //allow the component implemnetation ro read from the json
        if(this.readPropsFromJson) {
            this.readPropsFromJson(json);
        }
    }

    /** This is used to update properties, such as from the set properties form. */
    loadPropertyValues(json) {     
        if(this.readPropsFromJson) {
            this.readPropsFromJson(json);
        }
    }
    //==============================
    // Protected Instance Methods
    //==============================

    //This method should optionally be populated by an extending object.
    //** This method reads any necessary component implementation-specific stored data
    // * from the json. This should be used for stored data that is NOT updated when properties are updated. OPTIONAL */
    //readDataFromJson(json);

    //This method should optionally be populated by an extending object.
    //** This method reads any necessary component implementation-specific properties data
    // * from the json. This is also use when updating properties. OPTIONAL */
    //readPropsFromJson(json);

    //This method should optionally be populated by an extending object.
    //** This method writes any necessary component implementation-specific data
    // * to the json. OPTIONAL */
    //writeToJson(json,modelManager);

    /** This method cleans up after a delete. Any extending object that has delete
     * actions should pass a callback function to the method "addClenaupAction" */
    onDelete() {
        
        //execute cleanup actions
        for(var i = 0; i < this.cleanupActions.length; i++) {
            this.cleanupActions[i].call(this);
        }
    }

    /** This method extends the member udpated function from the base.
     * @protected */    
    memberUpdated(updatedMember) {
        
        let member = this.getField("member");
        if(updatedMember.getId() == member.getId()) {
            this.setField("member",updatedMember);
        }
        else {
            //there was an update to an internal field
            let internalMemberName = "member." + updatedMember.getName();
            this.setField(internalMemberName,updatedMember);
            
            //for now we will assume the internal members do not have their name update!!!
            //maybe I should add a error check 
        }
    }

    /** This method is used for setting initial values in the property dialog. 
     * If there are additional property lines, in the generator, this method should
     * be extended to give the values of those properties too. */
    getPropertyValues() {
        
        var member = this.getField("member");
        
        var values = {};
        values.name = member.getName();
        values.parentId = member.getParentId();

        if(member.constructor.generator.readProperties) {
            member.constructor.generator.readProperties(member,values);
        }
        if(this.readExtendedProperties) {
            this.readExtendedProperties(values);
        }
        return values;
    }

    //======================================
    // Static methods
    //======================================

    /** This function creates a json to create the member for a new component instance. 
     * It uses default values and then overwrites in with optionalBaseValues (these are intended to be base values outside of user input values)
     * and then optionalOverrideValues (these are intended to be user input values) */
    static createMemberJson(componentClass,optionalInputProperties,optionalBaseValues) {
        var json = apogeeutil$1.jsonCopy(componentClass.DEFAULT_MEMBER_JSON);
        if(optionalBaseValues) {
            for(var key in optionalBaseValues) {
                json[key]= optionalBaseValues[key];
            }
        }
        if(optionalInputProperties) {
            //add the base component values
            if(optionalInputProperties.name !== undefined) json.name = optionalInputProperties.name;
            
            //add the specific member properties for this component type
            if(componentClass.transferMemberProperties) {
                componentClass.transferMemberProperties(optionalInputProperties,json);
            }
        }
        
        return json;
    }

    /** This function merges values from two objects containing component property values. */
    static createComponentJson(componentClass,optionalInputProperties,optionalBaseValues) {
        //copy the base properties
        var newPropertyValues = optionalBaseValues ? apogeeutil$1.jsonCopy(optionalBaseValues) : {};
        
        //set the type
        newPropertyValues.type = componentClass.uniqueName;
        
        //add in the input property Value
        if((optionalInputProperties)&&(componentClass.transferComponentProperties)) {
            componentClass.transferComponentProperties(optionalInputProperties,newPropertyValues);
        }
        
        return newPropertyValues;
    }
}

//======================================
// All components should have a generator to create the component
// from a json. See existing components for examples.
//======================================

/** This component represents a json table object. */
class JsonTableComponent extends Component {
    
        
    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend edit component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //default view
            this.setField("dataView",JsonTableComponent.DEFAULT_DATA_VIEW);
        }
    };

    getDataView() {
        let dataView = this.getField("dataView");
        if(!dataView) dataView = JsonTableComponent.DEFAULT_DATA_VIEW;
        return dataView;
    }

    setDataView(dataView) {
        let oldDataView = this.getField("dataView");
        if(oldDataView != dataView) {
            this.setField("dataView",dataView);
        }
    }

    //==============================
    // serialization
    //==============================

    writeToJson(json,modelManager) {
        json.dataView = this.getDataView();
    }

    readPropsFromJson(json) {
        if(json.dataView !== undefined) {
            this.setDataView(json.dataView);
        }
    }

    //======================================
    // properties
    //======================================

    /** This returns the current values for the member and component properties in the  
     * proeprties dialog. */
    readExtendedProperties(values) {
        values.dataView = this.getDataView();
    }

    //======================================
    // Static methods
    //======================================

    /** This optional static function reads property input from the property 
     * dialog and copies it into a member property json. It is not needed for
     * this componnet. */
    //transferMemberProperties(inputValues,propertyJson) {
    //}

    /** This optional static function reads property input from the property 
     * dialog and copies it into a component property json. */
    static transferComponentProperties(inputValues,propertyJson) {
        if(inputValues.dataView !== undefined) {
            propertyJson.dataView = inputValues.dataView;
        }
    }
}

//======================================
// This is the component generator, to register the component
//======================================


/** This is the display name for the type of component */
JsonTableComponent.displayName = "Data Cell";
/** This is the univeral uniaue name for the component, used to deserialize the component. */
JsonTableComponent.uniqueName = "apogeeapp.JsonCell";

JsonTableComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.JsonMember"
};

/** This component represents a table object. */
class FunctionComponent extends Component {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend edit component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
    };

    /** This overrides the get title method of member to return the function declaration. */
    getDisplayName(useFullPath,modelManagerForFullPathOnly) {
        var name = useFullPath ? this.getFullName(modelManagerForFullPathOnly) : this.getName();
        let member = this.getMember();
        var argList = member.getArgList();
        var argListString = argList.join(",");
        return name + "(" + argListString + ")";
    }

    /** This method returns true if the display name field is updated. This method exists because
     * display name is potentially a compound field and this is a systematic way to see if it has changed.
     * Components modifying the getDisplayName method should also update this method.
     * Note this method only applies when useFullPath = false. We currently don't implement a method to see
     * if the full name was updated. */
    isDisplayNameUpdated() {
        return this.getMember().areAnyFieldsUpdated(["name","argList"]);
    }

    static transferMemberProperties(inputValues,propertyJson) {
        if(inputValues.argListString != undefined) { 
            if(!propertyJson.updateData) propertyJson.updateData = {};
            propertyJson.updateData.argList = apogeeutil$1.parseStringArray(inputValues.argListString);
        }
    }
   
}

//======================================
// This is the component generator, to register the component
//======================================

FunctionComponent.displayName = "Function Cell";
FunctionComponent.uniqueName = "apogeeapp.FunctionCell";

FunctionComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.FunctionMember"
};

// Mappable:: interface
// There are several things that positions can be mapped through.
// Such objects conform to this interface.
//
//   map:: (pos: number, assoc: ?number)  number
//   Map a position through this object. When given, `assoc` (should
//   be -1 or 1, defaults to 1) determines with which side the
//   position is associated, which determines in which direction to
//   move when a chunk of content is inserted at the mapped position.
//
//   mapResult:: (pos: number, assoc: ?number)  MapResult
//   Map a position, and return an object containing additional
//   information about the mapping. The result's `deleted` field tells
//   you whether the position was deleted (completely enclosed in a
//   replaced range) during the mapping. When content on only one side
//   is deleted, the position itself is only considered deleted when
//   `assoc` points in the direction of the deleted content.

// Recovery values encode a range index and an offset. They are
// represented as numbers, because tons of them will be created when
// mapping, for example, a large number of decorations. The number's
// lower 16 bits provide the index, the remaining bits the offset.
//
// Note: We intentionally don't use bit shift operators to en- and
// decode these, since those clip to 32 bits, which we might in rare
// cases want to overflow. A 64-bit float can represent 48-bit
// integers precisely.

const lower16 = 0xffff;
const factor16 = Math.pow(2, 16);

function makeRecover(index, offset) { return index + offset * factor16 }
function recoverIndex(value) { return value & lower16 }
function recoverOffset(value) { return (value - (value & lower16)) / factor16 }

// ::- An object representing a mapped position with extra
// information.
class MapResult {
  constructor(pos, deleted = false, recover = null) {
    // :: number The mapped version of the position.
    this.pos = pos;
    // :: bool Tells you whether the position was deleted, that is,
    // whether the step removed its surroundings from the document.
    this.deleted = deleted;
    this.recover = recover;
  }
}

// :: class extends Mappable
// A map describing the deletions and insertions made by a step, which
// can be used to find the correspondence between positions in the
// pre-step version of a document and the same position in the
// post-step version.
class StepMap {
  // :: ([number])
  // Create a position map. The modifications to the document are
  // represented as an array of numbers, in which each group of three
  // represents a modified chunk as `[start, oldSize, newSize]`.
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
  }

  recover(value) {
    let diff = 0, index = recoverIndex(value);
    if (!this.inverted) for (let i = 0; i < index; i++)
      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index * 3] + diff + recoverOffset(value)
  }

  // : (number, ?number)  MapResult
  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }

  // : (number, ?number)  number
  map(pos, assoc = 1) { return this._map(pos, assoc, true) }

  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos) break
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
      if (pos <= end) {
        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
        let result = start + diff + (side < 0 ? 0 : newSize);
        if (simple) return result
        let recover = makeRecover(i / 3, pos - start);
        return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff)
  }

  touches(pos, recover) {
    let diff = 0, index = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos) break
      let oldSize = this.ranges[i + oldIndex], end = start + oldSize;
      if (pos <= end && i == index * 3) return true
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false
  }

  // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))
  // Calls the given function on each of the changed ranges included in
  // this map.
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }

  // :: ()  StepMap
  // Create an inverted version of this map. The result can be used to
  // map positions in the post-step document to the pre-step document.
  invert() {
    return new StepMap(this.ranges, !this.inverted)
  }

  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges)
  }

  // :: (n: number)  StepMap
  // Create a map that moves all positions by offset `n` (which may be
  // negative). This can be useful when applying steps meant for a
  // sub-document to a larger document, or vice-versa.
  static offset(n) {
    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])
  }
}

StepMap.empty = new StepMap([]);

// :: class extends Mappable
// A mapping represents a pipeline of zero or more [step
// maps](#transform.StepMap). It has special provisions for losslessly
// handling mapping positions through a series of steps in which some
// steps are inverted versions of earlier steps. (This comes up when
// [rebasing](/docs/guide/#transform.rebasing) steps for
// collaboration or history management.)
class Mapping {
  // :: (?[StepMap])
  // Create a new mapping with the given position maps.
  constructor(maps, mirror, from, to) {
    // :: [StepMap]
    // The step maps in this mapping.
    this.maps = maps || [];
    // :: number
    // The starting position in the `maps` array, used when `map` or
    // `mapResult` is called.
    this.from = from || 0;
    // :: number
    // The end position in the `maps` array.
    this.to = to == null ? this.maps.length : to;
    this.mirror = mirror;
  }

  // :: (?number, ?number)  Mapping
  // Create a mapping that maps only through a part of this one.
  slice(from = 0, to = this.maps.length) {
    return new Mapping(this.maps, this.mirror, from, to)
  }

  copy() {
    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)
  }

  // :: (StepMap, ?number)
  // Add a step map to the end of this mapping. If `mirrors` is
  // given, it should be the index of the step map that is the mirror
  // image of this one.
  appendMap(map, mirrors) {
    this.to = this.maps.push(map);
    if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors);
  }

  // :: (Mapping)
  // Add all the step maps in a given mapping to this one (preserving
  // mirroring information).
  appendMapping(mapping) {
    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
    }
  }

  // :: (number)  ?number
  // Finds the offset of the step map that mirrors the map at the
  // given offset, in this mapping (as per the second argument to
  // `appendMap`).
  getMirror(n) {
    if (this.mirror) for (let i = 0; i < this.mirror.length; i++)
      if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)]
  }

  setMirror(n, m) {
    if (!this.mirror) this.mirror = [];
    this.mirror.push(n, m);
  }

  // :: (Mapping)
  // Append the inverse of the given mapping to this one.
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
    }
  }

  // :: ()  Mapping
  // Create an inverted version of this mapping.
  invert() {
    let inverse = new Mapping;
    inverse.appendMappingInverted(this);
    return inverse
  }

  // : (number, ?number)  number
  // Map a position through this mapping.
  map(pos, assoc = 1) {
    if (this.mirror) return this._map(pos, assoc, true)
    for (let i = this.from; i < this.to; i++)
      pos = this.maps[i].map(pos, assoc);
    return pos
  }

  // : (number, ?number)  MapResult
  // Map a position through this mapping, returning a mapping
  // result.
  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }

  _map(pos, assoc, simple) {
    let deleted = false, recoverables = null;

    for (let i = this.from; i < this.to; i++) {
      let map = this.maps[i], rec = recoverables && recoverables[i];
      if (rec != null && map.touches(pos, rec)) {
        pos = map.recover(rec);
        continue
      }

      let result = map.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          if (result.deleted) {
            i = corr;
            pos = this.maps[corr].recover(result.recover);
            continue
          } else {
(recoverables || (recoverables = Object.create(null)))[corr] = result.recover;
          }
        }
      }

      if (result.deleted) deleted = true;
      pos = result.pos;
    }

    return simple ? pos : new MapResult(pos, deleted)
  }
}

function TransformError(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError.prototype;
  return err
}

TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";

// ::- Abstraction to build up and track an array of
// [steps](#transform.Step) representing a document transformation.
//
// Most transforming methods return the `Transform` object itself, so
// that they can be chained.
class Transform {
  // :: (Node)
  // Create a transform that starts with the given document.
  constructor(doc) {
    // :: Node
    // The current document (the result of applying the steps in the
    // transform).
    this.doc = doc;
    // :: [Step]
    // The steps in this transform.
    this.steps = [];
    // :: [Node]
    // The documents before each of the steps.
    this.docs = [];
    // :: Mapping
    // A mapping with the maps for each of the steps in this transform.
    this.mapping = new Mapping;
  }

  // :: Node The starting document.
  get before() { return this.docs.length ? this.docs[0] : this.doc }

  // :: (step: Step)  this
  // Apply a new step in this transform, saving the result. Throws an
  // error when the step fails.
  step(object) {
    let result = this.maybeStep(object);
    if (result.failed) throw new TransformError(result.failed)
    return this
  }

  // :: (Step)  StepResult
  // Try to apply a step in this transformation, ignoring it if it
  // fails. Returns the step result.
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed) this.addStep(step, result.doc);
    return result
  }

  // :: bool
  // True when the document has been changed (when there are any
  // steps).
  get docChanged() {
    return this.steps.length > 0
  }

  addStep(step, doc) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc;
  }
}

function findDiffStart(a, b, pos) {
  for (let i = 0;; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos

    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) { pos += childA.nodeSize; continue }

    if (!childA.sameMarkup(childB)) return pos

    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null) return inner
    }
    pos += childA.nodeSize;
  }
}

function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount;;) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : {a: posA, b: posB}

    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size; posB -= size;
      continue
    }

    if (!childA.sameMarkup(childB)) return {a: posA, b: posB}

    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++; posA--; posB--;
      }
      return {a: posA, b: posB}
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) return inner
    }
    posA -= size; posB -= size;
  }
}

// ::- A fragment represents a node's collection of child nodes.
//
// Like nodes, fragments are persistent data structures, and you
// should not mutate them or their content. Rather, you create new
// instances whenever needed. The API tries to make this easy.
class Fragment {
  constructor(content, size) {
    this.content = content;
    // :: number
    // The size of the fragment, which is the total of the size of its
    // content nodes.
    this.size = size || 0;
    if (size == null) for (let i = 0; i < content.length; i++)
      this.size += content[i].nodeSize;
  }

  // :: (number, number, (node: Node, start: number, parent: Node, index: number)  ?bool, ?number)
  // Invoke a callback for all descendant nodes between the given two
  // positions (relative to start of this fragment). Doesn't descend
  // into a node when the callback returns `false`.
  nodesBetween(from, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end = pos + child.nodeSize;
      if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {
        let start = pos + 1;
        child.nodesBetween(Math.max(0, from - start),
                           Math.min(child.content.size, to - start),
                           f, nodeStart + start);
      }
      pos = end;
    }
  }

  // :: ((node: Node, pos: number, parent: Node)  ?bool)
  // Call the given callback for every descendant node. The callback
  // may return `false` to prevent traversal of a given node's children.
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }

  // : (number, number, ?string, ?string)  string
  textBetween(from, to, blockSeparator, leafText) {
    let text = "", separated = true;
    this.nodesBetween(from, to, (node, pos) => {
      if (node.isText) {
        text += node.text.slice(Math.max(from, pos) - pos, to - pos);
        separated = !blockSeparator;
      } else if (node.isLeaf && leafText) {
        text += leafText;
        separated = !blockSeparator;
      } else if (!separated && node.isBlock) {
        text += blockSeparator;
        separated = true;
      }
    }, 0);
    return text
  }

  // :: (Fragment)  Fragment
  // Create a new fragment containing the combined content of this
  // fragment and the other.
  append(other) {
    if (!other.size) return this
    if (!this.size) return other
    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first)) {
      content[content.length - 1] = last.withText(last.text + first.text);
      i = 1;
    }
    for (; i < other.content.length; i++) content.push(other.content[i]);
    return new Fragment(content, this.size + other.size)
  }

  // :: (number, ?number)  Fragment
  // Cut out the sub-fragment between the two given positions.
  cut(from, to) {
    if (to == null) to = this.size;
    if (from == 0 && to == this.size) return this
    let result = [], size = 0;
    if (to > from) for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end = pos + child.nodeSize;
      if (end > from) {
        if (pos < from || end > to) {
          if (child.isText)
            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));
          else
            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
        }
        result.push(child);
        size += child.nodeSize;
      }
      pos = end;
    }
    return new Fragment(result, size)
  }

  cutByIndex(from, to) {
    if (from == to) return Fragment.empty
    if (from == 0 && to == this.content.length) return this
    return new Fragment(this.content.slice(from, to))
  }

  // :: (number, Node)  Fragment
  // Create a new fragment in which the node at the given index is
  // replaced by the given node.
  replaceChild(index, node) {
    let current = this.content[index];
    if (current == node) return this
    let copy = this.content.slice();
    let size = this.size + node.nodeSize - current.nodeSize;
    copy[index] = node;
    return new Fragment(copy, size)
  }

  // : (Node)  Fragment
  // Create a new fragment by prepending the given node to this
  // fragment.
  addToStart(node) {
    return new Fragment([node].concat(this.content), this.size + node.nodeSize)
  }

  // : (Node)  Fragment
  // Create a new fragment by appending the given node to this
  // fragment.
  addToEnd(node) {
    return new Fragment(this.content.concat(node), this.size + node.nodeSize)
  }

  // :: (Fragment)  bool
  // Compare this fragment to another one.
  eq(other) {
    if (this.content.length != other.content.length) return false
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i])) return false
    return true
  }

  // :: ?Node
  // The first child of the fragment, or `null` if it is empty.
  get firstChild() { return this.content.length ? this.content[0] : null }

  // :: ?Node
  // The last child of the fragment, or `null` if it is empty.
  get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null }

  // :: number
  // The number of child nodes in this fragment.
  get childCount() { return this.content.length }

  // :: (number)  Node
  // Get the child node at the given index. Raise an error when the
  // index is out of range.
  child(index) {
    let found = this.content[index];
    if (!found) throw new RangeError("Index " + index + " out of range for " + this)
    return found
  }

  // :: (number)  ?Node
  // Get the child node at the given index, if it exists.
  maybeChild(index) {
    return this.content[index]
  }

  // :: ((node: Node, offset: number, index: number))
  // Call `f` for every child node, passing the node, its offset
  // into this parent node, and its index.
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }

  // :: (Fragment)  ?number
  // Find the first position at which this fragment and another
  // fragment differ, or `null` if they are the same.
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos)
  }

  // :: (Fragment)  ?{a: number, b: number}
  // Find the first position, searching from the end, at which this
  // fragment and the given fragment differ, or `null` if they are the
  // same. Since this position will not be the same in both nodes, an
  // object with two separate positions is returned.
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos)
  }

  // : (number, ?number)  {index: number, offset: number}
  // Find the index and inner offset corresponding to a given relative
  // position in this fragment. The result object will be reused
  // (overwritten) the next time the function is called. (Not public.)
  findIndex(pos, round = -1) {
    if (pos == 0) return retIndex(0, pos)
    if (pos == this.size) return retIndex(this.content.length, pos)
    if (pos > this.size || pos < 0) throw new RangeError(`Position ${pos} outside of fragment (${this})`)
    for (let i = 0, curPos = 0;; i++) {
      let cur = this.child(i), end = curPos + cur.nodeSize;
      if (end >= pos) {
        if (end == pos || round > 0) return retIndex(i + 1, end)
        return retIndex(i, curPos)
      }
      curPos = end;
    }
  }

  // :: ()  string
  // Return a debugging string that describes this fragment.
  toString() { return "<" + this.toStringInner() + ">" }

  toStringInner() { return this.content.join(", ") }

  // :: ()  ?Object
  // Create a JSON-serializeable representation of this fragment.
  toJSON() {
    return this.content.length ? this.content.map(n => n.toJSON()) : null
  }

  // :: (Schema, ?Object)  Fragment
  // Deserialize a fragment from its JSON representation.
  static fromJSON(schema, value) {
    if (!value) return Fragment.empty
    if (!Array.isArray(value)) throw new RangeError("Invalid input for Fragment.fromJSON")
    return new Fragment(value.map(schema.nodeFromJSON))
  }

  // :: ([Node])  Fragment
  // Build a fragment from an array of nodes. Ensures that adjacent
  // text nodes with the same marks are joined together.
  static fromArray(array) {
    if (!array.length) return Fragment.empty
    let joined, size = 0;
    for (let i = 0; i < array.length; i++) {
      let node = array[i];
      size += node.nodeSize;
      if (i && node.isText && array[i - 1].sameMarkup(node)) {
        if (!joined) joined = array.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new Fragment(joined || array, size)
  }

  // :: (?union<Fragment, Node, [Node]>)  Fragment
  // Create a fragment from something that can be interpreted as a set
  // of nodes. For `null`, it returns the empty fragment. For a
  // fragment, the fragment itself. For a node or array of nodes, a
  // fragment containing those nodes.
  static from(nodes) {
    if (!nodes) return Fragment.empty
    if (nodes instanceof Fragment) return nodes
    if (Array.isArray(nodes)) return this.fromArray(nodes)
    if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize)
    throw new RangeError("Can not convert " + nodes + " to a Fragment" +
                         (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""))
  }
}

const found = {index: 0, offset: 0};
function retIndex(index, offset) {
  found.index = index;
  found.offset = offset;
  return found
}

// :: Fragment
// An empty fragment. Intended to be reused whenever a node doesn't
// contain anything (rather than allocating a new empty fragment for
// each leaf node).
Fragment.empty = new Fragment([], 0);

function compareDeep(a, b) {
  if (a === b) return true
  if (!(a && typeof a == "object") ||
      !(b && typeof b == "object")) return false
  let array = Array.isArray(a);
  if (Array.isArray(b) != array) return false
  if (array) {
    if (a.length != b.length) return false
    for (let i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false
  } else {
    for (let p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false
    for (let p in b) if (!(p in a)) return false
  }
  return true
}

// ::- A mark is a piece of information that can be attached to a node,
// such as it being emphasized, in code font, or a link. It has a type
// and optionally a set of attributes that provide further information
// (such as the target of the link). Marks are created through a
// `Schema`, which controls which types exist and which
// attributes they have.
class Mark {
  constructor(type, attrs) {
    // :: MarkType
    // The type of this mark.
    this.type = type;
    // :: Object
    // The attributes associated with this mark.
    this.attrs = attrs;
  }

  // :: ([Mark])  [Mark]
  // Given a set of marks, create a new set which contains this one as
  // well, in the right position. If this mark is already in the set,
  // the set itself is returned. If any marks that are set to be
  // [exclusive](#model.MarkSpec.excludes) with this mark are present,
  // those are replaced by this one.
  addToSet(set) {
    let copy, placed = false;
    for (let i = 0; i < set.length; i++) {
      let other = set[i];
      if (this.eq(other)) return set
      if (this.type.excludes(other.type)) {
        if (!copy) copy = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy) copy = set.slice(0, i);
          copy.push(this);
          placed = true;
        }
        if (copy) copy.push(other);
      }
    }
    if (!copy) copy = set.slice();
    if (!placed) copy.push(this);
    return copy
  }

  // :: ([Mark])  [Mark]
  // Remove this mark from the given set, returning a new set. If this
  // mark is not in the set, the set itself is returned.
  removeFromSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1))
    return set
  }

  // :: ([Mark])  bool
  // Test whether this mark is in the given set of marks.
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i])) return true
    return false
  }

  // :: (Mark)  bool
  // Test whether this mark has the same type and attributes as
  // another mark.
  eq(other) {
    return this == other ||
      (this.type == other.type && compareDeep(this.attrs, other.attrs))
  }

  // :: ()  Object
  // Convert this mark to a JSON-serializeable representation.
  toJSON() {
    let obj = {type: this.type.name};
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break
    }
    return obj
  }

  // :: (Schema, Object)  Mark
  static fromJSON(schema, json) {
    if (!json) throw new RangeError("Invalid input for Mark.fromJSON")
    let type = schema.marks[json.type];
    if (!type) throw new RangeError(`There is no mark type ${json.type} in this schema`)
    return type.create(json.attrs)
  }

  // :: ([Mark], [Mark])  bool
  // Test whether two sets of marks are identical.
  static sameSet(a, b) {
    if (a == b) return true
    if (a.length != b.length) return false
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b[i])) return false
    return true
  }

  // :: (?union<Mark, [Mark]>)  [Mark]
  // Create a properly sorted mark set from null, a single mark, or an
  // unsorted array of marks.
  static setFrom(marks) {
    if (!marks || marks.length == 0) return Mark.none
    if (marks instanceof Mark) return [marks]
    let copy = marks.slice();
    copy.sort((a, b) => a.type.rank - b.type.rank);
    return copy
  }
}

// :: [Mark] The empty set of marks.
Mark.none = [];

// ReplaceError:: class extends Error
// Error type raised by [`Node.replace`](#model.Node.replace) when
// given an invalid replacement.

function ReplaceError(message) {
  let err = Error.call(this, message);
  err.__proto__ = ReplaceError.prototype;
  return err
}

ReplaceError.prototype = Object.create(Error.prototype);
ReplaceError.prototype.constructor = ReplaceError;
ReplaceError.prototype.name = "ReplaceError";

// ::- A slice represents a piece cut out of a larger document. It
// stores not only a fragment, but also the depth up to which nodes on
// both side are open (cut through).
class Slice {
  // :: (Fragment, number, number)
  // Create a slice. When specifying a non-zero open depth, you must
  // make sure that there are nodes of at least that depth at the
  // appropriate side of the fragmenti.e. if the fragment is an empty
  // paragraph node, `openStart` and `openEnd` can't be greater than 1.
  //
  // It is not necessary for the content of open nodes to conform to
  // the schema's content constraints, though it should be a valid
  // start/end/middle for such a node, depending on which sides are
  // open.
  constructor(content, openStart, openEnd) {
    // :: Fragment The slice's content.
    this.content = content;
    // :: number The open depth at the start.
    this.openStart = openStart;
    // :: number The open depth at the end.
    this.openEnd = openEnd;
  }

  // :: number
  // The size this slice would add when inserted into a document.
  get size() {
    return this.content.size - this.openStart - this.openEnd
  }

  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment, null);
    return content && new Slice(content, this.openStart, this.openEnd)
  }

  removeBetween(from, to) {
    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)
  }

  // :: (Slice)  bool
  // Tests whether this slice is equal to another slice.
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd
  }

  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")"
  }

  // :: ()  ?Object
  // Convert a slice to a JSON-serializable representation.
  toJSON() {
    if (!this.content.size) return null
    let json = {content: this.content.toJSON()};
    if (this.openStart > 0) json.openStart = this.openStart;
    if (this.openEnd > 0) json.openEnd = this.openEnd;
    return json
  }

  // :: (Schema, ?Object)  Slice
  // Deserialize a slice from its JSON representation.
  static fromJSON(schema, json) {
    if (!json) return Slice.empty
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON")
    return new Slice(Fragment.fromJSON(schema, json.content), json.openStart || 0, json.openEnd || 0)
  }

  // :: (Fragment, ?bool)  Slice
  // Create a slice from a fragment by taking the maximum possible
  // open value on both side of the fragment.
  static maxOpen(fragment, openIsolating=true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild) openEnd++;
    return new Slice(fragment, openStart, openEnd)
  }
}

function removeRange(content, from, to) {
  let {index, offset} = content.findIndex(from), child = content.maybeChild(index);
  let {index: indexTo, offset: offsetTo} = content.findIndex(to);
  if (offset == from || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError("Removing non-flat range")
    return content.cut(0, from).append(content.cut(to))
  }
  if (index != indexTo) throw new RangeError("Removing non-flat range")
  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))
}

function insertInto(content, dist, insert, parent) {
  let {index, offset} = content.findIndex(dist), child = content.maybeChild(index);
  if (offset == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert)) return null
    return content.cut(0, dist).append(insert).append(content.cut(dist))
  }
  let inner = insertInto(child.content, dist - offset - 1, insert);
  return inner && content.replaceChild(index, child.copy(inner))
}

// :: Slice
// The empty slice.
Slice.empty = new Slice(Fragment.empty, 0, 0);

function replace($from, $to, slice) {
  if (slice.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position")
  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
    throw new ReplaceError("Inconsistent open depths")
  return replaceOuter($from, $to, slice, 0)
}

function replaceOuter($from, $to, slice, depth) {
  let index = $from.index(depth), node = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
    let inner = replaceOuter($from, $to, slice, depth + 1);
    return node.copy(node.content.replaceChild(index, inner))
  } else if (!slice.content.size) {
    return close(node, replaceTwoWay($from, $to, depth))
  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))
  } else {
    let {start, end} = prepareSliceForReplace(slice, $from);
    return close(node, replaceThreeWay($from, start, end, $to, depth))
  }
}

function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name)
}

function joinable($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node
}

function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}

function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++) addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}

function close(node, content) {
  if (!node.type.validContent(content))
    throw new ReplaceError("Invalid content for node " + node.type.name)
  return node.copy(content)
}

function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);

  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content)
}

function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content)
}

function prepareSliceForReplace(slice, $along) {
  let extra = $along.depth - slice.openStart, parent = $along.node(extra);
  let node = parent.copy(slice.content);
  for (let i = extra - 1; i >= 0; i--)
    node = $along.node(i).copy(Fragment.from(node));
  return {start: node.resolveNoCache(slice.openStart + extra),
          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}
}

// ::- You can [_resolve_](#model.Node.resolve) a position to get more
// information about it. Objects of this class represent such a
// resolved position, providing various pieces of context information,
// and some helper methods.
//
// Throughout this interface, methods that take an optional `depth`
// parameter will interpret undefined as `this.depth` and negative
// numbers as `this.depth + value`.
class ResolvedPos {
  constructor(pos, path, parentOffset) {
    // :: number The position that was resolved.
    this.pos = pos;
    this.path = path;
    // :: number
    // The number of levels the parent node is from the root. If this
    // position points directly into the root node, it is 0. If it
    // points into a top-level paragraph, 1, and so on.
    this.depth = path.length / 3 - 1;
    // :: number The offset this position has into its parent node.
    this.parentOffset = parentOffset;
  }

  resolveDepth(val) {
    if (val == null) return this.depth
    if (val < 0) return this.depth + val
    return val
  }

  // :: Node
  // The parent node that the position points into. Note that even if
  // a position points into a text node, that node is not considered
  // the parenttext nodes are flat in this model, and have no content.
  get parent() { return this.node(this.depth) }

  // :: Node
  // The root node in which the position was resolved.
  get doc() { return this.node(0) }

  // :: (?number)  Node
  // The ancestor node at the given level. `p.node(p.depth)` is the
  // same as `p.parent`.
  node(depth) { return this.path[this.resolveDepth(depth) * 3] }

  // :: (?number)  number
  // The index into the ancestor at the given level. If this points at
  // the 3rd node in the 2nd paragraph on the top level, for example,
  // `p.index(0)` is 2 and `p.index(1)` is 3.
  index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1] }

  // :: (?number)  number
  // The index pointing after this position into the ancestor at the
  // given level.
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)
  }

  // :: (?number)  number
  // The (absolute) position at the start of the node at the given
  // level.
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1
  }

  // :: (?number)  number
  // The (absolute) position at the end of the node at the given
  // level.
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size
  }

  // :: (?number)  number
  // The (absolute) position directly before the wrapping node at the
  // given level, or, when `level` is `this.depth + 1`, the original
  // position.
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth) throw new RangeError("There is no position before the top-level node")
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]
  }

  // :: (?number)  number
  // The (absolute) position directly after the wrapping node at the
  // given level, or the original position when `level` is `this.depth + 1`.
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth) throw new RangeError("There is no position after the top-level node")
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize
  }

  // :: number
  // When this position points into a text node, this returns the
  // distance between the position and the start of the text node.
  // Will be zero for positions that point between nodes.
  get textOffset() { return this.pos - this.path[this.path.length - 1] }

  // :: ?Node
  // Get the node directly after the position, if any. If the position
  // points into a text node, only the part of that node after the
  // position is returned.
  get nodeAfter() {
    let parent = this.parent, index = this.index(this.depth);
    if (index == parent.childCount) return null
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
    return dOff ? parent.child(index).cut(dOff) : child
  }

  // :: ?Node
  // Get the node directly before the position, if any. If the
  // position points into a text node, only the part of that node
  // before the position is returned.
  get nodeBefore() {
    let index = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff) return this.parent.child(index).cut(0, dOff)
    return index == 0 ? null : this.parent.child(index - 1)
  }

  // :: ()  [Mark]
  // Get the marks at this position, factoring in the surrounding
  // marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the
  // position is at the start of a non-empty node, the marks of the
  // node after it (if any) are returned.
  marks() {
    let parent = this.parent, index = this.index();

    // In an empty parent, return the empty array
    if (parent.content.size == 0) return Mark.none

    // When inside a text node, just return the text node's marks
    if (this.textOffset) return parent.child(index).marks

    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
    // If the `after` flag is true of there is no node before, make
    // the node after this position the main reference.
    if (!main) { let tmp = main; main = other; other = tmp; }

    // Use all marks in the main node, except those that have
    // `inclusive` set to false and are not present in the other node.
    let marks = main.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);

    return marks
  }

  // :: (ResolvedPos)  ?[Mark]
  // Get the marks after the current position, if any, except those
  // that are non-inclusive and not present at position `$end`. This
  // is mostly useful for getting the set of marks to preserve after a
  // deletion. Will return `null` if this position is at the end of
  // its parent node or its parent node isn't a textblock (in which
  // case no marks should be preserved).
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline) return null

    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks
  }

  // :: (number)  number
  // The depth up to which this position and the given (non-resolved)
  // position share the same parent nodes.
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos) return depth
    return 0
  }

  // :: (?ResolvedPos, ?(Node)  bool)  ?NodeRange
  // Returns a range based on the place where this position and the
  // given position diverge around block content. If both point into
  // the same textblock, for example, a range around that textblock
  // will be returned. If they point into different blocks, the range
  // around those blocks in their shared ancestor is returned. You can
  // pass in an optional predicate that will be called with a parent
  // node to see if a range into that parent is acceptable.
  blockRange(other = this, pred) {
    if (other.pos < this.pos) return other.blockRange(this)
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d)
  }

  // :: (ResolvedPos)  bool
  // Query whether the given position shares the same parent node.
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset
  }

  // :: (ResolvedPos)  ResolvedPos
  // Return the greater of this and the given position.
  max(other) {
    return other.pos > this.pos ? other : this
  }

  // :: (ResolvedPos)  ResolvedPos
  // Return the smaller of this and the given position.
  min(other) {
    return other.pos < this.pos ? other : this
  }

  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset
  }

  static resolve(doc, pos) {
    if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError("Position " + pos + " out of range")
    let path = [];
    let start = 0, parentOffset = pos;
    for (let node = doc;;) {
      let {index, offset} = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset;
      path.push(node, index, start + offset);
      if (!rem) break
      node = node.child(index);
      if (node.isText) break
      parentOffset = rem - 1;
      start += offset + 1;
    }
    return new ResolvedPos(pos, path, parentOffset)
  }

  static resolveCached(doc, pos) {
    for (let i = 0; i < resolveCache.length; i++) {
      let cached = resolveCache[i];
      if (cached.pos == pos && cached.doc == doc) return cached
    }
    let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);
    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
    return result
  }
}

let resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;

// ::- Represents a flat range of content, i.e. one that starts and
// ends in the same node.
class NodeRange {
  // :: (ResolvedPos, ResolvedPos, number)
  // Construct a node range. `$from` and `$to` should point into the
  // same node until at least the given `depth`, since a node range
  // denotes an adjacent set of nodes in a single parent node.
  constructor($from, $to, depth) {
    // :: ResolvedPos A resolved position along the start of the
    // content. May have a `depth` greater than this object's `depth`
    // property, since these are the positions that were used to
    // compute the range, not re-resolved positions directly at its
    // boundaries.
    this.$from = $from;
    // :: ResolvedPos A position along the end of the content. See
    // caveat for [`$from`](#model.NodeRange.$from).
    this.$to = $to;
    // :: number The depth of the node that this range points into.
    this.depth = depth;
  }

  // :: number The position at the start of the range.
  get start() { return this.$from.before(this.depth + 1) }
  // :: number The position at the end of the range.
  get end() { return this.$to.after(this.depth + 1) }

  // :: Node The parent node that the range points into.
  get parent() { return this.$from.node(this.depth) }
  // :: number The start index of the range in the parent node.
  get startIndex() { return this.$from.index(this.depth) }
  // :: number The end index of the range in the parent node.
  get endIndex() { return this.$to.indexAfter(this.depth) }
}

const emptyAttrs = Object.create(null);

// ::- This class represents a node in the tree that makes up a
// ProseMirror document. So a document is an instance of `Node`, with
// children that are also instances of `Node`.
//
// Nodes are persistent data structures. Instead of changing them, you
// create new ones with the content you want. Old ones keep pointing
// at the old document shape. This is made cheaper by sharing
// structure between the old and new data as much as possible, which a
// tree shape like this (without back pointers) makes easy.
//
// **Do not** directly mutate the properties of a `Node` object. See
// [the guide](/docs/guide/#doc) for more information.
class Node$1 {
  constructor(type, attrs, content, marks) {
    // :: NodeType
    // The type of node that this is.
    this.type = type;

    // :: Object
    // An object mapping attribute names to values. The kind of
    // attributes allowed and required are
    // [determined](#model.NodeSpec.attrs) by the node type.
    this.attrs = attrs;

    // :: Fragment
    // A container holding the node's children.
    this.content = content || Fragment.empty;

    // :: [Mark]
    // The marks (things like whether it is emphasized or part of a
    // link) applied to this node.
    this.marks = marks || Mark.none;
  }

  // text:: ?string
  // For text nodes, this contains the node's text content.

  // :: number
  // The size of this node, as defined by the integer-based [indexing
  // scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  // amount of characters. For other leaf nodes, it is one. For
  // non-leaf nodes, it is the size of the content plus two (the start
  // and end token).
  get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size }

  // :: number
  // The number of children that the node has.
  get childCount() { return this.content.childCount }

  // :: (number)  Node
  // Get the child node at the given index. Raises an error when the
  // index is out of range.
  child(index) { return this.content.child(index) }

  // :: (number)  ?Node
  // Get the child node at the given index, if it exists.
  maybeChild(index) { return this.content.maybeChild(index) }

  // :: ((node: Node, offset: number, index: number))
  // Call `f` for every child node, passing the node, its offset
  // into this parent node, and its index.
  forEach(f) { this.content.forEach(f); }

  // :: (number, number, (node: Node, pos: number, parent: Node, index: number)  ?bool, ?number)
  // Invoke a callback for all descendant nodes recursively between
  // the given two positions that are relative to start of this node's
  // content. The callback is invoked with the node, its
  // parent-relative position, its parent node, and its child index.
  // When the callback returns false for a given node, that node's
  // children will not be recursed over. The last parameter can be
  // used to specify a starting position to count from.
  nodesBetween(from, to, f, startPos = 0) {
    this.content.nodesBetween(from, to, f, startPos, this);
  }

  // :: ((node: Node, pos: number, parent: Node)  ?bool)
  // Call the given callback for every descendant node. Doesn't
  // descend into a node when the callback returns `false`.
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }

  // :: string
  // Concatenates all the text nodes found in this fragment and its
  // children.
  get textContent() { return this.textBetween(0, this.content.size, "") }

  // :: (number, number, ?string, ?string)  string
  // Get all text between positions `from` and `to`. When
  // `blockSeparator` is given, it will be inserted whenever a new
  // block node is started. When `leafText` is given, it'll be
  // inserted for every non-text leaf node encountered.
  textBetween(from, to, blockSeparator, leafText) {
    return this.content.textBetween(from, to, blockSeparator, leafText)
  }

  // :: ?Node
  // Returns this node's first child, or `null` if there are no
  // children.
  get firstChild() { return this.content.firstChild }

  // :: ?Node
  // Returns this node's last child, or `null` if there are no
  // children.
  get lastChild() { return this.content.lastChild }

  // :: (Node)  bool
  // Test whether two nodes represent the same piece of document.
  eq(other) {
    return this == other || (this.sameMarkup(other) && this.content.eq(other.content))
  }

  // :: (Node)  bool
  // Compare the markup (type, attributes, and marks) of this node to
  // those of another. Returns `true` if both have the same markup.
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks)
  }

  // :: (NodeType, ?Object, ?[Mark])  bool
  // Check whether this node's markup correspond to the given type,
  // attributes, and marks.
  hasMarkup(type, attrs, marks) {
    return this.type == type &&
      compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&
      Mark.sameSet(this.marks, marks || Mark.none)
  }

  // :: (?Fragment)  Node
  // Create a new node with the same markup as this node, containing
  // the given content (or empty, if no content is given).
  copy(content = null) {
    if (content == this.content) return this
    return new this.constructor(this.type, this.attrs, content, this.marks)
  }

  // :: ([Mark])  Node
  // Create a copy of this node, with the given set of marks instead
  // of the node's own marks.
  mark(marks) {
    return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)
  }

  // :: (number, ?number)  Node
  // Create a copy of this node with only the content between the
  // given positions. If `to` is not given, it defaults to the end of
  // the node.
  cut(from, to) {
    if (from == 0 && to == this.content.size) return this
    return this.copy(this.content.cut(from, to))
  }

  // :: (number, ?number)  Slice
  // Cut out the part of the document between the given positions, and
  // return it as a `Slice` object.
  slice(from, to = this.content.size, includeParents = false) {
    if (from == to) return Slice.empty

    let $from = this.resolve(from), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start, $to.pos - start);
    return new Slice(content, $from.depth - depth, $to.depth - depth)
  }

  // :: (number, number, Slice)  Node
  // Replace the part of the document between the given positions with
  // the given slice. The slice must 'fit', meaning its open sides
  // must be able to connect to the surrounding content, and its
  // content nodes must be valid children for the node they are placed
  // into. If any of this is violated, an error of type
  // [`ReplaceError`](#model.ReplaceError) is thrown.
  replace(from, to, slice) {
    return replace(this.resolve(from), this.resolve(to), slice)
  }

  // :: (number)  ?Node
  // Find the node directly after the given position.
  nodeAt(pos) {
    for (let node = this;;) {
      let {index, offset} = node.content.findIndex(pos);
      node = node.maybeChild(index);
      if (!node) return null
      if (offset == pos || node.isText) return node
      pos -= offset + 1;
    }
  }

  // :: (number)  {node: ?Node, index: number, offset: number}
  // Find the (direct) child node after the given offset, if any,
  // and return it along with its index and offset relative to this
  // node.
  childAfter(pos) {
    let {index, offset} = this.content.findIndex(pos);
    return {node: this.content.maybeChild(index), index, offset}
  }

  // :: (number)  {node: ?Node, index: number, offset: number}
  // Find the (direct) child node before the given offset, if any,
  // and return it along with its index and offset relative to this
  // node.
  childBefore(pos) {
    if (pos == 0) return {node: null, index: 0, offset: 0}
    let {index, offset} = this.content.findIndex(pos);
    if (offset < pos) return {node: this.content.child(index), index, offset}
    let node = this.content.child(index - 1);
    return {node, index: index - 1, offset: offset - node.nodeSize}
  }

  // :: (number)  ResolvedPos
  // Resolve the given position in the document, returning an
  // [object](#model.ResolvedPos) with information about its context.
  resolve(pos) { return ResolvedPos.resolveCached(this, pos) }

  resolveNoCache(pos) { return ResolvedPos.resolve(this, pos) }

  // :: (number, number, MarkType)  bool
  // Test whether a mark of the given type occurs in this document
  // between the two given positions.
  rangeHasMark(from, to, type) {
    let found = false;
    if (to > from) this.nodesBetween(from, to, node => {
      if (type.isInSet(node.marks)) found = true;
      return !found
    });
    return found
  }

  // :: bool
  // True when this is a block (non-inline node)
  get isBlock() { return this.type.isBlock }

  // :: bool
  // True when this is a textblock node, a block node with inline
  // content.
  get isTextblock() { return this.type.isTextblock }

  // :: bool
  // True when this node allows inline content.
  get inlineContent() { return this.type.inlineContent }

  // :: bool
  // True when this is an inline node (a text node or a node that can
  // appear among text).
  get isInline() { return this.type.isInline }

  // :: bool
  // True when this is a text node.
  get isText() { return this.type.isText }

  // :: bool
  // True when this is a leaf node.
  get isLeaf() { return this.type.isLeaf }

  // :: bool
  // True when this is an atom, i.e. when it does not have directly
  // editable content. This is usually the same as `isLeaf`, but can
  // be configured with the [`atom` property](#model.NodeSpec.atom) on
  // a node's spec (typically used when the node is displayed as an
  // uneditable [node view](#view.NodeView)).
  get isAtom() { return this.type.isAtom }

  // :: ()  string
  // Return a string representation of this node for debugging
  // purposes.
  toString() {
    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name)
  }

  // :: (number)  ContentMatch
  // Get the content match in this node at the given index.
  contentMatchAt(index) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index);
    if (!match) throw new Error("Called contentMatchAt on a node with invalid content")
    return match
  }

  // :: (number, number, ?Fragment, ?number, ?number)  bool
  // Test whether replacing the range between `from` and `to` (by
  // child index) with the given replacement fragment (which defaults
  // to the empty fragment) would leave the node's content valid. You
  // can optionally pass `start` and `end` indices into the
  // replacement fragment.
  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
    let one = this.contentMatchAt(from).matchFragment(replacement, start, end);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd) return false
    for (let i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false
    return true
  }

  // :: (number, number, NodeType, ?[Mark])  bool
  // Test whether replacing the range `from` to `to` (by index) with a
  // node of the given type would leave the node's content valid.
  canReplaceWith(from, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks)) return false
    let start = this.contentMatchAt(from).matchType(type);
    let end = start && start.matchFragment(this.content, to);
    return end ? end.validEnd : false
  }

  // :: (Node)  bool
  // Test whether the given node's content could be appended to this
  // node. If that node is empty, this will only return true if there
  // is at least one node type that can appear in both nodes (to avoid
  // merging completely incompatible nodes).
  canAppend(other) {
    if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content)
    else return this.type.compatibleContent(other.type)
  }

  // Unused. Left for backwards compatibility.
  defaultContentType(at) {
    return this.contentMatchAt(at).defaultType
  }

  // :: ()
  // Check whether this node and its descendants conform to the
  // schema, and raise error when they do not.
  check() {
    if (!this.type.validContent(this.content))
      throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`)
    this.content.forEach(node => node.check());
  }

  // :: ()  Object
  // Return a JSON-serializeable representation of this node.
  toJSON() {
    let obj = {type: this.type.name};
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map(n => n.toJSON());
    return obj
  }

  // :: (Schema, Object)  Node
  // Deserialize a node from its JSON representation.
  static fromJSON(schema, json) {
    if (!json) throw new RangeError("Invalid input for Node.fromJSON")
    let marks = null;
    if (json.marks) {
      if (!Array.isArray(json.marks)) throw new RangeError("Invalid mark data for Node.fromJSON")
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string") throw new RangeError("Invalid text node in JSON")
      return schema.text(json.text, marks)
    }
    let content = Fragment.fromJSON(schema, json.content);
    return schema.nodeType(json.type).create(json.attrs, content, marks)
  }
}

class TextNode extends Node$1 {
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);

    if (!content) throw new RangeError("Empty text nodes are not allowed")

    this.text = content;
  }

  toString() {
    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)
    return wrapMarks(this.marks, JSON.stringify(this.text))
  }

  get textContent() { return this.text }

  textBetween(from, to) { return this.text.slice(from, to) }

  get nodeSize() { return this.text.length }

  mark(marks) {
    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)
  }

  withText(text) {
    if (text == this.text) return this
    return new TextNode(this.type, this.attrs, text, this.marks)
  }

  cut(from = 0, to = this.text.length) {
    if (from == 0 && to == this.text.length) return this
    return this.withText(this.text.slice(from, to))
  }

  eq(other) {
    return this.sameMarkup(other) && this.text == other.text
  }

  toJSON() {
    let base = super.toJSON();
    base.text = this.text;
    return base
  }
}

function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str
}

// ::- Persistent data structure representing an ordered mapping from
// strings to values, with some convenient update methods.
function OrderedMap(content) {
  this.content = content;
}

OrderedMap.prototype = {
  constructor: OrderedMap,

  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i
    return -1
  },

  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found = this.find(key);
    return found == -1 ? undefined : this.content[found + 1]
  },

  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found = self.find(key), content = self.content.slice();
    if (found == -1) {
      content.push(newKey || key, value);
    } else {
      content[found + 1] = value;
      if (newKey) content[found] = newKey;
    }
    return new OrderedMap(content)
  },

  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found = this.find(key);
    if (found == -1) return this
    var content = this.content.slice();
    content.splice(found, 2);
    return new OrderedMap(content)
  },

  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content))
  },

  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content)
  },

  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found = without.find(place);
    content.splice(found == -1 ? content.length : found, 0, key, value);
    return new OrderedMap(content)
  },

  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },

  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(map.content.concat(this.subtract(map).content))
  },

  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(this.subtract(map).content.concat(map.content))
  },

  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map) {
    var result = this;
    map = OrderedMap.from(map);
    for (var i = 0; i < map.content.length; i += 2)
      result = result.remove(map.content[i]);
    return result
  },

  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1
  }
};

// :: (?union<Object, OrderedMap>)  OrderedMap
// Return a map with the given content. If null, create an empty
// map. If given an ordered map, return that map itself. If given an
// object, create a map from the object's properties.
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content)
};

// ::- Instances of this class represent a match state of a node
// type's [content expression](#model.NodeSpec.content), and can be
// used to find out whether further content matches here, and whether
// a given position is a valid end of the node.
class ContentMatch {
  constructor(validEnd) {
    // :: bool
    // True when this match state represents a valid end of the node.
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }

  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null) return ContentMatch.empty
    let expr = parseExpr(stream);
    if (stream.next) stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match
  }

  // :: (NodeType)  ?ContentMatch
  // Match a node type, returning a match after that node if
  // successful.
  matchType(type) {
    for (let i = 0; i < this.next.length; i += 2)
      if (this.next[i] == type) return this.next[i + 1]
    return null
  }

  // :: (Fragment, ?number, ?number)  ?ContentMatch
  // Try to match a fragment. Returns the resulting match when
  // successful.
  matchFragment(frag, start = 0, end = frag.childCount) {
    let cur = this;
    for (let i = start; cur && i < end; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur
  }

  get inlineContent() {
    let first = this.next[0];
    return first ? first.isInline : false
  }

  // :: ?NodeType
  // Get the first matching node type at this match position that can
  // be generated.
  get defaultType() {
    for (let i = 0; i < this.next.length; i += 2) {
      let type = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs())) return type
    }
  }

  compatible(other) {
    for (let i = 0; i < this.next.length; i += 2)
      for (let j = 0; j < other.next.length; j += 2)
        if (this.next[i] == other.next[j]) return true
    return false
  }

  // :: (Fragment, bool, ?number)  ?Fragment
  // Try to match the given fragment, and if that fails, see if it can
  // be made to match by inserting nodes in front of it. When
  // successful, return a fragment of inserted nodes (which may be
  // empty if nothing had to be inserted). When `toEnd` is true, only
  // return a fragment if the resulting match goes to the end of the
  // content expression.
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types.map(tp => tp.createAndFill()))

      for (let i = 0; i < match.next.length; i += 2) {
        let type = match.next[i], next = match.next[i + 1];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found = search(next, types.concat(type));
          if (found) return found
        }
      }
    }

    return search(this, [])
  }

  // :: (NodeType)  ?[NodeType]
  // Find a set of wrapping node types that would allow a node of the
  // given type to appear at this position. The result may be empty
  // (when it fits directly) and will be null when no such wrapping
  // exists.
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target) return this.wrapCache[i + 1]
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed
  }

  computeWrapping(target) {
    let seen = Object.create(null), active = [{match: this, type: null, via: null}];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse()
      }
      for (let i = 0; i < match.next.length; i += 2) {
        let type = match.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
          active.push({match: type.contentMatch, type, via: current});
          seen[type.name] = true;
        }
      }
    }
  }

  // :: number
  // The number of outgoing edges this node has in the finite
  // automaton that describes the content expression.
  get edgeCount() {
    return this.next.length >> 1
  }

  // :: (number)  {type: NodeType, next: ContentMatch}
  // Get the _n_th outgoing edge from this node in the finite
  // automaton that describes the content expression.
  edge(n) {
    let i = n << 1;
    if (i > this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`)
    return {type: this.next[i], next: this.next[i + 1]}
  }

  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i = 1; i < m.next.length; i += 2)
        if (seen.indexOf(m.next[i]) == -1) scan(m.next[i]);
    }
    scan(this);
    return seen.map((m, i) => {
      let out = i + (m.validEnd ? "*" : " ") + " ";
      for (let i = 0; i < m.next.length; i += 2)
        out += (i ? ", " : "") + m.next[i].name + "->" + seen.indexOf(m.next[i + 1]);
      return out
    }).join("\n")
  }
}

ContentMatch.empty = new ContentMatch(true);

class TokenStream {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "") this.tokens.pop();
    if (this.tokens[0] == "") this.tokens.unshift();
  }

  get next() { return this.tokens[this.pos] }

  eat(tok) { return this.next == tok && (this.pos++ || true) }

  err(str) { throw new SyntaxError(str + " (in content expression '" + this.string + "')") }
}

function parseExpr(stream) {
  let exprs = [];
  do { exprs.push(parseExprSeq(stream)); }
  while (stream.eat("|"))
  return exprs.length == 1 ? exprs[0] : {type: "choice", exprs}
}

function parseExprSeq(stream) {
  let exprs = [];
  do { exprs.push(parseExprSubscript(stream)); }
  while (stream.next && stream.next != ")" && stream.next != "|")
  return exprs.length == 1 ? exprs[0] : {type: "seq", exprs}
}

function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (;;) {
    if (stream.eat("+"))
      expr = {type: "plus", expr};
    else if (stream.eat("*"))
      expr = {type: "star", expr};
    else if (stream.eat("?"))
      expr = {type: "opt", expr};
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else break
  }
  return expr
}

function parseNum(stream) {
  if (/\D/.test(stream.next)) stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result
}

function parseExprRange(stream, expr) {
  let min = parseNum(stream), max = min;
  if (stream.eat(",")) {
    if (stream.next != "}") max = parseNum(stream);
    else max = -1;
  }
  if (!stream.eat("}")) stream.err("Unclosed braced range");
  return {type: "range", min, max, expr}
}

function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type) return [type]
  let result = [];
  for (let typeName in types) {
    let type = types[typeName];
    if (type.groups.indexOf(name) > -1) result.push(type);
  }
  if (result.length == 0) stream.err("No node type or group '" + name + "' found");
  return result
}

function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")")) stream.err("Missing closing paren");
    return expr
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map(type => {
      if (stream.inline == null) stream.inline = type.isInline;
      else if (stream.inline != type.isInline) stream.err("Mixing inline and block content");
      return {type: "name", value: type}
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : {type: "choice", exprs}
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}

// The code below helps compile a regular-expression-like language
// into a deterministic finite automaton. For a good introduction to
// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html

// : (Object)  [[{term: ?any, to: number}]]
// Construct an NFA from an expression as returned by the parser. The
// NFA is represented as an array of states, which are themselves
// arrays of edges, which are `{term, to}` objects. The first state is
// the entry state and the last node is the success state.
//
// Note that unlike typical NFAs, the edge ordering in this one is
// significant, in that it is used to contruct filler content when
// necessary.
function nfa(expr) {
  let nfa = [[]];
  connect(compile(expr, 0), node());
  return nfa

  function node() { return nfa.push([]) - 1 }
  function edge(from, to, term) {
    let edge = {term, to};
    nfa[from].push(edge);
    return edge
  }
  function connect(edges, to) { edges.forEach(edge => edge.to = to); }

  function compile(expr, from) {
    if (expr.type == "choice") {
      return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), [])
    } else if (expr.type == "seq") {
      for (let i = 0;; i++) {
        let next = compile(expr.exprs[i], from);
        if (i == expr.exprs.length - 1) return next
        connect(next, from = node());
      }
    } else if (expr.type == "star") {
      let loop = node();
      edge(from, loop);
      connect(compile(expr.expr, loop), loop);
      return [edge(loop)]
    } else if (expr.type == "plus") {
      let loop = node();
      connect(compile(expr.expr, from), loop);
      connect(compile(expr.expr, loop), loop);
      return [edge(loop)]
    } else if (expr.type == "opt") {
      return [edge(from)].concat(compile(expr.expr, from))
    } else if (expr.type == "range") {
      let cur = from;
      for (let i = 0; i < expr.min; i++) {
        let next = node();
        connect(compile(expr.expr, cur), next);
        cur = next;
      }
      if (expr.max == -1) {
        connect(compile(expr.expr, cur), cur);
      } else {
        for (let i = expr.min; i < expr.max; i++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)]
    } else if (expr.type == "name") {
      return [edge(from, null, expr.value)]
    }
  }
}

function cmp(a, b) { return a - b }

// Get the set of nodes reachable by null edges from `node`. Omit
// nodes with only a single null-out-edge, since they may lead to
// needless duplicated nodes.
function nullFrom(nfa, node) {
  let result = [];
  scan(node);
  return result.sort(cmp)

  function scan(node) {
    let edges = nfa[node];
    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to)
    result.push(node);
    for (let i = 0; i < edges.length; i++) {
      let {term, to} = edges[i];
      if (!term && result.indexOf(to) == -1) scan(to);
    }
  }
}

// : ([[{term: ?any, to: number}]])  ContentMatch
// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set
// of state objects (`ContentMatch` instances) with transitions
// between them.
function dfa(nfa) {
  let labeled = Object.create(null);
  return explore(nullFrom(nfa, 0))

  function explore(states) {
    let out = [];
    states.forEach(node => {
      nfa[node].forEach(({term, to}) => {
        if (!term) return
        let known = out.indexOf(term), set = known > -1 && out[known + 1];
        nullFrom(nfa, to).forEach(node => {
          if (!set) out.push(term, set = []);
          if (set.indexOf(node) == -1) set.push(node);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);
    for (let i = 0; i < out.length; i += 2) {
      let states = out[i + 1].sort(cmp);
      state.next.push(out[i], labeled[states.join(",")] || explore(states));
    }
    return state
  }
}

function checkForDeadEnds(match, stream) {
  for (let i = 0, work = [match]; i < work.length; i++) {
    let state = work[i], dead = !state.validEnd, nodes = [];
    for (let j = 0; j < state.next.length; j += 2) {
      let node = state.next[j], next = state.next[j + 1];
      nodes.push(node.name);
      if (dead && !(node.isText || node.hasRequiredAttrs())) dead = false;
      if (work.indexOf(next) == -1) work.push(next);
    }
    if (dead) stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position");
  }
}

// For node types where all attrs have a default value (or which don't
// have any attributes), build up a single reusable default attribute
// object, and use it for all nodes that don't specify specific
// attributes.
function defaultAttrs(attrs) {
  let defaults = Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault) return null
    defaults[attrName] = attr.default;
  }
  return defaults
}

function computeAttrs(attrs, value) {
  let built = Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === undefined) {
      let attr = attrs[name];
      if (attr.hasDefault) given = attr.default;
      else throw new RangeError("No value supplied for attribute " + name)
    }
    built[name] = given;
  }
  return built
}

function initAttrs(attrs) {
  let result = Object.create(null);
  if (attrs) for (let name in attrs) result[name] = new Attribute(attrs[name]);
  return result
}

// ::- Node types are objects allocated once per `Schema` and used to
// [tag](#model.Node.type) `Node` instances. They contain information
// about the node type, such as its name and what kind of node it
// represents.
class NodeType {
  constructor(name, schema, spec) {
    // :: string
    // The name the node type has in this schema.
    this.name = name;

    // :: Schema
    // A link back to the `Schema` the node type belongs to.
    this.schema = schema;

    // :: NodeSpec
    // The spec that this type is based on
    this.spec = spec;

    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(spec.attrs);

    this.defaultAttrs = defaultAttrs(this.attrs);

    // :: ContentMatch
    // The starting match of the node type's content expression.
    this.contentMatch = null;

    // : ?[MarkType]
    // The set of marks allowed in this node. `null` means all marks
    // are allowed.
    this.markSet = null;

    // :: bool
    // True if this node type has inline content.
    this.inlineContent = null;

    // :: bool
    // True if this is a block type
    this.isBlock = !(spec.inline || name == "text");

    // :: bool
    // True if this is the text node type.
    this.isText = name == "text";
  }

  // :: bool
  // True if this is an inline type.
  get isInline() { return !this.isBlock }

  // :: bool
  // True if this is a textblock type, a block that contains inline
  // content.
  get isTextblock() { return this.isBlock && this.inlineContent }

  // :: bool
  // True for node types that allow no content.
  get isLeaf() { return this.contentMatch == ContentMatch.empty }

  // :: bool
  // True when this node is an atom, i.e. when it does not have
  // directly editable content.
  get isAtom() { return this.isLeaf || this.spec.atom }

  hasRequiredAttrs(ignore) {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired && (!ignore || !(n in ignore))) return true
    return false
  }

  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch)
  }

  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs) return this.defaultAttrs
    else return computeAttrs(this.attrs, attrs)
  }

  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  Node
  // Create a `Node` of this type. The given attributes are
  // checked and defaulted (you can pass `null` to use the type's
  // defaults entirely, if no required attributes exist). `content`
  // may be a `Fragment`, a node, an array of nodes, or
  // `null`. Similarly `marks` may be `null` to default to the empty
  // set of marks.
  create(attrs, content, marks) {
    if (this.isText) throw new Error("NodeType.create can't construct text nodes")
    return new Node$1(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))
  }

  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  Node
  // Like [`create`](#model.NodeType.create), but check the given content
  // against the node type's content restrictions, and throw an error
  // if it doesn't match.
  createChecked(attrs, content, marks) {
    content = Fragment.from(content);
    if (!this.validContent(content))
      throw new RangeError("Invalid content for node " + this.name)
    return new Node$1(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))
  }

  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  ?Node
  // Like [`create`](#model.NodeType.create), but see if it is necessary to
  // add nodes to the start or end of the given fragment to make it
  // fit the node. If no fitting wrapping can be found, return null.
  // Note that, due to the fact that required nodes can always be
  // created, this will always succeed if you pass null or
  // `Fragment.empty` as content.
  createAndFill(attrs, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before) return null
      content = before.append(content);
    }
    let after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);
    if (!after) return null
    return new Node$1(this, attrs, content.append(after), Mark.setFrom(marks))
  }

  // :: (Fragment)  bool
  // Returns true if the given fragment is valid content for this node
  // type with the given attributes.
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd) return false
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks)) return false
    return true
  }

  // :: (MarkType)  bool
  // Check whether the given mark type is allowed in this node.
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1
  }

  // :: ([Mark])  bool
  // Test whether the given set of marks are allowed in this node.
  allowsMarks(marks) {
    if (this.markSet == null) return true
    for (let i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false
    return true
  }

  // :: ([Mark])  [Mark]
  // Removes the marks that are not allowed in this node from the given set.
  allowedMarks(marks) {
    if (this.markSet == null) return marks
    let copy;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy) copy = marks.slice(0, i);
      } else if (copy) {
        copy.push(marks[i]);
      }
    }
    return !copy ? marks : copy.length ? copy : Mark.empty
  }

  static compile(nodes, schema) {
    let result = Object.create(null);
    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec));

    let topType = schema.spec.topNode || "doc";
    if (!result[topType]) throw new RangeError("Schema is missing its top node type ('" + topType + "')")
    if (!result.text) throw new RangeError("Every schema needs a 'text' type")
    for (let _ in result.text.attrs) throw new RangeError("The text node type should not have attributes")

    return result
  }
}

// Attribute descriptors

class Attribute {
  constructor(options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
  }

  get isRequired() {
    return !this.hasDefault
  }
}

// Marks

// ::- Like nodes, marks (which are associated with nodes to signify
// things like emphasis or being part of a link) are
// [tagged](#model.Mark.type) with type objects, which are
// instantiated once per `Schema`.
class MarkType {
  constructor(name, rank, schema, spec) {
    // :: string
    // The name of the mark type.
    this.name = name;

    // :: Schema
    // The schema that this mark type instance is part of.
    this.schema = schema;

    // :: MarkSpec
    // The spec on which the type is based.
    this.spec = spec;

    this.attrs = initAttrs(spec.attrs);

    this.rank = rank;
    this.excluded = null;
    let defaults = defaultAttrs(this.attrs);
    this.instance = defaults && new Mark(this, defaults);
  }

  // :: (?Object)  Mark
  // Create a mark of this type. `attrs` may be `null` or an object
  // containing only some of the mark's attributes. The others, if
  // they have defaults, will be added.
  create(attrs) {
    if (!attrs && this.instance) return this.instance
    return new Mark(this, computeAttrs(this.attrs, attrs))
  }

  static compile(marks, schema) {
    let result = Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));
    return result
  }

  // :: ([Mark])  [Mark]
  // When there is a mark of this type in the given set, a new set
  // without it is returned. Otherwise, the input set is returned.
  removeFromSet(set) {
    for (var i = 0; i < set.length; i++)
      if (set[i].type == this)
        return set.slice(0, i).concat(set.slice(i + 1))
    return set
  }

  // :: ([Mark])  ?Mark
  // Tests whether there is a mark of this type in the given set.
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (set[i].type == this) return set[i]
  }

  // :: (MarkType)  bool
  // Queries whether a given mark type is
  // [excluded](#model.MarkSpec.excludes) by this one.
  excludes(other) {
    return this.excluded.indexOf(other) > -1
  }
}

// SchemaSpec:: interface
// An object describing a schema, as passed to the [`Schema`](#model.Schema)
// constructor.
//
//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>
//   The node types in this schema. Maps names to
//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type
//   associated with that name. Their order is significantit
//   determines which [parse rules](#model.NodeSpec.parseDOM) take
//   precedence by default, and which nodes come first in a given
//   [group](#model.NodeSpec.group).
//
//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>
//   The mark types that exist in this schema. The order in which they
//   are provided determines the order in which [mark
//   sets](#model.Mark.addToSet) are sorted and in which [parse
//   rules](#model.MarkSpec.parseDOM) are tried.
//
//   topNode:: ?string
//   The name of the default top-level node for the schema. Defaults
//   to `"doc"`.

// NodeSpec:: interface
//
//   content:: ?string
//   The content expression for this node, as described in the [schema
//   guide](/docs/guide/#schema.content_expressions). When not given,
//   the node does not allow any content.
//
//   marks:: ?string
//   The marks that are allowed inside of this node. May be a
//   space-separated string referring to mark names or groups, `"_"`
//   to explicitly allow all marks, or `""` to disallow marks. When
//   not given, nodes with inline content default to allowing all
//   marks, other nodes default to not allowing marks.
//
//   group:: ?string
//   The group or space-separated groups to which this node belongs,
//   which can be referred to in the content expressions for the
//   schema.
//
//   inline:: ?bool
//   Should be set to true for inline nodes. (Implied for text nodes.)
//
//   atom:: ?bool
//   Can be set to true to indicate that, though this isn't a [leaf
//   node](#model.NodeType.isLeaf), it doesn't have directly editable
//   content and should be treated as a single unit in the view.
//
//   attrs:: ?Object<AttributeSpec>
//   The attributes that nodes of this type get.
//
//   selectable:: ?bool
//   Controls whether nodes of this type can be selected as a [node
//   selection](#state.NodeSelection). Defaults to true for non-text
//   nodes.
//
//   draggable:: ?bool
//   Determines whether nodes of this type can be dragged without
//   being selected. Defaults to false.
//
//   code:: ?bool
//   Can be used to indicate that this node contains code, which
//   causes some commands to behave differently.
//
//   defining:: ?bool
//   Determines whether this node is considered an important parent
//   node during replace operations (such as paste). Non-defining (the
//   default) nodes get dropped when their entire content is replaced,
//   whereas defining nodes persist and wrap the inserted content.
//   Likewise, in _inserted_ content the defining parents of the
//   content are preserved when possible. Typically,
//   non-default-paragraph textblock types, and possibly list items,
//   are marked as defining.
//
//   isolating:: ?bool
//   When enabled (default is false), the sides of nodes of this type
//   count as boundaries that regular editing operations, like
//   backspacing or lifting, won't cross. An example of a node that
//   should probably have this enabled is a table cell.
//
//   toDOM:: ?(node: Node)  DOMOutputSpec
//   Defines the default way a node of this type should be serialized
//   to DOM/HTML (as used by
//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).
//   Should return a DOM node or an [array
//   structure](#model.DOMOutputSpec) that describes one, with an
//   optional number zero (hole) in it to indicate where the node's
//   content should be inserted.
//
//   For text nodes, the default is to create a text DOM node. Though
//   it is possible to create a serializer where text is rendered
//   differently, this is not supported inside the editor, so you
//   shouldn't override that in your text node spec.
//
//   parseDOM:: ?[ParseRule]
//   Associates DOM parser information with this node, which can be
//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to
//   automatically derive a parser. The `node` field in the rules is
//   implied (the name of this node will be filled in automatically).
//   If you supply your own parser, you do not need to also specify
//   parsing rules in your schema.
//
//   toDebugString:: ?(node: Node) -> string
//   Defines the default way a node of this type should be serialized
//   to a string representation for debugging (e.g. in error messages).

// MarkSpec:: interface
//
//   attrs:: ?Object<AttributeSpec>
//   The attributes that marks of this type get.
//
//   inclusive:: ?bool
//   Whether this mark should be active when the cursor is positioned
//   at its end (or at its start when that is also the start of the
//   parent node). Defaults to true.
//
//   excludes:: ?string
//   Determines which other marks this mark can coexist with. Should
//   be a space-separated strings naming other marks or groups of marks.
//   When a mark is [added](#model.Mark.addToSet) to a set, all marks
//   that it excludes are removed in the process. If the set contains
//   any mark that excludes the new mark but is not, itself, excluded
//   by the new mark, the mark can not be added an the set. You can
//   use the value `"_"` to indicate that the mark excludes all
//   marks in the schema.
//
//   Defaults to only being exclusive with marks of the same type. You
//   can set it to an empty string (or any string not containing the
//   mark's own name) to allow multiple marks of a given type to
//   coexist (as long as they have different attributes).
//
//   group:: ?string
//   The group or space-separated groups to which this mark belongs.
//
//   spanning:: ?bool
//   Determines whether marks of this type can span multiple adjacent
//   nodes when serialized to DOM/HTML. Defaults to true.
//
//   toDOM:: ?(mark: Mark, inline: bool)  DOMOutputSpec
//   Defines the default way marks of this type should be serialized
//   to DOM/HTML. When the resulting spec contains a hole, that is
//   where the marked content is placed. Otherwise, it is appended to
//   the top node.
//
//   parseDOM:: ?[ParseRule]
//   Associates DOM parser information with this mark (see the
//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The
//   `mark` field in the rules is implied.

// AttributeSpec:: interface
//
// Used to [define](#model.NodeSpec.attrs) attributes on nodes or
// marks.
//
//   default:: ?any
//   The default value for this attribute, to use when no explicit
//   value is provided. Attributes that have no default must be
//   provided whenever a node or mark of a type that has them is
//   created.

// ::- A document schema. Holds [node](#model.NodeType) and [mark
// type](#model.MarkType) objects for the nodes and marks that may
// occur in conforming documents, and provides functionality for
// creating and deserializing such documents.
class Schema {
  // :: (SchemaSpec)
  // Construct a schema from a schema [specification](#model.SchemaSpec).
  constructor(spec) {
    // :: SchemaSpec
    // The [spec](#model.SchemaSpec) on which the schema is based,
    // with the added guarantee that its `nodes` and `marks`
    // properties are
    // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances
    // (not raw objects).
    this.spec = {};
    for (let prop in spec) this.spec[prop] = spec[prop];
    this.spec.nodes = OrderedMap.from(spec.nodes);
    this.spec.marks = OrderedMap.from(spec.marks);

    // :: Object<NodeType>
    // An object mapping the schema's node names to node type objects.
    this.nodes = NodeType.compile(this.spec.nodes, this);

    // :: Object<MarkType>
    // A map from mark names to mark type objects.
    this.marks = MarkType.compile(this.spec.marks, this);

    let contentExprCache = Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark")
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] ||
        (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      type.markSet = markExpr == "_" ? null :
        markExpr ? gatherMarks(this, markExpr.split(" ")) :
        markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }

    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);

    // :: NodeType
    // The type of the [default top node](#model.SchemaSpec.topNode)
    // for this schema.
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];

    // :: Object
    // An object for storing whatever values modules may want to
    // compute and cache per schema. (If you want to store something
    // in it, try to use property names unlikely to clash.)
    this.cached = Object.create(null);
    this.cached.wrappings = Object.create(null);
  }

  // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  Node
  // Create a node in this schema. The `type` may be a string or a
  // `NodeType` instance. Attributes will be extended
  // with defaults, `content` may be a `Fragment`,
  // `null`, a `Node`, or an array of nodes.
  node(type, attrs, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType))
      throw new RangeError("Invalid node type: " + type)
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")")

    return type.createChecked(attrs, content, marks)
  }

  // :: (string, ?[Mark])  Node
  // Create a text node in the schema. Empty text nodes are not
  // allowed.
  text(text, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks))
  }

  // :: (union<string, MarkType>, ?Object)  Mark
  // Create a mark with the given type and attributes.
  mark(type, attrs) {
    if (typeof type == "string") type = this.marks[type];
    return type.create(attrs)
  }

  // :: (Object)  Node
  // Deserialize a node from its JSON representation. This method is
  // bound.
  nodeFromJSON(json) {
    return Node$1.fromJSON(this, json)
  }

  // :: (Object)  Mark
  // Deserialize a mark from its JSON representation. This method is
  // bound.
  markFromJSON(json) {
    return Mark.fromJSON(this, json)
  }

  nodeType(name) {
    let found = this.nodes[name];
    if (!found) throw new RangeError("Unknown node type: " + name)
    return found
  }
}

function gatherMarks(schema, marks) {
  let found = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark = schema.marks[prop];
        if (name == "_" || (mark.spec.group && mark.spec.group.split(" ").indexOf(name) > -1))
          found.push(ok = mark);
      }
    }
    if (!ok) throw new SyntaxError("Unknown mark type: '" + marks[i] + "'")
  }
  return found
}

// ParseOptions:: interface
// These are the options recognized by the
// [`parse`](#model.DOMParser.parse) and
// [`parseSlice`](#model.DOMParser.parseSlice) methods.
//
//   preserveWhitespace:: ?union<bool, "full">
//   By default, whitespace is collapsed as per HTML's rules. Pass
//   `true` to preserve whitespace, but normalize newlines to
//   spaces, and `"full"` to preserve whitespace entirely.
//
//   findPositions:: ?[{node: dom.Node, offset: number}]
//   When given, the parser will, beside parsing the content,
//   record the document positions of the given DOM positions. It
//   will do so by writing to the objects, adding a `pos` property
//   that holds the document position. DOM positions that are not
//   in the parsed content will not be written to.
//
//   from:: ?number
//   The child node index to start parsing from.
//
//   to:: ?number
//   The child node index to stop parsing at.
//
//   topNode:: ?Node
//   By default, the content is parsed into the schema's default
//   [top node type](#model.Schema.topNodeType). You can pass this
//   option to use the type and attributes from a different node
//   as the top container.
//
//   topMatch:: ?ContentMatch
//   Provide the starting content match that content parsed into the
//   top node is matched against.
//
//   context:: ?ResolvedPos
//   A set of additional nodes to count as
//   [context](#model.ParseRule.context) when parsing, above the
//   given [top node](#model.ParseOptions.topNode).

// ParseRule:: interface
// A value that describes how to parse a given DOM node or inline
// style as a ProseMirror node or mark.
//
//   tag:: ?string
//   A CSS selector describing the kind of DOM elements to match. A
//   single rule should have _either_ a `tag` or a `style` property.
//
//   namespace:: ?string
//   The namespace to match. This should be used with `tag`.
//   Nodes are only matched when the namespace matches or this property
//   is null.
//
//   style:: ?string
//   A CSS property name to match. When given, this rule matches
//   inline styles that list that property. May also have the form
//   `"property=value"`, in which case the rule only matches if the
//   propery's value exactly matches the given value. (For more
//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)
//   and return undefined to indicate that the match failed.)
//
//   priority:: ?number
//   Can be used to change the order in which the parse rules in a
//   schema are tried. Those with higher priority come first. Rules
//   without a priority are counted as having priority 50. This
//   property is only meaningful in a schemawhen directly
//   constructing a parser, the order of the rule array is used.
//
//   context:: ?string
//   When given, restricts this rule to only match when the current
//   contextthe parent nodes into which the content is being
//   parsedmatches this expression. Should contain one or more node
//   names or node group names followed by single or double slashes.
//   For example `"paragraph/"` means the rule only matches when the
//   parent node is a paragraph, `"blockquote/paragraph/"` restricts
//   it to be in a paragraph that is inside a blockquote, and
//   `"section//"` matches any position inside a sectiona double
//   slash matches any sequence of ancestor nodes. To allow multiple
//   different contexts, they can be separated by a pipe (`|`)
//   character, as in `"blockquote/|list_item/"`.
//
//   node:: ?string
//   The name of the node type to create when this rule matches. Only
//   valid for rules with a `tag` property, not for style rules. Each
//   rule should have one of a `node`, `mark`, or `ignore` property
//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or
//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`
//   or `mark` property will be derived from its position).
//
//   mark:: ?string
//   The name of the mark type to wrap the matched content in.
//
//   ignore:: ?bool
//   When true, ignore content that matches this rule.
//
//   skip:: ?bool
//   When true, ignore the node that matches this rule, but do parse
//   its content.
//
//   attrs:: ?Object
//   Attributes for the node or mark created by this rule. When
//   `getAttrs` is provided, it takes precedence.
//
//   getAttrs:: ?(union<dom.Node, string>)  ?union<Object, false>
//   A function used to compute the attributes for the node or mark
//   created by this rule. Can also be used to describe further
//   conditions the DOM element or style must match. When it returns
//   `false`, the rule won't match. When it returns null or undefined,
//   that is interpreted as an empty/default set of attributes.
//
//   Called with a DOM Element for `tag` rules, and with a string (the
//   style's value) for `style` rules.
//
//   contentElement:: ?union<string, (dom.Node)  dom.Node>
//   For `tag` rules that produce non-leaf nodes or marks, by default
//   the content of the DOM element is parsed as content of the mark
//   or node. If the child nodes are in a descendent node, this may be
//   a CSS selector string that the parser must use to find the actual
//   content element, or a function that returns the actual content
//   element to the parser.
//
//   getContent:: ?(dom.Node, schema: Schema)  Fragment
//   Can be used to override the content of a matched node. When
//   present, instead of parsing the node's child nodes, the result of
//   this function is used.
//
//   preserveWhitespace:: ?union<bool, "full">
//   Controls whether whitespace should be preserved when parsing the
//   content inside the matched element. `false` means whitespace may
//   be collapsed, `true` means that whitespace should be preserved
//   but newlines normalized to spaces, and `"full"` means that
//   newlines should also be preserved.

// ::- A DOM parser represents a strategy for parsing DOM content into
// a ProseMirror document conforming to a given schema. Its behavior
// is defined by an array of [rules](#model.ParseRule).
class DOMParser {
  // :: (Schema, [ParseRule])
  // Create a parser that targets the given schema, using the given
  // parsing rules.
  constructor(schema, rules) {
    // :: Schema
    // The schema into which the parser parses.
    this.schema = schema;
    // :: [ParseRule]
    // The set of [parse rules](#model.ParseRule) that the parser
    // uses, in order of precedence.
    this.rules = rules;
    this.tags = [];
    this.styles = [];

    rules.forEach(rule => {
      if (rule.tag) this.tags.push(rule);
      else if (rule.style) this.styles.push(rule);
    });
  }

  // :: (dom.Node, ?ParseOptions)  Node
  // Parse a document from the content of a DOM node.
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, null, options.from, options.to);
    return context.finish()
  }

  // :: (dom.Node, ?ParseOptions)  Slice
  // Parses the content of the given DOM node, like
  // [`parse`](#model.DOMParser.parse), and takes the same set of
  // options. But unlike that method, which produces a whole node,
  // this one returns a slice that is open at the sides, meaning that
  // the schema constraints aren't applied to the start of nodes to
  // the left of the input and the end of nodes at the end.
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, null, options.from, options.to);
    return Slice.maxOpen(context.finish())
  }

  matchTag(dom, context) {
    for (let i = 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) &&
          (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&
          (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false) continue
          rule.attrs = result;
        }
        return rule
      }
    }
  }

  matchStyle(prop, value, context) {
    for (let i = 0; i < this.styles.length; i++) {
      let rule = this.styles[i];
      if (rule.style.indexOf(prop) != 0 ||
          rule.context && !context.matchesContext(rule.context) ||
          // Test that the style string either precisely matches the prop,
          // or has an '=' sign after the prop, followed by the given
          // value.
          rule.style.length > prop.length &&
          (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))
        continue
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false) continue
        rule.attrs = result;
      }
      return rule
    }
  }

  // : (Schema)  [ParseRule]
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority) break
      }
      result.splice(i, 0, rule);
    }

    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules) rules.forEach(rule => {
        insert(rule = copy(rule));
        rule.mark = name;
      });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules) rules.forEach(rule => {
        insert(rule = copy(rule));
        rule.node = name;
      });
    }
    return result
  }

  // :: (Schema)  DOMParser
  // Construct a DOM parser using the parsing rules listed in a
  // schema's [node specs](#model.NodeSpec.parseDOM), reordered by
  // [priority](#model.ParseRule.priority).
  static fromSchema(schema) {
    return schema.cached.domParser ||
      (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))
  }
}

// : Object<bool> The block-level tags in HTML5
const blockTags = {
  address: true, article: true, aside: true, blockquote: true, canvas: true,
  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,
  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,
  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,
  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true
};

// : Object<bool> The tags that we normally ignore.
const ignoreTags = {
  head: true, noscript: true, object: true, script: true, style: true, title: true
};

// Using a bitfield for node context options
const OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;

function wsOptionsFor(preserveWhitespace) {
  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0)
}

class NodeContext {
  constructor(type, attrs, marks, solid, match, options) {
    this.type = type;
    this.attrs = attrs;
    this.solid = solid;
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
    this.options = options;
    this.content = [];
    this.marks = marks;
    this.activeMarks = Mark.none;
  }

  findWrapping(node) {
    if (!this.match) {
      if (!this.type) return []
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start = this.type.contentMatch, wrap;
        if (wrap = start.findWrapping(node.type)) {
          this.match = start;
          return wrap
        } else {
          return null
        }
      }
    }
    return this.match.findWrapping(node.type)
  }

  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace
      let last = this.content[this.content.length - 1], m;
      if (last && last.isText && (m = /\s+$/.exec(last.text))) {
        if (last.text.length == m[0].length) this.content.pop();
        else this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content
  }
}

class ParseContext {
  // : (DOMParser, Object)
  constructor(parser, options, open) {
    // : DOMParser The parser we are using.
    this.parser = parser;
    // : Object The options passed to this parse.
    this.options = options;
    this.isOpen = open;
    this.pendingMarks = [];
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true,
                                   options.topMatch || topNode.type.contentMatch, topOptions);
    else if (open)
      topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    // : [Mark] The current set of marks
    this.open = 0;
    this.find = options.findPositions;
    this.needsBlock = false;
  }

  get top() {
    return this.nodes[this.open]
  }

  // : (dom.Node)
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom) {
    if (dom.nodeType == 3) {
      this.addTextNode(dom);
    } else if (dom.nodeType == 1) {
      let style = dom.getAttribute("style");
      let marks = style ? this.readStyles(parseStyles(style)) : null;
      if (marks != null) for (let i = 0; i < marks.length; i++) this.addPendingMark(marks[i]);
      this.addElement(dom);
      if (marks != null) for (let i = 0; i < marks.length; i++) this.removePendingMark(marks[i]);
    }
  }

  addTextNode(dom) {
    let value = dom.nodeValue;
    let top = this.top;
    if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /\S/.test(value)) {
      if (!(top.options & OPT_PRESERVE_WS)) {
        value = value.replace(/\s+/g, " ");
        // If this starts with whitespace, and there is no node before it, or
        // a hard break, or a text node that ends with whitespace, strip the
        // leading space.
        if (/^\s/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top.content[top.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore ||
              (domNodeBefore && domNodeBefore.nodeName == 'BR') ||
              (nodeBefore.isText && /\s$/.test(nodeBefore.text)))
            value = value.slice(1);
        }
      } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
        value = value.replace(/\r?\n|\r/g, " ");
      }
      if (value) this.insertNode(this.parser.schema.text(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }

  // : (dom.Element)
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom) {
    let name = dom.nodeName.toLowerCase();

    //==============================
    // TEMP - getting rid of this cludge (as he describes it)!!!
    //I need a different cludge
    //if (listTags.hasOwnProperty(name)) normalizeList(dom)
    //==============================

    let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) || this.parser.matchTag(dom, this);
    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
    } else if (!rule || rule.skip) {
      if (rule && rule.skip.nodeType) dom = rule.skip;
      let sync, top = this.top, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        sync = true;
        if (!top.type) this.needsBlock = true;
      }
      this.addAll(dom);
      if (sync) this.sync(top);
      this.needsBlock = oldNeedsBlock;
    } else {
      this.addElementByRule(dom, rule);
    }
  }

  // Run any style parser associated with the node's styles. Either
  // return an array of marks, or null to indicate some of the styles
  // had a rule with `ignore` set.
  readStyles(styles) {
    let marks = Mark.none;
    for (let i = 0; i < styles.length; i += 2) {
      let rule = this.parser.matchStyle(styles[i], styles[i + 1], this);
      if (!rule) continue
      if (rule.ignore) return null
      marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);
    }
    return marks
  }

  // : (dom.Element, ParseRule)  bool
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule) {
    let sync, nodeType, markType, mark;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (nodeType.isLeaf) this.insertNode(nodeType.create(rule.attrs));
      else sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);
    } else {
      markType = this.parser.schema.marks[rule.mark];
      mark = markType.create(rule.attrs);
      this.addPendingMark(mark);
    }
    let startIn = this.top;

    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node));
    } else {
      let contentDOM = rule.contentElement;
      if (typeof contentDOM == "string") contentDOM = dom.querySelector(contentDOM);
      else if (typeof contentDOM == "function") contentDOM = contentDOM(dom);
      if (!contentDOM) contentDOM = dom;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, sync);
    }
    if (sync) { this.sync(startIn); this.open--; }
    if (mark) this.removePendingMark(mark);
    return true
  }

  // : (dom.Node, ?NodeBuilder, ?number, ?number)
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, sync, startIndex, endIndex) {
    let index = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,
             end = endIndex == null ? null : parent.childNodes[endIndex];
         dom != end; dom = dom.nextSibling, ++index) {
      this.findAtPoint(parent, index);
      this.addDOM(dom);
      if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))
        this.sync(sync);
    }
    this.findAtPoint(parent, index);
  }

  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node) {
    let route, sync;
    for (let depth = this.open; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found = cx.findWrapping(node);
      if (found && (!route || route.length > found.length)) {
        route = found;
        sync = cx;
        if (!found.length) break
      }
      if (cx.solid) break
    }
    if (!route) return false
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      this.enterInner(route[i], null, false);
    return true
  }

  // : (Node)  ?Node
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block) this.enterInner(block);
    }
    if (this.findPlace(node)) {
      this.closeExtra();
      let top = this.top;
      this.applyPendingMarks(top);
      if (top.match) top.match = top.match.matchType(node.type);
      let marks = top.activeMarks;
      for (let i = 0; i < node.marks.length; i++)
        if (!top.type || top.type.allowsMarkType(node.marks[i].type))
          marks = node.marks[i].addToSet(marks);
      top.content.push(node.mark(marks));
    }
  }

  applyPendingMarks(top) {
    for (let i = 0; i < this.pendingMarks.length; i++) {
      let mark = this.pendingMarks[i];
      if ((!top.type || top.type.allowsMarkType(mark.type)) && !mark.isInSet(top.activeMarks)) {
        top.activeMarks = mark.addToSet(top.activeMarks);
        this.pendingMarks.splice(i--, 1);
      }
    }
  }

  // : (NodeType, ?Object)  bool
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs, preserveWS) {
    let ok = this.findPlace(type.create(attrs));
    if (ok) {
      this.applyPendingMarks(this.top);
      this.enterInner(type, attrs, true, preserveWS);
    }
    return ok
  }

  // Open a node of the given type
  enterInner(type, attrs, solid, preserveWS) {
    this.closeExtra();
    let top = this.top;
    top.match = top.match && top.match.matchType(type, attrs);
    let options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);
    if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) options |= OPT_OPEN_LEFT;
    this.nodes.push(new NodeContext(type, attrs, top.activeMarks, solid, null, options));
    this.open++;
  }

  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }

  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(this.isOpen || this.options.topOpen)
  }

  sync(to) {
    for (let i = this.open; i >= 0; i--) if (this.nodes[i] == to) {
      this.open = i;
      return
    }
  }

  addPendingMark(mark) {
    this.pendingMarks.push(mark);
  }

  removePendingMark(mark) {
    let found = this.pendingMarks.lastIndexOf(mark);
    if (found > -1) {
      this.pendingMarks.splice(found, 1);
    } else {
      let top = this.top;
      top.activeMarks = mark.removeFromSet(top.activeMarks);
    }
  }

  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j = content.length - 1; j >= 0; j--)
        pos += content[j].nodeSize;
      if (i) pos++;
    }
    return pos
  }

  findAtPoint(parent, offset) {
    if (this.find) for (let i = 0; i < this.find.length; i++) {
      if (this.find[i].node == parent && this.find[i].offset == offset)
        this.find[i].pos = this.currentPos;
    }
  }

  findInside(parent) {
    if (this.find) for (let i = 0; i < this.find.length; i++) {
      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
        this.find[i].pos = this.currentPos;
    }
  }

  findAround(parent, content, before) {
    if (parent != content && this.find) for (let i = 0; i < this.find.length; i++) {
      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
        let pos = content.compareDocumentPosition(this.find[i].node);
        if (pos & (before ? 2 : 4))
          this.find[i].pos = this.currentPos;
      }
    }
  }

  findInText(textNode) {
    if (this.find) for (let i = 0; i < this.find.length; i++) {
      if (this.find[i].node == textNode)
        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
    }
  }

  // : (string)  bool
  // Determines whether the given [context
  // string](#ParseRule.context) matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this)

    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0) continue
          for (; depth >= minDepth; depth--)
            if (match(i - 1, depth)) return true
          return false
        } else {
          let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type
              : option && depth >= minDepth ? option.node(depth - minDepth).type
              : null;
          if (!next || (next.name != part && next.groups.indexOf(part) == -1))
            return false
          depth--;
        }
      }
      return true
    };
    return match(parts.length - 1, this.open)
  }

  textblockFromContext() {
    let $context = this.options.context;
    if ($context) for (let d = $context.depth; d >= 0; d--) {
      let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt
    }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs) return type
    }
  }
}

// Apply a CSS selector.
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)
}

// : (string)  [string]
// Tokenize a style attribute into property/value pairs.
function parseStyles(style) {
  let re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
  while (m = re.exec(style)) result.push(m[1], m[2].trim());
  return result
}

function copy(obj) {
  let copy = {};
  for (let prop in obj) copy[prop] = obj[prop];
  return copy
}

// DOMOutputSpec:: interface
// A description of a DOM structure. Can be either a string, which is
// interpreted as a text node, a DOM node, which is interpreted as
// itself, or an array.
//
// An array describes a DOM element. The first value in the array
// should be a stringthe name of the DOM element. If the second
// element is plain object, it is interpreted as a set of attributes
// for the element. Any elements after that (including the 2nd if it's
// not an attribute object) are interpreted as children of the DOM
// elements, and must either be valid `DOMOutputSpec` values, or the
// number zero.
//
// The number zero (pronounced hole) is used to indicate the place
// where a node's child nodes should be inserted. It it occurs in an
// output spec, it should be the only child element in its parent
// node.

// ::- A DOM serializer knows how to convert ProseMirror nodes and
// marks of various types to DOM nodes.
class DOMSerializer {
  // :: (Object<(node: Node)  DOMOutputSpec>, Object<?(mark: Mark, inline: bool)  DOMOutputSpec>)
  // Create a serializer. `nodes` should map node names to functions
  // that take a node and return a description of the corresponding
  // DOM. `marks` does the same for mark names, but also gets an
  // argument that tells it whether the mark's content is block or
  // inline content (for typical use, it'll always be inline). A mark
  // serializer may be `null` to indicate that marks of that type
  // should not be serialized.
  constructor(nodes, marks) {
    // :: Object<(node: Node)  DOMOutputSpec>
    // The node serialization functions.
    this.nodes = nodes || {};
    // :: Object<?(mark: Mark, inline: bool)  DOMOutputSpec>
    // The mark serialization functions.
    this.marks = marks || {};
  }

  // :: (Fragment, ?Object)  dom.DocumentFragment
  // Serialize the content of this fragment to a DOM fragment. When
  // not in the browser, the `document` option, containing a DOM
  // document, should be passed so that the serializer can create
  // nodes.
  serializeFragment(fragment, options = {}, target) {
    if (!target) target = doc(options).createDocumentFragment();

    let top = target, active = null;
    fragment.forEach(node => {
      if (active || node.marks.length) {
        if (!active) active = [];
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) { rendered++; continue }
          if (!next.eq(active[keep]) || next.type.spec.spanning === false) break
          keep += 2; rendered++;
        }
        while (keep < active.length) {
          top = active.pop();
          active.pop();
        }
        while (rendered < node.marks.length) {
          let add = node.marks[rendered++];
          let markDOM = this.serializeMark(add, node.isInline, options);
          if (markDOM) {
            active.push(add, top);
            top.appendChild(markDOM.dom);
            top = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top.appendChild(this.serializeNode(node, options));
    });

    return target
  }

  // :: (Node, ?Object)  dom.Node
  // Serialize this node to a DOM node. This can be useful when you
  // need to serialize a part of a document, as opposed to the whole
  // document. To serialize a whole document, use
  // [`serializeFragment`](#model.DOMSerializer.serializeFragment) on
  // its [content](#model.Node.content).
  serializeNode(node, options = {}) {
    let {dom, contentDOM} =
        DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec")
      if (options.onContent)
        options.onContent(node, contentDOM, options);
      else
        this.serializeFragment(node.content, options, contentDOM);
    }
    return dom
  }

  serializeNodeAndMarks(node, options = {}) {
    let dom = this.serializeNode(node, options);
    for (let i = node.marks.length - 1; i >= 0; i--) {
      let wrap = this.serializeMark(node.marks[i], node.isInline, options);
      if (wrap) {
(wrap.contentDOM || wrap.dom).appendChild(dom);
        dom = wrap.dom;
      }
    }
    return dom
  }

  serializeMark(mark, inline, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))
  }

  // :: (dom.Document, DOMOutputSpec)  {dom: dom.Node, contentDOM: ?dom.Node}
  // Render an [output spec](#model.DOMOutputSpec) to a DOM node. If
  // the spec has a hole (zero) in it, `contentDOM` will point at the
  // node with the hole.
  static renderSpec(doc, structure) {
    if (typeof structure == "string")
      return {dom: doc.createTextNode(structure)}
    if (structure.nodeType != null)
      return {dom: structure}
    let dom = doc.createElement(structure[0]), contentDOM = null;
    let attrs = structure[1], start = 1;
    if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start = 2;
      for (let name in attrs) {
        if (attrs[name] != null) dom.setAttribute(name, attrs[name]);
      }
    }
    for (let i = start; i < structure.length; i++) {
      let child = structure[i];
      if (child === 0) {
        if (i < structure.length - 1 || i > start)
          throw new RangeError("Content hole must be the only child of its parent node")
        return {dom, contentDOM: dom}
      } else {
        let {dom: inner, contentDOM: innerContent} = DOMSerializer.renderSpec(doc, child);
        dom.appendChild(inner);
        if (innerContent) {
          if (contentDOM) throw new RangeError("Multiple content holes")
          contentDOM = innerContent;
        }
      }
    }
    return {dom, contentDOM}
  }

  // :: (Schema)  DOMSerializer
  // Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)
  // properties in a schema's node and mark specs.
  static fromSchema(schema) {
    return schema.cached.domSerializer ||
      (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))
  }

  // : (Schema)  Object<(node: Node)  DOMOutputSpec>
  // Gather the serializers in a schema's node specs into an object.
  // This can be useful as a base to build a custom serializer from.
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text) result.text = node => node.text;
    return result
  }

  // : (Schema)  Object<(mark: Mark)  DOMOutputSpec>
  // Gather the serializers in a schema's mark specs into an object.
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks)
  }
}

function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM) result[name] = toDOM;
  }
  return result
}

function doc(options) {
  // declare global: window
  return options.document || window.document
}

function mustOverride() { throw new Error("Override me") }

const stepsByID = Object.create(null);

// ::- A step object represents an atomic change. It generally applies
// only to the document it was created for, since the positions
// stored in it will only make sense for that document.
//
// New steps are defined by creating classes that extend `Step`,
// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`
// methods, and registering your class with a unique
// JSON-serialization identifier using
// [`Step.jsonID`](#transform.Step^jsonID).
class Step {
  // :: (doc: Node)  StepResult
  // Applies this step to the given document, returning a result
  // object that either indicates failure, if the step can not be
  // applied to this document, or indicates success by containing a
  // transformed document.
  apply(_doc) { return mustOverride() }

  // :: ()  StepMap
  // Get the step map that represents the changes made by this step,
  // and which can be used to transform between positions in the old
  // and the new document.
  getMap() { return StepMap.empty }

  // :: (doc: Node)  Step
  // Create an inverted version of this step. Needs the document as it
  // was before the step as argument.
  invert(_doc) { return mustOverride() }

  // :: (mapping: Mappable)  ?Step
  // Map this step through a mappable thing, returning either a
  // version of that step with its positions adjusted, or `null` if
  // the step was entirely deleted by the mapping.
  map(_mapping) { return mustOverride() }

  // :: (other: Step)  ?Step
  // Try to merge this step with another one, to be applied directly
  // after it. Returns the merged step when possible, null if the
  // steps can't be merged.
  merge(_other) { return null }

  // :: ()  Object
  // Create a JSON-serializeable representation of this step. When
  // defining this for a custom subclass, make sure the result object
  // includes the step type's [JSON id](#transform.Step^jsonID) under
  // the `stepType` property.
  toJSON() { return mustOverride() }

  // :: (Schema, Object)  Step
  // Deserialize a step from its JSON representation. Will call
  // through to the step class' own implementation of this method.
  static fromJSON(schema, json) {
    if (!json || !json.stepType) throw new RangeError("Invalid input for Step.fromJSON")
    let type = stepsByID[json.stepType];
    if (!type) throw new RangeError(`No step type ${json.stepType} defined`)
    return type.fromJSON(schema, json)
  }

  // :: (string, constructor<Step>)
  // To be able to serialize steps to JSON, each step needs a string
  // ID to attach to its JSON representation. Use this method to
  // register an ID for your step classes. Try to pick something
  // that's unlikely to clash with steps from other modules.
  static jsonID(id, stepClass) {
    if (id in stepsByID) throw new RangeError("Duplicate use of step JSON ID " + id)
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass
  }
}

// ::- The result of [applying](#transform.Step.apply) a step. Contains either a
// new document or a failure value.
class StepResult {
  // : (?Node, ?string)
  constructor(doc, failed) {
    // :: ?Node The transformed document.
    this.doc = doc;
    // :: ?string Text providing information about a failed step.
    this.failed = failed;
  }

  // :: (Node)  StepResult
  // Create a successful step result.
  static ok(doc) { return new StepResult(doc, null) }

  // :: (string)  StepResult
  // Create a failed step result.
  static fail(message) { return new StepResult(null, message) }

  // :: (Node, number, number, Slice)  StepResult
  // Call [`Node.replace`](#model.Node.replace) with the given
  // arguments. Create a successful result if it succeeds, and a
  // failed one if it throws a `ReplaceError`.
  static fromReplace(doc, from, to, slice) {
    try {
      return StepResult.ok(doc.replace(from, to, slice))
    } catch (e) {
      if (e instanceof ReplaceError) return StepResult.fail(e.message)
      throw e
    }
  }
}

// ::- Replace a part of the document with a slice of new content.
class ReplaceStep extends Step {
  // :: (number, number, Slice, ?bool)
  // The given `slice` should fit the 'gap' between `from` and
  // `to`the depths must line up, and the surrounding nodes must be
  // able to be joined with the open sides of the slice. When
  // `structure` is true, the step will fail if the content between
  // from and to is not just a sequence of closing and then opening
  // tokens (this is to guard against rebased replace steps
  // overwriting something they weren't supposed to).
  constructor(from, to, slice, structure) {
    super();
    this.from = from;
    this.to = to;
    this.slice = slice;
    this.structure = !!structure;
  }

  apply(doc) {
    if (this.structure && contentBetween(doc, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content")
    return StepResult.fromReplace(doc, this.from, this.to, this.slice)
  }

  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size])
  }

  invert(doc) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))
  }

  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted) return null
    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)
  }

  merge(other) {
    if (!(other instanceof ReplaceStep) || other.structure != this.structure) return null

    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty
          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty
          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice, this.structure)
    } else {
      return null
    }
  }

  toJSON() {
    let json = {stepType: "replace", from: this.from, to: this.to};
    if (this.slice.size) json.slice = this.slice.toJSON();
    if (this.structure) json.structure = true;
    return json
  }

  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON")
    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)
  }
}

Step.jsonID("replace", ReplaceStep);

// ::- Replace a part of the document with a slice of content, but
// preserve a range of the replaced content by moving it into the
// slice.
class ReplaceAroundStep extends Step {
  // :: (number, number, number, number, Slice, number, ?bool)
  // Create a replace-around step with the given range and gap.
  // `insert` should be the point in the slice into which the content
  // of the gap should be moved. `structure` has the same meaning as
  // it has in the [`ReplaceStep`](#transform.ReplaceStep) class.
  constructor(from, to, gapFrom, gapTo, slice, insert, structure) {
    super();
    this.from = from;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice;
    this.insert = insert;
    this.structure = !!structure;
  }

  apply(doc) {
    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||
                           contentBetween(doc, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content")

    let gap = doc.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range")
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted) return StepResult.fail("Content does not fit in gap")
    return StepResult.fromReplace(doc, this.from, this.to, inserted)
  }

  getMap() {
    return new StepMap([this.from, this.gapFrom - this.from, this.insert,
                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])
  }

  invert(doc) {
    let gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,
                                 this.from + this.insert, this.from + this.insert + gap,
                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
                                 this.gapFrom - this.from, this.structure)
  }

  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) return null
    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)
  }

  toJSON() {
    let json = {stepType: "replaceAround", from: this.from, to: this.to,
                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert};
    if (this.slice.size) json.slice = this.slice.toJSON();
    if (this.structure) json.structure = true;
    return json
  }

  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" ||
        typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON")
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,
                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)
  }
}

Step.jsonID("replaceAround", ReplaceAroundStep);

function contentBetween(doc, from, to) {
  let $from = doc.resolve(from), dist = to - from, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf) return true
      next = next.firstChild;
      dist--;
    }
  }
  return false
}

function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) &&
    (end == node.childCount || node.canReplace(0, end))
}

// :: (NodeRange)  ?number
// Try to find a target depth to which the content in the given range
// can be lifted. Will not go across
// [isolating](#model.NodeSpec.isolating) parent nodes.
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth;; --depth) {
    let node = range.$from.node(depth);
    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex, content))
      return depth
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break
  }
}

// :: (NodeRange, number)  this
// Split the content in the given range off from its parent, if there
// is sibling content before or after it, and move it up the tree to
// the depth specified by `target`. You'll probably want to use
// [`liftTarget`](#transform.liftTarget) to compute `target`, to make
// sure the lift is valid.
Transform.prototype.lift = function(range, target) {
  let {$from, $to, depth} = range;

  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start = gapStart, end = gapEnd;

  let before = Fragment.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end++;
    }

  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,
                                         new Slice(before.append(after), openStart, openEnd),
                                         before.size - openStart, true))
};

// :: (NodeRange, NodeType, ?Object, ?NodeRange)  ?[{type: NodeType, attrs: ?Object}]
// Try to find a valid way to wrap the content in the given range in a
// node of the given type. May introduce extra nodes around and inside
// the wrapper node, if necessary. Returns null if no valid wrapping
// could be found. When `innerRange` is given, that range's content is
// used as the content to fit into the wrapping, instead of the
// content of `range`.
function findWrapping(range, nodeType, attrs, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner) return null
  return around.map(withAttrs).concat({type: nodeType, attrs}).concat(inner.map(withAttrs))
}

function withAttrs(type) { return {type, attrs: null} }

function findWrappingOutside(range, type) {
  let {parent, startIndex, endIndex} = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around) return null
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null
}

function findWrappingInside(range, type) {
  let {parent, startIndex, endIndex} = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside) return null
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex; innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd) return null
  return inside
}

// :: (NodeRange, [{type: NodeType, attrs: ?Object}])  this
// Wrap the given [range](#model.NodeRange) in the given set of wrappers.
// The wrappers are assumed to be valid in this position, and should
// probably be computed with [`findWrapping`](#transform.findWrapping).
Transform.prototype.wrap = function(range, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));

  let start = range.start, end = range.end;
  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))
};

// :: (number, ?number, NodeType, ?Object)  this
// Set the type of all textblocks (partly) between `from` and `to` to
// the given node type with the given attributes.
Transform.prototype.setBlockType = function(from, to = from, type, attrs) {
  if (!type.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock")
  let mapFrom = this.steps.length;
  this.doc.nodesBetween(from, to, (node, pos) => {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this.doc, this.mapping.slice(mapFrom).map(pos), type)) {
      // Ensure all markup that isn't allowed in the new node type is cleared
      this.clearIncompatible(this.mapping.slice(mapFrom).map(pos, 1), type);
      let mapping = this.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      this.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,
                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      return false
    }
  });
  return this
};

function canChangeType(doc, pos, type) {
  let $pos = doc.resolve(pos), index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type)
}

// :: (number, ?NodeType, ?Object, ?[Mark])  this
// Change the type, attributes, and/or marks of the node at `pos`.
// When `type` isn't given, the existing node type is preserved,
Transform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {
  let node = this.doc.nodeAt(pos);
  if (!node) throw new RangeError("No node at given position")
  if (!type) type = node.type;
  let newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return this.replaceWith(pos, pos + node.nodeSize, newNode)

  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name)

  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,
                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))
};

// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}])  bool
// Check whether splitting at the given position is allowed.
function canSplit(doc, pos, depth = 1, typesAfter) {
  let $pos = doc.resolve(pos), base = $pos.depth - depth;
  let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;
  if (base < 0 || $pos.parent.type.spec.isolating ||
      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||
      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false
  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
    let node = $pos.node(d), index = $pos.index(d);
    if (node.type.spec.isolating) return false
    let rest = node.content.cutByIndex(index, node.childCount);
    let after = (typesAfter && typesAfter[i]) || node;
    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs));
    if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))
      return false
  }
  let index = $pos.indexAfter(base);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)
}

// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}])  this
// Split the node at the given position, and optionally, if `depth` is
// greater than one, any number of nodes above that. By default, the
// parts split off will inherit the node type of the original node.
// This can be changed by passing an array of types and attributes to
// use after the split.
Transform.prototype.split = function(pos, depth = 1, typesAfter) {
  let $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = Fragment.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))
};

// :: (Node, number)  bool
// Test whether the blocks before and after a given position can be
// joined.
function canJoin(doc, pos) {
  let $pos = doc.resolve(pos), index = $pos.index();
  return joinable$1($pos.nodeBefore, $pos.nodeAfter) &&
    $pos.parent.canReplace(index, index + 1)
}

function joinable$1(a, b) {
  return a && b && !a.isLeaf && a.canAppend(b)
}

// :: (number, ?number)  this
// Join the blocks around the given position. If depth is 2, their
// last and first siblings are also joined, and so on.
Transform.prototype.join = function(pos, depth = 1) {
  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
  return this.step(step)
};

// :: (Node, number, NodeType)  ?number
// Try to find a point where a node of the given type can be inserted
// near `pos`, by searching up the node hierarchy when `pos` itself
// isn't a valid place but is at the start or end of a node. Return
// null if no position was found.
function insertPoint(doc, pos, nodeType) {
  let $pos = doc.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos

  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1)
      if (index > 0) return null
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.after(d + 1)
      if (index < $pos.node(d).childCount) return null
    }
}

// :: (Node, number, Slice)  ?number
// Finds a position at or around the given position where the given
// slice can be inserted. Will look at parent nodes' nearest boundary
// and try there, even if the original position wasn't directly at the
// start or end of that node. Returns null when no position was found.
function dropPoint(doc, pos, slice) {
  let $pos = doc.resolve(pos);
  if (!slice.content.size) return pos
  let content = slice.content;
  for (let i = 0; i < slice.openStart; i++) content = content.firstChild.content;
  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      if (pass == 1
          ? $pos.node(d).canReplace(insertPos, insertPos, content)
          : $pos.node(d).contentMatchAt(insertPos).findWrapping(content.firstChild.type))
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1)
    }
  }
  return null
}

function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size) child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline) child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped)
}

// ::- Add a mark to all inline content between two positions.
class AddMarkStep extends Step {
  // :: (number, number, Mark)
  constructor(from, to, mark) {
    super();
    this.from = from;
    this.to = to;
    this.mark = mark;
  }

  apply(doc) {
    let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {
      if (!parent.type.allowsMarkType(this.mark.type)) return node
      return node.mark(this.mark.addToSet(node.marks))
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc, this.from, this.to, slice)
  }

  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark)
  }

  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos) return null
    return new AddMarkStep(from.pos, to.pos, this.mark)
  }

  merge(other) {
    if (other instanceof AddMarkStep &&
        other.mark.eq(this.mark) &&
        this.from <= other.to && this.to >= other.from)
      return new AddMarkStep(Math.min(this.from, other.from),
                             Math.max(this.to, other.to), this.mark)
  }

  toJSON() {
    return {stepType: "addMark", mark: this.mark.toJSON(),
            from: this.from, to: this.to}
  }

  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON")
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))
  }
}

Step.jsonID("addMark", AddMarkStep);

// ::- Remove a mark from all inline content between two positions.
class RemoveMarkStep extends Step {
  // :: (number, number, Mark)
  constructor(from, to, mark) {
    super();
    this.from = from;
    this.to = to;
    this.mark = mark;
  }

  apply(doc) {
    let oldSlice = doc.slice(this.from, this.to);
    let slice = new Slice(mapFragment(oldSlice.content, node => {
      return node.mark(this.mark.removeFromSet(node.marks))
    }), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc, this.from, this.to, slice)
  }

  invert() {
    return new AddMarkStep(this.from, this.to, this.mark)
  }

  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos) return null
    return new RemoveMarkStep(from.pos, to.pos, this.mark)
  }

  merge(other) {
    if (other instanceof RemoveMarkStep &&
        other.mark.eq(this.mark) &&
        this.from <= other.to && this.to >= other.from)
      return new RemoveMarkStep(Math.min(this.from, other.from),
                                Math.max(this.to, other.to), this.mark)
  }

  toJSON() {
    return {stepType: "removeMark", mark: this.mark.toJSON(),
            from: this.from, to: this.to}
  }

  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON")
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))
  }
}

Step.jsonID("removeMark", RemoveMarkStep);

// :: (number, number, Mark)  this
// Add the given mark to the inline content between `from` and `to`.
Transform.prototype.addMark = function(from, to, mark) {
  let removed = [], added = [], removing = null, adding = null;
  this.doc.nodesBetween(from, to, (node, pos, parent) => {
    if (!node.isInline) return
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);

      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i]))
            removing.to = end;
          else
            removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
        }
      }

      if (adding && adding.to == start)
        adding.to = end;
      else
        added.push(adding = new AddMarkStep(start, end, mark));
    }
  });

  removed.forEach(s => this.step(s));
  added.forEach(s => this.step(s));
  return this
};

// :: (number, number, ?union<Mark, MarkType>)  this
// Remove marks from inline nodes between `from` and `to`. When `mark`
// is a single mark, remove precisely that mark. When it is a mark type,
// remove all marks of that type. When it is null, remove all marks of
// any type.
Transform.prototype.removeMark = function(from, to, mark = null) {
  let matched = [], step = 0;
  this.doc.nodesBetween(from, to, (node, pos) => {
    if (!node.isInline) return
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let found = mark.isInSet(node.marks);
      if (found) toRemove = [found];
    } else if (mark) {
      if (mark.isInSet(node.marks)) toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end = Math.min(pos + node.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style = toRemove[i], found;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style.eq(matched[j].style)) found = m;
        }
        if (found) {
          found.to = end;
          found.step = step;
        } else {
          matched.push({style, from: Math.max(pos, from), to: end, step});
        }
      }
    }
  });
  matched.forEach(m => this.step(new RemoveMarkStep(m.from, m.to, m.style)));
  return this
};

// :: (number, NodeType, ?ContentMatch)  this
// Removes all marks and nodes from the content of the node at `pos`
// that don't match the given new parent node type. Accepts an
// optional starting [content match](#model.ContentMatch) as third
// argument.
Transform.prototype.clearIncompatible = function(pos, parentType, match = parentType.contentMatch) {
  let node = this.doc.nodeAt(pos);
  let delSteps = [], cur = pos + 1;
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i), end = cur + child.nodeSize;
    let allowed = match.matchType(child.type, child.attrs);
    if (!allowed) {
      delSteps.push(new ReplaceStep(cur, end, Slice.empty));
    } else {
      match = allowed;
      for (let j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type))
        this.step(new RemoveMarkStep(cur, end, child.marks[j]));
    }
    cur = end;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    this.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = delSteps.length - 1; i >= 0; i--) this.step(delSteps[i]);
  return this
};

// :: (Node, number, ?number, ?Slice)  ?Step
// Fit a slice into a given position in the document, producing a
// [step](#transform.Step) that inserts it. Will return null if
// there's no meaningful way to insert the slice here, or inserting it
// would be a no-op (an empty slice over an empty range).
function replaceStep(doc, from, to = from, slice = Slice.empty) {
  if (from == to && !slice.size) return null

  let $from = doc.resolve(from), $to = doc.resolve(to);
  // Optimization -- avoid work if it's obvious that it's not needed.
  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice)
  let placed = placeSlice($from, slice);

  let fittedLeft = fitLeft($from, placed);
  let fitted = fitRight($from, $to, fittedLeft);
  if (!fitted) return null
  if (fittedLeft.size != fitted.size && canMoveText($from, $to, fittedLeft)) {
    let d = $to.depth, after = $to.after(d);
    while (d > 1 && after == $to.end(--d)) ++after;
    let fittedAfter = fitRight($from, doc.resolve(after), fittedLeft);
    if (fittedAfter)
      return new ReplaceAroundStep(from, after, to, $to.end(), fittedAfter, fittedLeft.size)
  }
  return fitted.size || from != to ? new ReplaceStep(from, to, fitted) : null
}

// :: (number, ?number, ?Slice)  this
// Replace the part of the document between `from` and `to` with the
// given `slice`.
Transform.prototype.replace = function(from, to = from, slice = Slice.empty) {
  let step = replaceStep(this.doc, from, to, slice);
  if (step) this.step(step);
  return this
};

// :: (number, number, union<Fragment, Node, [Node]>)  this
// Replace the given range with the given content, which may be a
// fragment, node, or array of nodes.
Transform.prototype.replaceWith = function(from, to, content) {
  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))
};

// :: (number, number)  this
// Delete the content between the given positions.
Transform.prototype.delete = function(from, to) {
  return this.replace(from, to, Slice.empty)
};

// :: (number, union<Fragment, Node, [Node]>)  this
// Insert the given content at the given position.
Transform.prototype.insert = function(pos, content) {
  return this.replaceWith(pos, pos, content)
};



function fitLeftInner($from, depth, placed, placedBelow) {
  let content = Fragment.empty, openEnd = 0, placedHere = placed[depth];
  if ($from.depth > depth) {
    let inner = fitLeftInner($from, depth + 1, placed, placedBelow || placedHere);
    openEnd = inner.openEnd + 1;
    content = Fragment.from($from.node(depth + 1).copy(inner.content));
  }

  if (placedHere) {
    content = content.append(placedHere.content);
    openEnd = placedHere.openEnd;
  }
  if (placedBelow) {
    content = content.append($from.node(depth).contentMatchAt($from.indexAfter(depth)).fillBefore(Fragment.empty, true));
    openEnd = 0;
  }

  return {content, openEnd}
}

function fitLeft($from, placed) {
  let {content, openEnd} = fitLeftInner($from, 0, placed, false);
  return new Slice(content, $from.depth, openEnd || 0)
}

function fitRightJoin(content, parent, $from, $to, depth, openStart, openEnd) {
  let match, count = content.childCount, matchCount = count - (openEnd > 0 ? 1 : 0);
  let parentNode = openStart < 0 ? parent : $from.node(depth);
  if (openStart < 0)
    match = parentNode.contentMatchAt(matchCount);
  else if (count == 1 && openEnd > 0)
    match = parentNode.contentMatchAt(openStart ? $from.index(depth) : $from.indexAfter(depth));
  else
    match = parentNode.contentMatchAt($from.indexAfter(depth))
      .matchFragment(content, count > 0 && openStart ? 1 : 0, matchCount);

  let toNode = $to.node(depth);
  if (openEnd > 0 && depth < $to.depth) {
    let after = toNode.content.cutByIndex($to.indexAfter(depth)).addToStart(content.lastChild);
    let joinable = match.fillBefore(after, true);
    // Can't insert content if there's a single node stretched across this gap
    if (joinable && joinable.size && openStart > 0 && count == 1) joinable = null;

    if (joinable) {
      let inner = fitRightJoin(content.lastChild.content, content.lastChild, $from, $to,
                               depth + 1, count == 1 ? openStart - 1 : -1, openEnd - 1);
      if (inner) {
        let last = content.lastChild.copy(inner);
        if (joinable.size)
          return content.cutByIndex(0, count - 1).append(joinable).addToEnd(last)
        else
          return content.replaceChild(count - 1, last)
      }
    }
  }
  if (openEnd > 0)
    match = match.matchType((count == 1 && openStart > 0 ? $from.node(depth + 1) : content.lastChild).type);

  // If we're here, the next level can't be joined, so we see what
  // happens if we leave it open.
  let toIndex = $to.index(depth);
  if (toIndex == toNode.childCount && !toNode.type.compatibleContent(parent.type)) return null
  let joinable = match.fillBefore(toNode.content, true, toIndex);
  for (let i = toIndex; joinable && i < toNode.content.childCount; i++)
    if (!parentNode.type.allowsMarks(toNode.content.child(i).marks)) joinable = null;
  if (!joinable) return null

  if (openEnd > 0) {
    let closed = fitRightClosed(content.lastChild, openEnd - 1, $from, depth + 1,
                                count == 1 ? openStart - 1 : -1);
    content = content.replaceChild(count - 1, closed);
  }
  content = content.append(joinable);
  if ($to.depth > depth)
    content = content.addToEnd(fitRightSeparate($to, depth + 1));
  return content
}

function fitRightClosed(node, openEnd, $from, depth, openStart) {
  let match, content = node.content, count = content.childCount;
  if (openStart >= 0)
    match = $from.node(depth).contentMatchAt($from.indexAfter(depth))
      .matchFragment(content, openStart > 0 ? 1 : 0, count);
  else
    match = node.contentMatchAt(count);

  if (openEnd > 0) {
    let closed = fitRightClosed(content.lastChild, openEnd - 1, $from, depth + 1,
                                count == 1 ? openStart - 1 : -1);
    content = content.replaceChild(count - 1, closed);
  }

  return node.copy(content.append(match.fillBefore(Fragment.empty, true)))
}

function fitRightSeparate($to, depth) {
  let node = $to.node(depth);
  let fill = node.contentMatchAt(0).fillBefore(node.content, true, $to.index(depth));
  if ($to.depth > depth) fill = fill.addToEnd(fitRightSeparate($to, depth + 1));
  return node.copy(fill)
}

function normalizeSlice(content, openStart, openEnd) {
  while (openStart > 0 && openEnd > 0 && content.childCount == 1) {
    content = content.firstChild.content;
    openStart--;
    openEnd--;
  }
  return new Slice(content, openStart, openEnd)
}

// : (ResolvedPos, ResolvedPos, number, Slice)  Slice
function fitRight($from, $to, slice) {
  let fitted = fitRightJoin(slice.content, $from.node(0), $from, $to, 0, slice.openStart, slice.openEnd);
  if (!fitted) return null
  return normalizeSlice(fitted, slice.openStart, $to.depth)
}

function fitsTrivially($from, $to, slice) {
  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&
    $from.parent.canReplace($from.index(), $to.index(), slice.content)
}

function canMoveText($from, $to, slice) {
  if (!$to.parent.isTextblock) return false

  let parent = slice.openEnd ? nodeRight(slice.content, slice.openEnd)
      : $from.node($from.depth - (slice.openStart - slice.openEnd));
  if (!parent.isTextblock) return false
  for (let i = $to.index(); i < $to.parent.childCount; i++)
    if (!parent.type.allowsMarks($to.parent.child(i).marks)) return false
  let match;
  if (slice.openEnd) {
    match = parent.contentMatchAt(parent.childCount);
  } else {
    match = parent.contentMatchAt(parent.childCount);
    if (slice.size) match = match.matchFragment(slice.content, slice.openStart ? 1 : 0);
  }
  match = match.matchFragment($to.parent.content, $to.index());
  return match && match.validEnd
}

function nodeRight(content, depth) {
  for (let i = 1; i < depth; i++) content = content.lastChild.content;
  return content.lastChild
}

// Algorithm for 'placing' the elements of a slice into a gap:
//
// We consider the content of each node that is open to the left to be
// independently placeable. I.e. in <p("foo"), p("bar")>, when the
// paragraph on the left is open, "foo" can be placed (somewhere on
// the left side of the replacement gap) independently from p("bar").
//
// So placeSlice splits up a slice into a number of sub-slices,
// along with information on where they can be placed on the given
// left-side edge. It works by walking the open side of the slice,
// from the inside out, and trying to find a landing spot for each
// element, by simultaneously scanning over the gap side. When no
// place is found for an open node's content, it is left in that node.

// : (ResolvedPos, Slice)  [{content: Fragment, openEnd: number, depth: number}]
function placeSlice($from, slice) {
  let frontier = new Frontier($from);
  for (let pass = 1; slice.size && pass <= 3; pass++) {
    let value = frontier.placeSlice(slice.content, slice.openStart, slice.openEnd, pass);
    if (pass == 3 && value != slice && value.size) pass = 0; // Restart if the 3rd pass made progress but left content
    slice = value;
  }
  while (frontier.open.length) frontier.closeNode();
  return frontier.placed
}

// Helper class that models the open side of the insert position,
// keeping track of the content match and already inserted content
// at each depth.
class Frontier {
  constructor($pos) {
    // : [{parent: Node, match: ContentMatch, content: Fragment, wrapper: bool, openEnd: number, depth: number}]
    this.open = [];
    for (let d = 0; d <= $pos.depth; d++) {
      let parent = $pos.node(d), match = parent.contentMatchAt($pos.indexAfter(d));
      this.open.push({parent, match, content: Fragment.empty, wrapper: false, openEnd: 0, depth: d});
    }
    this.placed = [];
  }

  // : (Fragment, number, number, number, ?Node)  Slice
  // Tries to place the content of the given slice, and returns a
  // slice containing unplaced content.
  //
  // pass 1: try to fit directly
  // pass 2: allow wrapper nodes to be introduced
  // pass 3: allow unwrapping of nodes that aren't open
  placeSlice(fragment, openStart, openEnd, pass, parent) {
    if (openStart > 0) {
      let first = fragment.firstChild;
      let inner = this.placeSlice(first.content, Math.max(0, openStart - 1),
                                  openEnd && fragment.childCount == 1 ? openEnd - 1 : 0,
                                  pass, first);
      if (inner.content != first.content) {
        if (inner.content.size) {
          fragment = fragment.replaceChild(0, first.copy(inner.content));
          openStart = inner.openStart + 1;
        } else {
          if (fragment.childCount == 1) openEnd = 0;
          fragment = fragment.cutByIndex(1);
          openStart = 0;
        }
      }
    }
    let result = this.placeContent(fragment, openStart, openEnd, pass, parent);
    if (pass > 2 && result.size && openStart == 0) {
      let child = result.content.firstChild, single = result.content.childCount == 1;
      this.placeContent(child.content, 0, openEnd && single ? openEnd - 1 : 0, pass, child);
      result = single ? Fragment.empty : new Slice(result.content.cutByIndex(1), 0, openEnd);
    }
    return result
  }

  placeContent(fragment, openStart, openEnd, pass, parent) {
    let i = 0;
    // Go over the fragment's children
    for (; i < fragment.childCount; i++) {
      let child = fragment.child(i), placed = false, last = i == fragment.childCount - 1;
      // Try each open node in turn, starting from the innermost
      for (let d = this.open.length - 1; d >= 0; d--) {
        let open = this.open[d], wrap;

        // If pass > 1, it is allowed to wrap the node to help find a
        // fit, so if findWrapping returns something, we add open
        // nodes to the frontier for that wrapping.
        if (pass > 1 && (wrap = open.match.findWrapping(child.type)) &&
            !(parent && wrap.length && wrap[wrap.length - 1] == parent.type)) {
          while (this.open.length - 1 > d) this.closeNode();
          for (let w = 0; w < wrap.length; w++) {
            open.match = open.match.matchType(wrap[w]);
            d++;
            open = {parent: wrap[w].create(),
                    match: wrap[w].contentMatch,
                    content: Fragment.empty, wrapper: true, openEnd: 0, depth: d + w};
            this.open.push(open);
          }
        }

        // See if the child fits here
        let match = open.match.matchType(child.type);
        if (!match) {
          let fill = open.match.fillBefore(Fragment.from(child));
          if (fill) {
            for (let j = 0; j < fill.childCount; j++) {
              let ch = fill.child(j);
              this.addNode(open, ch, 0);
              match = open.match.matchFragment(ch);
            }
          } else if (parent && open.match.matchType(parent.type)) {
            // Don't continue looking further up if the parent node
            // would fit here.
            break
          } else {
            continue
          }
        }

        // Close open nodes above this one, since we're starting to
        // add to this.
        while (this.open.length - 1 > d) this.closeNode();
        // Strip marks from the child or close its start when necessary
        child = child.mark(open.parent.type.allowedMarks(child.marks));
        if (openStart) {
          child = closeNodeStart(child, openStart, last ? openEnd : 0);
          openStart = 0;
        }
        // Add the child to this open node and adjust its metadata
        this.addNode(open, child, last ? openEnd : 0);
        open.match = match;
        if (last) openEnd = 0;
        placed = true;
        break
      }
      // As soon as we've failed to place a node we stop looking at
      // later nodes
      if (!placed) break
    }
    // Close the current open node if it's not the the root and we
    // either placed up to the end of the node or the the current
    // slice depth's node type matches the open node's type
    if (this.open.length > 1 &&
        (i > 0 && i == fragment.childCount ||
         parent && this.open[this.open.length - 1].parent.type == parent.type))
      this.closeNode();

    return new Slice(fragment.cutByIndex(i), openStart, openEnd)
  }

  addNode(open, node, openEnd) {
    open.content = closeFragmentEnd(open.content, open.openEnd).addToEnd(node);
    open.openEnd = openEnd;
  }

  closeNode() {
    let open = this.open.pop();
    if (open.content.size == 0) ; else if (open.wrapper) {
      this.addNode(this.open[this.open.length - 1], open.parent.copy(open.content), open.openEnd + 1);
    } else {
      this.placed[open.depth] = {depth: open.depth, content: open.content, openEnd: open.openEnd};
    }
  }
}

function closeNodeStart(node, openStart, openEnd) {
  let content = node.content;
  if (openStart > 1) {
    let first = closeNodeStart(node.firstChild, openStart - 1, node.childCount == 1 ? openEnd - 1 : 0);
    content = node.content.replaceChild(0, first);
  }
  let fill = node.type.contentMatch.fillBefore(content, openEnd == 0);
  return node.copy(fill.append(content))
}

function closeNodeEnd(node, depth) {
  let content = node.content;
  if (depth > 1) {
    let last = closeNodeEnd(node.lastChild, depth - 1);
    content = node.content.replaceChild(node.childCount - 1, last);
  }
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(content.append(fill))
}

function closeFragmentEnd(fragment, depth) {
  return depth ? fragment.replaceChild(fragment.childCount - 1, closeNodeEnd(fragment.lastChild, depth)) : fragment
}

// :: (number, number, Slice)  this
// Replace a range of the document with a given slice, using `from`,
// `to`, and the slice's [`openStart`](#model.Slice.openStart) property
// as hints, rather than fixed start and end points. This method may
// grow the replaced area or close open nodes in the slice in order to
// get a fit that is more in line with WYSIWYG expectations, by
// dropping fully covered parent nodes of the replaced region when
// they are marked [non-defining](#model.NodeSpec.defining), or
// including an open parent node from the slice that _is_ marked as
// [defining](#model.NodeSpec.defining).
//
// This is the method, for example, to handle paste. The similar
// [`replace`](#transform.Transform.replace) method is a more
// primitive tool which will _not_ move the start and end of its given
// range, and is useful in situations where you need more precise
// control over what happens.
Transform.prototype.replaceRange = function(from, to, slice) {
  if (!slice.size) return this.deleteRange(from, to)

  let $from = this.doc.resolve(from), $to = this.doc.resolve(to);
  if (fitsTrivially($from, $to, slice))
    return this.step(new ReplaceStep(from, to, slice))

  let targetDepths = coveredDepths($from, this.doc.resolve(to));
  // Can't replace the whole document, so remove 0 if it's present
  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop();
  // Negative numbers represent not expansion over the whole node at
  // that depth, but replacing from $from.before(-D) to $to.pos.
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  // This loop picks a preferred target depth, if one of the covering
  // depths is not outside of a defining node, and adds negative
  // depths for any depth that has $from at its start and does not
  // cross a defining node.
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.isolating) break
    if (targetDepths.indexOf(d) > -1) preferredTarget = d;
    else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d);
  }
  // Try to fit each possible depth of the slice into each possible
  // target depth, starting with the preferred depths.
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);

  let leftNodes = [], preferredDepth = slice.openStart;
  for (let content = slice.content, i = 0;; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice.openStart) break
    content = node.content;
  }
  // Back up if the node directly above openStart, or the node above
  // that separated only by a non-defining textblock node, is defining.
  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&
      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)
    preferredDepth -= 1;
  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&
           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)
    preferredDepth -= 2;

  for (let j = slice.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert) continue
    for (let i = 0; i < targetDepths.length; i++) {
      // Loop over possible expansion levels, starting with the
      // preferred one
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth; }
      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks))
        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,
                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),
                                      openDepth, slice.openEnd))
    }
  }

  let startSteps = this.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    this.replace(from, to, slice);
    if (this.steps.length > startSteps) break
    let depth = targetDepths[i];
    if (i < 0) continue
    from = $from.before(depth); to = $to.after(depth);
  }
  return this
};

function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }
  if (depth > newOpen)
    fragment = parent.contentMatchAt(0).fillBefore(fragment, true).append(fragment);
  return fragment
}

// :: (number, number, Node)  this
// Replace the given range with a node, but use `from` and `to` as
// hints, rather than precise positions. When from and to are the same
// and are at the start or end of a parent node in which the given
// node doesn't fit, this method may _move_ them out towards a parent
// that does allow the given node to be placed. When the given range
// completely covers a parent node, this method may completely replace
// that parent node.
Transform.prototype.replaceRangeWith = function(from, to, node) {
  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {
    let point = insertPoint(this.doc, from, node.type);
    if (point != null) from = to = point;
  }
  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))
};

// :: (number, number)  this
// Delete the given range, expanding it to cover fully covered
// parent nodes until a valid replace is found.
Transform.prototype.deleteRange = function(from, to) {
  let $from = this.doc.resolve(from), $to = this.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last = i == covered.length - 1;
    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)
      return this.delete($from.start(depth), $to.end(depth))
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return this.delete($from.before(depth), $to.after(depth))
  }
  for (let d = 1; d <= $from.depth; d++) {
    if (from - $from.start(d) == $from.depth - d && to > $from.end(d))
      return this.delete($from.before(d), to)
  }
  return this.delete(from, to)
};

// : (ResolvedPos, ResolvedPos)  [number]
// Returns an array of all depths for which $from - $to spans the
// whole content of the nodes at that depth.
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) ||
        $to.end(d) > $to.pos + ($to.depth - d) ||
        $from.node(d).type.spec.isolating ||
        $to.node(d).type.spec.isolating) break
    if (start == $to.start(d)) result.push(d);
  }
  return result
}

/** Update Component Command
 *
 * Command JSON format:
 * {
 *   "type":"literatePageTransaction",
 *   "memberId":(main member full name),
 *   "steps":(steps json)
 * }
 */ 
let literatepagetransaction = {};

//=====================================
// Command Object
//=====================================

literatepagetransaction.createUndoCommand = function(workspaceManager,commandData) {
    
    if(commandData.undoSteps) {
        //temporary implementation
        var undoCommandData = {};
        undoCommandData.type = literatepagetransaction.commandInfo.type;
        undoCommandData.steps = commandData.undoSteps;
        undoCommandData.startSelection = commandData.endSelection;
        undoCommandData.startMarks = commandData.endMarks;
        undoCommandData.endSelection = commandData.startSelection;
        undoCommandData.endMarks = commandData.startMarks;
        undoCommandData.memberId = commandData.memberId;
        return undoCommandData;
    }
    else {
        return null;
    }
};


literatepagetransaction.executeCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getMutableModelManager();
    let componentId = modelManager.getComponentIdByMemberId(commandData.memberId);
    let component = modelManager.getMutableComponentByComponentId(componentId);

    let oldDocument = component.getDocument();
    let schema = component.getSchema();
            
    let newDocument = updateDocument(oldDocument,schema,commandData);

    if(newDocument) {
        //create the editor state info if we have it
        let editorStateInfo;
        if((commandData.endSelection)||(commandData.endMarks)) {
            editorStateInfo = {};
            editorStateInfo.selection = commandData.endSelection;
            editorStateInfo.storedMarks = commandData.endMarks;
        }

        //set the document. Also set some editor state that accompanies the document.
        //this editor state inof should only be stored temporarily, and not be maintained in the component.
        component.setDocument(newDocument,editorStateInfo);
    }
    else {
        throw new Error("Unknown error updating document");
    }
};

function updateDocument(initialDocument, schema, commandData) {

    //apply the editor transaction
    var transform = new Transform(initialDocument);

    //apply the steps
    commandData.steps.forEach(stepJson => {
      try {
        var step = Step.fromJSON(schema, stepJson);
        transform = transform.step(step);
      }
      catch (error) {
        if(error.stack) console.error(error.stack);
        console.log("Step failed: " + JSON.stringify(stepJson));
        return null;
      }
    });

    return transform.doc;
  }

literatepagetransaction.commandInfo = {
    "type": "literatePageTransaction",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(literatepagetransaction);

// :: Schema
// This the schema for the apogee page editor
function createFolderSchema(app,pageMemberId) {

  // :: Object
  // [Specs](#model.NodeSpec) for the nodes defined in this schema.
  const nodes = {
    // :: NodeSpec The top level document node.
    doc: {
      content: "(block | list | workerParent | apogeeComponent)+"
    },

    // :: NodeSpec A plain paragraph textblock. Represented in the DOM
    // as a `<p>` element.
    paragraph: {
      content: "inline*",
      group: "block",
      parseDOM: [{ tag: "p" }],
      toDOM() { return ["p", 0] }
    },

    heading1: {
      content: "inline*",
      group: "block",
      defining: true,
      parseDOM: [{ tag: "h1" }],
      toDOM(node) { return ["h1", 0] }
    },

    heading2: {
      content: "inline*",
      group: "block",
      defining: true,
      parseDOM: [{ tag: "h2" }],
      toDOM(node) { return ["h2", 0] }
    },

    heading3: {
      content: "inline*",
      group: "block",
      defining: true,
      parseDOM: [{ tag: "h3" }],
      toDOM(node) { return ["h3", 0] }
    },

    heading4: {
      content: "inline*",
      group: "block",
      defining: true,
      parseDOM: [{ tag: "h4" }],
      toDOM(node) { return ["h4", 0] }
    },

    bulletList: {
      content: "(listItem | list)+",
      group: "list",
      defining: true,
      parseDOM: [{ tag: "ul" }],
      toDOM(node) { return ["ul", 0] }
    },

    numberedList: {
      content: "(listItem | list)+",
      group: "list",
      defining: true,
      parseDOM: [{ tag: "ol" }],
      toDOM(node) { return ["ol", 0] }
    },

    listItem: {
      content: "inline*",
      parseDOM: [{ tag: "li" }],
      toDOM() { return ["li", 0] }
    },

    //this is used only to legally transition between states.
    //there is probably a better way of doing this...
    workerParent: {
      content: "(block | listItem | list | apogeeComponent )+",
      parseDOM: [{ tag: "w-p" }],
      toDOM(node) { return ["w-p", 0] }
    },

    // :: NodeSpec The text node.
    text: {
      group: "inline"
    },

    // :: NodeSpec An inline image (`<img>`) node. Supports `src`,
    // `alt`, and `href` attributes. The latter two default to the empty
    // string.
    image: {
      inline: true,
      attrs: {
        src: {},
        alt: { default: null },
        title: { default: null }
      },
      group: "inline",
      draggable: true,
      parseDOM: [{
        tag: "img[src]", getAttrs(dom) {
          return {
            src: dom.getAttribute("src"),
            title: dom.getAttribute("title"),
            alt: dom.getAttribute("alt")
          }
        }
      }],
      toDOM(node) { let { src, alt, title } = node.attrs; return ["img", { src, alt, title }] }
    },

    apogeeComponent: {
      marks: "",
      atom: true,
      defining: true,
      isolating: true,

      //TEMP TEST////
      hasInteractiveSelection: true,
      ///////////////

      attrs: { 
        "name": { default: "" },
        "id": {default: 0}, //to be used later?
        "state": { default: "" } //this is only used for transient loading, then erased
      },
      toDOM: node => {
        let name = node.attrs.name;

        let modelManager = app.getWorkspaceManager().getModelManager();
        let model = modelManager.getModel();

        let pageMember = model.lookupMemberById(pageMemberId);
        let nodeMemberId = pageMember.lookupChildId(name);
        let nodeComponentId = modelManager.getComponentIdByMemberId(nodeMemberId);
        let nodeComponent = modelManager.getComponentByComponentId(nodeComponentId);
        let nodeMember = nodeComponent.getMember();

        let state = {};
        state.memberJson = nodeMember ? nodeMember.toJson(modelManager.getModel()) : undefined;
        state.componentJson = nodeComponent ? nodeComponent.toJson(modelManager) : undefined;

        return ["div", { "data-name":name, "data-state": JSON.stringify(state) }]
      },
      parseDOM: [{
        tag: "div[data-name]",
        getAttrs: (dom) => {
          let name = dom.getAttribute("data-name");
          let stateString = dom.getAttribute("data-state");
          let state;
          if(stateString) {
            try {
              state =  JSON.parse(stateString);
            }
            catch(error) {
              //FIGURE OUT HOW TO HANDLE THIS ERROR!!!
              console.log("Error parsing entered component: ") + name;
              if(error.stack) console.error(error.stack);
              state = undefined;
            }
          }
          return { name, state };
        }
      }]
    }
  };

  // :: Object [Specs](#model.MarkSpec) for the marks in the schema.
  const marks = {
    // :: MarkSpec A link. Has `href` and `title` attributes. `title`
    // defaults to the empty string. Rendered and parsed as an `<a>`
    // element.
    link: {
      attrs: {
        href: {},
        title: { default: null }
      },
      inclusive: false,
      parseDOM: [{
        tag: "a[href]", getAttrs(dom) {
          return { href: dom.getAttribute("href"), title: dom.getAttribute("title") }
        }
      }],
      toDOM(node) { let { href, title } = node.attrs; return ["a", { href, title }, 0] }
    },

    // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.
    // Has parse rules that also match `<i>` and `font-style: italic`.
    italic: {
      parseDOM: [{ tag: "i" }, { tag: "em" }, { style: "font-style=italic" }],
      toDOM() { return ["em", 0] }
    },

    // :: MarkSpec A strong mark. Rendered as `<b>`, parse rules
    // also match `<strong>` and `font-weight: bold`.
    bold: {
      parseDOM: [{ tag: "strong" },
      // This works around a Google Docs misbehavior where
      // pasted content will be inexplicably wrapped in `<b>`
      // tags with a font-weight normal.
      { tag: "b", getAttrs: node => node.style.fontWeight != "normal" && null },
      { style: "font-weight", getAttrs: value => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null }],
      toDOM() { return ["b", 0] }
    },

    textcolor: {
      attrs: {
        color: { default: "black" }
      },
      parseDOM: [{
        tag: "clr-tag", style: "color", getAttrs(dom) {
          return { color: dom.style.color };
        }
      }],
      toDOM(node) { return ["clr-tag", { "style": "color:" + node.attrs["color"] + ";" }, 0] }
    },

    fontsize: {
      attrs: {
        fontsize: { default: "" }
      },
      parseDOM: [{
        tag: "fntsz-tag", style: "font-size", getAttrs(dom) {
          return { fontsize: dom.style["font-size"] };
        }
      }],
      toDOM(node) { return ["fntsz-tag", { "style": "font-size:" + node.attrs["fontsize"] + ";" }, 0] }
    },

    fontfamily: {
      attrs: {
        fontfamily: { default: "Sans-serif" }
      },
      parseDOM: [{
        tag: "fntfam-tag", style: "font-family", getAttrs(dom) {
          return { fontsize: dom.style["font-family"] };
        }
      }],
      toDOM(node) { return ["fntfam-tag", { "style": "font-family:" + node.attrs.fontfamily + ";" }, 0] }
    },

    highlight: {
      attrs: {
        color: { default: "white" }
      },
      parseDOM: [{
        tag: "bgd-tag", style: "background-color", getAttrs(dom) {
          return { "color": dom.style["background-color"] };
        }
      }],
      toDOM(node) { return ["bgd-tag", { "style": "background-color:" + node.attrs["color"] + ";" }, 0] }
    }

  };


  return new Schema({ nodes, marks })
}

/** This is the base class for a parent component (an object that has children),
 * It extends the component class. */
class ParentComponent extends Component {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //base constructor
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);

        //==============
        //Fields
        //==============
        //The following fields are added by the parent component. In order to add these, the method
        //"initializeSchema" must be called. See the notes on that method.
        //"schema"
        //"document"

        //==============
        //Working variables
        //==============
        this.tempEditorStateInfo = null;
 
    }

    getSchema() {
        return this.getField("schema");
    }

    /** This method sets the document. It also allows for temporarily storing some editor info 
     * to accompany a set document */
    setDocument(document,editorStateInfo) {
        //for now set dummy data to show a change
        this.setField("document",document);

        //set the temporary editor state, to be used with the new document
        if(editorStateInfo) this.tempEditorStateInfo = editorStateInfo;
    }

    getDocument() {
        return this.getField("document");
    }

    /** This method retrieves the editor state info that acompanies the set document.
     * The argument doClearInfo, if true, will trigger the stored state info to be cleared.
     * This field is meant purely as a temporary storage and should be cleared once it is read. */
    getEditorStateInfo(doClearInfo) {
        let tempEditorStateInfo = this.tempEditorStateInfo;
        if(doClearInfo) {
            this.tempEditorStateInfo = null;
        }
        return tempEditorStateInfo;
    }

    instantiateTabDisplay() {
        let member = this.getMember();
        let folder = this.getParentFolderForChildren();
        return new LiteratePageComponentDisplay(this,member,folder); 
    }

    /** This method should be called only when a new component is created, and not when it is copied. It creates the schema
     * and an initial empty document for the page. It should be called after the parent folder for the page children is initialized.
     * Preferebly it is called from the constructor, if there is not a reason to wait longer.. */
    initializeSchema(modelManager) {
        let pageFolderMember = this.getParentFolderForChildren();
        let schema = createFolderSchema(modelManager.getApp(),pageFolderMember.getId());
        this.setField("schema",schema);
        //initialize with an empty document
        let document = this._createEmptyDocument(schema);
        this.setField("document",document);
    }

    //==============================
    // serialization
    //==============================

    /** This serializes the table component. */
    writeToJson(json,modelManager) {
        //save the editor state
        let document = this.getField("document");
        if(document) {
            json.data = {};
            json.data.doc = document.toJSON();
        }
        
        //save the children
        var folder = this.getParentFolderForChildren();
        var childrenPresent = false;
        var children = {};
        var childIdMap = folder.getChildIdMap();
        for(var key in childIdMap) {
            var childId = childIdMap[key];
            var childComponentId = modelManager.getComponentIdByMemberId(childId);
            var childComponent = modelManager.getComponentByComponentId(childComponentId);
            var name = childComponent.getName();
            children[name] = childComponent.toJson(modelManager);
            childrenPresent = true;
        }
        if(childrenPresent) {
            json.children = children;
        }

        return json;
    }

    readDataFromJson(json) {
        let document;
        let schema = this.getField("schema");

        //read the editor state
        if((json.data)&&(json.data.doc)) {
            //parse the saved document
            document = Node$1.fromJSON(schema,json.data.doc);
        }
        else {
            //no document stored - create an empty document
            document = this._createEmptyDocument(schema);
        }
        this.setField("document",document);
    }

    /** This method loads the children for this component */
    loadChildrenFromJson(modelManager,componentJson) {
        if(componentJson.children) {
            let parentMember = this.getParentFolderForChildren();
            
            for(let childName in componentJson.children) {
                let childMember = parentMember.lookupChild(modelManager.getModel(),childName);
                if(childMember) {
                    let childComponentJson = componentJson.children[childName];
                    modelManager.createComponentFromMember(childMember,childComponentJson);
                }
            }
        }
    }

    /** This method makes an empty document */
    _createEmptyDocument(schema) {
        return DOMParser.fromSchema(schema).parse("");
    }

}

/** This is used to flag this as an edit component. */
ParentComponent.isParentComponent = true;

/** This component represents a table object. */
class FolderComponent extends ParentComponent {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend parent component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);

        if(!instanceToCopy) {
            //initialize the schema
            this.initializeSchema(modelManager);
        }
    };

    //cludge================================================
    //I need a real solution for this
    //this is a temp solution to return the parent member for children added to this componnet
    //it is used for now when we paste into the document to create a new component.
    getParentFolderForChildren() {
        return this.getMember();
    }
    //=======================================================

    //======================================
    // Static methods
    //======================================

    //if we want to allow importing a workspace as this object, we must add this method to the generator
    static appendMemberChildren(optionsJson,childrenJson) {
        optionsJson.children = childrenJson;
    }

}

//======================================
// This is the component generator, to register the component
//======================================

FolderComponent.displayName = "Page";
FolderComponent.uniqueName = "apogeeapp.PageComponent";
FolderComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.Folder"
};

/** This component represents a folderFunction, which is a function that is programmed using
 *apogee tables rather than writing code. */
class FolderFunctionComponent extends ParentComponent {
        
    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend parent component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
        
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //register this object as a parent container
            var internalFolder = member.getInternalFolder(modelManager.getModel());
            this.setField("member.body",internalFolder);
            modelManager.registerMember(internalFolder.getId(),this,false);

            //initialize the schema
            this.initializeSchema(modelManager);
        }
    }

    /** This overrides the get display method of componnet to return the function declaration. */
    getDisplayName(useFullPath,modelManagerForFullPathOnly) {
        let member = this.getMember();
        var name = useFullPath ? this.getFullName(modelManagerForFullPathOnly) : this.getName();
        var argList = member.getArgList();
        var argListString = argList.join(",");
        var returnValueString = member.getReturnValueString();
        
        var displayName = name + "(" + argListString + ")";
        if((returnValueString != null)&&(returnValueString.length > 0)) {
            displayName += " = " + returnValueString;
        }
        
        return displayName;
    }

    /** This method returns true if the display name field is updated. This method exists because
     * display name is potentially a compound field and this is a systematic way to see if it has changed.
     * Components modifying the getDisplayName method should also update this method.
     * Note this method only applies when useFullPath = false. We currently don't implement a method to see
     * if the full name was updated. */
    isDisplayNameUpdated() {
        return this.getMember().areAnyFieldsUpdated(["name","argList","returnValue"]);
    }

    //cludge================================================
    //I need a real solution for this
    //this is a temp solution to return the parent member for children added to this componnet
    //it is used for now when we paste into the document to create a new component.
    getParentFolderForChildren() {
        //use the internal folder
        return this.getField("member.body");
    }
    //=======================================================


    static transferMemberProperties(inputValues,propertyJson) {
        if(!propertyJson.updateData) propertyJson.updateData = {};
        if(inputValues.argListString !== undefined) {
            propertyJson.updateData.argList = apogeeutil$1.parseStringArray(inputValues.argListString);
        }
        if(inputValues.returnValueString !== undefined) {
            propertyJson.updateData.returnValue = inputValues.returnValueString;
        }
    }

    //if we want to allow importing a workspace as this object, we must add this method to the generator
    static appendMemberChildren(optionsJson,childrenJson) {
        var internalFolderJson = {};
        internalFolderJson.name = optionsJson.name;
        internalFolderJson.type = "apogee.Folder";
        internalFolderJson.children = childrenJson;
        
        optionsJson = {};
        optionsJson.children["body"] = internalFolderJson;
    }

    static appendMemberChildren(optionsJson,childrenJson) {
        optionsJson.children = childrenJson;
    }

}

//======================================
// This is the component generator, to register the component
//======================================

FolderFunctionComponent.displayName = "Page Function";
FolderFunctionComponent.uniqueName = "apogeeapp.PageFunctionComponent";
FolderFunctionComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.FolderFunction",
    "children": {
        "body": {
            "name": "body",
            "type": "apogee.Folder",
        }
    }
};

/** This component represents a table object. */
class DynamicForm extends Component {
        
    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend edit component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
    };

}

//======================================
// This is the component generator, to register the component
//======================================

DynamicForm.displayName = "Action Form Cell";
DynamicForm.uniqueName = "apogeeapp.ActionFormCell";
DynamicForm.DEFAULT_MEMBER_JSON = {
    "type": "apogee.FunctionMember",
    "updateData": {
        "argList": ["admin"]
    }
};

/** This ccomponent represents a data value, with input being from a configurable form.
 * This is an example of componound component. The data associated with the form
 * can be accessed from the variables (componentName).data. There are also subtables
 * "layout" which contains the form layout and "isInputValid" which is a function
 * to validate form input.
 * If you want a form to take an action on submit rather than create and edit a 
 * data value, you can use the dynmaic form. */
class FormDataComponent extends Component {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend edit component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
        
        //this should be present in the json that builds the folder, but in case it isn't (for one, because of a previous mistake)
        member.setChildrenWriteable(false);
        
        let model = modelManager.getModel();
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //internal tables
            let dataMember = member.lookupChild(model,"data");
            this.setField("member.data",dataMember);
            modelManager.registerMember(dataMember.getId(),this,false);

            let layoutFunctionMember = member.lookupChild(model,"layout");
            this.setField("member.layout",layoutFunctionMember);
            modelManager.registerMember(layoutFunctionMember.getId(),this,false);

            let isInputValidFunctionMember = member.lookupChild(model,"isInputValid");
            this.setField("member.isInputValid",isInputValidFunctionMember);
            modelManager.registerMember(isInputValidFunctionMember.getId(),this,false);
        }
    };

}

//======================================
// This is the component generator, to register the component
//======================================

FormDataComponent.displayName = "Data Form Cell";
FormDataComponent.uniqueName = "apogeeapp.DataFormCell";
FormDataComponent.DEFAULT_MEMBER_JSON = {
        "type": "apogee.Folder",
        "childrenNotWriteable": true,
        "children": {
            "layout": {
                "name": "layout",
                "type": "apogee.FunctionMember",
                "updateData": {
                    "argList":[],
                }
            },
            "data": {
                "name": "data",
                "type": "apogee.JsonMember",
                "updateData": {
                    "data": "",
                }
            },
            "isInputValid": {
                "name": "isInputValid",
                "type": "apogee.FunctionMember",
                "updateData": {
                    "argList":["formValue"],
                    "functionBody": "//If data valid, return true. If data is invalid, return an error message.\nreturn true;"
                }
            }
        }
    };

/** This is a custom resource component. 
 * To implement it, the resource script must have the methods "run()" which will
 * be called when the component is updated. It also must have any methods that are
 * confugred with initialization data from the model. */
class CustomComponent extends Component {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
        
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            this.setField("destroyOnInactive",false); //default to keep alive
            this.setField("html","");
            this.setField("css","");
            this.setField("uiCode","");
        }
    };

    //==============================
    //Resource Accessors
    //==============================

    getDestroyOnInactive() {
        return this.getField("destroyOnInactive");
    }

    setDestroyOnInactive(destroyOnInactive) {
        if(destroyOnInactive != this.destroyOnInactive) {
            this.setField("destroyOnInactive",destroyOnInactive);
        }
    }

    /** This method deseriliazes data for the custom resource component. This will
     * work is no json is passed in. */
    loadResourceFromJson(json) { 
        if((json)&&(json.resource)) {  
            for(let fieldName in json.resource) {
                this.update(fieldName,json.resource[fieldName]);
            }
        }
    }


    createResource() {
        try {
            var uiGeneratorBody = this.getField("uiCode");
            
            var resource;
            if((uiGeneratorBody)&&(uiGeneratorBody.length > 0)) {
                try {

                    //create the resource generator wrapped with its closure
                    var generatorFunctionBody = apogeeutil$1.formatString(
                        CustomComponent.GENERATOR_FUNCTION_FORMAT_TEXT,
                        uiGeneratorBody
                    );

                    //create the function generator, with the aliased variables in the closure
                    var generatorFunction = new Function(generatorFunctionBody);
                    var resourceFunction = generatorFunction();
                    
                    resource = resourceFunction();
                }
                catch(err) {
                    if(error.stack) console.error(error.stack);
                    console.log("bad ui generator function");
                }
            }
                
            //create a dummy
            if(!resource) {
                resource = {};
            }

            return resource;
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            
            alert("Error creating custom control: " + error.message);
        }
    }


    //=============================
    // Action
    //=============================

    doCodeFieldUpdate(app,codeFieldName,targetValue) { 
        let initialValue = this.getField(codeFieldName);

        var command = {};
        command.type = customComponentUpdateData.commandInfo.type;
        command.memberId = this.getMemberId();
        command.fieldName = codeFieldName;
        command.initialValue = initialValue;
        command.targetValue = targetValue;

        app.executeCommand(command);
        return true;  
    }

    update(fieldName,fieldValue) { 

        let oldFieldValue = this.getField(fieldName);
        if(fieldValue != oldFieldValue) {
            this.setField(fieldName,fieldValue);
        }

    }

    //==============================
    // serialization
    //==============================

    readPropsFromJson(json) {
        if(!json) return;
        
        //set destroy flag
        if(json.destroyOnInactive !== undefined) {
            var destroyOnInactive = json.destroyOnInactive;
            this.setDestroyOnInactive(destroyOnInactive);
        }
        
        //load the resource
        this.loadResourceFromJson(json);
    }

    /** This serializes the table component. */
    writeToJson(json,modelManager) {
        //store the resource info
        json.resource = {};
        json.resource["html"] = this.getField("html");
        json.resource["css"] = this.getField("css");
        json.resource["uiCode"] = this.getField("uiCode");
        json.destroyOnInactive = this.getField("destroyOnInactive");
    }

    //======================================
    // properties
    //======================================

    readExtendedProperties(values) {
        values.destroyOnInactive = this.getDestroyOnInactive();
    }

    //======================================
    // Static methods
    //======================================

    static transferComponentProperties(inputValues,propertyJson) {
        if(inputValues.destroyOnInactive !== undefined) {
            propertyJson.destroyOnInactive = inputValues.destroyOnInactive;
        }
    }
}

/** This is the format string to create the code body for updateing the member
 * Input indices:
 * 0: resouce methods code
 * 1: uiPrivate
 * @private
 */
CustomComponent.GENERATOR_FUNCTION_FORMAT_TEXT = [
    "//member functions",
    "var resourceFunction = function(component) {",
    "{0}",
    "}",
    "//end member functions",
    "return resourceFunction;",
    ""
       ].join("\n");
    


//======================================
// This is the control generator, to register the control
//======================================

CustomComponent.displayName = "Custom Cell";
CustomComponent.uniqueName = "apogeeapp.CustomCell";
CustomComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.JsonMember"
};

//=====================================
// Update Data Command
//=====================================

/*
 *
 * Command JSON format:
 * {
 *   "type":"customComponentUpdateCommand",
 *   "memberId":(main member ID),
 *   "fieldName": (the name of the field being updated),
 *   "initialValue":(original fields value)
 *   "targetValue": (desired fields value)
 * }
 */ 
let customComponentUpdateData = {};

customComponentUpdateData.createUndoCommand = function(workspaceManager,commandData) {
    let undoCommandData = {};
    undoCommandData.memberId = commandData.memberId;
    undoCommandData.fieldName = commandData.fieldName;
    undoCommandData.initialValue = commandData.targetValue;
    undoCommandData.targetValue = commandData.initialValue;
    return undoCommandData;
};

customComponentUpdateData.executeCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getMutableModelManager();
    let componentId = modelManager.getComponentIdByMemberId(commandData.memberId);
    let component = modelManager.getMutableComponentByComponentId(componentId);
    var commandResult = {};
    if(component) {
        try {
            component.update(commandData.fieldName,commandData.targetValue);

            commandResult.cmdDone = true;
            commandResult.target = component;
            commandResult.eventAction = "updated";
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            let msg = error.message ? error.message : error;
            commandResult.cmdDone = false;
            commandResult.alertMsg = "Exception on custom component update: " + msg;
        }
    }
    else {
        commandResult.cmdDone = false;
        commandResult.alertMsg = "Component not found: " + commandData.memberId;
    }
    
    return commandResult;
};

customComponentUpdateData.commandInfo = {
    "type": "customComponentUpdateCommand",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(customComponentUpdateData);

/** This attempt has a single form edit page which returns an object. */
// To add - I should make it so it does not call set data until after it is initialized. I will cache it rather 
//than making the user do that.

/** This is a custom resource component. 
 * To implement it, the resource script must have the methods "run()" which will
 * be called when the component is updated. It also must have any methods that are
 * confugred with initialization data from the model. */
class CustomDataComponent extends Component {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend edit component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
        
        //this should be present in the json that builds the folder, but in case it isn't (for one, because of a previous mistake)
        member.setChildrenWriteable(false);

        let model = modelManager.getModel();
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            //internal tables
            let dataMember = member.lookupChild(model,"data");
            this.setField("member.data",dataMember);
            modelManager.registerMember(dataMember.getId(),this,false);

            let inputMember = member.lookupChild(model,"input");
            this.setField("member.input",inputMember);
            modelManager.registerMember(inputMember.getId(),this,false);

            this.setField("destroyOnInactive",false); //default to keep alive
            this.setField("html","");
            this.setField("css","");
            this.setField("uiCode","");
        }
    };

    //==============================
    //Resource Accessors
    //==============================

    getDestroyOnInactive() {
        return this.getField("destroyOnInactive");
    }

    setDestroyOnInactive(destroyOnInactive) {
        if(destroyOnInactive != this.getField("destroyOnInactive")) {
            this.setField("destroyOnInactive",destroyOnInactive);
        }
    }

    /** This method deseriliazes data for the custom resource component. This will
     * work is no json is passed in. */
    loadResourceFromJson(json) { 
        if((json)&&(json.resource)) {  
            for(let fieldName in json.resource) {
                this.update(fieldName,json.resource[fieldName]);
            }
        }
    }

    createResource() {
        try {
            var uiGeneratorBody = this.getField("uiCode");
            
            var resource;
            if((uiGeneratorBody)&&(uiGeneratorBody.length > 0)) {
                try {

                    //create the resource generator wrapped with its closure
                    var generatorFunctionBody = apogeeutil$1.formatString(
                        CustomDataComponent.GENERATOR_FUNCTION_FORMAT_TEXT,
                        uiGeneratorBody
                    );

                    //create the function generator, with the aliased variables in the closure
                    var generatorFunction = new Function(generatorFunctionBody);
                    var resourceFunction = generatorFunction();
                    
                    resource = resourceFunction();
                }
                catch(err) {
                    if(err.stack) console.error(err.stack);
                    
                    console.log("bad ui generator function");
                }
            }
                
            //create a dummy
            if(!resource) {
                resource = {};
            }

            return resource;
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            
            alert("Error creating custom control: " + error.message);
        }
    }

    //=============================
    // Action
    //=============================

    doCodeFieldUpdate(app,fieldName,targetValue) { 
        var initialValue = this.getField(fieldName);
        var command = {};
        command.type = customDataComponentUpdateData.commandInfo.type;
        command.memberId = this.getMemberId();
        command.fieldName = fieldName;
        command.initialValue = initialValue;
        command.targetValue = targetValue;

        app.executeCommand(command);
        return true; 
    }

    update(fieldName,fieldValue) { 

        let oldFieldValue = this.getField(fieldName);
        if(fieldValue != oldFieldValue) {
            this.setField(fieldName,fieldValue);
        }
    }

    //==============================
    // serialization
    //==============================

    readPropsFromJson(json) {
        if(!json) return;
        
        //set destroy flag
        if(json.destroyOnInactive !== undefined) {
            var destroyOnInactive = json.destroyOnInactive;
            this.setDestroyOnInactive(destroyOnInactive);
        }
        
        //load the resource
        this.loadResourceFromJson(json);
    }

    /** This serializes the table component. */
    writeToJson(json,modelManager) {
        //store the resource info
        json.resource = {};
        json.resource["html"] = this.getField("html");
        json.resource["css"] = this.getField("css");
        json.resource["uiCode"] = this.getField("uiCode");
        json.destroyOnInactive = this.getField("destroyOnInactive");
    }

    //======================================
    // properties
    //======================================

    readExtendedProperties(values) {
        values.destroyOnInactive = this.getDestroyOnInactive();
    }



    //======================================
    // Static methods
    //======================================

    static transferComponentProperties(inputValues,propertyJson) {
        if(inputValues.destroyOnInactive !== undefined) {
            propertyJson.destroyOnInactive = inputValues.destroyOnInactive;
        }
    }
    
}

/** This is the format string to create the code body for updateing the member
 * Input indices:
 * 0: resouce methods code
 * 1: uiPrivate
 * @private
 */
CustomDataComponent.GENERATOR_FUNCTION_FORMAT_TEXT = [
    "//member functions",
    "var resourceFunction = function(component) {",
    "{0}",
    "}",
    "//end member functions",
    "return resourceFunction;",
    ""
       ].join("\n");

//======================================
// This is the control generator, to register the control
//======================================

CustomDataComponent.displayName = "Custom Data Cell";
CustomDataComponent.uniqueName = "apogeeapp.CustomDataCell";
CustomDataComponent.DEFAULT_MEMBER_JSON = {
        "type": "apogee.Folder",
        "childrenNotWriteable": true,
        "children": {
            "input": {
                "name": "input",
                "type": "apogee.JsonMember",
                "updateData": {
                    "data":"",
                }
            },
            "data": {
                "name": "data",
                "type": "apogee.JsonMember",
                "updateData": {
                    "data": "",
                }
            }
        }
    };



//=====================================
// Update Data Command
//=====================================

/*
 *
 * Command JSON format:
 * {
 *   "type":"customComponentUpdateCommand",
 *   "memberId":(main member ID),
 *   "fieldName": (the name of the field being updated),
 *   "initialValue":(original fields value)
 *   "targetValue": (desired fields value)
 * }
 */ 

let customDataComponentUpdateData = {};

customDataComponentUpdateData.createUndoCommand = function(workspaceManager,commandData) {
    let undoCommandData = {};
    undoCommandData.memberId = commandData.memberId;
    undoCommandData.fieldName = commandData.fieldName;
    undoCommandData.initialValue = commandData.targetValue;
    undoCommandData.targetValue = commandData.initialValue;
    return undoCommandData;
};

customDataComponentUpdateData.executeCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getMutableModelManager();
    let componentId = modelManager.getComponentIdByMemberId(commandData.memberId);
    let component = modelManager.getMutableComponentByComponentId(componentId);
    var commandResult = {};
    if(component) {
        try {
            component.update(commandData.fieldName,commandData.targetValue);

            commandResult.cmdDone = true;
            commandResult.target = component;
            commandResult.eventAction = "updated";
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            let msg = error.message ? error.message : error;
            commandResult.cmdDone = false;
            commandResult.alertMsg = "Exception on custom component update: " + msg;
        }
    }
    else {
        commandResult.cmdDone = false;
        commandResult.alertMsg = "Component not found: " + commandData.memberId;
    }
    
    return commandResult;
};

customDataComponentUpdateData.commandInfo = {
    "type": "customDataComponentUpdateCommand",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(customDataComponentUpdateData);

/** This component represents a json table object. */
class ErrorComponent extends Component {

    constructor(member,modelManager,instanceToCopy,keepUpdatedFixed) {
        //extend edit component
        super(member,modelManager,instanceToCopy,keepUpdatedFixed);
    };

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /** This overrides the save method to return the original input. */
    toJson(modelManager) {
        return this.completeJson;
    }

    /** This overrides the open deserialize method to save the entire json. */
    loadStoredData(json) {
        this.completeJson = json;
    }

    //======================================
    // Static methods
    //======================================

}

//======================================
// This is the component generator, to register the component
//======================================

ErrorComponent.displayName = "Error Cell";
ErrorComponent.uniqueName = "apogeeapp.ErrorCell";
ErrorComponent.DEFAULT_MEMBER_JSON = {
    "type": "apogee.ErrorMember"
};

/** This module initializes the default component classes. */

let componentInfo = {};

let componentClasses = {};
let standardComponents = [];
let additionalComponents = [];
let pageComponents = [];

//==========================
// Functions
//==========================

/** This method registers a new component. It will be exposed when the user
 * requests to create a new component */
componentInfo.registerComponent = function(componentClass) {
    var name = componentClass.uniqueName;

    //we should maybe warn if another component bundle is being overwritten
    componentClasses[name] = componentClass;
    if(additionalComponents.indexOf(name) < 0) {
        additionalComponents.push(name);
    }
};

/** This method registers a component. */
componentInfo.registerStandardComponent = function(componentClass) {
    var name = componentClass.uniqueName;

    //we should maybe warn if another component bundle is being overwritten 
    componentClasses[name] = componentClass;
    if(standardComponents.indexOf(name) < 0) {
        standardComponents.push(name);
    }
};

/** This method registers a new component. It will be exposed when the user
 * requests to create a new component */
componentInfo.registerPageComponent = function(componentClass) {
    var name = componentClass.uniqueName;

    //we should maybe warn if another component bundle is being overwritten
    componentClasses[name] = componentClass;
    if(pageComponents.indexOf(name) < 0) {
        pageComponents.push(name);
    }
};

/** This method registers a new component. It will be exposed when the user
 * requests to create a new component */
componentInfo.unregisterComponent = function(componentClass) {
    //implement this
};

/** This method returns a component generator of a given name. */
componentInfo.getComponentClass = function(name) {
    return componentClasses[name];
};

componentInfo.getStandardComponentNames = function() {
    return standardComponents;
};

componentInfo.getAdditionalComponentNames = function() {
    return additionalComponents;
};

componentInfo.getPageComponentNames = function() {
    return pageComponents;
};

//===============================
//initialization
//===============================

//register standard child components
componentInfo.registerStandardComponent(JsonTableComponent);
componentInfo.registerStandardComponent(FunctionComponent);
componentInfo.registerStandardComponent(FolderFunctionComponent);
componentInfo.registerStandardComponent(DynamicForm);
componentInfo.registerStandardComponent(FormDataComponent);

//additional child components
componentInfo.registerComponent(CustomComponent);
componentInfo.registerComponent(CustomDataComponent);

componentInfo.registerPageComponent(FolderComponent);
componentInfo.registerPageComponent(FolderFunctionComponent);

//other components
componentInfo.FOLDER_COMPONENT_CLASS = FolderComponent;
componentInfo.ERROR_COMPONENT_CLASS = ErrorComponent;

/** This class manages the user interface for a model object. */
class ModelManager extends FieldObject {

    constructor(app,instanceToCopy,keepUpdatedFixed) {
        super("modelManager",instanceToCopy,keepUpdatedFixed);

        this.app = app;

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            this.setField("model",null);
            this.setField("componentMap",{});
            this.setField("memberMap",{});
        }

        //==============
        //Working variables
        //==============
        this.viewStateCallback = null;
        this.cachedViewState = null;

        this.workingChangeMap = {};

        //add a change map entry for this object
        this.workingChangeMap[this.getId()] = {action: instanceToCopy ? "modelManager_updated" : "modelManager_created", instance: this};
      
    }

    //====================================
    // Methods
    //====================================

    /** This gets the application instance. */
    getApp() {
        return this.app;
    }

    /** This method gets the model object. */
    getModel() {
        return this.getField("model");
    }

    /** This method returns a mutable instance of the model. If the active model is already mutable
     * it returns that. If not, it returns a mutble copy that also becomes the current model instance. */
    getMutableModel() {
        let oldModel = this.getModel();
        if(oldModel.getIsLocked()) {
            let newModel = oldModel.getMutableModel();
            this.setField("model",newModel);
            
            //add listeners
            //newModel.addListener("member_created", member => this.memberCreated(member));
            newModel.addListener("member_updated", member => this.memberUpdated(member));
            newModel.addListener("member_deleted", member => this.memberDeleted(member));
            newModel.addListener("model_updated", model => this.modelUpdated(model));

            return newModel;
        }
        else {
            return oldModel;
        }
    }

    
    //============================
    // Component Creation
    //============================

    /** This returns the list of parents for newly created members. The argument includeRootFolder includes
     * the root folder in the list. This should only be done for other parent objects (The root should not 
     * hold any children.). */
    getParentList(includeRootFolder) {
        let componentMap = this.getField("componentMap");
        let model = this.getModel();
        let folders = [];
        //get the model parent entry
        if(includeRootFolder) {
            folders.push([model.getId(),"Root Folder"]);
        }
        
        //get folder compontents
        for(var key in componentMap) {
            var component = componentMap[key];
            if(component.getParentFolderForChildren) {
                let folderMember = component.getParentFolderForChildren();
                if(folderMember.getChildrenWriteable()) { 
                    let folderEntry = [];
                    folderEntry.push(folderMember.getId());
                    folderEntry.push(folderMember.getFullName(model));
                    folders.push(folderEntry);
                }
            }
        }
        return folders;
    }
        
    createComponentFromMember(member,componentJson) {

        if(!member) {
            throw new Error("Unknown error: member missing!");
        }
        
        //response - get new member
        var component;
        var componentClass = componentInfo.getComponentClass(componentJson.type);
        if((componentClass)&&(member.constructor.generator.type != "apogee.ErrorMember")) {
            //create empty component
            component = new componentClass(member,this);

            //apply any serialized values
            if(componentJson) {
                component.loadStoredData(componentJson);
            }
        }

        //if we failed to create the component, or if we failed to make the member properly (and we used the error member)
        if(!component) {
            //table not found - create an empty error table
            componentClass = componentInfo.ERROR_COMPONENT_CLASS;
            component = new componentClass(member,this);
            if(componentJson) {
                component.loadStoredData(componentJson);
            }
        }

        if(!component) {
            throw new Error("Unknown error creating componet: " + member.getName());
        }

        //load the children, after the component load is completed
        if(component.loadChildrenFromJson) {
            component.loadChildrenFromJson(this,componentJson);
        }

    }

    
    //=============================
    // Model event handlers
    //=============================

    /** This method responds to a member updated. */
    memberCreated(member) {
    }


    /** This method responds to a member updated. */
    memberUpdated(member) {
        let componentId = this.getComponentIdByMemberId(member.getId());
        if(componentId) {
            let component = this.getMutableComponentByComponentId(componentId);
            component.memberUpdated(member);
        }
    }

    modelUpdated(model) {
    }

    /** This method responds to a delete menu event. */
    memberDeleted(member) {
        let memberId = member.getId();
        let componentId = this.getComponentIdByMemberId(memberId);
        if(componentId) {
            let oldComponentMap = this.getField("componentMap");
            let component = oldComponentMap[componentId];

            //take any delete actions (thes should not require a mutable member)
            component.onDelete();

            //unregister the component
            this._unregisterComponent(component);
        }
    }


    //====================================
    // Component Owner Functionality
    //====================================

    /** The change map lists the changes to the components and model. This will only be
     * valid when the ModelManager is unlocked */
    getChangeMap() {
        return this.workingChangeMap;
    }

    /** This method locks the model manager and all components. */
    lockAll() {
        this.workingChangeMap = null;

        let componentMap = this.getField("componentMap");
        for(var id in componentMap) {
            componentMap[id].lock();
        }
        this.lock();
    }

    getComponentByComponentId(componentId) {
        return this.getField("componentMap")[componentId];
    }

    /** This method gets the component associated with a member object. */
    getMutableComponentByComponentId(componentId) {
        let oldComponentMap = this.getField("componentMap");
        var oldComponent = oldComponentMap[componentId];
        if(oldComponent) {
            if(oldComponent.getIsLocked()) {
                //create an unlocked instance of the component
                let newComponent = new oldComponent.constructor(oldComponent.getMember(),this,oldComponent);

                //register this instance
                this.registerComponent(newComponent);

                return newComponent;
            }
            else {
                return oldComponent;
            }
        }
        else {
            return null;
        }
    }

    /** This method gets the component associated with a member object. */
    getComponentIdByMemberId(memberId) {
        let memberMap = this.getField("memberMap");
        var memberInfo = memberMap[memberId];
        if(memberInfo) {
            return memberInfo.componentId;
        }
        else {
            return null;
        }
    }

    /** This method stores the component instance. It must be called when a
     * new component is created and when a component instance is replaced. */
    registerComponent(component) {
        let componentId = component.getId();
        let oldComponentMap = this.getField("componentMap");

        //create the udpated map
        let newComponentMap = {};
        Object.assign(newComponentMap,oldComponentMap);
        newComponentMap[componentId] = component;
        this.setField("componentMap",newComponentMap);

        //update the change map
        let oldChangeEntry = this.workingChangeMap[componentId];  
        let newAction; 
        //this.workingChangeMap[componentId] = {action: (oldInstance ? "component_updated" : "component_created"), instance: component};
        if(oldChangeEntry) {
            //we will assume the events come in order
            //the only scenarios assuming order are:
            //created then updated => keep action as created
            //updated then updated => no change
            //we will just update the component
            newAction = oldChangeEntry.action;
        }
        else {
            //new action will depend on if we have the component in our old component map
            newAction = oldComponentMap[componentId] ? "component_updated" : "component_created"; 
        }
        this.workingChangeMap[componentId] = {action: newAction, instance: component};
    }

    /** This method takes the local actions needed when a component is deleted. It is called internally. */
    _unregisterComponent(component) {
        let componentId = component.getId();

        //update the component map
        let oldComponentMap = this.getField("componentMap");
        let newComponentMap = {};
        Object.assign(newComponentMap,oldComponentMap);
        //remove the given component
        delete newComponentMap[componentId];
        //save the updated map
        this.setField("componentMap",newComponentMap);

        //update the member map
        //this is a little cumbersome
        let oldMemberMap = this.getField("memberMap");
        let newMemberMap = {};
        Object.assign(newMemberMap,oldMemberMap);
        for(let componentMemberId in newMemberMap) {
            let componentInfo = newMemberMap[componentMemberId];
            if(componentInfo.componentId == componentId) {
                delete newMemberMap[componentMemberId];
            }
        }
        this.setField("memberMap",newMemberMap);

        //update the change map
        let oldChangeEntry = this.workingChangeMap[componentId];
        let newChangeEntry;
        if(oldChangeEntry) {
            //handle the case of an existing change entry
            if(oldChangeEntry.action == "component_created") {
                //component created and deleted during this action - flag it as transient
                newChangeEntry = {action: "transient", instance: component};
            }
            else if(oldChangeEntry.action == "component_updated") {
                newChangeEntry = {action: "component_deleted", instance: component};
            }
            else {
                //this shouldn't happen. If it does there is no change to the action
                //we will just update the component
                newChangeEntry = {action: oldChangeEntry.action, instance: component};
            }
        }
        else {
            //add a new change entry
            newChangeEntry = {action: "component_deleted", instance: component};
        }
        this.workingChangeMap[componentId] = newChangeEntry;  
    }

    /** This method registers a member data object and its associated component object.
     * If the member is not the main member assoicated with component but instead an included
     * member, the main componentMember should be passed in also. Otherwise it should be left 
     * undefined. */
    registerMember(memberId,component,isMain) {

        let oldMemberMap = this.getField("memberMap");

        if(oldMemberMap[memberId]) {
            //already registered
            return;
        }

        //copy the old map
        let newMemberMap = {};
        Object.assign(newMemberMap,oldMemberMap);

        //add the new info
        let memberInfo = {};
        memberInfo.memberId = memberId;
        memberInfo.componentId = component.getId();
        memberInfo.isMain = isMain;

        newMemberMap[memberId] = memberInfo;

        this.setField("memberMap",newMemberMap);
    }
    
    testPrint(eventInfo) {
        if(eventInfo.updated) {
            console.log(JSON.stringify(eventInfo.updated));
        }
    }

    //====================================
    // open and save methods
    //====================================
    
    setViewStateCallback(viewStateCallback) {
        this.viewStateCallback = viewStateCallback;
    }

    getCachedViewState() {
        return this.cachedViewState;
    }

     /** This method loads the model data and model components from the json. */
    load(workspaceManager,json) {

        let modelJson; 
        let componentsJson;

        if(json) {
            modelJson = json.model;
            componentsJson = json.components;

            //set the view state
            if(json.viewState !== undefined) {
                this.cachedViewState = json.viewState;
            }
        }

        //load defaults if there is not saved model data
        if(!modelJson) modelJson = Model.EMPTY_MODEL_JSON;
        if(!componentsJson) componentsJson = ModelManager.EMPTY_MODEL_COMPONENT_JSON;

        //create model
        let model = new Model(workspaceManager.getModelRunContext());
        this.setField("model",model);
        
        //add listeners
        //model.addListener("member_created", member => this.memberCreated(member));
        model.addListener("member_updated", member => this.memberUpdated(member));
        model.addListener("member_deleted", member => this.memberDeleted(member));
        model.addListener("model_updated", model => this.modelUpdated(model));

        //load the model
        let loadAction = {};
        loadAction.action = "loadModel";
        loadAction.modelJson = modelJson;
        let actionResult = doAction(model,loadAction);

        //create the return result
        let commandResult = {};

        if(actionResult.actionDone) {
            commandResult.eventAction = "updated";
            commandResult.cmdDone = true;
            commandResult.target = this;

            //create the children
            let childCommandResults = [];
            let rootChildIdMap = model.getChildIdMap();
            for(let childName in rootChildIdMap) {
                let childMemberId = rootChildIdMap[childName];
                let childMember = model.lookupMemberById(childMemberId);
                if(childMember) {
                    let childJson = componentsJson[childName];
                    let childCommandResult = this.createComponentFromMember(childMember,childJson);
                    childCommandResults.push(childCommandResult);
                }
            }
            if(childCommandResults.length > 0) {
                commandResult.childCommandResults = childCommandResults;
            }

            commandResult.actionResult = actionResult;
        }
        else {
            commandResult.cmdDone = false;
            commandResult.errorMsg = "Error opening workspace model";
        }

        return commandResult;
    }

    /** This method closes the model object. */
    close() {
        //delete all the components - to make sure the are cleaned up
        let componentMap = this.getField("componentMap");
        for(let key in componentMap) {
            let component = componentMap[key];
            component.onDelete();
        }

        let model = this.getModel();
        model.onClose(model);
    }

    /** This saves the model. It the optionalSavedRootFolder is passed in,
     * it will save a model with that as the root folder. */
    toJson(optionalSavedRootFolder) {

        let model = this.getField("model");
        let json = {};

        //get the model json
        if(optionalSavedRootFolder) {
            throw new Error("Need to correctly save the model for the optional saved root folder!");
        }
        json.model = model.toJson();

        //get the components json
        let componentsJson = {};

        //get the "root folder" - either for the model or the optional folder to save.
        let childIdMap;
        if(optionalSavedRootFolder) {
            childIdMap = optionalSavedRootFolder.getChildMap();
        }
        else {
            childIdMap = model.getChildIdMap();
        } 

        //get all the components asoicated with the root members
        for(let childName in childIdMap) {
            //member
            let memberId = childIdMap[childName];
            let componentId = this.getComponentIdByMemberId(memberId);
            let component = this.getComponentByComponentId(componentId);
            componentsJson[childName] = component.toJson(this);
        }
        json.components = componentsJson;

        //model view state
        if(this.viewStateCallback) {
            this.cachedViewState = this.viewStateCallback();
            if(this.cachedViewState) componentsJson.viewState = this.cachedViewState;
        }

        return json;
    }

    //==================================
    // DEV FUNCTION
    //==================================

    showDependencies() {
        console.log(JSON.stringify(this.createDependencies()));
    }

    createDependencies() {
        throw new Error("This needs to be rewritten, probably in Model rather than here.")
        //for one thing I removed the model instance from componentInfo in the component map
        //instead I should just read all the members from the model.

        // let model = this.getField("model");
        // var memberInfo = {};

        // let componentMap = this.getField("componentMap");

        // for(var key in componentMap) {
        //     var componentInfo = componentMap[key];
        //     if((componentInfo)&&(componentInfo.member)) {


        //         var member = componentInfo.member;

        //         var memberStruct = {};
        //         memberStruct.type = member.constructor.generator.type;
        //         var parentMember = member.getParentMember(model);
        //         memberStruct.parent = parentMember ? parentMember.getFullName(model) : null;

        //         if(member.isDependent) {
        //             let depList = [];
        //             let dependsOnMap = member.getDependsOn();
        //             for(var idString in dependsOnMap) {
        //                 dependencyType = dependsOnMap[idString];
        //                 if(dependencyType == apogeeutil.NORMAL_DEPENDENCY) {
        //                     let dependency = model.lookupMemberById(idString);
        //                     depList.push(dependency.getFullName(model));
        //                 }
        //             }
        //             if(depList.length > 0) {
        //                 memberStruct.dep = depList;
        //             }
        //         }

        //         memberInfo[member.getFullName(model)] = memberStruct;
        //     }
        // }

        // return memberInfo;
    }

}

//this is the json for an empty model
ModelManager.EMPTY_MODEL_COMPONENT_JSON = {
    "main": {
        "type":"apogeeapp.PageComponent"
    }
};

/** This class manages the workspace. */
class WorkspaceManager extends FieldObject {

    constructor(app,instanceToCopy,keepUpdatedFixed) {
        super("workspaceManager",instanceToCopy,keepUpdatedFixed);

        this.app = app;
        
        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            let modelManager = new ModelManager(this.app);
            this.setField("modelManager",modelManager);

            let referenceManager = new ReferenceManager(this.app);
            this.setField("referenceManager",referenceManager);

            //this is not a field like above because when we do not require a command to change it
            this.fileMetadata = null;

            //temporary
            this.created = true;
        }
        else {
            //this is not a field like above because when we do not require a command to change it
            this.fileMetadata = instanceToCopy.fileMetadata;

            //temporary
            this.created = false;
        }

        //==============
        //Working variables
        //==============
        this.viewStateCallback = null;
        this.cachedViewState = null;

        //listen to the workspace dirty event from the app
        this.app.addListener("workspaceDirty",() => this.setIsDirty());

        this.isClosed = false;
    }

    //====================================
    // Workspace Management
    //====================================

    /** This gets the application instance. */
    getApp() {
        return this.app;
    }

    /** This method returns a mutable copy of this instance. If the instance is already mutable
     * it will be returned rather than making a new one.  */
    getMutableWorkspaceManager() {
        if(this.getIsLocked()) {
            //create a new instance that is a copy of this one
            return new WorkspaceManager(this.app,this);
        }
        else {
            //return this instance since it si already unlocked
            return this;
        }
    }

    // temporary implementation
    getChangeMap() {
        let changeMap = {};
        //workspace always changes
        let workspaceManagerEvent;
        if(this.isClosed) workspaceManagerEvent = "workspaceManager_deleted";
        else if(this.created)  workspaceManagerEvent = "workspaceManager_created";
        else workspaceManagerEvent = "workspaceManager_updated";
        changeMap[this.getId()] = {action: workspaceManagerEvent, instance: this};

        let referenceManager = this.getReferenceManager();
        let referenceChangeMap = referenceManager.getChangeMap();
        if(referenceChangeMap) Object.assign(changeMap,referenceChangeMap);

        let modelManager = this.getModelManager();
        let modelChangeMap = modelManager.getChangeMap();
        if(modelChangeMap) Object.assign(changeMap,modelChangeMap);

        return changeMap;
    }

    /** This method locks this workspace instance and all the contained object instances. */
    lockAll() {
        //we maybe shouldn't be modifying the members in place, but we will do it anyway
        this.getReferenceManager().lockAll();
        this.getModelManager().lockAll();
        this.lock();
    }

    getReferenceManager() {
        return this.getField("referenceManager");
    }

    /** This method returns an unlocked reference manager instance. If the current
     * reference manager is unlocked it will return that. Otherwise it will return
     * a new unlocked instance that will also be set as the current instance. */
    getMutableReferenceManager() {
        let oldReferenceManager = this.getReferenceManager();
        if(oldReferenceManager.getIsLocked()) {
            //create a new instance that is a copy of this one
            let newReferenceManager = new ReferenceManager(this.app,oldReferenceManager);
            this.setField("referenceManager",newReferenceManager);
            return newReferenceManager;
        }
        else {
            //return this instance since it si already unlocked
            return oldReferenceManager;
        }
    }

    getModelManager() {
        return this.getField("modelManager");
    }

    /** This method returns an unlocked model manager instance. If the current
     * model manager is unlocked it will return that. Otherwise it will return
     * a new unlocked instance that will also be set as the current instance. */
    getMutableModelManager() {
        let oldModelManager = this.getModelManager();
        if(oldModelManager.getIsLocked()) {
            //create a new instance that is a copy of this one
            let newModelManager = new ModelManager(this.app,oldModelManager);
            this.setField("modelManager",newModelManager);
            return newModelManager;
        }
        else {
            //return this instance since it si already unlocked
            return oldModelManager;
        }
    }

    getIsDirty() {
        return this.isDirty;
        
    }
    
    setIsDirty() {
        this.isDirty = true;
    }
    
    clearIsDirty() {
        this.isDirty = false;
    }

    getIsClosed() {
        return this.isClosed;
    }
    
    
    //====================================
    // asynch run context methods
    //====================================
    runFutureCommand(commandData) {
        //run command asynchronously
        setTimeout(() => this.app.executeCommand(commandData),0);
    }

    getModelRunContext() {
        let modelRunContext = {};
        modelRunContext.doAsynchActionCommand = (modelId,action) => {
            //create a command to run this action
            let modelActionCommand = {};
            modelActionCommand.type = "futureModelActionCommand";
            modelActionCommand.modelId = modelId;
            modelActionCommand.action = action;

            //execut this command as a future command
            this.runFutureCommand(modelActionCommand);
        };

        return modelRunContext;
    }

    //====================================
    // configuration
    //====================================

    /** This retrieves the file metadata used to save the file. */
    getFileMetadata() {
        return this.fileMetadata;
    }

    /** This method should be used to update the file metadata for the workspace, such as after the file is saved. */
    setFileMetadata(fileMetadata) {
        this.fileMetadata = fileMetadata;
    }

    //====================================
    // open and save methods
    //====================================

    setViewStateCallback(viewStateCallback) {
        this.viewStateCallback = viewStateCallback;
    }

    getCachedViewState() {
        return this.cachedViewState;
    }

    /** This saves the workspace. It the optionalSavedRootFolder is passed in,
     * it will save a workspace with that as the root folder. */
    toJson(optionalSavedRootFolder) {
        var json = {};
        json.fileType = "apogee app js workspace";

        json.version = WorkspaceManager.FILE_VERSION;

        json.references = this.getReferenceManager().toJson();

        json.code = this.getModelManager().toJson(optionalSavedRootFolder);

        if(this.viewStateCallback) {
            this.cachedViewState = this.viewStateCallback();
            if(this.cachedViewState) json.viewState = this.cachedViewState;
        }

        return json;
    }

    
     /** This method sets the workspace. The argument workspaceJson should be included
      * if the workspace is not empty, such as when opening a existing workspace. It
      * contains the data for the component associated with each model member. For 
      * a new empty workspace the workspaceJson should be omitted. 
      * The argument fileMetadata is the file identifier if the workspace is opened from a file.
      * This will be used for the "save" function to save to an existing file. */
     load(json,fileMetadata) {

        //check file format
        if(json) {
            if(json.version != WorkspaceManager.FILE_VERSION) {
                let msg = "Version mismatch. Expected version " + WorkspaceManager.FILE_VERSION + ", Found version " + workspaceJson.version;
                alert(msg);
                throw new Error(msg);
            }
        }
        else {
            //create aan empty json to load
            json = {};
        }

        //store the file metadata
        this.fileMetadata = fileMetadata;

        //set the view state
        if(json.viewState !== undefined) {
            this.cachedViewState = json.viewState;
        }

        //check for references. If we have references we must load these before loading the model
        if(json.references) {
            //if there are references, load these before loading the model.
            //this is asynchronous so we must load the model in a future command
            let referenceManager = this.getReferenceManager();
            let referenceLoadPromise = referenceManager.load(this,json.references);

            let onReferencesLoaded = () => {
                //load references regardless of success or failure in loading references
                let loadModelCommand = {};
                loadModelCommand.type = "loadModelManager";
                loadModelCommand.json = json.code;
                this.runFutureCommand(loadModelCommand);
            };

            referenceLoadPromise.then(onReferencesLoaded);
        }
        else {
            //if there are not references we can load the model directly.
            let modelManager = this.getModelManager();
            modelManager.load(this,json.code);
        }
    }

    /** This method closes the workspace object. */
    close() {
        //close model manager
        let modelManager = this.getModelManager();
        modelManager.close();

        //close reference manager
        let referenceManager = this.getReferenceManager();
        referenceManager.close();

        //flag the workspace as closed
        this.isClosed = true;
    }

}

WorkspaceManager.FILE_VERSION = "0.60";


//=====================================
// Command Object
//=====================================

/*** 
 * This command loads the model manager. It is a follow on command to opening a workspace,
 * if there are references present, which must be loaded first.
 * 
 * commandData.type = "loadModelManager"
 * commandData.json = (json for the model/model manager)
 */

let loadmodelmanager = {};

//There is no undo command since this is a follow on to opening a workspace
//loadmodelmanager.createUndoCommand = function(workspaceManager,commandData) {

/** This method loads an existing, unpopulated model manager. It is intended only as
 * a asynchronous follow on command to opening a workspace, once any references have
 * been loaded.
 */
loadmodelmanager.executeCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getMutableModelManager();
    return modelManager.load(workspaceManager,commandData.json);
};

loadmodelmanager.commandInfo = {
    "type": "loadModelManager",
    "targetType": "modelManager",
    "event": "updated"
};

CommandManager.registerCommand(loadmodelmanager);

/** @private */
let apogeeInstance = null;

//======================================
//class definition
//======================================

/** This is the main class of the apogee application. 
 * This constuctor should not be called externally, the static creation method 
 * should be used. This is a singlet.
 * 
 * @param appConfigManager - An instance of an AppConfigManager on configure the application.
 * 
 * @private */
class Apogee {

    constructor(appConfigManager) {

        //mixin initialization
        this.eventManagerMixinInit();
        
        //make sure we define this once
        if(apogeeInstance != null) {
            throw new Error("Error: There is already an Apogee app instance - the Apogee class is a singleton.");
        }
        else {
            apogeeInstance = this;
        }
        
        this.appConfigManager = appConfigManager;
        
        //---------------------------------
        //construct the base app structures
        //---------------------------------
        
        //workspace manager
        this.workspaceManager = null;
        
        //component generators
        this.componentClasses = {};
        this.standardComponents = [];
        //these are a list of names of components that go in the "added component" list
        this.additionalComponents = [];
        
        //default settings
        this.appSettings = {};
        
        //reference manager
        this.referenceManager = new ReferenceManager(this);
        
        //command manager
        this.commandManager = new CommandManager(this);
        
        //----------------------------------
        //configure the application
        //----------------------------------
        var appConfigPromise = this.appConfigManager.getConfigPromise(this);
        
        appConfigPromise.then(() => this.initApp()).catch(errorMsg => alert("Fatal error configuring application!"));
        
    }

    //======================================
    // static singleton methods
    //======================================

    /** This retrieves an existing instance. It does not create an instance. */
    static getInstance() {
        return apogeeInstance;
    }

    // /** This function initializes the default classes for the application. */
    // static setBaseClassLists(standardComponents, additionalComponents, errorComponentClass) {
    //     Apogee.standardComponents = standardComponents;
    //     Apogee.additionalComponents = additionalComponents;
    //     Apogee.errorComponentClass = errorComponentClass;
    // }

    //==================================
    // Workspace Management
    //==================================

    /** This method returns the active WorkspaceManager object. */
    getWorkspaceManager() {
        return this.workspaceManager;
    }

    createWorkspaceManager() {
        return new WorkspaceManager(this);
    }

    /** This method returns the active model object. */
    getModel() {
        if(this.workspaceManager) {
            return this.workspaceManager.getModelManager().getModel();
        }
        else {
            return null;
        }
    }

    /** This method makes an empty workspace object. This can be used to set the initial workspace
     * manager or to give the new instance of the workspace manager. However, if the workspace manager
     * is being updated it must have the same ID as the existing workspace manager or else an exception
     * will be thrown.
     */
    setWorkspaceManager(workspaceManager) {
        //we can only have one workspace of a given id
        if((this.workspaceManager)&&(this.workspaceManager.getId() != workspaceManager.getId())) {
            throw new Error("There is already an open workspace");
        }
        this.workspaceManager = workspaceManager;
        return true;
    }

    /** This method closes the active workspace. */
    clearWorkspaceManager() {
        //remove the workspace from the app
        this.workspaceManager = null;
        
        return true;
    }

    //====================================
    // Command Management
    //====================================

    /** This method should be called to execute commands. */
    executeCommand(command) {
        this.commandManager.executeCommand(command);
    }

    /** This method is intended for the UI for the undo/redo functionality */
    getCommandManager() {
        return this.commandManager;
    }

    /** This method returns true if the workspcae contains unsaved data. */
    getWorkspaceIsDirty() {
        if(this.workspaceManager) {
            return this.workspaceManager.getIsDirty();
        }
        else {
            return false;
        }
    }

    /** This method clears the workspace dirty flag. */
    clearWorkspaceIsDirty() {
        if(this.workspaceManager) {
            return this.workspaceManager.clearIsDirty();
        }
        else {
            return false;
        }
    }

    
    //======================================
    // configuration methods methods
    //======================================

    /** This method returns the app settings json. */
    getAppSettings() {
        return this.appSettings;
    }

    /** This mehod return the application ReferenceManager. */
    getAppReferenceManager() {
        return this.referenceManager;
    }

    /** This method sets the file access object. */
    setFileAccessObject(fileAccessObject) {
        this.fileAccessObject = fileAccessObject;
    }

    /** This method retrieves the file access object for the application. */
    getFileAccessObject() {
        return this.fileAccessObject;
    }



    //==================================
    // App Initialization
    //==================================

    /** This should be called to set any settings, if there are any. If there are
     * no settings, this may be omitted.
     * 
     * configJson format:
     * {
     *   "settings": { (settings json - settings keys with associated settings value) },
     *   "references": [ (array of references - same format as refernces in workspace.) ]
     * }
     * 
     * References may include self-installing modules, for example a custom file
     * access method or custom components. See info on self installing modules.
     */ 
    getConfigurationPromise(configJson) {   
        if(!configJson) return;
        
        //set the settings JSON
        this.appSettings = configJson.settings;
        if(!this.appSettings) this.appSettings = {};
        
        //load references
        var openEntriesPromise;
        if(configJson.references) {
            openEntriesPromise = this.referenceManager.getOpenEntriesPromise(configJson.references);
        }
        else {
            //instant resolve promise (with no meaningful return)
            openEntriesPromise = Promise.resolve();
        }
        
        var onLoadReferenceError = errorMsg => alert("Error setting application level modules - some functionality may not be available: " + errorMsg);
        
        //if there is an error loading the promise, print a mesage and continue.
        return openEntriesPromise.catch(onLoadReferenceError);
    }
        
    /** This completes application initialization after any settings have been set. 
     * @private
     * */    
    initApp() {
        
        //file accessor - load the default if it wasn't loaded in cofiguration
        if(!this.fileAccessObject) {
            this.fileAccessObject = this.appConfigManager.getDefaultFileAccessObject(this);
        }
        
        //open the initial workspace
        var workspaceFilePromise = this.appConfigManager.getInitialWorkspaceFilePromise(this);
        if(workspaceFilePromise) {
            var workspaceFileMetadata = this.appConfigManager.getInitialWorkspaceFileMetadata(this);
            
            var openInitialWorkspace = workspaceText => {
                let workspaceJson = JSON.parse(workspaceText);

                //open workspace
                var commandData = {};
                commandData.type = "openWorkspace";
                commandData.workspaceJson = workspaceJson;
                commandData.fileMetadata = workspaceFileMetadata;

                this.executeCommand(commandData);
            };
            
            workspaceFilePromise.then(openInitialWorkspace).catch(errorMsg => alert("Error downloading initial workspace: " + errorMsg));
        }
        
    }
}

//add mixins to this class
apogeeutil$1.mixin(Apogee,EventManager);


Apogee.DEFAULT_Workspace_NAME = "workspace";

/** 
 * This is a base class for workspace opening and saveing, or whatever actions
 * are appropriate. It should be extended to provide functionality.
 */
class BaseFileAccess {
    /**
     * Constructor
     */
    constructor() {
        
    }

    /** 
     * This method should return a list of menu options for opening and closing
     * the workspace. The format should be a array with each entry being a
     * two entry array. The first item is the menu entry text and the second 
     * is the callback for the menu item action. 
     * Example: [["Open",openCallback],["Save",saveCallback]]
     * */
    getWorkspaceOpenSaveMenuOptions(app) {
        
    }
    
    /**
     * This method returns fileMetadata appropriate for a new workspace.
     */
    getNewFileMetadata() {
        
    }

    //===============================
    // The following methods must be implmented by the extending class
    //===============================

    /**
     * This method returns true if the workspace has an existing file to which 
     * is can be saved without opening a save dialog. 
     */
    directSaveOk(fileMetadata) {
        return false;
    }
    
    /**
     * This method opens a file, including dispalying a dialog
     * to select the file.
     * arguments:
     * - onOpen(err,workspaceData,fileMetadata);
     * 
     * onOpen callback arguments:
     * - err - This is a string that will be populated if there was an error
     * - fileData - This is the file contents as a string
     * - fileMetadata - This is a implementation-defined structure that is used to store the file location.
     */
    //openFile(onOpen);

    /** This  method shows a save dialog and saves the file.
     * arguments:
     * - fileMetadata - This is a implementation-defined structure that is used to store the file location.
     * - fileData - This is the file contents as a string
     * - onSave(err,fileSaved,fileMetadata);
     * 
     * onSave callback arguments:
     * - err - This is a string that will be populated if there was an error
     * - fileSaved - This is boolean telling if the file was saved.
     * - fileMetadata - This is a implementation-defined structure that gives the saved file location.
     */
    //saveFileAs(fileMetadata,data,onSave);

    /** This  method directly saves the file without letting the user select the location.
     * arguments:
     * - fileMetadata - This is a implementation-defined structure that is used to store the file location.
     * - fileData - This is the file contents as a string
     * - onSave(err,fileSaved,fileMetadata);
     * 
     * onSave callback arguments:
     * - err - This is a string that will be populated if there was an error
     * - fileSaved - This is boolean telling if the file was saved.
     * - fileMetadata - This is a implementation-defined structure that gives the saved file location.
     */
    //saveFile(fileMetadata,data,onSave);


}

/** Add Component Command
 *
 * Command JSON format:
 * {
 *   "type":"addComponent",
 *   "parentId":(parent ID),
 *   "memberJson":(member property json),
 *   "componentJson":(component property json)
 * }
 */ 

let addcomponent = {};

//=====================================
// Command Object
//=====================================

addcomponent.createUndoCommand = function(workspaceManager,commandData) {
    
    var undoCommandJson = {};
    undoCommandJson.type = "deleteComponent";
    undoCommandJson.parentId = commandData.parentId;
    undoCommandJson.memberName = commandData.memberJson.name;
    
    return undoCommandJson;
};

addcomponent.executeCommand = function(workspaceManager,commandData) { 
    
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();

    //create the member
    let createAction = {};
    createAction.action = "createMember";
    createAction.parentId = commandData.parentId;
    createAction.createData = commandData.memberJson;
    let actionResult = doAction(model,createAction);
    
    //create the components for the member
    //I need error handling for the create component action
    if(actionResult.actionDone) {
        //this is a bit clumsy...
        let parentMember = model.lookupMemberById(commandData.parentId);
        let name = commandData.memberJson.name;
        let componentMember = parentMember.lookupChild(model,name);
        modelManager.createComponentFromMember(componentMember,commandData.componentJson);
    }
    else {
        throw new Error("Failure creating member: " + actionResult.errorMsg);
    }
};

addcomponent.commandInfo = {
    "type": "addComponent",
    "targetType": "component",
    "event": "created"
};

CommandManager.registerCommand(addcomponent);

/** Add Link Command
 *
 * Command JSON format:
 * {
 *   "type":"addLink",
 *   "entryType":(entry type),
 *   "url":(url),
 *   "nickname":(nickname - optional)
 * }
 */ 
let addlink = {};

//=====================================
// Command Object
//=====================================

addlink.createUndoCommand = function(workspaceManager,commandData) {
    var undoCommandJson = {};
    undoCommandJson.type = "deleteLink";
    undoCommandJson.entryType = commandData.entryType;
    undoCommandJson.url = commandData.url;
    return undoCommandJson;
};

addlink.executeCommand = function(workspaceManager,commandData) {
    let referenceManager = workspaceManager.getMutableReferenceManager();
    //this creates the entry but does not load it
    let referenceEntry = referenceManager.createEntry(commandData);
    //this loads the entry - it will cause an asynchronouse command on completion
    referenceEntry.loadEntry(workspaceManager);
};

addlink.commandInfo = {
    "type": "addLink",
    "targetType": "link",
    "event": "created"
};

CommandManager.registerCommand(addlink);

let closeworkspace = {};

//=====================================
// Action
//=====================================

//NO UNDO FOR CLOSE Workspace
//closeworkspace.createUndoCommand = function(workspaceManager,commandData) {

closeworkspace.executeCommand = function(workspaceManager,commandData) {
    workspaceManager.close();
};

closeworkspace.commandInfo = {
    "type": "closeWorkspace",
    "targetType": "workspace",
    "event": "deleted"
};

CommandManager.registerCommand(closeworkspace);

let compoundcommand = {};

//=====================================
// Command Object
//=====================================

compoundcommand.createUndoCommand = function(workspaceManager,commandData) {
    let undoCommandJson = {};
    undoCommandJson.type = compoundcommand.commandInfo.type;
    undoCommandJson.childCommands = [];
    
    //add the child undo commands in the reverse order
    for(var i = commandData.childCommands.length-1; i >= 0; i--) {
        let childCommandJson = commandData.childCommands[i];
        let childCommandObject = CommandManager.getCommandObject(childCommandJson.type);
        let childUndoCommandJson = childCommandObject.createUndoCommand(workspaceManager,childCommandJson);
        undoCommandJson.childCommands.push(childUndoCommandJson);
    }
    
    return undoCommandJson;
};

/** This method is used for updating property values from the property dialog. 
 * If there are additional property lines, in the generator, this method should
 * be extended to edit the values of those properties too. */
compoundcommand.executeCommand = function(workspaceManager,commandData) {
    //execute all child commands
    for(var i = 0; i < commandData.childCommands.length; i++) {
        let childCommandJson = commandData.childCommands[i];
        let childCommandObject = CommandManager.getCommandObject(childCommandJson.type);
        childCommandObject.executeCommand(workspaceManager,childCommandJson);
    }
};

compoundcommand.commandInfo = {
    "type": "compoundCommand",
};

CommandManager.registerCommand(compoundcommand);

let deletecomponent = {};

//=====================================
// Command Object
//=====================================

/*** 
 * This command supports two formats:
 * 
 * Format 1: member ID
 * commandData.type = "deleteComponent"
 * commandData.memberId = (memberId)
 * 
 * Format 2: parent ID, memberName
 * commandData.type = "deleteComponent"
 * commandData.parentId = (parentId)
 * commandData.memberName = (memberName)
 */
deletecomponent.createUndoCommand = function(workspaceManager,commandData) {
    
    //problems
    // - is this member a component main member?
    
    let modelManager = workspaceManager.getModelManager();
    var model = modelManager.getModel();
    let member;
    let parent;

    if(commandData.memberId) {
        member = model.lookupMemberById(commandData.memberId);
        parent = member.getParent(model);
    }
    else {
        parent = model.lookupMemberById(commandData.parentId);
        member = parent.lookupChild(commandData.memberName);
    }

    let componentId = modelManager.getComponentIdByMemberId(member.getId());
    let component = modelManager.getComponentByComponentId(componentId);
    
    var commandUndoJson = {};
    commandUndoJson.type = "addComponent";
    commandUndoJson.parentId = parent.getId();
    commandUndoJson.memberJson = member.toJson(model);
    commandUndoJson.componentJson = component.toJson(modelManager);
    
    return commandUndoJson;
};

/** This method deletes the component and the underlying member. It should be passed
 *  the model and the member full name. (We delete by name and model to handle
 *  undo/redo cases where the instance of the member changes.)
 */
deletecomponent.executeCommand = function(workspaceManager,commandData) {
    
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();

    var actionJson = {};
    actionJson.action = "deleteMember";

    if(commandData.memberId) {
        actionJson.memberId = commandData.memberId;
    }
    else {
        let parent = model.lookupMemberById(commandData.parentId);
        let member = parent.lookupChild(model,commandData.memberName);
        actionJson.memberId = member.getId();
    }
    
    var actionResult = doAction(model,actionJson);
    if(!actionResult.actionDone) {
        throw new Error("Error deleting component: " + actionResult.errorMsg);
    }
};

deletecomponent.commandInfo = {
    "type": "deleteComponent",
    "targetType": "component",
    "event": "deleted"
};

CommandManager.registerCommand(deletecomponent);

/** Delete Link Command
 *
 * Command JSON format:
 * {
 *   "type":"deleteLink",
 *   "entryType":(entry type),
 *   "url":(url)
 * }
 */ 
let deletelink = {};

//=====================================
// Command Object
//=====================================

deletelink.createUndoCommand = function(workspaceManager,commandData) {
    
    var nickname;

    var referenceManager = workspaceManager.getReferenceManager();
    var referenceEntry = referenceManager.lookupEntry(commandData.entryType,commandData.url);
    
    if(referenceEntry) nickname = referenceEntry.getNickname();

    var undoCommandJson = {};
    undoCommandJson.type = "addLink";
    undoCommandJson.entryType = commandData.entryType;
    undoCommandJson.url = commandData.url;
    undoCommandJson.nickname = nickname;
    
    return undoCommandJson;
};

deletelink.executeCommand = function(workspaceManager,commandData) {
    var referenceManager = workspaceManager.getMutableReferenceManager();
    
    //lookup entry
    let referenceEntry = referenceManager.lookupEntry(commandData.entryType,commandData.url);
    if(!referenceEntry) throw new Error("Reference entry not found. refEntryId: " + refEntryId);

    referenceEntry.removeEntry();
    referenceManager.unregisterRefEntry(referenceEntry);
};

deletelink.commandInfo = {
    "type": "deleteLink",
    "targetType": "link",
    "event": "deleted"
};

CommandManager.registerCommand(deletelink);

/**
 * This command is intended to run asynchronous commands, for which no undo is given.
 * The intention is that these commands are byproducts of a different action that will be
 * undone by undoing that different action. (NEED TO THINK ABOUT HOW THIS IS GARUNTEED)
 */

let futuremodelactioncommand = {};

//=====================================
// Command Object
//=====================================

/** NO UNDO - DANGEROUS. THIS IS MEANT ONLY FOR FUTURE ACTIONS. IIF SOMEONE USES
 * IT FOR A REGULAR ACTION THEN IT WILL NOT PROPERLY BE REVERSIBLE!!!
 */
//futuremodelactioncommand.createUndoCommand = function(workspaceManager,commandData) {};

/** This method deletes the component and the underlying member. It should be passed
 *  the model and the member full name. (We delete by name and model to handle
 *  undo/redo cases where the instance of the member changes.)
 */
futuremodelactioncommand.executeCommand = function(workspaceManager,commandData) {
    
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();

    var actionResult = doAction(model,commandData.action);
    if(!actionResult.actionDone) {
        throw new Error("Error in model action command: " + actionResult.errorMsg);
    }
};

futuremodelactioncommand.commandInfo = {
    "type": "futureModelActionCommand",
    "targetType": "component",
    "event": "unknown :-)"
};

CommandManager.registerCommand(futuremodelactioncommand);

let movecomponent = {};

//=====================================
// Action
//=====================================


/** This creates the command. Both the initial and full names should be passed in 
 * even is they are the same. */
movecomponent.createUndoCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getModelManager();
    var model = modelManager.getModel();
    var member = model.lookupMemberById(commandData.memberId);
    var parent = member.getParent(model);
    var oldMemberName = member.getName();
    
    var undoCommandJson = {};
    undoCommandJson.type = movecomponent.commandInfo.type;
    undoCommandJson.memberId = commandData.memberId;
    undoCommandJson.newMemberName = oldMemberName;
    undoCommandJson.newParentId = parent.getId();
    
    return undoCommandJson;
};

movecomponent.executeCommand = function(workspaceManager,commandData) {
    
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();

    var actionData = {};
    actionData.action = "moveMember";
    actionData.memberId = commandData.memberId;
    actionData.targetName = commandData.newMemberName;
    actionData.targetParentId = commandData.newParentId;

    let actionResult = doAction(model,actionData);
    if(!actionResult.actionDone) {
        throw new Error("Error moving member: " + actionResult.errorMsg);
    }
};

movecomponent.commandInfo = {
    "type": "moveComponent",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(movecomponent);

/** Open Workspace Command
 *
 * Command JSON format:
 * {
 *   "type":"openWorkspace",
 *   "workspaceJson":(workspace JSON),
 *   "fileMetadata":(file metadata)
 * }
 */ 
let openworkspace = {};

//=====================================
// Action
//=====================================

//NO UNDO FOR OPEN Workspace
//openworkspace.createUndoCommand = function(workspaceManager,commandData) {

openworkspace.executeCommand = function(workspaceManager,commandData) {
    workspaceManager.load(commandData.workspaceJson,commandData.fileMetadata);
};

openworkspace.commandInfo = {
    "type": "openWorkspace",
    "targetType": "workspace",
    "event": "created"
};

CommandManager.registerCommand(openworkspace);

/** This file contains some methods for creating commands to do updates for component members.
 * There are 
 */



/** This method can be called to create a undo function to return a member to the current state
 * following a code or data update. */
function getMemberStateUndoCommand(model, memberId) {
    
    var member = model.lookupMemberById(memberId);
    var command = {};
    
    if((member.isCodeable)&&(member.hasCode())) {
        //check if the current state has code set - if so, set the code for the undo function
        command.type = "saveMemberCode";
        command.argList = member.getArgList();
        command.functionBody = member.getFunctionBody();
        command.supplemental = member.getSupplementalCode();      
    }
    else {
        command.type = "saveMemberData";
        
        //here the object has data set. Check if an "alternate" data values was set - error, pending or invalid
        let state = member.getState();
        if(state == apogeeutil$1.STATE_ERROR) {
            //member has an error
            let errors = member.getErrors();
            //Fix this to save all the 
            command.data = errors[0];
            
        }
        else if(state == apogeeutil$1.STATE_INVALID) {
            //result is invalid - set value to invalid in undo
            command.data = apogeeutil$1.INVALID_VALUE;
        }
        else if(state == apogeeutil$1.STATE_PENDING) {
            //we have a pending promise. use it for the command
            commandData = member.getPendingPromise();
        }
        else {
            //normal data case
            command.data = member.getData();
        }
    }

    command.memberId = memberId;
    
    return command;
}




/** @private */
function getSaveDataAction(model,memberId,data) {

    var actionData = {};
    actionData.action = "updateData";
    actionData.memberId = memberId;
    actionData.data = data;
    return actionData;
}

function getSetCodeAction$1(model,memberId,argList,functionBody,supplementalCode,optionalClearCodeDataValue) {
     
    var actionData = {};

    if((optionalClearCodeDataValue != undefined)&&(functionBody == "")&&(supplementalCode == "")) {
        //special case - clear code
        actionData.action = "updateData";
        actionData.memberId = memberId;
        actionData.data = optionalClearCodeDataValue;
    }
    else {
        //standard case - edit code
        actionData.action = "updateCode";
        actionData.memberId = memberId;
        actionData.argList = argList;
        actionData.functionBody = functionBody;
        actionData.supplementalCode = supplementalCode;  
    }

    return actionData;
}

/** Save Member Data Command
 *
 * Command JSON format:
 * {
 *   "type":"saveMembeData",
 *   "memberId":(main member ID),
 *   "argList":(argument list json array),
 *   "functionBody":(function body)
 *   "supplementalCode":(supplementalCode code - optional)
 *   "clearCodeDataValue":(value to set data is code cleared - optional)
 * }
 */ 
let savemembercode = {};

//=====================================
// Action
//=====================================

savemembercode.createUndoCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getModelManager();
    let model = modelManager.getModel();
    var undoCommandJson = getMemberStateUndoCommand(model,commandData.memberId); 
    return undoCommandJson;
};

savemembercode.executeCommand = function(workspaceManager,commandData) {
    
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();
    
    var actionData = getSetCodeAction$1(model,
        commandData.memberId,
        commandData.argList,
        commandData.functionBody,
        commandData.supplementalCode,
        commandData.clearCodeDataValue);
    
    var actionResult = doAction(model,actionData);
    if(!actionResult.actionDone) {
        throw new Error("Error saving member code: " + actionResult.errorMsg);
    }
};

savemembercode.commandInfo = {
    "type": "saveMemberCode",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(savemembercode);

/** Compound Update Member Command
*
* Command JSON format:
* {
*   "type":"saveMemberCompound",
*   "updateList": [
*          {    //for data update entry
*              "memberId": (member id),
*              "data": (member data value)
*          },
*          {    //for code update entry
*               "memberId": (member id),
 *              "argList":(argument list json array),
 *              "functionBody":(function body)
 *              "supplementalCode":(supplementalCode code - optional)
 *              "clearCodeDataValue":(value to set data is code cleared - optional)
*          }
*    ]
* }
*/


let savemembercompound = {};

savemembercompound.createUndoCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getModelManager();
    let model = modelManager.getModel();

    let undoCommandJson = {};
    undoCommandJson.type = "saveMemberCompound";
    //each entry looks like the associated command, but with "type" removed
    undoCommandJson.updateList = commandData.updateList.forEach( updateEntry => {
        let childUndoUpdateEntry = getMemberStateUndoCommand(model,updateEntry.memberId);
        //the udpate entry is identical to he command without the type, so we will just delete it
        delete childUndoUpdateEntry.type;
        return childUndoUpdateEntry;
    }); 
    return undoCommandJson;
};

savemembercompound.executeCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();
    
    let actionData = {};
    actionData.action = "compoundAction";
    actionData.actions = commandData.updateList.map( updateEntry => {
        if(updateEntry.data != undefined) {
            return getSaveDataAction(model,
                updateEntry.memberId,
                updateEntry.data);
        }
        else if(updateEntry.functionBody != undefined) {
            return getSetCodeAction(model,
                updateEntry.memberId,
                updateEntry.argList,
                updateEntry.functionBody,
                updateEntry.supplementalCode,
                updateEntry.clearCodeDataValue);
        }
    });
    
    var actionResult = doAction(model,actionData);
    if(!actionResult.actionDone) {
        throw new Error("Error saving member data: " + actionResult.errorMsg);
    }
};

savemembercompound.commandInfo = {
    "type": "saveMemberCompound",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(savemembercompound);

/** Save Member Data Command
 *
 * Command JSON format:
 * {
 *   "type":"saveMemberData",
 *   "memberId":(main member Id),
 *   "data":(member data value)
 * }
 */ 
let savememberdata = {};

//=====================================
// Action
//=====================================

savememberdata.createUndoCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getModelManager();
    let model = modelManager.getModel();
    var undoCommandJson = getMemberStateUndoCommand(model,commandData.memberId); 
    return undoCommandJson;
};

savememberdata.executeCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();
    
    var actionData = getSaveDataAction(model,commandData.memberId,commandData.data);
    
    var actionResult = doAction(model,actionData);
    if(!actionResult.actionDone) {
        throw new Error("Error saving member data: " + actionResult.errorMsg);
    }
};

savememberdata.commandInfo = {
    "type": "saveMemberData",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(savememberdata);

/** Update Component Command
 *
 * Command JSON format:
 * {
 *   "type":"updateComponent",
 *   "memberId":(main member ID),
 *   "updatedMemberProperties":(member property json),
 *   "updatedComponentProperties":(component property json)
 * }
 */ 
let updatecomponent = {};

//=====================================
// Command Object
//=====================================

updatecomponent.createUndoCommand = function(workspaceManager,commandData) {
    let modelManager = workspaceManager.getModelManager();
    let model = modelManager.getModel();
    var member = model.lookupMemberById(commandData.memberId);
    var componentId = modelManager.getComponentIdByMemberId(commandData.memberId);
    var component = modelManager.getComponentByComponentId(componentId);

    var originalMemberProperties = {};
    if(member.constructor.generator.readProperties) member.constructor.generator.readProperties(member,originalMemberProperties);
    var originalComponentProperties = {};
    if(component.readExtendedProperties) component.readExtendedProperties(originalComponentProperties);
    
    var undoMemberProperties;
    var undoComponentProperties;
    
    if(commandData.updatedMemberProperties) {
        undoMemberProperties = {};
        for(var propKey in commandData.updatedMemberProperties) {
            undoMemberProperties = originalMemberProperties[propKey];
        }
    }
    
    if(commandData.updatedComponentProperties) {
        undoComponentProperties = {};
        for(var propKey in commandData.updatedComponentProperties) {
            undoComponentProperties = originalComponentProperties[propKey];
        }
    }
    
    var undoCommandJson = {};
    undoCommandJson.type = updatecomponent.commandInfo.type;
    undoCommandJson.memberId = commandData.memberId;
    if(undoMemberProperties) undoCommandJson.updatedMemberProperties = undoMemberProperties;
    if(undoComponentProperties) undoCommandJson.updatedComponentProperties = undoComponentProperties;
    
    return undoCommandJson;
};

/** This method is used for updating property values from the property dialog. 
 * If there are additional property lines, in the generator, this method should
 * be extended to edit the values of those properties too. */
updatecomponent.executeCommand = function(workspaceManager,commandData) {
    
    let modelManager = workspaceManager.getMutableModelManager();
    //wait to get a mutable model instance only if we need it
    let model = modelManager.getModel();
    var member = model.lookupMemberById(commandData.memberId);
    var componentId = modelManager.getComponentIdByMemberId(commandData.memberId);
    var component = modelManager.getMutableComponentByComponentId(componentId);
    
    //create an action to update an member additional properties
    var memberGenerator = member.constructor.generator;
    let actionResult;
    if(memberGenerator.getPropertyUpdateAction) {
        var actionData = memberGenerator.getPropertyUpdateAction(member,commandData.updatedMemberProperties);  
        if(actionData) {
            //get a new, mutable model instance here
            model = modelManager.getMutableModel();
            actionResult = doAction(model,actionData);
            if(!actionResult.actionDone) {
                throw new Error("Error updating member properties: " + actionResult.errorMsg);
            }
        }
    }
 
    //update an component additional properties
    component.loadPropertyValues(commandData.updatedComponentProperties);
};

updatecomponent.commandInfo = {
    "type": "updateComponent",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(updatecomponent);

/** Update Link Command
 *
 * Command JSON format:
 * {
 *   "type":"updateLink",
 *   "entryType":(entry type),
 *   "oldUrl":(original url),
 *   "newUrl":(new url - optional),
 *   "newNickname":(new nickname - optional)
 * }
 */ 
let updatelink = {};


updatelink.createUndoCommand = function(workspaceManager,commandData) {
    var undoCommandJson = {};
    undoCommandJson.type = updatelink.commandInfo.type;
    
    undoCommandJson.entryType = commandData.entryType;
    undoCommandJson.oldUrl = commandData.newUrl;
    
    if(commandData.newUrl != commandData.oldUrl) undoCommandJson.newUrl = commandData.oldUrl;
    
    if(commandData.newNickname !== undefined) {
        //look up the pre-command entry (we change back gto this)
        var referenceManager = workspaceManager.getReferenceManager();
        var referenceEntry = referenceManager.lookupEntry(commandData.entryType,commandData.oldUrl);
        if((referenceEntry)&&(commandData.newNickname != referenceEntry.getNickname())) {
            undoCommandJson.newNickname = referenceEntry.getNickname();
        }
    }
    
    return undoCommandJson;
};

updatelink.executeCommand = function(workspaceManager,commandData) {
    let referenceManager = workspaceManager.getMutableReferenceManager();

    let refEntryId = referenceManager.lookupRefEntryId(commandData.entryType,commandData.oldUrl);
    if(!refEntryId) throw new Error("Reference entry not found. " + entryType + ":" + url);

    let referenceEntry = referenceManager.getMutableRefEntryById(refEntryId);
    if(!referenceEntry) throw new Error("Reference entry not found. refEntryId: " + refEntryId);

    //update entry
    let targetUrl = (commandData.newUrl !== undefined) ? commandData.newUrl : referenceEntry.getUrl();
    let targetNickname = (commandData.newNickname !== undefined) ? commandData.newNickname : referenceEntry.getNickname();
    referenceEntry.updateData(workspaceManager,targetUrl,targetNickname);

    referenceManager.registerRefEntry(referenceEntry);
};

updatelink.commandInfo = {
    "type": "updateLink",
    "targetType": "component",
    "event": "updated"
};

CommandManager.registerCommand(updatelink);

/** Update Workspace Command
 *
 * Command JSON format:
 * {
 *   "type":"updateWorkspace",
 *   "updatedCoreProperties":(member property json), //name only
 *   "updatedAppProperties":(component property json) //currently not used
 * }
 */ 
let updateworkspace = {};

//=====================================
// Action
//=====================================

updateworkspace.createUndoCommand = function(workspaceManager,commandData) {
    var undoCommandJson = {};
    undoCommandJson.type = updateworkspace.commandInfo.type;
    
    //right now we assume this is just a name update
    let modelManager = workspaceManager.getModelManager();
    let model = modelManager.getModel();
    undoCommandJson.updatedCoreProperties = {};
    undoCommandJson.updatedCoreProperties.name = model.getName();
    
    return undoCommandJson;
};

updateworkspace.executeCommand = function(workspaceManager,commandData) {
    
    let modelManager = workspaceManager.getMutableModelManager();
    let model = modelManager.getMutableModel();

    var actionResult;    
    var actionData;
    actionData = {};
    actionData.action = "updateModel";
    actionData.model = model;
    actionData.properties = commandData.updatedCoreProperties;

    actionResult = doAction(model,actionData);
    if(!actionResult.actionDone) {
        throw new Error("Error updating workspace: " + actionResult.errorMsg);
    }

    //update any workspace manager properties here - none for now
};

updateworkspace.commandInfo = {
    "type": "updateWorkspace",
    "targetType": "workspace",
    "event": "updated"
};

CommandManager.registerCommand(updateworkspace);

/** This class manages references for the web page.*/
class ReferenceEntry extends FieldObject {
    
    /** The reference data is a json entry with the referenceType, url and optionally nickname.
     * If this is a copy, the reference data wil be ignored and can be set to null. */
    constructor(referenceData,instanceToCopy,keepUpdatedFixed) {
        super("referenceEntry",instanceToCopy,keepUpdatedFixed);

        if(instanceToCopy) {
            this.referenceType = instanceToCopy.referenceType;
        }
        else {
            this.referenceType = referenceData.entryType;
        }

        //==============
        //Fields
        //==============
        //Initailize these if this is a new instance
        if(!instanceToCopy) {
            this.setField("url",referenceData.url);

            //we create in a pending state because the link is not loaded.
            this.setField("state",apogeeutil$1.STATE_PENDING);

            let nickname = referenceData.nickname;
            if(!nickname) nickname = NO_NICKNAME_EMPTY_STRING; 
            this.setField("nickname",nickname);
        }

        //==============
        //Working variables
        //==============
        this.viewStateCallback = null;
        this.cachedViewState = null;    
    }

    //---------------------------
    // references entry interface
    //---------------------------
    
    getEntryType() {
        return this.referenceType;
    }

    getState() {
        return this.getField("state");
    }

    getUrl() {
        return this.getField("url");
    }

    getNickname() {
        return this.getField("nickname");
    }

    getLabel() {
        let nickname = this.getNickname();
        return nickname ? nickname : this.getUrl();
    }

    getIsLabelUpdated() {
        //this will return true sometimes where there is no update to the label
        return this.areAnyFieldsUpdated(["url","nickname"]);
    }

    setViewStateCallback(viewStateCallback) {
        this.viewStateCallback = viewStateCallback;
    }

    getCachedViewState() {
        return this.cachedViewState;
    }



    ///////////////////////////////////////////////////////////////////////////

    /** This method loads the link onto the page. If passed, the onLoadComplete
     * callback will be called when load completes successfully or fails. */
    loadEntry(workspaceManager) {

        let entryLoadPromise = new Promise( (resolve,reject) => {

            //create load event handlers
            //on completion execute a command to update the link status
            let onLoad = () => {
                let commandData = {
                    type: "updateLinkLoadStatus",
                    entryType: this.referenceType,
                    url: this.getUrl(),
                    success: true
                };
                workspaceManager.runFutureCommand(commandData);
                //call resolve in any case
                resolve();
            };
            let onError = (error) => {
                //for osme on loads we get an event object with no error info
                //convert this to a string
                if(error instanceof Event) {
                    error = "Link load unsuccessful";
                }

                let commandData = {
                    type: "updateLinkLoadStatus",
                    entryType: this.referenceType,
                    url: this.getUrl(),
                    success: false,
                    error: error
                };
                workspaceManager.runFutureCommand(commandData);
                //call resolve in any case
                resolve();
            };

            this.implementationLoadEntry(onLoad,onError,workspaceManager);
        });

        return entryLoadPromise;
    }

    /** This method loads the link onto the page. It should call the 
     * appropriate callback on completion. */
    //implementationLoadEntry(onLoad,onError);
    
    /** This method removes the reference. It returns true if the link remove is successful. */
    //remove()
    
    
    ///////////////////////////////////////////////////////////////////////////

    /** This method loads the link onto the page. It returns a promise that
     * resolves when the link is loaded. */
    toJson() {
        var entryJson = {};
        entryJson.url = this.getUrl();
        if(this.nickname != NO_NICKNAME_EMPTY_STRING) entryJson.nickname = this.getNickname();
        entryJson.entryType = this.referenceType;
        return entryJson;
    }

    //-------------------------
    // Entry specific management methods
    //-------------------------

    /** This method removes and reloads the link, returning a promise. */
    updateData(workspaceManager,url,nickname) {

        //update nickname
        if(!nickname) nickname = NO_NICKNAME_EMPTY_STRING;
        if(this.nickname != nickname) {
            this.setField("nickname",nickname);
        }

        //update url
        if(this.url != url) {
            this.removeEntry();
            this.setField("url",url);
            var promise = this.loadEntry(workspaceManager);
        }

        //if we didn't do a URL update, make a promise that says update was successful
        if(!promise) promise = Promise.resolve({
            cmdDone: true,
            target: this,
            eventAction: "updated"
        });

        return promise;
    }

    //===================================
    // private methods
    //===================================

    setClearState() {
        this.setState(apogeeutil$1.STATE_NORMAL);
    }

    setError(errorMsg) {
        this.setState(apogeeutil$1.STATE_ERROR,errorMsg);
    }

    setPendingState() {
        this.setState(apogeeutil$1.STATE_PENDING,"loading");
    }

    setState(state,msg) {
        if(this.state != state) {
            //for now we are not tracking msg. If we do, we should check for that change too
            this.setField("state",state);
        }
    }

}

//====================================
// Static Fields
//====================================


ReferenceEntry.ELEMENT_ID_BASE = "__apogee_link_element_";

let NO_NICKNAME_EMPTY_STRING = "";

//=====================================
// Status Commands
// These are commands run to update the status of the link after loading completes
//=====================================

/*
 *
 * Command JSON format:
 * {
 *   "type":"updateLinkLoadStatus",
 *   "entryType":(entry type),
 *   "url":(url),
 *   "success":(boolean),
 *   "error":(error object or error string - optional. Only used in the success=false case)
 * }
 * 
 */ 

let updatelinkstatus = {};

//No undo command. Only the original call needs to be undone.
//updatelinkstatus.createUndoCommand = function(workspaceManager,commandData) {

updatelinkstatus.executeCommand = function(workspaceManager,commandData) {
    
    var commandResult = {};
    var referenceManager = workspaceManager.getMutableReferenceManager();
    
    //lookup entry for this reference
    let refEntryId = referenceManager.lookupRefEntryId(commandData.entryType,commandData.url);
    let referenceEntry = referenceManager.getMutableRefEntryById(refEntryId);
    if(referenceEntry) {
        //update entry status
        //add event handlers
        if(commandData.success) {
            commandResult.cmdDone = true;
            referenceEntry.setClearState();
        }
        else {
            var errorMsg = "Failed to load link '" + referenceEntry.getUrl() + "':" + commandData.error.toString();
            console.error(errorMsg);
            referenceEntry.setError(errorMsg);
        }

        //save the updated entry
        referenceManager.registerRefEntry(referenceEntry);
    }
    else {
        //reference entry not found
        throw new Error("Reference entry not found: " + commandData.url);
    }
    
    return commandResult;
};

updatelinkstatus.commandInfo = {
    "type": "updateLinkLoadStatus",
    "targetType": "referenceEntry",
    "event": "updated"
};

CommandManager.registerCommand(updatelinkstatus);

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
class EsModuleEntry extends ReferenceEntry {
    
    constructor(referenceList,referenceData) {
        super(referenceList,referenceData,EsModuleEntry.REFERENCE_TYPE_INFO);
    }
            
    /** This method loads the actual link. */
    implementationLoadEntry(onLoad,onError,workspaceManager) {
        let localOnLoad = (module) => {
            if(module) {
                if(module.initApogeeModule) module.initApogeeModule();
            
                let commandData = {
                    type: "setEsModule",
                    entryType: this.referenceType,
                    url: this.getUrl(),
                    module: module
                };
                workspaceManager.runFutureCommand(commandData);
                onLoad();
            }
            else {
                onError("Unknown error: Module not properly loaded. " + this.getUrl());
            }

        };

        //load the module
        var moduleLoadPromise = import(this.getUrl()).then(localOnLoad).catch(onError);
    }
    
    /** This method removes the link. This returns a command result for the removed link. */
    removeEntry() {
        //allow for an optional module remove step
        let module = this.getField("module");
        if(module) {
            if(module.removeApogeeModule) module.removeApogeeModule();
            this.clearField("module");
        }
        return true;
    }
    
}

EsModuleEntry.REFERENCE_TYPE = "es module";

//=====================================
//Load Module Command
// These are commands run to update the status of the link after loading completes
//=====================================

/*
 *
 * Command JSON format:
 * {
 *   "type":"setEsModule",
 *   "entryType":(entry type),
 *   "url":(url),
 *   "module":(the module),
 * }
 * 
 */ 

let setesmodule = {};

//No undo command. Only the original call needs to be undone.
//setesmodule.createUndoCommand = function(workspaceManager,commandData) {

setesmodule.executeCommand = function(workspaceManager,commandData) {
    
    let referenceManager = workspaceManager.getMutableReferenceManager();

    let refEntryId = referenceManager.lookupRefEntryId(commandData.entryType,commandData.url);
    if(!refEntryId) throw new Error("Reference entry not found. " + commandData.entryType + ":" + commandData.url);

    let referenceEntry = referenceManager.getMutableRefEntryById(refEntryId);
    if(!referenceEntry) throw new Error("Reference entry not found. refEntryId: " + refEntryId);
    
    referenceEntry.setField("module",commandData.module);
};

setesmodule.commandInfo = {
    "type": "setEsModule",
    "targetType": "referenceEntry",
    "event": "updated"
};

CommandManager.registerCommand(setesmodule);

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
class NpmModuleEntry extends ReferenceEntry {
    
    constructor(referenceList,referenceData) {
        super(referenceList,referenceData,NpmModuleEntry.REFERENCE_TYPE_INFO);

    }

    /** This method loads the actual link. */
    implementationLoadEntry(onLoad,onError) {

        //synchronous loading
        try {
            let module = require(this.getUrl());
            if((module)&&(module.initApogeeModule)) module.initApogeeModule();
            this.setField("module",module);
            
            onLoad();
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            
            onError(errorMsg);
        }

    }
    
    /** This method removes the link. */
    removeEntry() {
        //allow for an optional module remove step
        let module = this.getField("module");
        if(module) {
            if(module.removeApogeeModule) module.removeApogeeModule();

            this.clearField("module");
        }
        
        //we aren't really removing it...
        //require.undef(this.url);

        return true;
    }
    
}

NpmModuleEntry.REFERENCE_TYPE = "npm module";

/** This is the main apogeeapp ui file */
let uiutil = {};

/** This should be called to initializethe resource path. */
uiutil.initResourcePath = function(resourceDirectory) {
    uiutil.RESOURCE_DIR = resourceDirectory;
};

/** This retreives the resoruce path for a resource. */
uiutil.getResourcePath = function(relativePath) {
    return uiutil.RESOURCE_DIR + relativePath;
};

//I put some utilities in here. I shoudl figure out a better place to put this.

//=====================================
// ZIndex Constants
//=====================================
uiutil.MENU_ZINDEX = 100;
uiutil.WINDOW_FRAME_ZINIDEX = 10;
uiutil.DIALOG_ZINDEX = 200;

//======================================
// ID Generator
//======================================

uiutil.idIndex = 0;
uiutil.idBase = "_visiui_id_";

/** This method generates a generic id for dom elements. */
uiutil.createId = function() {
    return uiutil.idBase + uiutil.idIndex++;
};

//=========================================
// style methods
//=========================================

/** This method applies the style json to the dom element. */
uiutil.applyStyle = function(element,style) {
    for(var key in style) {
        element.style[key] = style[key];
    }
};

//=========================================
// resources
//=========================================

uiutil.MINIMIZE_CMD_IMAGE = "/minimize.png";
uiutil.RESTORE_CMD_IMAGE = "/restore.png";
uiutil.MAXIMIZE_CMD_IMAGE = "/maximize.png";
uiutil.CLOSE_CMD_IMAGE = "/close_gray.png";
uiutil.MENU_IMAGE = "/hamburger.png";

//=========================================
// dom methods
//=========================================


/** This method removes all the content from a DOM element. */
uiutil.removeAllChildren = function(element) {
	while(element.lastChild) {
		element.removeChild(element.lastChild);
	}
};

/** This method applies the style json to the dom element. All arguments
 * besides type are optional.
 * 
 * type is the element type
 * properties are javascript properties, 
 * styleProperties are the style properties
 * */
uiutil.createElement = function(type,properties,styleProperties) {
    var element = document.createElement(type);
    if(properties) {
        for(var key in properties) {
            element[key] = properties[key];
        }
    }
    if(styleProperties) {
        uiutil.applyStyle(element,styleProperties);
    }
    return element;
};

/** This method creates a DOM element of the given type, sets the class name
 * and, if present, adds it to the given parent. */
uiutil.createElementWithClass = function(elementType,className,parent) {
    var element = document.createElement(elementType);
    element.className = className;
    if(parent) parent.appendChild(element);
    return element;
};

//=========================================
// window and dialog methods
//=========================================

uiutil.dialogLayer = null;

uiutil.BASE_ELEMENT_STYLE = {
    "position":"absolute",
    "left":"0px",
    "right":"0px",
    "top":"0px",
    "bottom":"0px",
    "zIndex":1
};

uiutil.DIALOG_LAYER_STYLE = {
    "position":"absolute",
    "left":"0px",
    "right":"0px",
    "top":"0px",
    "bottom":"0px",
    "zIndex": 2,
    "pointerEvents": "none"
};

uiutil.DIALOG_SHIELD_STYLE = {
    "position":"absolute",
    "left":"0px",
    "right":"0px",
    "top":"0px",
    "bottom":"0px",
    "pointerEvents": "auto"
};
    
uiutil.initWindows = function(appElementId) {
    //create the ui elements from the app element
    var appContainer = document.getElementById(appElementId);
    if(!appContainer) {
        throw new Error("Container ID not found: " + appElementId);
    }
    
    var elements = {};
    elements.baseElement = uiutil.createElement("div",null,uiutil.BASE_ELEMENT_STYLE); 
    elements.dialogLayer = uiutil.createElement("div",null,uiutil.DIALOG_LAYER_STYLE);
    
    appContainer.appendChild(elements.baseElement);
    appContainer.appendChild(elements.dialogLayer);
    
    uiutil.dialogLayer = elements.dialogLayer;
    
    return elements;
};

uiutil.WINDOW_STATE_MINIMIZED = -1;
uiutil.WINDOW_STATE_NORMAL = 0;
uiutil.WINDOW_STATE_MAXIMIZED = 1;

//refers to minimized, restored or maximized
uiutil.WINDOW_STATE_CHANGED = "window state change";

uiutil.MINIMIZABLE = 0x01;
uiutil.MAXIMIZABLE = 0x02;
uiutil.CLOSEABLE = 0x04;

/** This is a handler name used to request closing the window, tab or other UI element. */
uiutil.REQUEST_CLOSE = "request_close";
uiutil.DENY_CLOSE = -1;

uiutil.CLOSE_EVENT = "closed";
uiutil.RESIZED_EVENT = "resized";
uiutil.SHOWN_EVENT = "shown";
uiutil.HIDDEN_EVENT = "hidden";

/** This function adds CSS data for a given member id. */
uiutil.setObjectCssData = function(objectId,cssText) {
    var cssElementId = "css_" + objectId;
    
    var cssElement = document.getElementById(cssElementId);
    if(cssText != "") {
        if(!cssElement) {
            cssElement = document.createElement("style");
            cssElement.id = cssElementId;
            document.head.appendChild(cssElement);
        }
        cssElement.innerHTML = cssText;
    }
    else {
        if(cssElement) {
            document.head.removeChild(cssElement);
        }
    }
};

//======================================
//window content types
//These are types of content that can be put in a window or other container. If is it 
//resizable it can be fitted to the window size. If it is fixed size it can be 
//added to a scrolling window or used to set the container size
//======================================
uiutil.RESIZABLE = 0x01;
uiutil.FIXED_SIZE = 0x02;

uiutil.SCROLL_NONE = 0x00;
uiutil.SCROLL_VERTICAL = 0x01;
uiutil.SCROLL_HORIZONTAL = 0x02;
uiutil.SCROLL_BOTH = 0x03;


//this is not an actual content type, but an option for displaying FIXED_SIZE content
uiutil.SIZE_WINDOW_TO_CONTENT = 0x03;

//---------------------------------
// Link Element Management - This manages DOM elements for links
//---------------------------------
class LinkLoader {
    /** 
     * This is a singleton and the constructor should not be called.
     * @private
     */
    constructor() {          
        this.scriptElements = [];
        this.cssElements = [];
        this.nextLinkCallerId = 1;
    }
    
    /** This returns a unique caller id which should bbe used when adding or removing
     * a link. This is done to allow mulitple callers to share a link.
     */
    createLinkCallerId() {
        return this.nextLinkCallerId++;
    }

    /** 
     * This method adds a link element to a page, supporting 'css' and 'script'. 
     * The caller identifer should be a unique identifier among people
     * requesting links of this given type. It cna be requested from
     * ReferenceEntry._createId
     * @protected
     */
    addLinkElement(type,url,linkCallerId,onLoad,onError) {
        try {
            var addElementToPage = false;
            var elementType;

            var elementList;
            if(type == "css") {
                elementList = this.cssElements;
                elementType = "link";
            }
            else if(type == "script") {
                elementList = this.scriptElements;
                elementType = "script";
            }
            else throw new Error("Unknown link type: " + type);

            var elementEntry = elementList[url];
            if(!elementEntry) {
                //create script element reference
                elementEntry = {};
                elementEntry.url = url;
                elementEntry.callerInfoList = [];

                //create script element
                var element = document.createElement(elementType);

                if(type == "css") {
                    element.href = url;
                    element.rel = "stylesheet";
                    element.type = "text/css";
                }
                else if(type == "script") {
                    element.src = url;
                }

                element.onload = () => {
                    elementEntry.callerInfoList.forEach(callerInfo => {if(callerInfo.onLoad) callerInfo.onLoad();});
                };
                element.onerror = (error) => {
                    elementEntry.callerInfoList.forEach(callerInfo => {if(callerInfo.onError) callerInfo.onError(error);});
                };

                elementEntry.element = element;
                elementList[url] = elementEntry;

                addElementToPage = true;  
            }

            //add this to the caller info only if it is not there
            if(!elementEntry.callerInfoList.some(callerInfo => (callerInfo.id == linkCallerId))) {
                var callerInfo = {};
                callerInfo.id = linkCallerId;
                if(onLoad) callerInfo.onLoad = onLoad;
                if(onError) callerInfo.onError = onError;

                elementEntry.callerInfoList.push(callerInfo);
            }

            if(addElementToPage) {
                document.head.appendChild(elementEntry.element);
            }
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            
            //error loading link  
            if(onError) {
                onError(error);
            }
            else {
                console.error(error.stack);
            }
        }

    }

    /** This method removes a link element from the page.
     * @protected */
    removeLinkElement(type,url,linkCallerId) {
        var elementList;
        if(type == "css") elementList = this.cssElements;
        else if(type == "script") elementList = this.scriptElements;
        else throw new Error("Unknown link type: " + type);

        var elementEntry = elementList[url];
        if(elementEntry) {
            //remove this caller from caller list
            elementEntry.callerInfoList = elementEntry.callerInfoList.filter(callerInfo => callerInfo.id != linkCallerId);

            //remove link if there are no people left using it
            if(elementEntry.callerInfoList.length === 0) {
                if(elementEntry.element) document.head.removeChild(elementEntry.element);
                delete elementList[url];
            }
        }
    }
}

//======================================
// static singleton methods
//======================================

/** @private */
let instance = null;

/** This retrieves the link loader instance. */
function getLinkLoader() {
    if(!instance) {
        instance = new LinkLoader();
    }
    return instance;
}

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
class JsScriptEntry extends ReferenceEntry {
    
    constructor(referenceList,referenceData) {
        super(referenceList,referenceData,JsScriptEntry.REFERENCE_TYPE_INFO);

    }

    /** This method loads the actual link. */
    implementationLoadEntry(onLoad,onError) {
        this.linkCallerId = getLinkLoader().createLinkCallerId();
        getLinkLoader().addLinkElement("script",this.getUrl(),this.getId(),onLoad,onError);
    }
    
    /** This method removes the link. */
    removeEntry() {
        getLinkLoader().removeLinkElement("script",this.getUrl(),this.getId());
        return true;
    }
    
    _getLinkCallerHandle() {
        return "JsScriptEntry-" + this.getId();
    }
}

JsScriptEntry.REFERENCE_TYPE = "js link";

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
class CssEntry extends ReferenceEntry {
    
    constructor(referenceList,referenceData) {
        super(referenceList,referenceData,CssEntry.REFERENCE_TYPE_INFO);
    }


    /** This method loads the actual link. */
    implementationLoadEntry(onLoad,onError) {
        this.linkCallerId = getLinkLoader().createLinkCallerId();
        getLinkLoader().addLinkElement("css",this.getUrl(),this.getId(),onLoad,onError);
    }

    
    /** This method removes the link. It returns true if the link is removed. */
    removeEntry() {
        getLinkLoader().removeLinkElement("css",this.getUrl(),this.getId());
        return true;
    }
}

CssEntry.REFERENCE_TYPE = "css link";

/** This file initializes the reference class types available. */

let referenceClassArray = [];
if(__APOGEE_ENVIRONMENT__ == "WEB") {
    referenceClassArray.push(EsModuleEntry);
    referenceClassArray.push(JsScriptEntry);
    referenceClassArray.push(CssEntry);
}
else if(__APOGEE_ENVIRONMENT__ == "NODE") {
    referenceClassArray.push(NpmModuleEntry);
}
else {
    console.log("Warning - apogee environment not recognized!");
}

ReferenceManager.setReferenceClassArray(referenceClassArray);

//This is a single module that exports the public items from the apogee app namespace

var apogeeapp = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Apogee: Apogee,
    BaseFileAccess: BaseFileAccess,
    Component: Component,
    componentInfo: componentInfo
});

/** Thiis is a namespace with functions to control menu operation
 *
 * NOTE - the name Menu should probably be menu because this
 * is just a namespace and not a class, however when I converted this from a namespace
 * qualified by apogeeui, I didn't want to collide with local variables which are
 * often named "menu".
 *
 * @class 
 */
let Menu = {};

Menu.initialized = false;
Menu.activeMenu = null;

/** This method creates a static menu with the given text. */
Menu.createMenu = function(text) {

    //initialize menus, if needed
    if(!Menu.initialized) {
        Menu.initialize();
    }

    var element = uiutil.createElementWithClass("div", "visiui-menu-heading visiui-menu-text");
    element.innerHTML = text;
    return new MenuHeader(element);
};

/** This method creates a static menu from the given img url. */
Menu.createMenuFromImage = function(imageUrl) {

    //initialize menus, if needed
    if(!Menu.initialized) {
        Menu.initialize();
    }

    var imageElement = document.createElement("img");
    imageElement.src = imageUrl;
    var element = uiutil.createElementWithClass("div", "visiui-menu-heading visiui-menu-image");
    element.appendChild(imageElement);
    return new MenuHeader(element);
};

/** This method creates a context menu object. */
Menu.createContextMenu = function() {

    //initialize menus, if needed
    if(!Menu.initialized) {
        Menu.initialize();
    }

    return new MenuBody();
};

Menu.showContextMenu = function(menuBody,contextEvent) {
    //create menu and attach to document body
    menuBody.setPosition(contextEvent.clientX, contextEvent.clientY, document.body);
    //cacnel default popup
    contextEvent.preventDefault();
    //show
    Menu.show(menuBody);
};

Menu.menuHeaderPressed = function(menuHeader) {
	//if there is an active menu, pressing that header closes the active menu otherwise show the menu
	if(Menu.activeMenu === menuHeader) {
		//active menu - close the menu
		Menu.hideActiveMenu();
	}
	else {
		//no active menu, open this menu
		Menu.show(menuHeader.getMenuBody());
	}
};

Menu.nonMenuPressed = function() {
	//if the mouse is pressed outside the menu, close any active menu
	if(Menu.activeMenu) {
		Menu.hideActiveMenu();
	}
};

//================================
// Internal
//================================

Menu.show = function(menuBody) {
	if(Menu.activeMenu) {
		Menu.hideActiveMenu();
	}
	var parentElement = menuBody.getParentElement();
    menuBody.prepareShow();
    var menuElement = menuBody.getMenuElement();
    if((parentElement)&&(menuElement)) {
        parentElement.appendChild(menuElement);
        Menu.activeMenu = menuBody;
        //set the header to active
        var menuHeader = menuBody.getMenuHeader();
        if(menuHeader) {
            menuHeader.className = "visiui-menu-heading visiui-menu-heading-active";
        }
    }
};

Menu.hideActiveMenu = function() {
	if(Menu.activeMenu) {
        var activeMenu = Menu.activeMenu;
        //set the header to normal (not active)
        var menuHeader = activeMenu.getMenuHeader();
        if(menuHeader) {
            menuHeader.className = "visiui-menu-heading";
        }
        
        var parentElement = activeMenu.getParentElement();
        var menuElement = activeMenu.getMenuElement();
        if((parentElement)&&(menuElement)) {
            parentElement.removeChild(menuElement);
            Menu.activeMenu = null;
        }
        activeMenu.menuHidden();
	}
};

Menu.nonMenuMouseHandler = null;

Menu.initialize = function() {
	window.addEventListener("mousedown",Menu.nonMenuPressed);
	Menu.initialized = true;
};

/** This method allows you to undo the initialization actions. I am not sure you would ever need to do it. */
Menu.deinitialize = function() {
	window.removeEventListener("mousedown",Menu.nonMenuPressed);
	Menu.initialized = false;
};

//##################################################################################################


/** This is a menu component
 * This class shoudl only be constructed internally the Menu namespace. 
 * Before it is constructed, the Menu should be initialized.
 *
 * @class 
 */
class MenuBody {

    constructor() {
        
        //variables
        this.menuDiv = null;
        this.parentElement = null;
        
        this.menuItems = {};
        
        //construct the menu
        this.createMenuElement();
        
        //this will be set if it is a static menu
        this.menuHeader = null;
    }

    /** this returns the dom element for the menu object. */
    getMenuElement() {
        return this.menuDiv;
    }

    /** This returns the parent element for the menu.  */
    getParentElement() {
        return this.parentElement;
    }

    /** This returns the parent element for the menu.  */
    getMenuHeader() {
        return this.menuHeader;
    }

    /** This returns the parent element for the menu.  */
    getIsContext() {
        return (this.menuHeader == null);
    }

    /** This is called before the menu body is shown */
    prepareShow() {
        if(this.isOnTheFlyMenu) {
            this.constructItemsForShow();
        }
    }

    /** This is called after the menu body is hidden. */
    menuHidden() {
        if(this.isOnTheFlyMenu) {
            this.destroyItemsForHides();
        }
    }

    /** This method is used to attach the menu to the menu head, in a static menu. */
    attachToMenuHeader(menuHeader) {
        //attach menu to heading
        this.parentElement = menuHeader.getElement();
        this.menuDiv.style.left = "0%";
        this.menuDiv.style.top = "100%";
        this.menuHeader = menuHeader;
    }

    /** This method is used to set the position for a context menu. The x and y coordinates
     * should be the coordinates in the parent element. It is recommended to use the 
     * document body. */
    setPosition(x, y, parentElement) {
        this.parentElement = parentElement;
    
    //we need to calculate the size, so I add and remove it - there is probably another way
    parentElement.appendChild(this.menuDiv);
        var parentWidth = parentElement.offsetWidth;
        var parentHeight = parentElement.offsetHeight;
        var menuWidth = this.menuDiv.clientWidth;
        var menuHeight = this.menuDiv.clientHeight;
    parentElement.appendChild(this.menuDiv);

        //position
        if((x + menuWidth > parentWidth)&&(x > parentWidth/2)) {
            this.menuDiv.style.left = (x - menuWidth) + "px";
        }
        else {
            this.menuDiv.style.left = x + "px";
        }
        if((y + menuHeight > parentHeight)&&(y > parentHeight/2)) {
            this.menuDiv.style.top = (y - menuHeight) + "px";
        }
        else {
            this.menuDiv.style.top = y + "px";
        }
    }

    /** This sets a callback to create the menu when the menu is opened. This is
     * for static menus where we do not want to populate it ahead of time. */
    setAsOnTheFlyMenu(menuItemsCallback) {
        this.isOnTheFlyMenu = true;
        this.menuItemsCallback = menuItemsCallback;
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    addEventMenuItem(title, eventName, eventData, eventManager) {
        var itemInfo = {};
        itemInfo.title = title;
        itemInfo.eventName = eventName;
        itemInfo.eventData = eventData;
        itemInfo.eventManager = eventManager;
        this.addMenuItem(itemInfo);
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    addCallbackMenuItem(title, callback) {
        var itemInfo = {};
        itemInfo.title = title;
        itemInfo.callback = callback;
        this.addMenuItem(itemInfo);
    }
        
    /** this adds a menu item that dispatchs the given event when clicked. */
    addMenuItem(itemInfo) {
        itemInfo.element = uiutil.createElementWithClass("div","visiui-menu-item");
        itemInfo.element.innerHTML = itemInfo.title;
        
        if(itemInfo.childMenuItems) {
            //create a parent menu item
            var childMenuBody = this.createChildMenuBody(itemInfo.childMenuItems);
            var childMenuDiv = childMenuBody.getMenuElement();
            childMenuDiv.style.left = "100%";
            childMenuDiv.style.top = "0%";
            itemInfo.element.appendChild(childMenuDiv);
            
            //prevent normal action on a click
            itemInfo.element.onmousedown = (event) => {
                event.stopPropagation();
            };
            itemInfo.element.onclick = (event) => {
                event.stopPropagation();
            };
        }
        else {
            //create a norman (clickable) menu item
            itemInfo.element.onmousedown = (event) => {
                event.stopPropagation();
            };
            itemInfo.element.onclick = (event) => {
                //close menu
                Menu.hideActiveMenu();

                //do menu action
                if(itemInfo.eventName) {
                    //dispatch event
                    itemInfo.eventManager.dispatchEvent(itemInfo.eventName,itemInfo.eventData);
                }
                else if(itemInfo.callback) {
                    //use the callback
                    itemInfo.callback();
                }
                event.stopPropagation();
            };
        }
        
        this.menuDiv.appendChild(itemInfo.element);
        this.menuItems[itemInfo.title] = itemInfo;
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    setMenuItems(itemInfos) {
        for(var i = 0; i < itemInfos.length; i++) {
            this.addMenuItem(itemInfos[i]);
        }
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    removeMenuItem(title) {
        var itemInfo = this.menuItems[title];
        if(itemInfo) {
            this.menuDiv.removeChild(itemInfo.element);
            delete this.menuItems[title];
        }
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    removeAllMenuItems() {
        for(var title in this.menuItems) {
            this.removeMenuItem(title);
        }
    }

    //================================
    // Internal
    //================================

    /** This method creates the menu body that is shown below the header. */
    createMenuElement() {
        this.menuDiv = uiutil.createElementWithClass("div","visiui-menu-body");
    }

    constructItemsForShow () {
        if(this.menuItemsCallback) {
            var menuItems = this.menuItemsCallback();
            this.setMenuItems(menuItems);
        }
    }

    /** This is called after the menu body is hidden. */
    destroyItemsForHides() {
        if(this.menuDiv) {
            uiutil.removeAllChildren(this.menuDiv);
        }
        this.menuItems = {};
    }

    createChildMenuBody(menuItems) {
        var childMenuBody = new MenuBody();
        childMenuBody.setMenuItems(menuItems);
        return childMenuBody;
    }

}

//###########################################################################################################

/** This is a menu component, attached to the given dom element
 * This class shoudl only be constructed internally the Menu namespace. 
 * Before it is constructed, the Menu should be initialized.
 *
 * @class 
 */
class MenuHeader {

    constructor(domElement) {
        
        //variables
        this.domElement = domElement;
        this.menuBody = new MenuBody();
        
        //construct the menu
        this.initHeadingElement();
        
        //attach menu to heading
        this.menuBody.attachToMenuHeader(this);
    }

    /** this returns the dom element for the menu heading. */
    getElement() {
        return this.domElement;
    }

    /** this returns the dom element for the menu heading. */
    setChildLocation(childLocation) {
        this.childLocation = childLocation;
    }

    /** this returns the dom element for the menu heading. */
    getChildLocation() {
        return this.childLocation;
    }

    /** this returns the dom element for the menu object. */
    getMenuBody() {
        return this.menuBody;
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    addEventMenuItem(title, eventName, eventData, eventManager) {
        this.menuBody.addEventMenuItem(title,eventName, eventData, eventManager);
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    addCallbackMenuItem(title, callback) {
        this.menuBody.addCallbackMenuItem(title,callback);
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    addMenuItem(itemInfo) {
        this.menuBody.addMenuItem(itemInfo);
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    setMenuItems(itemInfos) {
        this.menuBody.setMenuItems(itemInfos);
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    removeMenuItem(title) {
        this.menuBody.removeMenuItem(title);
    }

    /** this adds a menu item that dispatchs the given event when clicked. */
    removeAllMenuItems() {
        this.menuBody.removeAllMenuItems();
    }

    /** This sets a callback to create the menu when the menu is opened. This is
     * for static menus where we do not want to populate it ahead of time. */
    setAsOnTheFlyMenu(getMenuItemsCallback) {
        this.menuBody.setAsOnTheFlyMenu(getMenuItemsCallback);
    }
    //================================
    // Init
    //================================

    /** this adds a menu item that dispatchs the given event when clicked. */
    initHeadingElement() {	
        this.domElement.onmousedown = (e) => {
            Menu.menuHeaderPressed(this);
            e.stopPropagation();
        };	
    }

}

/** This is a window frame component. IT is used the table window and the dialog.
 *
 * It can be minimized an maximized and dragged and resized with the mouse.  
 * 
 * options:
 * minimizable - allow content to be minimized. defaylt value: false
 * maximizable - allow content to be maximized. default value: false
 * closable - display a close button. defalt value: false
 * resizable- allow resizing window with mouse. default vlue: false
 * movable - allow moving window with mouse. default value : false
 *
 * @class 
 */
class WindowFrame {

    constructor(options) {
        //mixin initialization
        this.eventManagerMixinInit();
        
        //set the options
        if(!options) {
            options = {};
        }
        
        //variables
        this.windowParent = null;
        this.parentElement = null;
        this.options = options;

        this.windowState = (options.initialState !== undefined) ? options.initialState : uiutil.WINDOW_STATE_NORMAL; //minimize, normal, maximize
        
        //set default size values
        this.posInfo = {};
        this.posInfo.x = 0;
        this.posInfo.y = 0;
        this.sizeInfo = {};
        this.sizeInfo.width = WindowFrame.DEFAULT_WINDOW_WIDTH;
        this.sizeInfo.height = WindowFrame.DEFAULT_WINDOW_HEIGHT;
        
        this.frame = null;
        this.titleCell = null;
        this.headerCell = null;
        this.bodyCell = null;
        
        this.content = null;
        
        this.windowDragActive = false;
        this.moveOffsetX = null;
        this.moveOffsetX = null;
        //handlers we place on the parent during a move
        this.moveOnMouseMove = null;
        this.moveOnMouseLeave = null;
        this.moveOnMouseUp = null;
        
        this.resizeEastActive = false;
        this.resizeWestActive = false;
        this.resizeNorthActive = false;
        this.resizeSouthActive = false;
        this.resizeOffsetWidth = null;
        this.resizeOffsetHeight = null;
        //hanlders we place on the parent during a resize
        this.resizeOnMouseUp = null;
        this.resizeOnMouseMove = null;
        this.resizeOnMouseLeave = null;
        
        //these should be set to soemthing more meeaningful, like the minimum sensible width of the title bar
        this.minWidth = 0;
        this.minHeight = 0;
        
        //initialize
        this.initUI();
        
        //add the handler to move the active window to the front
        var frontHandler = () => {
            this.windowParent.bringToFront(this);
        };
        var element = this.getElement();
        element.addEventListener("mousedown",frontHandler);
    }


    //====================================
    // Public Methods
    //====================================

    //---------------------------
    // WINDOW CONTAINER
    //---------------------------

    /** This method shows the window. */
    getTitle() {
        return this.title;
    }

    /** This method shows the window. */
    setTitle(title) {
        this.title = title;
        this.titleBarTitleElement.innerHTML = title;
    }

    /** This method shows the window. */
    createMenu(iconUrl) {
        if(!iconUrl) iconUrl = uiutil.getResourcePath(uiutil.MENU_IMAGE);
        this.menu = Menu.createMenuFromImage(iconUrl);
        this.titleBarMenuElement.appendChild(this.menu.getElement());
        //create the icon (menu) overlay
        this.iconOverlayElement = uiutil.createElementWithClass("div","visiui_win_icon_overlay_style",this.titleBarMenuElement);
        
        return this.menu;
    }

    /** This method shows the window. */
    getMenu() {
        return this.menu;
    }

    /** This sets the given element as the icon overlay. If null or other [false} is passed
     * this will just clear the icon overlay. */
    setIconOverlay(element) {
        if(this.iconOverlayElement) {
            this.clearIconOverlay();
            if(element) {
                this.iconOverlayElement.appendChild(element);
            }
        }
    }

    clearIconOverlay() {
        if(this.iconOverlayElement) {
            uiutil.removeAllChildren(this.iconOverlayElement);
        }
    }

    /** This sets the content for the window. If null (or otherwise false) is passed
     * the content will be set to empty.*/
    setHeaderContent(contentElement) {
        uiutil.removeAllChildren(this.headerCell);
        if(contentElement) {
            this.headerCell.appendChild(contentElement);
        }
    }

    /** This sets the content for the window. The content type
     *  can be:
     *  uiutil.RESIZABLE - content can be resized to fit window - scrolling, if necessary is managed within the content element.
     *  uiutil.FIXED_SIZE - the content is fixed size. The window will decide how to display the complete object.
     *  uiutil.SIZE_WINDOW_TO_CONTENT - this is not a content type but a input option for content FIXED_SIZE that shrinks the window to fit the content. */
    setContent(contentElement,elementType) {
        
        if(!this.contentContainer) {
            this.contentContainer = uiutil.createElement("div");
            uiutil.removeAllChildren(this.bodyCell);
            this.bodyCell.appendChild(this.contentContainer);
        }
        if(elementType == uiutil.RESIZABLE) {
            this.contentContainer.className = "visiui_win_container_fixed";
        }
        else if(elementType == uiutil.FIXED_SIZE) {
            this.contentContainer.className = "visiui_win_container_scrolling";
        }
        else if(elementType == uiutil.SIZE_WINDOW_TO_CONTENT) {
            this.contentContainer.className = "visiui_win_container_fit_content";
        }
        else {
            throw new Error("Unknown content type: " + elementType);
        }
        
        uiutil.removeAllChildren(this.contentContainer);
        this.contentContainer.appendChild(contentElement);
        
        this.content = contentElement;
    }

    /** This method removes the given element from the content display. If the element
     * is not in the content display, no action is taken. */
    safeRemoveContent(contentElement) {
        for(var i = 0; i < this.bodyCell.childNodes.length; i++) {
            var node = this.bodyCell.childNodes[i];
            if(node === contentElement) {
                this.bodyCell.removeChild(contentElement);
                this.content = null;
            }
        }
    }

    addTitleToolElement(element) {
        this.titleBarToolElement.appendChild(element);
    }

    removeTitleToolElement(element) {
        this.titleBarToolElement.removeChild(element);
    }




    //---------------------------
    // WINDOW CHILD
    //---------------------------

    /** This method returns the parent container for the window.*/
    getParent() {
        return this.windowParent;
    }

    /** This method returns true if the window is showing. */
    getIsShowing() {
        if(this.windowParent) {
            return this.windowParent.getIsShowing();
        }
        else {
            return false;
        }
    }

    /** This method closes the window. If the argument forceClose is not
     * set to true the "request_close" handler is called to check if
     * it is ok to close the window. */
    close(forceClose) {
        if(!this.windowParent) return;
        
        if(!forceClose) {
            //make a close request
            var requestResponse = this.callHandler(uiutil.REQUEST_CLOSE,this);
            if(requestResponse == uiutil.DENY_CLOSE) {
                //do not close the window
                return;
            }
        }

        this.windowParent.removeListener(uiutil.SHOWN_EVENT, this.windowShownListener);
        this.windowParent.removeListener(uiutil.HIDDEN_EVENT, this.windowHiddenListener);
        this.windowParent.removeWindow(this);
        this.windowParent = null;

        this.dispatchEvent(uiutil.CLOSE_EVENT,this);
    }

    /** This method sets the position of the window frame in the parent. */
    setPosition(x,y) {
        //don't let window be placed at a negative coord. We can lose it.
        if(x < 0) x = 0;
        if(y < 0) y = 0;
        this.posInfo.x = x;
        this.posInfo.y = y;
        
        this.updateCoordinates();
    }

    /** This method sets the size of the window frame, including the title bar. */
    setSize(width,height) {
        this.sizeInfo.width = width;
        this.sizeInfo.height = height;
        
        this.updateCoordinates();
    }

    /** This method gets the location and size info for the window. */
    getPosInfo() {
        return this.posInfo;
    }

    /** This method gets the location and size info for the window. */
    setPosInfo(posInfo) {
        this.posInfo = posInfo;
        this.updateCoordinates();
    }

    /** This method gets the location and size info for the window. */
    getSizeInfo() {
        return this.sizeInfo;
    }

    /** This method gets the location and size info for the window. */
    setSizeInfo(sizeInfo) {
        this.sizeInfo = sizeInfo;
        this.updateCoordinates();
    }

    /** This method sets the location and size info for the window at the same time. */
    setCoordinateInfo(posInfo,sizeInfo) {
        this.posInfo = posInfo;
        this.sizeInfo = sizeInfo;
        this.updateCoordinates();
    }


    /** This method sets the size of the window, including the title bar and other decorations. */
    setZIndex(zIndex) {
        this.frame.style.zIndex = String(zIndex);
    }


    //---------------------------
    // GUI ELEMENT
    //---------------------------

    /** This method returns the main dom element for the window frame. */
    getElement() {
        return this.frame;
    }



    //----------------------------------------------------------------
    //object specific

    /** This method sets the size of the window to fit the content. */
    fitToContent() {
        this.sizeInfo.width = undefined;
        this.sizeInfo.height = undefined;
    }

    /** This method centers the window in its parent. it should only be called
     *after the window is shown. */
    centerInParent() {
        var coords = this.windowParent.getCenterOnPagePosition(this);
        this.setPosition(coords[0],coords[1]);
    }


    /** This method gets the location and size info for the window. */
    getWindowState() {
        return this.windowState;
    }

    /** This method sets the location and size info for the window. */
    setWindowState(windowState) {
        switch(windowState) {
            case uiutil.WINDOW_STATE_NORMAL:
                this.restoreContent();
                break;
                
            case uiutil.WINDOW_STATE_MINIMIZED:
                this.minimizeContent();
                break;
                
            case uiutil.WINDOW_STATE_MAXIMIZED:
                this.maximizeContent();
                break;
                
            default:
                alert("Unknown window state: " + windowState);
                break;
        }
    }

    //================================
    // Internal
    //================================

    /** This method shows the window. This automatically called internally when the window is
     * added to the parent. */
    onAddedToParent(newWindowParent) {
        this.windowParent = newWindowParent;
        this.parentElement = newWindowParent.getOuterElement();
        
        //attach to listeners to forward show and hide events
        this.windowShownListener = (windowParent) => {
            this.dispatchEvent(uiutil.SHOWN_EVENT,this);
        };
        this.windowParent.addListener(uiutil.SHOWN_EVENT, this.windowShownListener);
        this.windowHiddenListener = (windowParent) => {
            this.dispatchEvent(uiutil.HIDDEN_EVENT,this);
        };
        this.windowParent.addListener(uiutil.HIDDEN_EVENT, this.windowHiddenListener);
        
        //do the show event if the parent is currently wshowing
        if(this.windowParent.getIsShowing()) {
            this.dispatchEvent(uiutil.SHOWN_EVENT,this);
        }
        
        //we will redo this since the size of elements used in calculation may have been wrong
        if(this.sizeInfo.height !== undefined) {
            this.updateCoordinates();
        }
    }

    //====================================
    // Motion/Reseize Event Handlers and functions
    //====================================

    /** Mouse down handler for moving the window. */
    moveMouseDown(e) {
        //do not do move in maximized state
        if(this.windowState === uiutil.WINDOW_STATE_MAXIMIZED) return;
        
        if(this.parentElement) {
            this.windowDragActive = true;
            this.moveOffsetX = e.clientX - this.frame.offsetLeft;
            this.moveOffsetY = e.clientY - this.frame.offsetTop;
            
            //add move events to the parent, since the mouse can leave this element during a move
            this.parentElement.addEventListener("mousemove",this.moveOnMouseMove);
            this.parentElement.addEventListener("mouseleave",this.moveOnMouseLeave);
            this.parentElement.addEventListener("mouseup",this.moveOnMouseUp);
            
            //move start event would go here
        }
    }

    /** Mouse m,ove handler for moving the window. */
    moveMouseMoveImpl(e) {
        if(!this.windowDragActive) return;
        var newX = e.clientX - this.moveOffsetX;
        if(newX < 0) newX = 0;
        var newY = e.clientY - this.moveOffsetY;
        if(newY < 0) newY = 0;
        this.posInfo.x = newX;
        this.posInfo.y = newY;
        this.updateCoordinates();
    }

    /** Mouse up handler for moving the window. */
    moveMouseUpImpl(e) {
        this.endMove();
    }

    /** Mouse leave handler for moving the window. */
    moveMouseLeaveImpl(e) {
        this.endMove();
    }

    /** Mouse down handler for resizing the window. */
    resizeMouseDownImpl(e,resizeFlags) {
        //do not do resize in maximized state
        if(this.windowState === uiutil.WINDOW_STATE_MAXIMIZED) return;

        if(resizeFlags) {
            if(resizeFlags & WindowFrame.RESIZE_EAST) {
                this.resizeEastActive = true;
                this.resizeOffsetWidth = e.clientX - this.bodyCell.clientWidth;
            }
            else if(resizeFlags & WindowFrame.RESIZE_WEST) {
                this.resizeWestActive = true;
                this.resizeOffsetWidth = e.clientX + this.bodyCell.clientWidth;
                this.moveOffsetX = e.clientX - this.frame.offsetLeft;
            }
            if(resizeFlags & WindowFrame.RESIZE_SOUTH) {
                this.resizeSouthActive = true;
                this.resizeOffsetHeight = e.clientY - this.bodyCell.clientHeight;
            }
            else if(resizeFlags & WindowFrame.RESIZE_NORTH) {
                this.resizeNorthActive = true;
                this.resizeOffsetHeight = e.clientY + this.bodyCell.clientHeight;
                this.moveOffsetY = e.clientY - this.frame.offsetTop;
            }

            //add resize events to the parent, since the mouse can leave this element during a move
            this.parentElement.addEventListener("mouseup",this.resizeOnMouseUp);
            this.parentElement.addEventListener("mousemove",this.resizeOnMouseMove);
            this.parentElement.addEventListener("mouseleave",this.resizeOnMouseLeave);
        }
    }

    /** Mouse move handler for resizing the window. */
    resizeMouseMoveImpl(e) {
        var newHeight;
        var newWidth;
        var newX;
        var newY;
        var changeMade = false;
        
        if(this.resizeEastActive) {
            newWidth = e.clientX - this.resizeOffsetWidth;
            //if(newWidth < this.minWidth) return;
            this.sizeInfo.width = newWidth;
            changeMade = true;
        }
        else if(this.resizeWestActive) {
            newWidth = this.resizeOffsetWidth - e.clientX;
            //if(newWidth < this.minWidth) return;
            newX = e.clientX - this.moveOffsetX;
            if(newX < 0) newX = 0;
            this.sizeInfo.width = newWidth;
            this.posInfo.x = newX;
            changeMade = true;
        }
        if(this.resizeSouthActive) {
            newHeight = e.clientY - this.resizeOffsetHeight;
            //if(newHeight < this.minHeight) return;
            this.sizeInfo.height = newHeight;
            changeMade = true;
        }
        else if(this.resizeNorthActive) {
            newHeight = this.resizeOffsetHeight - e.clientY;
            //if(newHeight < this.minHeight) return;
            newY = e.clientY - this.moveOffsetY;
            if(newY < 0) newY = 0;
            this.sizeInfo.height = newHeight;
            this.posInfo.y = newY;
            changeMade = true;
        }
            
        if(changeMade) {
            //update coordinates
            this.updateCoordinates();
        }
    }

    /** Mouse up handler for resizing the window. */
    resizeMouseUpImpl(e) {
        this.endResize();
    }

    /** Mouse up handler for resizing the window. */
    resizeMouseLeaveImpl(e) {
        this.endResize();
    }


    /** This method ends a move action. 
     * @private */
    endMove(e) {
        this.windowDragActive = false;
        this.parentElement.removeEventListener("mousemove",this.moveOnMouseMove);
        this.parentElement.removeEventListener("mouseup",this.moveOnMouseUp);
        this.parentElement.removeEventListener("mouseleave",this.moveOnMouseLeave);
    }

    /** this method ends a resize action.
     * @private */
    endResize() {
        this.resizeEastActive = false;
        this.resizeWestActive = false;
        this.resizeSouthActive = false;
        this.resizeNorthActive = false;
        this.parentElement.removeEventListener("mouseup",this.resizeOnMouseUp);
        this.parentElement.removeEventListener("mousemove",this.resizeOnMouseMove);
        this.parentElement.removeEventListener("mouseleave",this.resizeOnMouseLeave);
    }

    //====================================
    //  Min/max Methods
    //====================================

    /** This is the minimize function for the window.*/
    minimizeContent() {
        
        //set body as hidden
        this.headerCell.style.display = "none";
        this.bodyCell.style.display = "none";
        
        var wasMinimized = (this.windowState === uiutil.WINDOW_STATE_MINIMIZED);
    
        //set the window state
        this.windowState = uiutil.WINDOW_STATE_MINIMIZED;
        this.updateCoordinates();
        this.setMinMaxButtons();
        
        //dispatch resize event
        if(!wasMinimized) { 
            this.dispatchEvent(uiutil.WINDOW_STATE_CHANGED,this);
        }
    }

    /** This is the restore function for the window.*/
    restoreContent() {
        
        //set body as not hidden
        this.headerCell.style.display = "";
        this.bodyCell.style.display = "";
        
        var wasMinimized = (this.windowState === uiutil.WINDOW_STATE_MINIMIZED);
        var wasMaximized = (this.windowState === uiutil.WINDOW_STATE_MAXIMIZED);
        
        //set the window state
        this.windowState = uiutil.WINDOW_STATE_NORMAL;
        this.updateCoordinates();
        this.setMinMaxButtons();
        
        if((wasMinimized)||(wasMaximized)) {
            this.dispatchEvent(uiutil.WINDOW_STATE_CHANGED,this);
        }
    }

    /** This is the minimize function for the window.*/
    maximizeContent() {
        
        //set body as not hidden
        this.headerCell.style.display = "";
        this.bodyCell.style.display = "";
        
        var wasMaximized = (this.windowState === uiutil.WINDOW_STATE_MAXIMIZED);
        
        //set the window state
        this.windowState = uiutil.WINDOW_STATE_MAXIMIZED;
        this.updateCoordinates();
        this.setMinMaxButtons();
        
        if(!wasMaximized) {
            this.dispatchEvent(uiutil.WINDOW_STATE_CHANGED,this);
        }
    }

    /** @private */
    updateCoordinates() {
        
        var initialBodyHeight = this.bodyCell.style.height;
        var initialBodyWidth = this.bodyCell.style.width;
        
        if(this.windowState === uiutil.WINDOW_STATE_MAXIMIZED) {
            //apply the maximized coordinates size
            this.frame.style.left = "0px";
            this.frame.style.top = "0px";
            this.frame.style.height = "100%";
            this.frame.style.width = "100%";
            
            this.bodyCell.style.height = "100%";
            this.bodyCell.style.width = "100%";
        }
        else if(this.windowState === uiutil.WINDOW_STATE_NORMAL) {
            //apply the normal size to the window
            this.frame.style.left = this.posInfo.x + "px";
            this.frame.style.top = this.posInfo.y + "px";
            this.frame.style.height = "";
            this.frame.style.width = "";
            
            if(this.sizeInfo.height !== undefined) {
                this.bodyCell.style.height = this.sizeInfo.height + "px";
            }
            else {
                this.bodyCell.style.height = "";
            }
            if(this.sizeInfo.width !== undefined) {
                this.bodyCell.style.width = this.sizeInfo.width + "px";
            }
            else {
                this.bodyCell.style.width = "";
            }
        }
        else if(this.windowState === uiutil.WINDOW_STATE_MINIMIZED) {
            //apply the minimized size to the window
            this.frame.style.left = this.posInfo.x + "px";
            this.frame.style.top = this.posInfo.y + "px";
            this.frame.style.height = "";
            this.frame.style.width = "";
            
            this.bodyCell.style.height = "0px";
            this.bodyCell.style.width = "0px";
        }
        
        if((initialBodyHeight != this.bodyCell.style.height)||(initialBodyWidth != this.bodyCell.style.width)) {
            this.dispatchEvent(uiutil.RESIZED_EVENT,this);
        }
    }

    //====================================
    // Initialization Methods
    //====================================

    /** @private */
    initUI() {
        
        var table;
        var row;
        var cell;
        
        table = document.createElement("table");
        table.className = "visiui_win_main";
        this.frame = table; 
        
        //top border
        row = document.createElement("tr");
        table.appendChild(row);
        cell = document.createElement("td");
        cell.className = "visiui_win_windowColorClass visiui_win_topLeft";
        this.addResizeHandlers(cell,WindowFrame.RESIZE_WEST | WindowFrame.RESIZE_NORTH);
        row.appendChild(cell);
        cell = document.createElement("td");
        cell.className = "visiui_win_windowColorClass visiui_win_top";
        this.addResizeHandlers(cell,WindowFrame.RESIZE_NORTH);  
        row.appendChild(cell);
        cell = document.createElement("td");
        cell.className = "visiui_win_windowColorClass visiui_win_topRight";
        this.addResizeHandlers(cell,WindowFrame.RESIZE_EAST | WindowFrame.RESIZE_NORTH);  
        row.appendChild(cell);
        
        //title bar
        row = document.createElement("tr");
        table.appendChild(row);
        cell = document.createElement("td");
        cell.className = "visiui_win_windowColorClass visiui_win_left";
        this.addResizeHandlers(cell,WindowFrame.RESIZE_WEST); 
        cell.rowSpan = 3;
        row.appendChild(cell);
        cell = document.createElement("td");
        cell.className = "visiui_win_windowColorClass";
        this.titleBarCell = cell;
        row.appendChild(cell);
        cell = document.createElement("td");
        cell.className = "visiui_win_windowColorClass visiui_win_right";
        this.addResizeHandlers(cell,WindowFrame.RESIZE_EAST); 
        cell.rowSpan = 3;
        row.appendChild(cell);
        
        //header
        row = document.createElement("tr");
        row.className = "visiui_win_headerRow";
        table.appendChild(row);
        cell = document.createElement("td");
        cell.className = "visiui_win_headerCell";
        this.headerCell = cell;
        row.appendChild(cell);
        
        //body
        row = document.createElement("tr");
        row.className = "visiui_win_bodyRow";
        table.appendChild(row);
        cell = document.createElement("td");
        cell.className = "visiui_win_bodyCell";
        this.bodyCell = cell;
        row.appendChild(cell);
        
        //bottom border
        row = document.createElement("tr");
        table.appendChild(row);
        cell = document.createElement("td");
        cell.className = "visiui_win_windowColorClass visiui_win_bottomLeft";
        this.addResizeHandlers(cell,WindowFrame.RESIZE_WEST | WindowFrame.RESIZE_SOUTH); 
        row.appendChild(cell);
        cell = document.createElement("td");
        cell.className = "visiui_win_windowColorClass visiui_win_bottom";
        this.addResizeHandlers(cell,WindowFrame.RESIZE_SOUTH);  
        row.appendChild(cell);
        cell = document.createElement("td");
        cell.className = "visiui_win_windowColorClass visiui_win_bottomRight";
        this.addResizeHandlers(cell,WindowFrame.RESIZE_EAST | WindowFrame.RESIZE_SOUTH);
        row.appendChild(cell);
    
        //create the title bar
        this.createTitleBar();
    }

    /** @private */
    addResizeHandlers(cell,flags) {
        //add handlers if the window is resizable
        if(this.options.resizable) {
            cell.onmousedown = (event) => {
                this.resizeMouseDownImpl(event,flags);
            };
            
            //these are not cel specific. they are used on all cells and on the parent container
            //during a move.
            if(!this.resizeOnMouseMove) {
                this.resizeOnMouseMove = (event) => {
                    this.resizeMouseMoveImpl(event);
                };
                this.resizeOnMouseUp = (event) => {
                    this.resizeMouseUpImpl(event);
                };
                this.resizeOnMouseLeave = (event) => {
                    this.resizeMouseLeaveImpl(event);
                };
            }
        }
    }

    /** @private */
    createTitleBar() {
        
        this.titleBarElement = uiutil.createElementWithClass("div","visiui_win_titleBarClass",this.titleBarCell);

        //add elements
        this.titleBarLeftElements = uiutil.createElementWithClass("div","visiui_win_left_style",this.titleBarElement);
        this.titleBarMenuElement = uiutil.createElementWithClass("div","visiui_win_menu_style",this.titleBarLeftElements);
        this.titleBarTitleElement = uiutil.createElementWithClass("div","visiui_win_title",this.titleBarLeftElements);
        
        this.titleBarRightElements = uiutil.createElementWithClass("div","visiui_win_right_style",this.titleBarElement);
        this.titleBarToolElement = uiutil.createElementWithClass("div","visiui_win_tool_style",this.titleBarRightElements);
        
        //add window commands ( we will hide the bottons that are not needed)
        //minimize button
        if(this.options.minimizable) {
            this.minimizeButton = uiutil.createElementWithClass("img","visiui_win_cmd_button",this.titleBarRightElements);
            this.minimizeButton.src = uiutil.getResourcePath(uiutil.MINIMIZE_CMD_IMAGE);
            this.minimizeButton.onclick = () => {
                this.minimizeContent();
            };
        }
        
        //restore button - only if we cn minimize or maximize
        if(this.options.minimizable || this.options.maximizable) {	
            this.restoreButton = uiutil.createElementWithClass("img","visiui_win_cmd_button",this.titleBarRightElements);
            this.restoreButton.src = uiutil.getResourcePath(uiutil.RESTORE_CMD_IMAGE);
            this.restoreButton.onclick = () => {
                this.restoreContent();
            };
        }
        
        //maximize button and logic
    //DISABLE MAXIMIZE - just don't show button for now
    //    if(this.options.maximizable) {
    //        this.maximizeButton = uiutil.createElementWithClass("img","visiui_win_cmd_button",this.titleBarRightElements);
    //        this.maximizeButton.src = uiutil.getResourcePath(uiutil.MAXIMIZE_CMD_IMAGE);
    //        this.maximizeButton.onclick = () => {
    //            this.maximizeContent();
    //        }
    //    }
        
        //layout the window buttons
        this.windowState = uiutil.WINDOW_STATE_NORMAL;
        this.setMinMaxButtons();
        
        //close button
        if(this.options.closable) {
            this.closeButton = uiutil.createElementWithClass("img","visiui_win_cmd_button",this.titleBarRightElements);
            this.closeButton.src = uiutil.getResourcePath(uiutil.CLOSE_CMD_IMAGE);
            this.closeButton.onclick = () => {
                this.close();
            };
        }
        
        //add am empty title
        this.setTitle("");
        
        //mouse move and resize
        if(this.options.movable) {
            //add mouse handlers for moving the window 
            this.titleBarElement.onmousedown = (event) => {
                this.moveMouseDown(event);
            };

            //mouse window drag events we will place on the parent container - since the mouse drag 
            //may leave the window frame during the move
            this.moveOnMouseMove = (event) => {
                this.moveMouseMoveImpl(event);
            };
            this.moveOnMouseUp = (event) => {
                this.moveMouseUpImpl(event);
            };
            this.moveOnMouseLeave = (event) => {
                this.moveMouseLeaveImpl(event);
            };
        }
    }


    /** This method shows the min/max/restore buttons properly 
     * @private */
    setMinMaxButtons() {
        if(this.minimizeButton) {
            if(this.windowState == uiutil.WINDOW_STATE_MINIMIZED) {
                this.minimizeButton.style.display = "none";
            }
            else {
                this.minimizeButton.style.display = "";
            }
        }
        if(this.restoreButton) {
            if(this.windowState == uiutil.WINDOW_STATE_NORMAL) {
                this.restoreButton.style.display = "none";
            }
            else {
                this.restoreButton.style.display = "";
            }
        }
        if(this.maximizeButton) {
            if(this.windowState == uiutil.WINDOW_STATE_MAXIMIZED) {
                this.maximizeButton.style.display = "none";
            }
            else {
                this.maximizeButton.style.display = "";
            }
        }
    }

}

//add mixins to this class
apogeeutil$1.mixin(WindowFrame,EventManager);

WindowFrame.RESIZE_LOCATION_SIZE = 10;

//constants for resizing
WindowFrame.RESIZE_TOLERANCE = 5;
WindowFrame.RESIZE_EAST = 1;
WindowFrame.RESIZE_WEST = 2;
WindowFrame.RESIZE_SOUTH = 4;
WindowFrame.RESIZE_NORTH = 8;
WindowFrame.RESIZE_NE = WindowFrame.RESIZE_NORTH + WindowFrame.RESIZE_EAST;
WindowFrame.RESIZE_NW = WindowFrame.RESIZE_NORTH + WindowFrame.RESIZE_WEST;
WindowFrame.RESIZE_SE = WindowFrame.RESIZE_SOUTH + WindowFrame.RESIZE_EAST;
WindowFrame.RESIZE_SW = WindowFrame.RESIZE_SOUTH + WindowFrame.RESIZE_WEST;

/** size must be speicifed for the window. If not these values are used. */
WindowFrame.DEFAULT_WINDOW_HEIGHT = 300;
WindowFrame.DEFAULT_WINDOW_WIDTH = 300;

/** This object is a container for window frames. The argument of the constructor should
 * be an element that will hold the window frames.  */
class WindowParent {

    constructor(containerElement) {
        //mixin initialization
        this.eventManagerMixinInit();
        
        this.containerElement = containerElement;
        
        this.windowFrameStack = [];
        
        this.showing = false;
        
        //child auto positioning variables
        this.prevNewChildX = 0;
        this.prevNewChildY = 0;
        this.wrapCount = 0;
    }

    //==============================
    // Public Instance Methods
    //==============================

    /** This should be called when the window parent element is shown, if the
     * "shown" event is to be supported.  */
    elementIsShown() {
        this.showing = true;
        this.dispatchEvent(uiutil.SHOWN_EVENT,this);
    }

    /** This should be called when the window parent element is shown, if the
     * "shown" event is to be supported.  */
    elementIsHidden() {
        this.showing = false;
        this.dispatchEvent(uiutil.HIDDEN_EVENT,this);
    }

    /** This method returns true if this window parent is showing. */
    getIsShowing() {
        return this.showing;
    }

    getOuterElement() {
        return this.containerElement;
    }

    /** This method adds a windows to the parent. It does not show the window. Show must be done. */
    addWindow(windowFrame) {
        this.containerElement.appendChild(windowFrame.getElement());
        this.windowFrameStack.push(windowFrame);
        this.updateOrder();
        
        windowFrame.onAddedToParent(this);
    }

    /** This method removes the window from the parent container. */
    removeWindow(windowFrame) {
        this.containerElement.removeChild(windowFrame.getElement());
        var index = this.windowFrameStack.indexOf(windowFrame);
        this.windowFrameStack.splice(index,1);
        this.updateOrder();
    }

    /** This brings the given window to the front inside this container. */
    bringToFront(windowFrame) {
        //remove from array
        var index = this.windowFrameStack.indexOf(windowFrame);
        this.windowFrameStack.splice(index,1);
        //readd at the end
        this.windowFrameStack.push(windowFrame);
        this.updateOrder();
    }

    /** This method centers the dialog on the page. It must be called after the conten
     * is set, and possibly after it is rendered, so the size of it is calculated. */
    getCenterOnPagePosition(child) {
        var element = child.getElement();
        var x = (this.containerElement.offsetWidth - element.clientWidth)/2;
        var y = (this.containerElement.offsetHeight - element.clientHeight)/2;
        return [x,y];
    }


    /** This method returns the position of the next window for auto/cascade positioning. */
    getNextWindowPosition() {
        var x = this.prevNewChildX + WindowParent.DELTA_CHILD_X;
        var y = this.prevNewChildY + WindowParent.DELTA_CHILD_Y;
        
        if( ((x > WindowParent.MAX_WRAP_WIDTH) || 
            (y > WindowParent.MAX_WRAP_HEIGHT)) ) {
            this.wrapCount++;
            x = WindowParent.DELTA_CHILD_X * (this.wrapCount + 1);
            y = WindowParent.DELTA_CHILD_Y;
        }
        
        this.prevNewChildX = x;
        this.prevNewChildY = y;
        
        var pos = {};
        pos.x = x;
        pos.y = y;
        return pos;
    }

    //=========================
    // Private Methods
    //=========================

    /** This updates the order for the windows.
     * @private */
    updateOrder() {
        var zIndex = WindowParent.BASE_ZINDEX;
        for(var i = 0; i < this.windowFrameStack.length; i++) {
            var windowFrame = this.windowFrameStack[i];
            windowFrame.setZIndex(zIndex++);
        }
    }

}

//add mixins to this class
apogeeutil$1.mixin(WindowParent,EventManager);

WindowParent.BASE_ZINDEX = 0;

//constants for window placement
WindowParent.DELTA_CHILD_X = 25;
WindowParent.DELTA_CHILD_Y = 25;
WindowParent.MAX_WRAP_WIDTH = 400; 
WindowParent.MAX_WRAP_HEIGHT = 400;

let dialogMgr = {};

/** This method creates a normal window which is situated above a shiled layer blocking
 *out events to the app, making the dialog like a modal dialog. If this function is used
 *to create a dialog, it must be closed with the dialogMgr.closeDialog function to
 *remove the modal layer, whether or not the dialog was shown. The options passed are the 
 *normal options for a window frame. (Note - if there are other events with whihc to act with
 *the app they may need to be shileded too.) */
dialogMgr.createDialog = function(options) {
    var dialog = new WindowFrame(options);
    return dialog;
};

dialogMgr.showDialog = function(dialog) {
    var shieldElement = uiutil.createElement("div",null,uiutil.DIALOG_SHIELD_STYLE);
    var dialogParent = new WindowParent(shieldElement);
    uiutil.dialogLayer.appendChild(shieldElement);

    dialogParent.addWindow(dialog);
};

/** This method closes a dialog created with createDialog. It
 *hides the window and removes the modal shiled. */
dialogMgr.closeDialog = function(dialog) {
    var parent = dialog.getParent();
    dialog.close();
    uiutil.dialogLayer.removeChild(parent.getOuterElement());
};

/** This namespacve provides methods to create a status banner and icon overlay. */

//constants for the window banner bar
let bannerConstants = {};

bannerConstants.BANNER_TYPE_ERROR = apogeeutil$1.STATE_ERROR;
bannerConstants.BANNER_BGCOLOR_ERROR = "red";
bannerConstants.BANNER_FGCOLOR_ERROR = "white";
bannerConstants.ERROR_ICON_IMAGE = "/error.png";

bannerConstants.BANNER_TYPE_PENDING = apogeeutil$1.STATE_PENDING;
bannerConstants.BANNER_BGCOLOR_PENDING = "yellow";
bannerConstants.BANNER_FGCOLOR_PENDING = "black";
bannerConstants.PENDING_ICON_IMAGE = "/pending.png";

bannerConstants.BANNER_TYPE_INVALID = apogeeutil$1.STATE_INVALID;
bannerConstants.BANNER_BGCOLOR_INVALID = "gray";
bannerConstants.BANNER_FGCOLOR_INVALID = "white";
bannerConstants.INVALID_ICON_IMAGE = "/invalid.png";

bannerConstants.BANNER_BGCOLOR_UNKNOWN = "yellow";
bannerConstants.BANNER_FGCOLOR_UNKNOWN = "black";

bannerConstants.BANNER_TYPE_NONE = apogeeutil$1.STATE_NORMAL;

bannerConstants.PENDING_MESSAGE = "Calculation pending...";bannerConstants.INVALID_MESSAGE = "Result not valid!";

/** This method returns a banner for the given state and message. This should 
 * not be called for banner state bannerConstants.BANNER_TYPE_NONE */
function getBanner(text,bannerState) {
    
    //get banner colors and icon overlay resource
    var bgColor;
    var fgColor;
    if(bannerState == bannerConstants.BANNER_TYPE_INVALID) {
        bgColor = bannerConstants.BANNER_BGCOLOR_INVALID;
        fgColor = bannerConstants.BANNER_FGCOLOR_INVALID;
    }
    else if(bannerState == bannerConstants.BANNER_TYPE_ERROR) {
        bgColor = bannerConstants.BANNER_BGCOLOR_ERROR;
        fgColor = bannerConstants.BANNER_FGCOLOR_ERROR;
    }
    else if(bannerState == bannerConstants.BANNER_TYPE_PENDING) {
        bgColor = bannerConstants.BANNER_BGCOLOR_PENDING;
        fgColor = bannerConstants.BANNER_FGCOLOR_PENDING;
    }
    else {
        bgColor = bannerConstants.BANNER_BGCOLOR_UNKNOWN;
        fgColor = bannerConstants.BANNER_FGCOLOR_UNKNOWN;
    }
   
    //banner showing
    var bannerDiv = uiutil.createElement("div",null,
        {
            //"display":"block",
            //"position":"relative",
            //"top":"0px",
            "backgroundColor":bgColor,
            "color":fgColor
        });
    bannerDiv.innerHTML = text;
    
    return bannerDiv;
}

/** This method creates an icon overlay for a given banner state. This should 
 * not be called for banner state bannerConstants.BANNER_TYPE_NONE */
function getIconOverlay(bannerState) {
    var resource;
    if(bannerState == bannerConstants.BANNER_TYPE_INVALID) {
        resource = bannerConstants.INVALID_ICON_IMAGE;
    }
    else if(bannerState == bannerConstants.BANNER_TYPE_ERROR) {
        resource = bannerConstants.ERROR_ICON_IMAGE;
    }
    else if(bannerState == bannerConstants.BANNER_TYPE_PENDING) {
        resource = bannerConstants.PENDING_ICON_IMAGE;
    }
    else {
        //unknown
        resource = null;
    }
    
    var iconOverlayElement = document.createElement("img");
    if(resource) {
        var url = uiutil.getResourcePath(resource);
        iconOverlayElement.src = url;
    }
    return iconOverlayElement;
}

/** This is is a layout element to fill a parent element with a header element and
 * a display element which takes all the remaning vertical space.
 * 
 * The header and display types may be the following:
 * DisplayAndHeader.SCROLLING_PANE
 * DisplayAndHeader.FIXED_PANE
 * 
 * Additionally a CSS class may be specified for each fo give information such as
 * coloring and, for the sake of the header, height.
 */ 
class DisplayAndHeader {

    constructor(headerType,headerStyleClass,bodyType,bodyStyleClass) {
    //    this.container = uiutil.createElementWithClass("div","visiui-dnh-container");
    //    
    //    this.headerOuter = uiutil.createElementWithClass("div","visiui-dnh-header",this.container);
    //    this.header = uiutil.createElementWithClass("div","visiui-dnh-header-inner",this.headerOuter);
    //    this.bodyOuter = uiutil.createElementWithClass("div","visiui-dnh-body",this.container);
    //    this.body = uiutil.createElementWithClass("div","visiui-dnh-body-inner",this.bodyOuter);
    //    
    //    this.headerStyleClass = headerStyleClass;
    //    this.bodyStyleClass = bodyStyleClass;
    //    
    //    this.headerContent = document.createElement("div");
    //    this.header.appendChild(this.headerContent);
    //    this.bodyContent = document.createElement("div");
    //    this.body.appendChild(this.bodyContent);
        
        this.container = uiutil.createElementWithClass("table","visiui-dnh-container");
        
        this.headerOuter = uiutil.createElementWithClass("tr","visiui-dnh-header",this.container);
        this.header = uiutil.createElementWithClass("td","visiui-dnh-header-inner",this.headerOuter);
        this.bodyOuter = uiutil.createElementWithClass("tr","visiui-dnh-body",this.container);
        this.body = uiutil.createElementWithClass("td","visiui-dnh-body-inner",this.bodyOuter);
        
        this.headerStyleClass = headerStyleClass;
        this.bodyStyleClass = bodyStyleClass;
        
        this.headerContent = document.createElement("div");
        this.header.appendChild(this.headerContent);
        this.bodyContent = document.createElement("div");
        this.body.appendChild(this.bodyContent);
        
        //this.setHeaderType(headerType);
        this.setHeaderType("visiui-dnh-shrink-to-fit");
        this.setBodyType(bodyType);
    }

    /** this method sets the header type. */
    setHeaderType(headerType) {
        var headerClass = headerType;
        if(this.headerStyleClass) headerClass += " " + this.headerStyleClass;
        this.headerContent.className = headerClass;
    }

    /** this method sets the body type. */
    setBodyType(bodyType) {
        var bodyClass = bodyType;
        if(this.bodyStyleClass) bodyClass += " " + this.bodyStyleClass;
        this.bodyContent.className = bodyClass;
    }

    /** this method returns the DOM element for ths combined layout. */
    getOuterElement() {
        return this.container;
    }

    /** this method returns the content element for the header. */
    getHeaderContainer() {
        return this.header;
    }

    /** this method returns the content element for the display pane. */
    getBodyContainer() {
        return this.body;
    }

    /** this method returns the content element for the header. */
    getHeader() {
        return this.headerContent;
    }

    /** this method returns the content element for the display pane. */
    getBody() {
        return this.bodyContent;
    }

}

/** This is the pane type for a pane that scrolls in both X and Y, iv needed. */
DisplayAndHeader.FIXED_PANE = "visiui-dnh-fixed";

/** This is the pane type for a pane that does not scrolling, hiding any overflow. */
DisplayAndHeader.SCROLLING_PANE = "visiui-dnh-scrolling";

class Tab {

    constructor(id) {
        //mixin initialization
        this.eventManagerMixinInit();
        
        this.tabFrame = null;
        this.id = id;
        this.tabLabelElement = uiutil.createElementWithClass("div","visiui-tf-tab-base visiui-tf-tab-inactive");
        
        this.menuContainer = uiutil.createElementWithClass("div","visiui-tf_tab-menuDiv",this.tabLabelElement);
        this.titleElement = uiutil.createElementWithClass("div","visiui_tf_tab_title",this.tabLabelElement);
        
        this.closeButton = uiutil.createElementWithClass("img","visiui_tf_tab_cmd_button",this.tabLabelElement);
        this.closeButton.src = uiutil.getResourcePath(uiutil.CLOSE_CMD_IMAGE);
        
        this.closeButton.onclick = () => {
            this.close();
        };
        
        //create the tab element
        this.displayFrame = uiutil.createElementWithClass("div","visiui-tf-tab-window");
        this.tabInsideContainer = new DisplayAndHeader(DisplayAndHeader.FIXED_PANE,
                null,
                DisplayAndHeader.FIXED_PANE,
                null
            );
        this.displayFrame.appendChild(this.tabInsideContainer.getOuterElement());
        
        this.headerContainer = this.tabInsideContainer.getHeaderContainer();
        this.bodyContainer = this.tabInsideContainer.getBodyContainer();
        
        this.isShowing = false;
    }

    //---------------------------
    // WINDOW CONTAINER
    //---------------------------

    /** This is called by the tab frame. */
    setTabFrame(tabFrame) {
        this.tabFrame = tabFrame;
        var instance = this;
        //attach to listeners to forward show and hide events
        this.tabShownListener = (tab) => {
            if(tab == instance) {
                this.isShowing = true;
                instance.dispatchEvent(uiutil.SHOWN_EVENT,instance);
            }
        };
        this.tabFrame.addListener(uiutil.SHOWN_EVENT, this.tabShownListener);
        this.tabHiddenListener = (tab) => {
            if(tab == instance) {
                this.isShowing = false;
                instance.dispatchEvent(uiutil.HIDDEN_EVENT,instance);
            }
        };
        this.tabFrame.addListener(uiutil.HIDDEN_EVENT, this.tabHiddenListener);
    }

    /** This sets the tab as the active tab. It returns true if it can do this. In the case
     * it does not have an active frame, it returns false. */
    makeActive() {
        if(this.tabFrame) {
            this.tabFrame.setActiveTab(this.id);
            return true;
        }
        else {
            return false;
        }
    }

    /** This method must be implemented in inheriting objects. */
    getId() {
        return this.id;
    }

    /** This returns true if the tab is showing in the display. */
    getIsShowing() {
        return this.isShowing;
    }

    /** This method must be implemented in inheriting objects. */
    setTitle(title) {
        this.titleElement.innerHTML = title;
        this.title = title;
    }

    /** This sets the content for the window. If null (or otherwise false) is passed
     * the content will be set to empty.*/
    setHeaderContent(contentElement) {
        uiutil.removeAllChildren(this.headerContainer);
        if(contentElement) {
            this.headerContainer.appendChild(contentElement);
        }
    }

    /** This sets the content for the window. */
    setContent(contentElement) {
        if(!this.contentContainer) {
            this.contentContainer = uiutil.createElement("div");
            uiutil.removeAllChildren(this.bodyContainer);
            this.bodyContainer.appendChild(this.contentContainer);
        }
        this.contentContainer.className = "visiui_tf_tab_container";
        
        uiutil.removeAllChildren(this.contentContainer);
        this.contentContainer.appendChild(contentElement);
        
        this.content = contentElement;
    }

    /** This method must be implemented in inheriting objects. */
    getTitle() {
        return this.title;
    }

    /** This method shows the window. */
    createMenu(iconUrl) {
        if(!iconUrl) iconUrl = uiutil.getResourcePath(uiutil.MENU_IMAGE);
        this.menu = Menu.createMenuFromImage(iconUrl);
        this.menuContainer.appendChild(this.menu.domElement);
        //add the icon overlay element
        this.iconOverlayElement = uiutil.createElementWithClass("div","visiui_tf_icon_overlay",this.menuContainer);
        return this.menu;
    }

    /** This method shows the window. */
    getMenu() {
        return this.menu;
    }

    /** This sets the given element as the icon overlay. If null or other [false} is passed
     * this will just clear the icon overlay. */
    setIconOverlay(element) {
        if(this.iconOverlayElement) {
            this.clearIconOverlay();
            if(element) {
                this.iconOverlayElement.appendChild(element);
            }
        }
    }

    clearIconOverlay() {
        if(this.iconOverlayElement) {
            uiutil.removeAllChildren(this.iconOverlayElement);
        }
    }

    /** This method closes the window. */
    close(forceClose) {
        if(!this.tabFrame) return;
        
        if(!forceClose) {
            //make a close request
            var requestResponse = this.callHandler(uiutil.REQUEST_CLOSE,this);
            if(requestResponse == uiutil.DENY_CLOSE) {
                //do not close the window
                return;
            }
        }
        
        this.tabFrame.closeTab(this.id);
        this.tabFrame.removeListener(uiutil.SHOWN_EVENT, this.tabShownListener);
        this.tabFrame.removeListener(uiutil.HIDDEN_EVENT, this.tabHiddenListener);
        this.tabFrame = null;
        
        this.dispatchEvent(uiutil.CLOSE_EVENT,this);
        
        
    }

    //---------------------------
    // GUI ELEMENT
    //---------------------------

    /** This method must be implemented in inheriting objects. */
    getMainElement() {
        return this.displayFrame;
    }

    /** This method must be implemented in inheriting objects. */
    getLabelElement() {
        return this.tabLabelElement;
    }

}

//add mixins to this class
apogeeutil$1.mixin(Tab,EventManager);

/** This is a tab frame.
 * 
 * @class 
 */
class TabFrame {

    constructor() {
        //mixin initialization
        this.eventManagerMixinInit();
        
        //variables
        this.tabTable = {};
        this.activeTab = null;
        
        this.tabFrameControl = uiutil.createElementWithClass("div","visiui-tf-frame");
        this.tabBar = uiutil.createElementWithClass("div","visiui-tf-tab-bar",this.tabFrameControl);
        this.tabFrame = uiutil.createElementWithClass("div","visiui-tf-tab-container",this.tabFrameControl);   	
    }

    /** This method returns the dom element for the control. */
    getElement() {
        return this.tabFrameControl;
    }

    /** This method returns the main dom element for the window frame. */
    getTab(id) {
        return this.tabTable[id];
    }

    /** This method adds a tab to the tab frame. */
    addTab(tab,makeActive) {
        var id = tab.getId();
        
        //make sure there is no tab with this name
        if(this.tabTable[id]) {
            alert("There is already a tab with this id!");
            return null;
        }
        
        tab.setTabFrame(this);
        this.tabFrame.appendChild(tab.getMainElement());
        
        var tabLabelElement = tab.getLabelElement();
        this.tabBar.appendChild(tabLabelElement);
        
        //add the click handler
        tabLabelElement.onclick = () => {
            this.setActiveTab(id);
        };
        tabLabelElement.onmousedown = (e) => {
            //this prevents text selection
            e.preventDefault();
        };
        
        //add to tabs
        this.tabTable[id] = tab;
        
        if((makeActive)||(this.activeTab == null)) {
            this.setActiveTab(id);
        }
        else {
            this.updateTabDisplay();
        }
    }

    /** This method adds a tab to the tab frame. */
    closeTab(id) {
        var tab = this.tabTable[id];
        if(tab) {
            this.tabFrame.removeChild(tab.getMainElement());
            
            var tabLabelElement = tab.getLabelElement();
            this.tabBar.removeChild(tabLabelElement);
            delete tabLabelElement.onclick;
            delete tabLabelElement.onmousedown;
            
            delete this.tabTable[id];
            
            if(this.activeTab == id) {
                this.dispatchEvent(uiutil.HIDDEN_EVENT,tab);
                this.activeTab = null;
                //choose a random tab
                for(var newId in this.tabTable) {
                    this.setActiveTab(newId);
                    break;
                }
            }
            
            this.updateTabDisplay();
        }
    }

    /** This gets the active tab, by tab id. */
    getActiveTab() {
        return this.activeTab;
    }

    /** This sets the active tab, by tab id. */
    setActiveTab(id) {
        var tab = this.tabTable[id];
        if(tab) {
            var oldTab;
            if(this.activeTab) {
                oldTab = this.tabTable[this.activeTab];
            }
            this.activeTab = id;
            this.tabFrame.appendChild(tab.getMainElement());
            this.updateTabDisplay();
            if(oldTab) {
                this.dispatchEvent(uiutil.HIDDEN_EVENT,oldTab);
            }
            this.dispatchEvent(uiutil.SHOWN_EVENT,tab);
            
        }
    }

    /** This gets the active tab, by tab id. */
    getOpenTabs() {
        var openTabs = [];
        for(var idString in this.tabTable) {
            var id = parseInt(idString);
            openTabs.push(id);
        }
        return openTabs;
    }

    /** This updates the tabs. */
    updateTabDisplay() {
        var id;
        for(id in this.tabTable) {
            var tab = this.tabTable[id];
            if(id == this.activeTab) {
                tab.getMainElement().style.display = "";
                tab.getLabelElement().className = "visiui-tf-tab-base visiui-tf-tab-active";
            }
            else {
                tab.getMainElement().style.display = "none";
                tab.getLabelElement().className = "visiui-tf-tab-base visiui-tf-tab-inactive";
            }
        }
    }

}

//add mixins to this class
apogeeutil$1.mixin(TabFrame,EventManager);

/** This is a split pane, with a right and left pane. The types of pane are 
 * given by the constants defined below:
 * SplitPane.SCROLLING_PANE
 * SplitPane.FIXED_PANE
 */ 
class SplitPane {

    constructor(leftPaneType,rightPaneType) {
        //mixin initialization
        this.eventManagerMixinInit();

        //-----------------
        // Create the DOM elements
        //-----------------
        
        this.container1 = uiutil.createElementWithClass("div","visiui-sp-parent");
        var container2 = uiutil.createElementWithClass("div","visiui-sp-parent2",this.container1);
        var table = uiutil.createElementWithClass("table","visiui-sp-table",container2);
        
        var row = uiutil.createElementWithClass("tr","visiui-sp-row",table);
        
        var leftCell = uiutil.createElementWithClass("td","visiui-sp-left",row);
        var divider = uiutil.createElementWithClass("td","visiui-sp-divider",row);
        var rightCell = uiutil.createElementWithClass("td","visiui-sp-right",row);

        var leftInnerPane = uiutil.createElementWithClass("div","visiui-sp-inner",leftCell);
        this.leftOuterPane = uiutil.createElementWithClass("div",leftPaneType,leftInnerPane);
        
        var rightInnerPane = uiutil.createElementWithClass("div","visiui-sp-inner",rightCell);
        this.rightOuterPane = uiutil.createElementWithClass("div",rightPaneType,rightInnerPane);

        //-----------------
        // Create the mouse handler logic for resizing
        //-----------------
        var resizeActive = false;
        var resizeBasePixels = 0;
        var resizeBasePosition = 0;
        
        //mouse down handler
        var mouseDown = function(e) {

                resizeActive = true;
                resizeBasePixels = e.clientX;
                resizeBasePosition = leftCell.offsetWidth;

                //add resize events to the parent, since the mouse can leave this element during a move
                table.addEventListener("mouseup",mouseUp);
                table.addEventListener("mousemove",mouseMove);
                table.addEventListener("mouseleave",mouseLeave);
        };

        //mouse move handler
        var mouseMove = (e) => {
            if(resizeActive) {
                var delta = e.clientX - resizeBasePixels;
                leftCell.style.width = (resizeBasePosition + delta) + "px";
                this.dispatchEvent("move",this);
            }
        };

        //mouse up handler
        var mouseUp = function(e) {
            endResize();
        };

        //mouse leave handler
        var mouseLeave = function(e) {
            endResize();
        };
        
        //end resize function
        var endResize = function() {
            resizeActive = false;
            table.removeEventListener("mouseup",mouseUp);
            table.removeEventListener("mousemove",mouseMove);
            table.removeEventListener("mouseleave",mouseLeave);
        };
        
        divider.addEventListener("mousedown",mouseDown);

    }

    /** this method returns the DOM element for ths split pane. */
    getOuterElement() {
        return this.container1;
    }

    /** this method returns the content element for the left pane. */
    getLeftPaneContainer() {
        return this.leftOuterPane;
    }

    /** this method returns the content element for the left pane. */
    getRightPaneContainer() {
        return this.rightOuterPane;
    }

}

//add mixins to this class
apogeeutil$1.mixin(SplitPane,EventManager);

/** This is the pane type for a pane that scrolls in both X and Y, iv needed. */
SplitPane.SCROLLING_PANE = "visiui-sp-scrolling";

/** This is the pane type for a pane that does not scrolling, hiding any overflow. */
SplitPane.FIXED_PANE = "visiui-sp-fixed";

class TreeControl {

    constructor() {
        this.list = uiutil.createElementWithClass("ul","visiui-tc-child-list",this.element); 
    }

    /** The outer DOM element */
    getElement() {
        return this.list;
    }

    setRootEntry(treeEntry) {
        this.clearRootEntry();
        this.list.appendChild(treeEntry.getElement());
    }

    clearRootEntry() {
        uiutil.removeAllChildren(this.list);
    }

}

class TreeEntry {

    constructor(labelText,iconSrc,dblClickCallback,menuItemCallback,isRoot) {
        
        this.contractUrl = uiutil.getResourcePath("/opened_bluish.png");
        this.expandUrl = uiutil.getResourcePath("/closed_bluish.png");
        this.noControlUrl = uiutil.getResourcePath("/circle_bluish.png");
        this.emptyControlUrl = uiutil.getResourcePath("/circle_bluish.png");
        
        this.isRoot = isRoot;
        
        var baseCssClass;
        if(isRoot) {
            baseCssClass = "visiui-tc-root";
        }
        else {
            baseCssClass = "visiui-tc-child";
        }
        
        this.element = uiutil.createElementWithClass("li", baseCssClass);
        this.control = uiutil.createElementWithClass("img", "visiui-tc-control",this.element);
        

        //icon/menu
        if(iconSrc) {
            this.iconContainerElement = uiutil.createElementWithClass("div", "visiui-tc-icon-container",this.element);
            if(menuItemCallback) {
                //icon as menu
                this.menu = Menu.createMenuFromImage(iconSrc);
                this.menu.setAsOnTheFlyMenu(menuItemCallback);
                this.iconContainerElement.appendChild(this.menu.getElement());
            }
            else {
                //plain icon
                this.icon = uiutil.createElementWithClass("img", "visiui-tc-icon",this.iconContainerElement);
                this.icon.src = iconSrc; 
            }
            this.iconOverlayElement = uiutil.createElementWithClass("div","visiui_tc_icon_overlay",this.iconContainerElement);
        }
        
        
        
        //label
        this.label = uiutil.createElementWithClass("div", "visiui-tc-label",this.element);
        if(labelText) {
            this.setLabel(labelText);
        }
        
        this.childContainer = null;
        this.childEntries = [];
        this.parent = null;
        this.sortFunction = null;
        this.extraSortParam = null;
        
        //set the non-empty state for in case we get children
        //but for now it will be empty
        this.nonEmptyState = TreeEntry.DEFAULT_STATE;
        this.setState(TreeEntry.NO_CONTROL);
        
        //context menu and double click
        var contextMenuCallback = (event) => {
            var contextMenu = Menu.createContextMenu();
            var menuItems = menuItemCallback();
            contextMenu.setMenuItems(menuItems);
            Menu.showContextMenu(contextMenu,event);
        };
        this.label.oncontextmenu = contextMenuCallback;
        
        //double click action
        if(dblClickCallback) {
            this.label.ondblclick = dblClickCallback;
        }
    }

    /** The outer DOM element */
    getElement() {
        return this.element;
    }

    /** This sets a sort function for the children of the node. If none is set the
     * children will be sorted by the order they are added. */
    setSortFunction(sortFunction) {
        this.sortFunction = sortFunction;
    }

    /** The label for the entry. */
    setLabel(labelText) {
        this.labelText = labelText;
        this.label.innerHTML = labelText;
        if(this.parent) {
            this.parent._notifyNameChange(this);
        }
    }

    /** The label for the entry. */
    getLabel() {
        return this.labelText;
    }

    /** This allows for specified ordering of the chidlren. */
    setExtraSortParam(value) {
        this.extraSortParam = value;
    }

    /** This allows for specified ordering of the chidlren. */
    getExtraSortParam() {
        return this.extraSortParam;
    }

    addChild(childTreeEntry) {
        this.childEntries.push(childTreeEntry);
        this._insertChildIntoList(childTreeEntry);
        childTreeEntry._setParent(this);
    }

    removeChild(childTreeEntry) {
        if(this.childContainer) {
            var index = this.childEntries.indexOf(childTreeEntry);
            if(index >= 0) {
                this.childEntries.splice(index,1);
                this._removeChildFromList(childTreeEntry);
                childTreeEntry._setParent(null);
            }
        }
    }

    getState() {
        return this.state;
    }

    setState(state) {
        //if we have no children, always make the state no control
        //but we will store the state below for latert
        if((!this.childContainer)||(this.childContainer.length == 0)) {
            this.state = TreeEntry.NO_CONTROL;
        }
        else {
            this.state = state;
        }
        
        //save this as the non-empty state if it is not no control
        if(state != TreeEntry.NO_CONTROL) {
            this.nonEmptyState = state;
        }
        
        //configure the state
        if(this.state == TreeEntry.NO_CONTROL) {
            if(this.isRoot) {
                this.control.src = this.emptyControlUrl;
            }
            else {
                this.control.src = this.noControlUrl;
            }
        }
        else if(this.state == TreeEntry.EXPANDED) {
            this.control.src = this.contractUrl;
            
            if(!this.collapse) {
                this.collapse = () => {
                    this.setState(TreeEntry.COLLAPSED);
                };
            }
            
            this.control.onclick = this.collapse;
            this.childContainer.style.display = "";
        }
        else if(this.state == TreeEntry.COLLAPSED) {
            this.control.src = this.expandUrl;
            
            if(!this.expand) {
                this.expand = () => {
                    this.setState(TreeEntry.EXPANDED);
                };
            }
            
            this.control.onclick = this.expand;
            this.childContainer.style.display = "none";
        }
    }

    /** This sets the given element as the icon overlay. If null or other [false} is passed
     * this will just clear the icon overlay. */
    setIconOverlay(element) {
        this.clearIconOverlay();
        if(element) {
            this.iconOverlayElement.appendChild(element);
        }
    }

    clearIconOverlay() {
        uiutil.removeAllChildren(this.iconOverlayElement);
    }

    setBannerState(bannerState) {
        var iconOverlay = getIconOverlay(bannerState);
        if(iconOverlay) {
            this.setIconOverlay(iconOverlay);
        }
        else {
            this.clearIconOverlay();
        }
    }

    //=====================================
    // Private
    //=====================================

    /** I want to make sure people don't do this themselves. It is done in add/remove child. 
     * @private */
    _setParent(parent) {
        this.parent = parent;
    }

    /** I want to make sure people don't do this themselves. It is done in add/remove child. 
     * @private */
    _insertChildIntoList(childEntry) {
        if(!this.childContainer) {
            //add the child list if it does not exist
            this.childContainer = uiutil.createElementWithClass("ul","visiui-tc-child-list",this.element); 
            this.setState(this.nonEmptyState);
        }
        
        if(this.sortFunction) {
            this._updateChildElements();
        }
        else {
            this.childContainer.appendChild(childEntry.getElement());
        }
    }

    /** I want to make sure people don't do this themselves. It is done in add/remove child. 
     * @private */
    _removeChildFromList(childEntry) {
        this.childContainer.removeChild(childEntry.getElement());
        
        //remove the child list if there are no children
        if(this.childContainer.childElementCount === 0) {
            this.element.removeChild(this.childContainer);
            this.childContainer = null;
            //set state to empty, but save our old setting
            this.nonEmtpyState = this.state;
            this.setState(TreeEntry.NO_CONTROL); 
        }
    }

    /** I want to make sure people don't do this themselves. It is done in add/remove child. 
     * @private */
    _notifyNameChange(childEntry) {
        if(this.sortFunction) {
            this._updateChildElements();
        }
    }

    /** This sets the children elements in the sorted order 
     * @private */
    _updateChildElements() {
    var temp = this.childEntries.map( element => element);
    temp.sort(this.sortFunction);
    uiutil.removeAllChildren(this.childContainer);
    temp.forEach(child => this.childContainer.appendChild(child.getElement()));

    }    

}


TreeEntry.NO_CONTROL = 0;
TreeEntry.EXPANDED = 1;
TreeEntry.COLLAPSED = -1;

TreeEntry.DEFAULT_STATE = TreeEntry.EXPANDED;

let ConfigurablePanelConstants = {};

ConfigurablePanelConstants.STATE_NORMAL = "normal";
ConfigurablePanelConstants.STATE_DISABLED = "disabled";
ConfigurablePanelConstants.STATE_HIDDEN = "hidden";
ConfigurablePanelConstants.STATE_INACTIVE = "inactive";

ConfigurablePanelConstants.DEFAULT_SUBMIT_LABEL = "OK";
ConfigurablePanelConstants.DEFAULT_CANCEL_LABEL = "Cancel";

/** This is a panel with forma elements that can be configured using a javascript object.
 * 
 * @class 
 */
class ConfigurablePanel {
    
    constructor(optionalContainerClassName = ConfigurablePanel.CONTAINER_CLASS_SELF_SIZED) {
        this.elementObjects = [];
        this.panelElement = this.createPanelElement(optionalContainerClassName); 
    }
    
    configureForm(formInitData) {
        
        //TEMPORARY - legacy check correction----------------------
        if((formInitData)&&(formInitData.constructor == Array)) {
            formInitData = {layout:formInitData};
        }
        //---------------------------------------------------------
        
        //check for an invalid input
        if((!formInitData)||(!formInitData.layout)||(formInitData.layout.constructor != Array)) {
            formInitData = ConfigurablePanel.INVALID_INIT_DATA;
        }
        
        //clear data
        uiutil.removeAllChildren(this.panelElement);
        this.elementObjects = [];
        
        try {
            //create elements     
            formInitData.layout.forEach(elementInitData => this.addToPanel(elementInitData));

            //additional init
            if(formInitData.onChange) {
                this.addOnChange(formInitData.onChange);
            }

            if(formInitData.onSubmitInfo) {
                this.addSubmit(formInitData.onSubmitInfo.onSubmit,
                    formInitData.onSubmitInfo.onCancel,
                    formInitData.onSubmitInfo.submitLabel,
                    formInitData.onSubmitInfo.cancelLabel);
            }

            if(formInitData.disabled) {
                this.setDisabled(true);
            }
        }
        catch(error) {
            var errorMsg = "Error in panel: " + error.message;
            
            //display an error layout
            //but only try this once. If the error layout throws an error jsut continue
            if(!formInitData.isErrorLayout) {
                var errorLayoutInfo = ConfigurablePanel.getErrorMessageLayoutInfo(errorMsg);
                this.configureForm(errorLayoutInfo);
            }
        }
    }
    
    /** This method returns the ConfigurableElement for the given key. */
    getEntry(key) {
        return this.elementObjects.find(elementObject => elementObject.getKey() == key);
    }

    /** This method returns the data value object for this given panel. */
    getValue() {
        var formValue = {};
        var addValue = elementObject => {
            if(elementObject.getState() != ConfigurablePanelConstants.STATE_INACTIVE) {
                var elementValue = elementObject.getValue();
                if(elementValue !== undefined) {
                    var key = elementObject.getKey();
                    formValue[key] = elementValue;
                }
            }
        };
        this.elementObjects.forEach(addValue);
        return formValue;
    }
    
    /** This method returns the data value object for this given panel. */
    setValue(formValue) {
        for(var key in formValue) {
            var entry = this.getEntry(key);
            if(entry) {
                entry.setValue(formValue[key]);
            }
        }
    }
    
    getElement() {
        return this.panelElement;
    }
    
    getChildEntries() {
        return this.elementObjects;
    }
    
    /** This is an alternate way to add a submit entry to the form. This is useful
     * if the layout has no other handlers in it and is a pure JSON object. This 
     * will then separate out any handlers from the layout. */
    addSubmit(onSubmit,
            onCancel,
            optionalSubmitLabel = ConfigurablePanelConstants.DEFAULT_SUBMIT_LABEL,
            optionalCancelLabel = ConfigurablePanelConstants.DEFAULT_CANCEL_LABEL) {
                
        var data = {};
        data.type = "submit";
        if(onSubmit) {
            data.onSubmit = onSubmit;
            data.submitLabel = optionalSubmitLabel;
        }
        if(onCancel) {
            data.onCancel = onCancel;
            data.cancelLabel = optionalCancelLabel;
        }
        
        this.addToPanel(data);
    }
    
    //takes a handler onChange(formValue,form)
    addOnChange(onChange) {
        var childOnChange = (childValue,form) => {
            var formValue = this.getValue();
            onChange(formValue,form);
        };
        this.elementObjects.forEach( elementObject => {if(elementObject.addOnChange) elementObject.addOnChange(childOnChange);} );
    }
    
    setDisabled(isDisabled) {
        this.elementObjects.forEach( elementObject => {
            if(elementObject._setDisabled) {
                elementObject._setDisabled(isDisabled);
            }
        });
    }
    
    /** This method is used to register configurable elements with the panel */
    static addConfigurableElement(constructorFunction) {
        var type = constructorFunction.TYPE_NAME;
        ConfigurablePanel.elementMap[type] = constructorFunction;
    }
    
    /** This method can be used to generate an error message layout. */
    static getErrorMessageLayoutInfo(errorMsg) {
        var layout = [];
        var entry = {};
        entry.type = "htmlDisplay";
        entry.html = "<em style='color:red'>" + errorMsg + "</em>";
        layout.push(entry);
        return {"layout":layout, "isErrorLayout": true};
    }
    
    //=================================
    // Private methods
    //=================================
    
    /** This creates the container element for the panel. */
    createPanelElement(containerClassName) {
        var panelElement = document.createElement("div");
        panelElement.className = containerClassName;
        return panelElement;
    }
    
    /** this is called internally to add an element to the panel. */
    addToPanel(elementInitData) {
        var type = elementInitData.type;
        if(!type) {
            throw new Error("Type not found for configurable form entry!");
        }
        
        var constructor = ConfigurablePanel.getTypeConstructor(type);
        if(!constructor) {
            throw new Error("Type not found for configurable element: " + type);
        }

        var elementObject = new constructor(this,elementInitData);

        
        this.elementObjects.push(elementObject);
        var domElement = elementObject.getElement();
        if(domElement) {
            this.panelElement.appendChild(domElement);
        }
    }
    
    static getTypeConstructor(type) {
        return ConfigurablePanel.elementMap[type];
    }
}

//static fields
ConfigurablePanel.elementMap = {};

ConfigurablePanel.CONTAINER_CLASS_FILL_PARENT = "apogee_configurablePanelBody_fillParent";
ConfigurablePanel.CONTAINER_CLASS_SELF_SIZED = "apogee_configurablePanelBody_selfSized";

//This is displayed if there is an invalid layout passed in
ConfigurablePanel.INVALID_INIT_DATA = {
    layout: [
        {
            type: "heading",
            text: "INVALID FORM LAYOUT!",
            level: 4
        }
    ]
};

/** This is an element that composes the content of a configurable panel.
 * 
 * @class 
 */
class ConfigurableElement {
    constructor(form,elementInitData,optionalContainerClassName = ConfigurableElement.CONTAINER_CLASS_STANDARD) {
        this.form = form;
        this.key = elementInitData.key;
        this.domElement = uiutil.createElement("div",{"className":optionalContainerClassName});
    }
    
    /** This method returns the key for this ConfigurableElement within this panel. */
    getKey() {
        return this.key;
    }

    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return undefined;
    }  
    
    getState() {
        return this.state;
    }

    /** This hides or shows the given element within the panel. */
    setState(state) {
        this.state = state;

console.log("Settings state: " + state + "; element key: " + this.key);
         
        switch(state) {
            case ConfigurablePanelConstants.STATE_NORMAL:
                this._setVisible(true);
                this._setDisabled(false);
                break;
                
            case ConfigurablePanelConstants.STATE_DISABLED:
                this._setVisible(true);
                this._setDisabled(true);
                break;
                
            case ConfigurablePanelConstants.STATE_HIDDEN:
                this._setVisible(false);
                break;
                
            case ConfigurablePanelConstants.STATE_INACTIVE:
                this._setVisible(false);
                break;
        }
        
    }

    /** This method updates the value for a given element. See the specific element
     * to see if this method is applicable. */
    setValue(value) {
    }

    /** This method returns the DOM element for this configurable element. */
    getElement() {
        return this.domElement;
    }
    
    /** This method returns the parent form for this configurable element. */
    getForm() {
        return this.form;
    }
    
    /** This allows this element to control visibility of the given child.
     * When the value of the element is set, the child will be made visible depending
     * if its childs target valud matches the current element value. */
    addSelectionChild(childElement,value,keepActiveOnHide) {
        if(!this.childSelectionElements) {
            this._initAsParent();
        }
        var childData = {};
        childData.element = childElement;
        childData.value = value;
        childData.keepActiveOnHide = keepActiveOnHide;
        this.childSelectionElements.push(childData);
        
        this.setChildState(childData,this.getValue());
    }
    
    checkChildSelection(value) {
        if((this.childSelectionElements)&&(this.setChildState)) {
            this.childSelectionElements.forEach( childData => this.setChildState(childData,value));
        } 
    }
    
//    /* Implement this if the element can selector children */
//    setChildState(childData,value) {
//        
//    }

    //---------------------------------
    //set child state implementations
    //---------------------------------
    
    /** This is a function that can be used to set values when the parent element has a single value. */
    static setChildStateSingleValue(childData,value) {
console.log("Setting child state single. Child Data Value: " + childData.value + ". Parent value: " + value);
        if(childData.value == value) {
            childData.element.setState(ConfigurablePanelConstants.STATE_NORMAL);
        }
        else {
            var state = childData.keepActiveOnHide ? ConfigurablePanelConstants.STATE_HIDDEN : ConfigurablePanelConstants.STATE_INACTIVE;
            childData.element.setState(state);
        }
    }
    
    /** This is a function that can be used to set values when the parent element has an array value. */
    static setChildStateArrayValue(childData,value) {
console.log("Setting child state array.");
        if(value.indexOf(childData.value) >= 0) {
            childData.element.setState(ConfigurablePanelConstants.STATE_NORMAL);
        }
        else {
            var state = childData.keepActiveOnHide ? ConfigurablePanelConstants.STATE_HIDDEN : ConfigurablePanelConstants.STATE_INACTIVE;
            childData.element.setState(state);
        }
    }
    
    
    //===================================
    // internal Methods
    //==================================
    
    /** This method does standard initialization which requires the element be created. 
     * Any extending method should call this at the end of the constructor. */
    _postInstantiateInit(elementInitData) {
        
        //standard fields
        if(elementInitData.value !== undefined) {
            this.setValue(elementInitData.value);
        }
        
        var state = (elementInitData.state != undefined) ? elementInitData.state : ConfigurablePanelConstants.STATE_NORMAL;
        this.setState(state);
        
        //standard events
        if(elementInitData.onChange) {
            this.addOnChange(elementInitData.onChange);
        }
        
        //accont for parent elements
        if(elementInitData.selector) {
            if(!elementInitData.selector.parentKey) throw new Error("Parent key is required for a selectable child element:" + elementInitData.key);
            if(elementInitData.selector.parentValue === undefined) throw new Error("A child selectable element must contain a value: " + elementInitData.key)
            var parentElement = this.form.getEntry(elementInitData.selector.parentKey);
            if(!parentElement) throw new Error("Parent element " + elementInitData.selector.parentKey + " not found for selectable child element " + elementInitData.key);
            if(!parentElement.setChildState) throw new Error("Parent element " + elementInitData.selector.parentKey + " does not support selection of a child element - in element = " + elementInitData.key);
            
            parentElement.addSelectionChild(this,elementInitData.selector.parentValue,elementInitData.selector.keepActiveOnHide);
        }
    }
    
    _setDisabled(isDisabled) {};
    
    _setVisible(isVisible) {
        if(isVisible) {
            this.domElement.style.display = "";
        }
        else {
            this.domElement.style.display = "none";
        }
    }
    
    _initAsParent() {
        this.childSelectionElements = [];
        this.parentOnChangeHandler = (value,form) => this.childSelectionElements.forEach( childElement => this.setChildState(childElement,value));
        this.addOnChange(this.parentOnChangeHandler);
    }
}

ConfigurableElement.CONTAINER_CLASS_STANDARD = "apogee_configurablePanelLine_standard";
ConfigurableElement.CONTAINER_CLASS_NO_MARGIN = "apogee_configurablePanelPanelLine_noMargin";
ConfigurableElement.CONTAINER_CLASS_INVISIBLE = "apogee_configurablePanelPanelLine_hidden";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class CheckboxElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        //label
        if(elementInitData.label) {
            this.labelElement = document.createElement("span");
            this.labelElement.className = "apogee_configurablePanelLabel";
            this.labelElement.innerHTML = elementInitData.label;
            containerElement.appendChild(this.labelElement);
        }
        else {
            this.labelElement = null;
        }
        
        //checkbox field
        this.checkbox = uiutil.createElement("input",{"type":"checkbox"});
        containerElement.appendChild(this.checkbox);  
        
        this._postInstantiateInit(elementInitData);
        
        //add suport for selection children
        this.setChildState = ConfigurableElement.setChildStateSingleValue;
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return this.checkbox.checked;
    }   

    /** This method updates the value for a given element. See the specific element
     * to see if this method is applicable. */
    setValue(value) {
        this.checkbox.checked = (value === true);
        
        //needed for selection children
        this.checkChildSelection(value);
    }
    
    /** This should be extended in elements to handle on change listeners. */
    addOnChange(onChange) {
        var onChangeImpl = () => {
            onChange(this.getValue(),this.getForm());
        };
        this.checkbox.addEventListener("change",onChangeImpl);
    }
    
    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.checkbox.disabled = isDisabled;
    }
}

CheckboxElement.TYPE_NAME = "checkbox";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class CheckboxGroupElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        //label
        if(elementInitData.label) {
            this.labelElement = document.createElement("span");
            this.labelElement.className = "apogee_configurablePanelLabel";
            this.labelElement.innerHTML = elementInitData.label;
            containerElement.appendChild(this.labelElement);
            
            if(!elementInitData.horizontal) containerElement.appendChild(document.createElement("br"));
        }
        else {
            this.labelElement = null;
        }
        
        //check boxes
        this.checkboxList = [];
        var addCheckbox = checkboxInfo => {
            var buttonContainer = uiutil.createElement("div");
            buttonContainer.style.display = elementInitData.horizontal ? "inline-block" : "block";
            containerElement.appendChild(buttonContainer);

            var checkbox = uiutil.createElement("input");
            checkbox.type = "checkbox";
            
            var label;
            var value;
            if(apogeeutil$1.getObjectType(checkboxInfo) == "Array") {
                label = checkboxInfo[0];
                value = checkboxInfo[1];     
            }
            else {
                label = checkboxInfo;
                value = checkboxInfo; 
            }
            checkbox.value = value;
            this.checkboxList.push(checkbox);
            buttonContainer.appendChild(checkbox);
            buttonContainer.appendChild(document.createTextNode(label));

            if(elementInitData.horizontal) buttonContainer.appendChild(document.createTextNode("\u00A0\u00A0\u00A0\u00A0"));

            
            if(elementInitData.disabled) checkbox.disabled = true;
        };
        elementInitData.entries.forEach(addCheckbox);   
        
        this._postInstantiateInit(elementInitData);
        
        //add suport for selection children
        this.setChildState = ConfigurableElement.setChildStateArrayValue;
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return this.checkboxList.filter(checkbox => checkbox.checked).map(checkbox => checkbox.value);
    }   

    /** This method updates the list of checked entries. */
    setValue(valueList) {
        this.checkboxList.forEach(checkbox => checkbox.checked = (valueList.indexOf(checkbox.value) >= 0));
        
        //needed for selection children
        this.checkChildSelection(valueList);
    }
    
    /** This should be extended in elements to handle on change listeners. */
    addOnChange(onChange) {
        var onChangeImpl = () => {
            onChange(this.getValue(),this.getForm());
        };
        this.checkboxList.forEach(checkbox => checkbox.addEventListener("change",onChangeImpl));
    }
    
    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.checkboxList.forEach(checkbox => checkbox.disabled = isDisabled);
    }
}

CheckboxGroupElement.TYPE_NAME = "checkboxGroup";

/** This is a custom configurable element.
 * It elementInfoData should contain the entries:
 * - type - this should be the value "custom"
 * - key - this is the standard element key
 * - builderFunction - this is a function that takes the instance as an argument. it should be used to add
 * or override any functions to the instance.
 * 
 * @class 
 */
class CustomElement extends ConfigurableElement {

    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        elementInitData.builderFunction(this);
    }

}

CustomElement.TYPE_NAME = "custom";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class DropdownElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        //label
        if(elementInitData.label) {
            this.labelElement = document.createElement("span");
            this.labelElement.className = "apogee_configurablePanelLabel";
            this.labelElement.innerHTML = elementInitData.label;
            containerElement.appendChild(this.labelElement);
        }
        else {
            this.labelElement = null;
        }
        
        this.select = uiutil.createElement("select");
        var addEntry = entryInfo => {
            var label;
            var value;
            if(apogeeutil$1.getObjectType(entryInfo) == "Array") {
                label = entryInfo[0];
                value = entryInfo[1];
            }
            else {
                label = entryInfo;
                value = entryInfo;   
            }
            var entry = document.createElement("option");
            entry.text = label;
            entry.value = value;
            this.select.appendChild(entry);
        };
        if(elementInitData.entries) {
            elementInitData.entries.forEach(addEntry);
        }
        containerElement.appendChild(this.select); 
        
        this._postInstantiateInit(elementInitData);
        
        //add suport for selection children
        this.setChildState = ConfigurableElement.setChildStateSingleValue;
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return this.select.value;
    }   

    /** This method updates the value for a given element. See the specific element
     * to see if this method is applicable. */
    setValue(value) {
        this.select.value = value;
        
        //needed for selection children
        this.checkChildSelection(value);
    }
    
    /** This should be extended in elements to handle on change listeners. */
    addOnChange(onChange) {
        var onChangeImpl = () => {
            onChange(this.getValue(),this.getForm());
        };
        this.select.addEventListener("change",onChangeImpl);
    }
    
    
  
    
    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.select.disabled = isDisabled;
    }
}

DropdownElement.TYPE_NAME = "dropdown";

/** This is a heading element configurable element.
 * 
 * @class 
 */
class HeadingElement extends ConfigurableElement {

    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        var headingLevel;
        if(elementInitData.level) { 
            headingLevel = elementInitData.level;
        }
        else {
            headingLevel = HeadingElement.DEFAULT_HEADING_LEVEL;
        }
        var headingType = "h" + headingLevel;
        
        this.headingElement = uiutil.createElement(headingType,{"className":"apogee_configurablePanelHeading","innerHTML":elementInitData.text});
        containerElement.appendChild(this.headingElement);
    }

    /** This method updates the data for the given element. See the specific element
     * type for fields that can be updated. */
    updateData(elementInitData) {
        //no action;
    }
}


HeadingElement.DEFAULT_HEADING_LEVEL = 2;

HeadingElement.TYPE_NAME = "heading";

/** This is a heading element configurable element.
 * 
 * @class 
 */
class HTMLDisplayElement extends ConfigurableElement {

    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        containerElement.innerHTML = elementInitData.html;
    }

    /** This method updates the data for the given element. See the specific element
     * type for fields that can be updated. */
    updateData(elementInitData) {
        //no action;
    }
}

HTMLDisplayElement.TYPE_NAME = "htmlDisplay";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class InvisibleElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        //we will hide this element by setting display none. Someone can go ahead 
        //and show it, in which case they will get an empty element with margins.
        //maybe we should have a way to not create the element in the first place.
        super(form,elementInitData,ConfigurableElement.CONTAINER_CLASS_INVISIBLE);
        
        this._postInstantiateInit(elementInitData);
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return this.value;
    }   

    /** This method updates the value for a given element. See the specific element
     * to see if this method is applicable. */
    setValue(value) {
        this.value = value;
    }
}

InvisibleElement.TYPE_NAME = "invisible";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class PanelElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData,ConfigurableElement.CONTAINER_CLASS_NO_MARGIN);
        
        var containerElement = this.getElement();
        //update the container class
        containerElement.className = "apogee_configurablePanelPanelLine";
        
        var formInitData = elementInitData.formData;
        this.panel = new ConfigurablePanel();
        this.panel.configureForm(formInitData);
        var panelElement = this.panel.getElement();
        panelElement.className = "apogee_configurablePanelPanelLine";
        containerElement.appendChild(panelElement);  
        
        this._postInstantiateInit(elementInitData);
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return this.panel.getValue();
    }   

    /** This method updates the value for a given element. See the specific element
     * to see if this method is applicable. */
    setValue(value) {
        this.panel.setValue(value);
    }
    
    /** This will call the handler is this panel changes value. */
    addOnChange(onChange) {
        //add this to each element in the panel
        this.panel.getChildEntries().forEach( elementObject => {if(elementObject.addOnChange) elementObject.addOnChange(onChange);} );
    }
    
    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.panel.setDisabled(isDisabled);
    }
}

PanelElement.TYPE_NAME = "panel";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class RadioGroupElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        //label
        if(elementInitData.label) {
            this.labelElement = document.createElement("span");
            this.labelElement.className = "apogee_configurablePanelLabel";
            this.labelElement.innerHTML = elementInitData.label;
            containerElement.appendChild(this.labelElement);
            
            if(!elementInitData.horizontal) containerElement.appendChild(document.createElement("br"));
        }
        else {
            this.labelElement = null;
        }
        
        //radio buttons
        this.buttonList = [];
        var groupName = elementInitData.groupName;
        var addButton = buttonInfo => {
            var buttonContainer = uiutil.createElement("div");
            buttonContainer.style.display = elementInitData.horizontal ? "inline-block" : "block";
            containerElement.appendChild(buttonContainer);

            var radio = uiutil.createElement("input");
            radio.type = "radio";
            radio.name = groupName;
            
            var label;
            var value;
            if(apogeeutil$1.getObjectType(buttonInfo) == "Array") {
                label = buttonInfo[0];
                value = buttonInfo[1];     
            }
            else {
                label = buttonInfo;
                value = buttonInfo; 
            }
            radio.value = value;
            this.buttonList.push(radio);
            buttonContainer.appendChild(radio);
            buttonContainer.appendChild(document.createTextNode(label));
            
            if(elementInitData.horizontal) buttonContainer.appendChild(document.createTextNode("\u00A0\u00A0\u00A0\u00A0"));
        };
        elementInitData.entries.forEach(addButton);
        
        this._postInstantiateInit(elementInitData);
        
        //add suport for selection children
        this.setChildState = ConfigurableElement.setChildStateSingleValue;
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        var checkedRadio = this.buttonList.find(radio => radio.checked);
        if(checkedRadio) {
            return checkedRadio.value;
        }
        else {
            return undefined;
        }
    }   

    /** This method updates the list of checked entries. */
    setValue(value) {
        var checkedButton = this.buttonList.find(radioButton => (radioButton.value == value));
        if(checkedButton) {
            checkedButton.checked = true;
        }
        
        //needed for selection children
        this.checkChildSelection(value);
    }
    
    /** This should be extended in elements to handle on change listeners. */
    addOnChange(onChange) {
        var onChangeImpl = () => {
            onChange(this.getValue(),this.getForm());
        };
        this.buttonList.forEach(radioButton => radioButton.addEventListener("change",onChangeImpl));
    }
    
    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.buttonList.forEach(radioButton => radioButton.disabled = isDisabled);
    }
}

RadioGroupElement.TYPE_NAME = "radioButtonGroup";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class SpacerElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        //we will hide this element by setting display none. Someone can go ahead 
        //and show it, in which case they will get an empty element with margins.
        //maybe we should have a way to not create the element in the first place.
        super(form,elementInitData,ConfigurableElement.CONTAINER_CLASS_NO_MARGIN);
        
        var containerElement = this.getElement();
        
        this.spacerElement = document.createElement("div");
        var spacerHeight;
        if(elementInitData.height !== undefined) {
            spacerHeight = elementInitData.height;
        }
        else {
            spacerHeight = SpacerElement.DEFAULT_HEIGHT;
        }
        //this.spacerElement.style.display = "table";
        this.spacerElement.style.height = spacerHeight + "px";
        
        containerElement.appendChild(this.spacerElement);
        
        this._postInstantiateInit(elementInitData);
    }
}

//adding this includes the extra space of two margins rather than one,
//so just one pixel has a large effect
SpacerElement.DEFAULT_HEIGHT = 15;

SpacerElement.TYPE_NAME = "spacer";

/** This is an submit element configurable element.
 * 
 * @class 
 */
class SubmitElement extends ConfigurableElement {
    
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();

        this.submitDisabled = elementInitData.submitDisabled;
        this.cancelDisabled = elementInitData.cancelDisabled;
        
        //create the submit button
        if(elementInitData.onSubmit) {
            
            var onSubmit = () => {
                var formValue = form.getValue();
                elementInitData.onSubmit(formValue,form);
            };
            
            var submitLabel;
            if(elementInitData.submitLabel) { 
                submitLabel = elementInitData.submitLabel;
            }
            else {
                submitLabel = ConfigurablePanelConstants.DEFAULT_SUBMIT_LABEL;
            }
            
            this.submitButton = uiutil.createElement("button",{"className":"apogee_configurablePanelButton","innerHTML":submitLabel,"onclick":onSubmit});
            containerElement.appendChild(this.submitButton);
        }
        else {
            this.submitButton = null;
        }
        
        //create the cancel button
        if(elementInitData.onCancel) {
            
            var onCancel = () => {
                elementInitData.onCancel(form);
            };
            
            var cancelLabel;
            if(elementInitData.cancelLabel) { 
                cancelLabel = elementInitData.cancelLabel;
            }
            else {
                cancelLabel = ConfigurablePanelConstants.DEFAULT_CANCEL_LABEL;
            }
            
            this.cancelButton = uiutil.createElement("button",{"className":"apogee_configurablePanelButton","innerHTML":cancelLabel,"onclick":onCancel});
            containerElement.appendChild(this.cancelButton);
        }
        else {
            this.cancelButton = null;
        }  

        this._setButtonState();    
        
        this._postInstantiateInit(elementInitData);
    }
    
    submitDisable(isDisabled) {
        this.submitDisabled = isDisabled;
        this._setButtonState();
    }
    
    cancelDisable(isDisabled) {
        this.cancelDisabled = isDisabled;
        this._setButtonState();
    }

    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.overallDisabled = isDisabled;
        this._setButtonState();
    }

    _setButtonState() {
        if(this.submitButton) this.submitButton.disabled = this.overallDisabled || this.submitDisabled;
        if(this.cancelButton) this.cancelButton.disabled = this.overallDisabled || this.cancelDisabled;
    }
}

SubmitElement.TYPE_NAME = "submit";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class TextareaElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        //label
        if(elementInitData.label) {
            this.labelElement = document.createElement("span");
            this.labelElement.className = "apogee_configurablePanelLabel";
            this.labelElement.innerHTML = elementInitData.label;
            containerElement.appendChild(this.labelElement);
        }
        else {
            this.labelElement = null;
        }
        
        //text field
        this.inputElement = uiutil.createElement("textarea");
        if(elementInitData.rows) {
            this.inputElement.rows = elementInitData.rows;
        }
        if(elementInitData.cols) {
            this.inputElement.cols = elementInitData.cols;
        }
        containerElement.appendChild(this.inputElement); 
        
        //non standard events
        if(elementInitData.onChangeCompleted) {
            this.addOnChangeCompleted(elementInitData.onChangeCompleted);
        }
        
        this._postInstantiateInit(elementInitData);
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return this.inputElement.value.trim();
    }   

    /** This method updates the value for a given element. See the specific element
     * to see if this method is applicable. */
    setValue(value) {
        this.inputElement.value = value;
    }
    
    /** This should be extended in elements to handle on change listeners. */
    addOnChange(onChange) {
        var onChangeImpl = () => {
            onChange(this.getValue(),this.getForm());
        };
        this.inputElement.addEventListener("input",onChangeImpl);
    }
    
    /** This should be extended in elements to handle on change listeners. */
    addOnChangeCompleted(onChangeCompleted) {
        var onChangeCompletedImpl = () => {
            onChangeCompleted(this.getValue(),this.getForm());
        };
        this.inputElement.addEventListener("change",onChangeCompletedImpl);
    }
    
    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.inputElement.disabled = isDisabled;
    }
}

TextareaElement.TYPE_NAME = "textarea";

/** This is an text field element configurable element.
 * 
 * @class 
 */
class TextFieldElement extends ConfigurableElement {
    constructor(form,elementInitData) {
        super(form,elementInitData);
        
        var containerElement = this.getElement();
        
        //label
        if(elementInitData.label) {
            this.labelElement = document.createElement("span");
            this.labelElement.className = "apogee_configurablePanelLabel";
            this.labelElement.innerHTML = elementInitData.label;
            containerElement.appendChild(this.labelElement);
        }
        else {
            this.labelElement = null;
        }
        
        //text field (maight had password flag)
        var type = (elementInitData.password === true) ? "password" : "text";
        this.inputElement = uiutil.createElement("input",{"type":type});
        containerElement.appendChild(this.inputElement); 
        
        if(elementInitData.size !== undefined) {
            this.inputElement.size = elementInitData.size;
        }
        
        //non-standard events
        if(elementInitData.onChangeCompleted) {
            this.addOnChangeCompleted(elementInitData.onChangeCompleted);
        }
        
        this._postInstantiateInit(elementInitData);
    }
    
    /** This method returns value for this given element, if applicable. If not applicable
     * this method returns undefined. */
    getValue() {
        return this.inputElement.value.trim();
    }   

    /** This method updates the value for a given element. See the specific element
     * to see if this method is applicable. */
    setValue(value) {
        this.inputElement.value = value;
    }
    
    /** This should be extended in elements to handle on change listeners. */
    addOnChange(onChange) {
        var onChangeImpl = () => {
            onChange(this.getValue(),this.getForm());
        };
        this.inputElement.addEventListener("input",onChangeImpl);
    }
    
    /** This should be extended in elements to handle on change listeners. */
    addOnChangeCompleted(onChangeCompleted) {
        var onChangeCompletedImpl = () => {
            onChangeCompleted(this.getValue(),this.getForm());
        };
        this.inputElement.addEventListener("change",onChangeCompletedImpl);
    }
    
    //===================================
    // internal Methods
    //==================================
    
    _setDisabled(isDisabled) { 
        this.inputElement.disabled = isDisabled;
    }
}

TextFieldElement.TYPE_NAME = "textField";

ConfigurablePanel.addConfigurableElement(CheckboxElement);
ConfigurablePanel.addConfigurableElement(CheckboxGroupElement);
ConfigurablePanel.addConfigurableElement(CustomElement);
ConfigurablePanel.addConfigurableElement(DropdownElement);
ConfigurablePanel.addConfigurableElement(HeadingElement);
ConfigurablePanel.addConfigurableElement(HTMLDisplayElement);
ConfigurablePanel.addConfigurableElement(InvisibleElement);
ConfigurablePanel.addConfigurableElement(PanelElement);
ConfigurablePanel.addConfigurableElement(RadioGroupElement);
ConfigurablePanel.addConfigurableElement(SpacerElement);
ConfigurablePanel.addConfigurableElement(SubmitElement);
ConfigurablePanel.addConfigurableElement(TextareaElement);
ConfigurablePanel.addConfigurableElement(TextFieldElement);



var apogeeui = /*#__PURE__*/Object.freeze({
    __proto__: null,
    uiutil: uiutil,
    dialogMgr: dialogMgr,
    bannerConstants: bannerConstants,
    getBanner: getBanner,
    getIconOverlay: getIconOverlay,
    Tab: Tab,
    TabFrame: TabFrame,
    Menu: Menu,
    SplitPane: SplitPane,
    TreeControl: TreeControl,
    TreeEntry: TreeEntry,
    DisplayAndHeader: DisplayAndHeader,
    ConfigurablePanel: ConfigurablePanel
});

//-----------------------------------------
// ES6 Module Conversion - Added to execute this UMD module as CommonJS and use "exports" as the export.
// Additional code appears at the bottom of the file.
let module$1 = {};
module$1.exports = {};
let exports$1 = module$1.exports;
//
//Note - this still sets window.ace in the web version, and it requires this in the theme loading
//------------------------------------------

(function(){function o(n){var i=e;n&&(e[n]||(e[n]={}),i=e[n]);if(!i.define||!i.define.packaged)t.original=i.define,i.define=t,i.define.packaged=!0;if(!i.require||!i.require.packaged)r.original=i.require,i.require=r,i.require.packaged=!0;}var ACE_NAMESPACE="",e=function(){return this}();!e&&typeof window!="undefined"&&(e=window);if(typeof requirejs!="undefined")return;var t=function(e,n,r){if(typeof e!="string"){t.original?t.original.apply(this,arguments):(console.error("dropping module because define wasn't a string."),console.trace());return}arguments.length==2&&(r=n),t.modules[e]||(t.payloads[e]=r,t.modules[e]=null);};t.modules={},t.payloads={};var n=function(e,t,n){if(typeof t=="string"){var i=s(e,t);if(i!=undefined)return n&&n(),i}else if(Object.prototype.toString.call(t)==="[object Array]"){var o=[];for(var u=0,a=t.length;u<a;++u){var f=s(e,t[u]);if(f==undefined&&r.original)return;o.push(f);}return n&&n.apply(null,o)||!0}},r=function(e,t){var i=n("",e,t);return i==undefined&&r.original?r.original.apply(this,arguments):i},i=function(e,t){if(t.indexOf("!")!==-1){var n=t.split("!");return i(e,n[0])+"!"+i(e,n[1])}if(t.charAt(0)=="."){var r=e.split("/").slice(0,-1).join("/");t=r+"/"+t;while(t.indexOf(".")!==-1&&s!=t){var s=t;t=t.replace(/\/\.\//,"/").replace(/[^\/]+\/\.\.\//,"");}}return t},s=function(e,r){r=i(e,r);var s=t.modules[r];if(!s){s=t.payloads[r];if(typeof s=="function"){var o={},u={id:r,uri:"",exports:o,packaged:!0},a=function(e,t){return n(r,e,t)},f=s(a,o,u);o=f||u.exports,t.modules[r]=o,delete t.payloads[r];}s=t.modules[r]=o||s;}return s};o(ACE_NAMESPACE);})(),define("ace/lib/regexp",["require","exports","module"],function(e,t,n){function o(e){return (e.global?"g":"")+(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.extended?"x":"")+(e.sticky?"y":"")}function u(e,t,n){if(Array.prototype.indexOf)return e.indexOf(t,n);for(var r=n||0;r<e.length;r++)if(e[r]===t)return r;return -1}var r={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},i=r.exec.call(/()??/,"")[1]===undefined,s=function(){var e=/^/g;return r.test.call(e,""),!e.lastIndex}();if(s&&i)return;RegExp.prototype.exec=function(e){var t=r.exec.apply(this,arguments),n,a;if(typeof e=="string"&&t){!i&&t.length>1&&u(t,"")>-1&&(a=RegExp(this.source,r.replace.call(o(this),"g","")),r.replace.call(e.slice(t.index),a,function(){for(var e=1;e<arguments.length-2;e++)arguments[e]===undefined&&(t[e]=undefined);}));if(this._xregexp&&this._xregexp.captureNames)for(var f=1;f<t.length;f++)n=this._xregexp.captureNames[f-1],n&&(t[n]=t[f]);!s&&this.global&&!t[0].length&&this.lastIndex>t.index&&this.lastIndex--;}return t},s||(RegExp.prototype.test=function(e){var t=r.exec.call(this,e);return t&&this.global&&!t[0].length&&this.lastIndex>t.index&&this.lastIndex--,!!t});}),define("ace/lib/es5-shim",["require","exports","module"],function(e,t,n){function r(){}function w(e){try{return Object.defineProperty(e,"sentinel",{}),"sentinel"in e}catch(t){}}function H(e){return e=+e,e!==e?e=0:e!==0&&e!==1/0&&e!==-1/0&&(e=(e>0||-1)*Math.floor(Math.abs(e))),e}Function.prototype.bind||(Function.prototype.bind=function(t){var n=this;if(typeof n!="function")throw new TypeError("Function.prototype.bind called on incompatible "+n);var i=u.call(arguments,1),s=function(){if(this instanceof s){var e=n.apply(this,i.concat(u.call(arguments)));return Object(e)===e?e:this}return n.apply(t,i.concat(u.call(arguments)))};return n.prototype&&(r.prototype=n.prototype,s.prototype=new r,r.prototype=null),s});var i=Function.prototype.call,s=Array.prototype,o=Object.prototype,u=s.slice,a=i.bind(o.toString),f=i.bind(o.hasOwnProperty),l,c,h,p,d;if(d=f(o,"__defineGetter__"))l=i.bind(o.__defineGetter__),c=i.bind(o.__defineSetter__),h=i.bind(o.__lookupGetter__),p=i.bind(o.__lookupSetter__);if([1,2].splice(0).length!=2)if(!function(){function e(e){var t=new Array(e+2);return t[0]=t[1]=0,t}var t=[],n;t.splice.apply(t,e(20)),t.splice.apply(t,e(26)),n=t.length,t.splice(5,0,"XXX"),n+1==t.length;if(n+1==t.length)return !0}())Array.prototype.splice=function(e,t){var n=this.length;e>0?e>n&&(e=n):e==void 0?e=0:e<0&&(e=Math.max(n+e,0)),e+t<n||(t=n-e);var r=this.slice(e,e+t),i=u.call(arguments,2),s=i.length;if(e===n)s&&this.push.apply(this,i);else{var o=Math.min(t,n-e),a=e+o,f=a+s-o,l=n-a,c=n-o;if(f<a)for(var h=0;h<l;++h)this[f+h]=this[a+h];else if(f>a)for(h=l;h--;)this[f+h]=this[a+h];if(s&&e===c)this.length=c,this.push.apply(this,i);else{this.length=c+s;for(h=0;h<s;++h)this[e+h]=i[h];}}return r};else{var v=Array.prototype.splice;Array.prototype.splice=function(e,t){return arguments.length?v.apply(this,[e===void 0?0:e,t===void 0?this.length-e:t].concat(u.call(arguments,2))):[]};}Array.isArray||(Array.isArray=function(t){return a(t)=="[object Array]"});var m=Object("a"),g=m[0]!="a"||!(0 in m);Array.prototype.forEach||(Array.prototype.forEach=function(t){var n=F(this),r=g&&a(this)=="[object String]"?this.split(""):n,i=arguments[1],s=-1,o=r.length>>>0;if(a(t)!="[object Function]")throw new TypeError;while(++s<o)s in r&&t.call(i,r[s],s,n);}),Array.prototype.map||(Array.prototype.map=function(t){var n=F(this),r=g&&a(this)=="[object String]"?this.split(""):n,i=r.length>>>0,s=Array(i),o=arguments[1];if(a(t)!="[object Function]")throw new TypeError(t+" is not a function");for(var u=0;u<i;u++)u in r&&(s[u]=t.call(o,r[u],u,n));return s}),Array.prototype.filter||(Array.prototype.filter=function(t){var n=F(this),r=g&&a(this)=="[object String]"?this.split(""):n,i=r.length>>>0,s=[],o,u=arguments[1];if(a(t)!="[object Function]")throw new TypeError(t+" is not a function");for(var f=0;f<i;f++)f in r&&(o=r[f],t.call(u,o,f,n)&&s.push(o));return s}),Array.prototype.every||(Array.prototype.every=function(t){var n=F(this),r=g&&a(this)=="[object String]"?this.split(""):n,i=r.length>>>0,s=arguments[1];if(a(t)!="[object Function]")throw new TypeError(t+" is not a function");for(var o=0;o<i;o++)if(o in r&&!t.call(s,r[o],o,n))return !1;return !0}),Array.prototype.some||(Array.prototype.some=function(t){var n=F(this),r=g&&a(this)=="[object String]"?this.split(""):n,i=r.length>>>0,s=arguments[1];if(a(t)!="[object Function]")throw new TypeError(t+" is not a function");for(var o=0;o<i;o++)if(o in r&&t.call(s,r[o],o,n))return !0;return !1}),Array.prototype.reduce||(Array.prototype.reduce=function(t){var n=F(this),r=g&&a(this)=="[object String]"?this.split(""):n,i=r.length>>>0;if(a(t)!="[object Function]")throw new TypeError(t+" is not a function");if(!i&&arguments.length==1)throw new TypeError("reduce of empty array with no initial value");var s=0,o;if(arguments.length>=2)o=arguments[1];else do{if(s in r){o=r[s++];break}if(++s>=i)throw new TypeError("reduce of empty array with no initial value")}while(!0);for(;s<i;s++)s in r&&(o=t.call(void 0,o,r[s],s,n));return o}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(t){var n=F(this),r=g&&a(this)=="[object String]"?this.split(""):n,i=r.length>>>0;if(a(t)!="[object Function]")throw new TypeError(t+" is not a function");if(!i&&arguments.length==1)throw new TypeError("reduceRight of empty array with no initial value");var s,o=i-1;if(arguments.length>=2)s=arguments[1];else do{if(o in r){s=r[o--];break}if(--o<0)throw new TypeError("reduceRight of empty array with no initial value")}while(!0);do o in this&&(s=t.call(void 0,s,r[o],o,n));while(o--);return s});if(!Array.prototype.indexOf||[0,1].indexOf(1,2)!=-1)Array.prototype.indexOf=function(t){var n=g&&a(this)=="[object String]"?this.split(""):F(this),r=n.length>>>0;if(!r)return -1;var i=0;arguments.length>1&&(i=H(arguments[1])),i=i>=0?i:Math.max(0,r+i);for(;i<r;i++)if(i in n&&n[i]===t)return i;return -1};if(!Array.prototype.lastIndexOf||[0,1].lastIndexOf(0,-3)!=-1)Array.prototype.lastIndexOf=function(t){var n=g&&a(this)=="[object String]"?this.split(""):F(this),r=n.length>>>0;if(!r)return -1;var i=r-1;arguments.length>1&&(i=Math.min(i,H(arguments[1]))),i=i>=0?i:r-Math.abs(i);for(;i>=0;i--)if(i in n&&t===n[i])return i;return -1};Object.getPrototypeOf||(Object.getPrototypeOf=function(t){return t.__proto__||(t.constructor?t.constructor.prototype:o)});if(!Object.getOwnPropertyDescriptor){var y="Object.getOwnPropertyDescriptor called on a non-object: ";Object.getOwnPropertyDescriptor=function(t,n){if(typeof t!="object"&&typeof t!="function"||t===null)throw new TypeError(y+t);if(!f(t,n))return;var r,i,s;r={enumerable:!0,configurable:!0};if(d){var u=t.__proto__;t.__proto__=o;var i=h(t,n),s=p(t,n);t.__proto__=u;if(i||s)return i&&(r.get=i),s&&(r.set=s),r}return r.value=t[n],r};}Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(t){return Object.keys(t)});if(!Object.create){var b;Object.prototype.__proto__===null?b=function(){return {__proto__:null}}:b=function(){var e={};for(var t in e)e[t]=null;return e.constructor=e.hasOwnProperty=e.propertyIsEnumerable=e.isPrototypeOf=e.toLocaleString=e.toString=e.valueOf=e.__proto__=null,e},Object.create=function(t,n){var r;if(t===null)r=b();else{if(typeof t!="object")throw new TypeError("typeof prototype["+typeof t+"] != 'object'");var i=function(){};i.prototype=t,r=new i,r.__proto__=t;}return n!==void 0&&Object.defineProperties(r,n),r};}if(Object.defineProperty){var E=w({}),S=typeof document=="undefined"||w(document.createElement("div"));if(!E||!S)var x=Object.defineProperty;}if(!Object.defineProperty||x){var T="Property description must be an object: ",N="Object.defineProperty called on non-object: ",C="getters & setters can not be defined on this javascript engine";Object.defineProperty=function(t,n,r){if(typeof t!="object"&&typeof t!="function"||t===null)throw new TypeError(N+t);if(typeof r!="object"&&typeof r!="function"||r===null)throw new TypeError(T+r);if(x)try{return x.call(Object,t,n,r)}catch(i){}if(f(r,"value"))if(d&&(h(t,n)||p(t,n))){var s=t.__proto__;t.__proto__=o,delete t[n],t[n]=r.value,t.__proto__=s;}else t[n]=r.value;else{if(!d)throw new TypeError(C);f(r,"get")&&l(t,n,r.get),f(r,"set")&&c(t,n,r.set);}return t};}Object.defineProperties||(Object.defineProperties=function(t,n){for(var r in n)f(n,r)&&Object.defineProperty(t,r,n[r]);return t}),Object.seal||(Object.seal=function(t){return t}),Object.freeze||(Object.freeze=function(t){return t});try{Object.freeze(function(){});}catch(k){Object.freeze=function(t){return function(n){return typeof n=="function"?n:t(n)}}(Object.freeze);}Object.preventExtensions||(Object.preventExtensions=function(t){return t}),Object.isSealed||(Object.isSealed=function(t){return !1}),Object.isFrozen||(Object.isFrozen=function(t){return !1}),Object.isExtensible||(Object.isExtensible=function(t){if(Object(t)===t)throw new TypeError;var n="";while(f(t,n))n+="?";t[n]=!0;var r=f(t,n);return delete t[n],r});if(!Object.keys){var L=!0,A=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],O=A.length;for(var M in {toString:null})L=!1;Object.keys=function I(e){if(typeof e!="object"&&typeof e!="function"||e===null)throw new TypeError("Object.keys called on a non-object");var I=[];for(var t in e)f(e,t)&&I.push(t);if(L)for(var n=0,r=O;n<r;n++){var i=A[n];f(e,i)&&I.push(i);}return I};}Date.now||(Date.now=function(){return (new Date).getTime()});var _="	\n\x0b\f\r \u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029\ufeff";if(!String.prototype.trim||_.trim()){_="["+_+"]";var D=new RegExp("^"+_+_+"*"),P=new RegExp(_+_+"*$");String.prototype.trim=function(){return String(this).replace(D,"").replace(P,"")};}var F=function(e){if(e==null)throw new TypeError("can't convert "+e+" to object");return Object(e)};}),define("ace/lib/fixoldbrowsers",["require","exports","module","ace/lib/regexp","ace/lib/es5-shim"],function(e,t,n){e("./regexp"),e("./es5-shim"),typeof Element!="undefined"&&!Element.prototype.remove&&Object.defineProperty(Element.prototype,"remove",{enumerable:!1,writable:!0,configurable:!0,value:function(){this.parentNode&&this.parentNode.removeChild(this);}});}),define("ace/lib/useragent",["require","exports","module"],function(e,t,n){t.OS={LINUX:"LINUX",MAC:"MAC",WINDOWS:"WINDOWS"},t.getOS=function(){return t.isMac?t.OS.MAC:t.isLinux?t.OS.LINUX:t.OS.WINDOWS};if(typeof navigator!="object")return;var r=(navigator.platform.match(/mac|win|linux/i)||["other"])[0].toLowerCase(),i=navigator.userAgent;t.isWin=r=="win",t.isMac=r=="mac",t.isLinux=r=="linux",t.isIE=navigator.appName=="Microsoft Internet Explorer"||navigator.appName.indexOf("MSAppHost")>=0?parseFloat((i.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]):parseFloat((i.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]),t.isOldIE=t.isIE&&t.isIE<9,t.isGecko=t.isMozilla=i.match(/ Gecko\/\d+/),t.isOpera=window.opera&&Object.prototype.toString.call(window.opera)=="[object Opera]",t.isWebKit=parseFloat(i.split("WebKit/")[1])||undefined,t.isChrome=parseFloat(i.split(" Chrome/")[1])||undefined,t.isEdge=parseFloat(i.split(" Edge/")[1])||undefined,t.isAIR=i.indexOf("AdobeAIR")>=0,t.isIPad=i.indexOf("iPad")>=0,t.isAndroid=i.indexOf("Android")>=0,t.isChromeOS=i.indexOf(" CrOS ")>=0,t.isIOS=/iPad|iPhone|iPod/.test(i)&&!window.MSStream,t.isIOS&&(t.isMac=!0),t.isMobile=t.isIPad||t.isAndroid;}),define("ace/lib/dom",["require","exports","module","ace/lib/useragent"],function(e,t,n){var r=e("./useragent"),i="http://www.w3.org/1999/xhtml";t.buildDom=function o(e,t,n){if(typeof e=="string"&&e){var r=document.createTextNode(e);return t&&t.appendChild(r),r}if(!Array.isArray(e))return e;if(typeof e[0]!="string"||!e[0]){var i=[];for(var s=0;s<e.length;s++){var u=o(e[s],t,n);u&&i.push(u);}return i}var a=document.createElement(e[0]),f=e[1],l=1;f&&typeof f=="object"&&!Array.isArray(f)&&(l=2);for(var s=l;s<e.length;s++)o(e[s],a,n);return l==2&&Object.keys(f).forEach(function(e){var t=f[e];e==="class"?a.className=Array.isArray(t)?t.join(" "):t:typeof t=="function"||e=="value"?a[e]=t:e==="ref"?n&&(n[t]=a):t!=null&&a.setAttribute(e,t);}),t&&t.appendChild(a),a},t.getDocumentHead=function(e){return e||(e=document),e.head||e.getElementsByTagName("head")[0]||e.documentElement},t.createElement=function(e,t){return document.createElementNS?document.createElementNS(t||i,e):document.createElement(e)},t.removeChildren=function(e){e.innerHTML="";},t.createTextNode=function(e,t){var n=t?t.ownerDocument:document;return n.createTextNode(e)},t.createFragment=function(e){var t=e?e.ownerDocument:document;return t.createDocumentFragment()},t.hasCssClass=function(e,t){var n=(e.className+"").split(/\s+/g);return n.indexOf(t)!==-1},t.addCssClass=function(e,n){t.hasCssClass(e,n)||(e.className+=" "+n);},t.removeCssClass=function(e,t){var n=e.className.split(/\s+/g);for(;;){var r=n.indexOf(t);if(r==-1)break;n.splice(r,1);}e.className=n.join(" ");},t.toggleCssClass=function(e,t){var n=e.className.split(/\s+/g),r=!0;for(;;){var i=n.indexOf(t);if(i==-1)break;r=!1,n.splice(i,1);}return r&&n.push(t),e.className=n.join(" "),r},t.setCssClass=function(e,n,r){r?t.addCssClass(e,n):t.removeCssClass(e,n);},t.hasCssString=function(e,t){var n=0,r;t=t||document;if(r=t.querySelectorAll("style"))while(n<r.length)if(r[n++].id===e)return !0},t.importCssString=function(n,r,i){var s=i;if(!i||!i.getRootNode)s=document;else{s=i.getRootNode();if(!s||s==i)s=document;}var o=s.ownerDocument||s;if(r&&t.hasCssString(r,s))return null;r&&(n+="\n/*# sourceURL=ace/css/"+r+" */");var u=t.createElement("style");u.appendChild(o.createTextNode(n)),r&&(u.id=r),s==o&&(s=t.getDocumentHead(o)),s.insertBefore(u,s.firstChild);},t.importCssStylsheet=function(e,n){t.buildDom(["link",{rel:"stylesheet",href:e}],t.getDocumentHead(n));},t.scrollbarWidth=function(e){var n=t.createElement("ace_inner");n.style.width="100%",n.style.minWidth="0px",n.style.height="200px",n.style.display="block";var r=t.createElement("ace_outer"),i=r.style;i.position="absolute",i.left="-10000px",i.overflow="hidden",i.width="200px",i.minWidth="0px",i.height="150px",i.display="block",r.appendChild(n);var s=e.documentElement;s.appendChild(r);var o=n.offsetWidth;i.overflow="scroll";var u=n.offsetWidth;return o==u&&(u=r.clientWidth),s.removeChild(r),o-u},typeof document=="undefined"&&(t.importCssString=function(){}),t.computedStyle=function(e,t){return window.getComputedStyle(e,"")||{}},t.setStyle=function(e,t,n){e[t]!==n&&(e[t]=n);},t.HAS_CSS_ANIMATION=!1,t.HAS_CSS_TRANSFORMS=!1,t.HI_DPI=r.isWin?typeof window!="undefined"&&window.devicePixelRatio>=1.5:!0;if(typeof document!="undefined"){var s=document.createElement("div");t.HI_DPI&&s.style.transform!==undefined&&(t.HAS_CSS_TRANSFORMS=!0),!r.isEdge&&typeof s.style.animationName!="undefined"&&(t.HAS_CSS_ANIMATION=!0),s=null;}t.HAS_CSS_TRANSFORMS?t.translate=function(e,t,n){e.style.transform="translate("+Math.round(t)+"px, "+Math.round(n)+"px)";}:t.translate=function(e,t,n){e.style.top=Math.round(n)+"px",e.style.left=Math.round(t)+"px";};}),define("ace/lib/oop",["require","exports","module"],function(e,t,n){t.inherits=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}});},t.mixin=function(e,t){for(var n in t)e[n]=t[n];return e},t.implement=function(e,n){t.mixin(e,n);};}),define("ace/lib/keys",["require","exports","module","ace/lib/oop"],function(e,t,n){var r=e("./oop"),i=function(){var e={MODIFIER_KEYS:{16:"Shift",17:"Ctrl",18:"Alt",224:"Meta"},KEY_MODS:{ctrl:1,alt:2,option:2,shift:4,"super":8,meta:8,command:8,cmd:8},FUNCTION_KEYS:{8:"Backspace",9:"Tab",13:"Return",19:"Pause",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"Print",45:"Insert",46:"Delete",96:"Numpad0",97:"Numpad1",98:"Numpad2",99:"Numpad3",100:"Numpad4",101:"Numpad5",102:"Numpad6",103:"Numpad7",104:"Numpad8",105:"Numpad9","-13":"NumpadEnter",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"Numlock",145:"Scrolllock"},PRINTABLE_KEYS:{32:" ",48:"0",49:"1",50:"2",51:"3",52:"4",53:"5",54:"6",55:"7",56:"8",57:"9",59:";",61:"=",65:"a",66:"b",67:"c",68:"d",69:"e",70:"f",71:"g",72:"h",73:"i",74:"j",75:"k",76:"l",77:"m",78:"n",79:"o",80:"p",81:"q",82:"r",83:"s",84:"t",85:"u",86:"v",87:"w",88:"x",89:"y",90:"z",107:"+",109:"-",110:".",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",111:"/",106:"*"}},t,n;for(n in e.FUNCTION_KEYS)t=e.FUNCTION_KEYS[n].toLowerCase(),e[t]=parseInt(n,10);for(n in e.PRINTABLE_KEYS)t=e.PRINTABLE_KEYS[n].toLowerCase(),e[t]=parseInt(n,10);return r.mixin(e,e.MODIFIER_KEYS),r.mixin(e,e.PRINTABLE_KEYS),r.mixin(e,e.FUNCTION_KEYS),e.enter=e["return"],e.escape=e.esc,e.del=e["delete"],e[173]="-",function(){var t=["cmd","ctrl","alt","shift"];for(var n=Math.pow(2,t.length);n--;)e.KEY_MODS[n]=t.filter(function(t){return n&e.KEY_MODS[t]}).join("-")+"-";}(),e.KEY_MODS[0]="",e.KEY_MODS[-1]="input-",e}();r.mixin(t,i),t.keyCodeToString=function(e){var t=i[e];return typeof t!="string"&&(t=String.fromCharCode(e)),t.toLowerCase()};}),define("ace/lib/event",["require","exports","module","ace/lib/keys","ace/lib/useragent"],function(e,t,n){function a(e,t,n){var a=u(t);if(!i.isMac&&s){t.getModifierState&&(t.getModifierState("OS")||t.getModifierState("Win"))&&(a|=8);if(s.altGr){if((3&a)==3)return;s.altGr=0;}if(n===18||n===17){var f="location"in t?t.location:t.keyLocation;if(n===17&&f===1)s[n]==1&&(o=t.timeStamp);else if(n===18&&a===3&&f===2){var l=t.timeStamp-o;l<50&&(s.altGr=!0);}}}n in r.MODIFIER_KEYS&&(n=-1),a&8&&n>=91&&n<=93&&(n=-1);if(!a&&n===13){var f="location"in t?t.location:t.keyLocation;if(f===3){e(t,a,-n);if(t.defaultPrevented)return}}if(i.isChromeOS&&a&8){e(t,a,n);if(t.defaultPrevented)return;a&=-9;}return !!a||n in r.FUNCTION_KEYS||n in r.PRINTABLE_KEYS?e(t,a,n):!1}function f(){s=Object.create(null);}var r=e("./keys"),i=e("./useragent"),s=null,o=0;t.addListener=function(e,t,n){if(e.addEventListener)return e.addEventListener(t,n,!1);if(e.attachEvent){var r=function(){n.call(e,window.event);};n._wrapper=r,e.attachEvent("on"+t,r);}},t.removeListener=function(e,t,n){if(e.removeEventListener)return e.removeEventListener(t,n,!1);e.detachEvent&&e.detachEvent("on"+t,n._wrapper||n);},t.stopEvent=function(e){return t.stopPropagation(e),t.preventDefault(e),!1},t.stopPropagation=function(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0;},t.preventDefault=function(e){e.preventDefault?e.preventDefault():e.returnValue=!1;},t.getButton=function(e){return e.type=="dblclick"?0:e.type=="contextmenu"||i.isMac&&e.ctrlKey&&!e.altKey&&!e.shiftKey?2:e.preventDefault?e.button:{1:0,2:2,4:1}[e.button]},t.capture=function(e,n,r){function i(e){n&&n(e),r&&r(e),t.removeListener(document,"mousemove",n,!0),t.removeListener(document,"mouseup",i,!0),t.removeListener(document,"dragstart",i,!0);}return t.addListener(document,"mousemove",n,!0),t.addListener(document,"mouseup",i,!0),t.addListener(document,"dragstart",i,!0),i},t.addTouchMoveListener=function(e,n){var r,i;t.addListener(e,"touchstart",function(e){var t=e.touches,n=t[0];r=n.clientX,i=n.clientY;}),t.addListener(e,"touchmove",function(e){var t=e.touches;if(t.length>1)return;var s=t[0];e.wheelX=r-s.clientX,e.wheelY=i-s.clientY,r=s.clientX,i=s.clientY,n(e);});},t.addMouseWheelListener=function(e,n){"onmousewheel"in e?t.addListener(e,"mousewheel",function(e){var t=8;e.wheelDeltaX!==undefined?(e.wheelX=-e.wheelDeltaX/t,e.wheelY=-e.wheelDeltaY/t):(e.wheelX=0,e.wheelY=-e.wheelDelta/t),n(e);}):"onwheel"in e?t.addListener(e,"wheel",function(e){var t=.35;switch(e.deltaMode){case e.DOM_DELTA_PIXEL:e.wheelX=e.deltaX*t||0,e.wheelY=e.deltaY*t||0;break;case e.DOM_DELTA_LINE:case e.DOM_DELTA_PAGE:e.wheelX=(e.deltaX||0)*5,e.wheelY=(e.deltaY||0)*5;}n(e);}):t.addListener(e,"DOMMouseScroll",function(e){e.axis&&e.axis==e.HORIZONTAL_AXIS?(e.wheelX=(e.detail||0)*5,e.wheelY=0):(e.wheelX=0,e.wheelY=(e.detail||0)*5),n(e);});},t.addMultiMouseDownListener=function(e,n,r,s){function c(e){t.getButton(e)!==0?o=0:e.detail>1?(o++,o>4&&(o=1)):o=1;if(i.isIE){var c=Math.abs(e.clientX-u)>5||Math.abs(e.clientY-a)>5;if(!f||c)o=1;f&&clearTimeout(f),f=setTimeout(function(){f=null;},n[o-1]||600),o==1&&(u=e.clientX,a=e.clientY);}e._clicks=o,r[s]("mousedown",e);if(o>4)o=0;else if(o>1)return r[s](l[o],e)}function h(e){o=2,f&&clearTimeout(f),f=setTimeout(function(){f=null;},n[o-1]||600),r[s]("mousedown",e),r[s](l[o],e);}var o=0,u,a,f,l={2:"dblclick",3:"tripleclick",4:"quadclick"};Array.isArray(e)||(e=[e]),e.forEach(function(e){t.addListener(e,"mousedown",c),i.isOldIE&&t.addListener(e,"dblclick",h);});};var u=!i.isMac||!i.isOpera||"KeyboardEvent"in window?function(e){return 0|(e.ctrlKey?1:0)|(e.altKey?2:0)|(e.shiftKey?4:0)|(e.metaKey?8:0)}:function(e){return 0|(e.metaKey?1:0)|(e.altKey?2:0)|(e.shiftKey?4:0)|(e.ctrlKey?8:0)};t.getModifierString=function(e){return r.KEY_MODS[u(e)]},t.addCommandKeyListener=function(e,n){var r=t.addListener;if(i.isOldGecko||i.isOpera&&!("KeyboardEvent"in window)){var o=null;r(e,"keydown",function(e){o=e.keyCode;}),r(e,"keypress",function(e){return a(n,e,o)});}else{var u=null;r(e,"keydown",function(e){s[e.keyCode]=(s[e.keyCode]||0)+1;var t=a(n,e,e.keyCode);return u=e.defaultPrevented,t}),r(e,"keypress",function(e){u&&(e.ctrlKey||e.altKey||e.shiftKey||e.metaKey)&&(t.stopEvent(e),u=null);}),r(e,"keyup",function(e){s[e.keyCode]=null;}),s||(f(),r(window,"focus",f));}};if(typeof window=="object"&&window.postMessage&&!i.isOldIE){var l=1;t.nextTick=function(e,n){n=n||window;var r="zero-timeout-message-"+l++,i=function(s){s.data==r&&(t.stopPropagation(s),t.removeListener(n,"message",i),e());};t.addListener(n,"message",i),n.postMessage(r,"*");};}t.$idleBlocked=!1,t.onIdle=function(e,n){return setTimeout(function r(){t.$idleBlocked?setTimeout(r,100):e();},n)},t.$idleBlockId=null,t.blockIdle=function(e){t.$idleBlockId&&clearTimeout(t.$idleBlockId),t.$idleBlocked=!0,t.$idleBlockId=setTimeout(function(){t.$idleBlocked=!1;},e||100);},t.nextFrame=typeof window=="object"&&(window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame||window.oRequestAnimationFrame),t.nextFrame?t.nextFrame=t.nextFrame.bind(window):t.nextFrame=function(e){setTimeout(e,17);};}),define("ace/range",["require","exports","module"],function(e,t,n){var r=function(e,t){return e.row-t.row||e.column-t.column},i=function(e,t,n,r){this.start={row:e,column:t},this.end={row:n,column:r};};(function(){this.isEqual=function(e){return this.start.row===e.start.row&&this.end.row===e.end.row&&this.start.column===e.start.column&&this.end.column===e.end.column},this.toString=function(){return "Range: ["+this.start.row+"/"+this.start.column+"] -> ["+this.end.row+"/"+this.end.column+"]"},this.contains=function(e,t){return this.compare(e,t)==0},this.compareRange=function(e){var t,n=e.end,r=e.start;return t=this.compare(n.row,n.column),t==1?(t=this.compare(r.row,r.column),t==1?2:t==0?1:0):t==-1?-2:(t=this.compare(r.row,r.column),t==-1?-1:t==1?42:0)},this.comparePoint=function(e){return this.compare(e.row,e.column)},this.containsRange=function(e){return this.comparePoint(e.start)==0&&this.comparePoint(e.end)==0},this.intersects=function(e){var t=this.compareRange(e);return t==-1||t==0||t==1},this.isEnd=function(e,t){return this.end.row==e&&this.end.column==t},this.isStart=function(e,t){return this.start.row==e&&this.start.column==t},this.setStart=function(e,t){typeof e=="object"?(this.start.column=e.column,this.start.row=e.row):(this.start.row=e,this.start.column=t);},this.setEnd=function(e,t){typeof e=="object"?(this.end.column=e.column,this.end.row=e.row):(this.end.row=e,this.end.column=t);},this.inside=function(e,t){return this.compare(e,t)==0?this.isEnd(e,t)||this.isStart(e,t)?!1:!0:!1},this.insideStart=function(e,t){return this.compare(e,t)==0?this.isEnd(e,t)?!1:!0:!1},this.insideEnd=function(e,t){return this.compare(e,t)==0?this.isStart(e,t)?!1:!0:!1},this.compare=function(e,t){return !this.isMultiLine()&&e===this.start.row?t<this.start.column?-1:t>this.end.column?1:0:e<this.start.row?-1:e>this.end.row?1:this.start.row===e?t>=this.start.column?0:-1:this.end.row===e?t<=this.end.column?0:1:0},this.compareStart=function(e,t){return this.start.row==e&&this.start.column==t?-1:this.compare(e,t)},this.compareEnd=function(e,t){return this.end.row==e&&this.end.column==t?1:this.compare(e,t)},this.compareInside=function(e,t){return this.end.row==e&&this.end.column==t?1:this.start.row==e&&this.start.column==t?-1:this.compare(e,t)},this.clipRows=function(e,t){if(this.end.row>t)var n={row:t+1,column:0};else if(this.end.row<e)var n={row:e,column:0};if(this.start.row>t)var r={row:t+1,column:0};else if(this.start.row<e)var r={row:e,column:0};return i.fromPoints(r||this.start,n||this.end)},this.extend=function(e,t){var n=this.compare(e,t);if(n==0)return this;if(n==-1)var r={row:e,column:t};else var s={row:e,column:t};return i.fromPoints(r||this.start,s||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return i.fromPoints(this.start,this.end)},this.collapseRows=function(){return this.end.column==0?new i(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new i(this.start.row,0,this.end.row,0)},this.toScreenRange=function(e){var t=e.documentToScreenPosition(this.start),n=e.documentToScreenPosition(this.end);return new i(t.row,t.column,n.row,n.column)},this.moveBy=function(e,t){this.start.row+=e,this.start.column+=t,this.end.row+=e,this.end.column+=t;};}).call(i.prototype),i.fromPoints=function(e,t){return new i(e.row,e.column,t.row,t.column)},i.comparePoints=r,i.comparePoints=function(e,t){return e.row-t.row||e.column-t.column},t.Range=i;}),define("ace/lib/lang",["require","exports","module"],function(e,t,n){t.last=function(e){return e[e.length-1]},t.stringReverse=function(e){return e.split("").reverse().join("")},t.stringRepeat=function(e,t){var n="";while(t>0){t&1&&(n+=e);if(t>>=1)e+=e;}return n};var r=/^\s\s*/,i=/\s\s*$/;t.stringTrimLeft=function(e){return e.replace(r,"")},t.stringTrimRight=function(e){return e.replace(i,"")},t.copyObject=function(e){var t={};for(var n in e)t[n]=e[n];return t},t.copyArray=function(e){var t=[];for(var n=0,r=e.length;n<r;n++)e[n]&&typeof e[n]=="object"?t[n]=this.copyObject(e[n]):t[n]=e[n];return t},t.deepCopy=function s(e){if(typeof e!="object"||!e)return e;var t;if(Array.isArray(e)){t=[];for(var n=0;n<e.length;n++)t[n]=s(e[n]);return t}if(Object.prototype.toString.call(e)!=="[object Object]")return e;t={};for(var n in e)t[n]=s(e[n]);return t},t.arrayToMap=function(e){var t={};for(var n=0;n<e.length;n++)t[e[n]]=1;return t},t.createMap=function(e){var t=Object.create(null);for(var n in e)t[n]=e[n];return t},t.arrayRemove=function(e,t){for(var n=0;n<=e.length;n++)t===e[n]&&e.splice(n,1);},t.escapeRegExp=function(e){return e.replace(/([.*+?^${}()|[\]\/\\])/g,"\\$1")},t.escapeHTML=function(e){return (""+e).replace(/&/g,"&#38;").replace(/"/g,"&#34;").replace(/'/g,"&#39;").replace(/</g,"&#60;")},t.getMatchOffsets=function(e,t){var n=[];return e.replace(t,function(e){n.push({offset:arguments[arguments.length-2],length:e.length});}),n},t.deferredCall=function(e){var t=null,n=function(){t=null,e();},r=function(e){return r.cancel(),t=setTimeout(n,e||0),r};return r.schedule=r,r.call=function(){return this.cancel(),e(),r},r.cancel=function(){return clearTimeout(t),t=null,r},r.isPending=function(){return t},r},t.delayedCall=function(e,t){var n=null,r=function(){n=null,e();},i=function(e){n==null&&(n=setTimeout(r,e||t));};return i.delay=function(e){n&&clearTimeout(n),n=setTimeout(r,e||t);},i.schedule=i,i.call=function(){this.cancel(),e();},i.cancel=function(){n&&clearTimeout(n),n=null;},i.isPending=function(){return n},i};}),define("ace/keyboard/textinput",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/lib/dom","ace/lib/lang","ace/lib/keys"],function(e,t,n){var r=e("../lib/event"),i=e("../lib/useragent"),s=e("../lib/dom"),o=e("../lib/lang"),u=i.isChrome<18,a=i.isIE,f=i.isChrome>63,l=400,c=e("../lib/keys"),h=c.KEY_MODS,p=i.isIOS,d=p?/\s/:/\n/,v=function(e,t){function W(){x=!0,n.blur(),n.focus(),x=!1;}function V(e){e.keyCode==27&&n.value.length<n.selectionStart&&(g||(T=n.value),N=C=-1,A()),X();}function J(){clearTimeout($),$=setTimeout(function(){b&&(n.style.cssText=b,b=""),t.renderer.$keepTextAreaAtCursor==null&&(t.renderer.$keepTextAreaAtCursor=!0,t.renderer.$moveTextAreaToCursor());},0);}function Q(e,t,n){var r=null,i=!1;n.addEventListener("keydown",function(e){r&&clearTimeout(r),i=!0;},!0),n.addEventListener("keyup",function(e){r=setTimeout(function(){i=!1;},100);},!0);var s=function(e){if(document.activeElement!==n)return;if(i||g)return;if(v)return;var r=n.selectionStart,s=n.selectionEnd,o=null,u=0;console.log(r,s);if(r==0)o=c.up;else if(r==1)o=c.home;else if(s>C&&T[s]=="\n")o=c.end;else if(r<N&&T[r-1]==" ")o=c.left,u=h.option;else if(r<N||r==N&&C!=N&&r==s)o=c.left;else if(s>C&&T.slice(0,s).split("\n").length>2)o=c.down;else if(s>C&&T[s-1]==" ")o=c.right,u=h.option;else if(s>C||s==C&&C!=N&&r==s)o=c.right;r!==s&&(u|=h.shift),o&&(t.onCommandKey(null,u,o),N=r,C=s,A(""));};document.addEventListener("selectionchange",s),t.on("destroy",function(){document.removeEventListener("selectionchange",s);});}var n=s.createElement("textarea");n.className="ace_text-input",n.setAttribute("wrap","off"),n.setAttribute("autocorrect","off"),n.setAttribute("autocapitalize","off"),n.setAttribute("spellcheck",!1),n.style.opacity="0",e.insertBefore(n,e.firstChild);var v=!1,m=!1,g=!1,y=!1,b="";i.isMobile||(n.style.fontSize="1px");var S=!1,x=!1,T="",N=0,C=0;try{var k=document.activeElement===n;}catch(L){}r.addListener(n,"blur",function(e){if(x)return;t.onBlur(e),k=!1;}),r.addListener(n,"focus",function(e){if(x)return;k=!0;if(i.isEdge)try{if(!document.hasFocus())return}catch(e){}t.onFocus(e),i.isEdge?setTimeout(A):A();}),this.$focusScroll=!1,this.focus=function(){if(b||f||this.$focusScroll=="browser")return n.focus({preventScroll:!0});var e=n.style.top;n.style.position="fixed",n.style.top="0px";try{var t=n.getBoundingClientRect().top!=0;}catch(r){return}var i=[];if(t){var s=n.parentElement;while(s&&s.nodeType==1)i.push(s),s.setAttribute("ace_nocontext",!0),!s.parentElement&&s.getRootNode?s=s.getRootNode().host:s=s.parentElement;}n.focus({preventScroll:!0}),t&&i.forEach(function(e){e.removeAttribute("ace_nocontext");}),setTimeout(function(){n.style.position="",n.style.top=="0px"&&(n.style.top=e);},0);},this.blur=function(){n.blur();},this.isFocused=function(){return k},t.on("beforeEndOperation",function(){if(t.curOp&&t.curOp.command.name=="insertstring")return;g&&(T=n.value="",z()),A();});var A=p?function(e){if(!k||v&&!e)return;e||(e="");var r="\n ab"+e+"cde fg\n";r!=n.value&&(n.value=T=r);var i=4,s=4+(e.length||(t.selection.isEmpty()?0:1));(N!=i||C!=s)&&n.setSelectionRange(i,s),N=i,C=s;}:function(){if(g||y)return;if(!k&&!D)return;g=!0;var e=t.selection,r=e.getRange(),i=e.cursor.row,s=r.start.column,o=r.end.column,u=t.session.getLine(i);if(r.start.row!=i){var a=t.session.getLine(i-1);s=r.start.row<i-1?0:s,o+=a.length+1,u=a+"\n"+u;}else if(r.end.row!=i){var f=t.session.getLine(i+1);o=r.end.row>i+1?f.length:o,o+=u.length+1,u=u+"\n"+f;}u.length>l&&(s<l&&o<l?u=u.slice(0,l):(u="\n",s=0,o=1));var c=u+"\n\n";c!=T&&(n.value=T=c,N=C=c.length),D&&(N=n.selectionStart,C=n.selectionEnd);if(C!=o||N!=s||n.selectionEnd!=C)try{n.setSelectionRange(s,o),N=s,C=o;}catch(h){}g=!1;};k&&t.onFocus();var O=function(e){return e.selectionStart===0&&e.selectionEnd>=T.length&&e.value===T&&T&&e.selectionEnd!==C},M=function(e){if(g)return;v?v=!1:O(n)&&(t.selectAll(),A());},_=null;this.setInputHandler=function(e){_=e;},this.getInputHandler=function(){return _};var D=!1,P=function(e,r){D&&(D=!1);if(m)return A(),e&&t.onPaste(e),m=!1,"";var i=n.selectionStart,s=n.selectionEnd,o=N,u=T.length-C,a=e,f=e.length-i,l=e.length-s,c=0;while(o>0&&T[c]==e[c])c++,o--;a=a.slice(c),c=1;while(u>0&&T.length-c>N-1&&T[T.length-c]==e[e.length-c])c++,u--;return f-=c-1,l-=c-1,a=a.slice(0,a.length-c+1),!r&&f==a.length&&!o&&!u&&!l?"":(y=!0,a&&!o&&!u&&!f&&!l||S?t.onTextInput(a):t.onTextInput(a,{extendLeft:o,extendRight:u,restoreStart:f,restoreEnd:l}),y=!1,T=e,N=i,C=s,a)},H=function(e){if(g)return U();var t=n.value,r=P(t,!0);(t.length>l+100||d.test(r))&&A();},B=function(e,t,n){var r=e.clipboardData||window.clipboardData;if(!r||u)return;var i=a||n?"Text":"text/plain";try{return t?r.setData(i,t)!==!1:r.getData(i)}catch(e){if(!n)return B(e,t,!0)}},j=function(e,i){var s=t.getCopyText();if(!s)return r.preventDefault(e);B(e,s)?(p&&(A(s),v=s,setTimeout(function(){v=!1;},10)),i?t.onCut():t.onCopy(),r.preventDefault(e)):(v=!0,n.value=s,n.select(),setTimeout(function(){v=!1,A(),i?t.onCut():t.onCopy();}));},F=function(e){j(e,!0);},I=function(e){j(e,!1);},q=function(e){var s=B(e);typeof s=="string"?(s&&t.onPaste(s,e),i.isIE&&setTimeout(A),r.preventDefault(e)):(n.value="",m=!0);};r.addCommandKeyListener(n,t.onCommandKey.bind(t)),r.addListener(n,"select",M),r.addListener(n,"input",H),r.addListener(n,"cut",F),r.addListener(n,"copy",I),r.addListener(n,"paste",q),(!("oncut"in n)||!("oncopy"in n)||!("onpaste"in n))&&r.addListener(e,"keydown",function(e){if(i.isMac&&!e.metaKey||!e.ctrlKey)return;switch(e.keyCode){case 67:I(e);break;case 86:q(e);break;case 88:F(e);}});var R=function(e){if(g||!t.onCompositionStart||t.$readOnly)return;g={};if(S)return;setTimeout(U,0),t.on("mousedown",W);var r=t.getSelectionRange();r.end.row=r.start.row,r.end.column=r.start.column,g.markerRange=r,g.selectionStart=N,t.onCompositionStart(g),g.useTextareaForIME?(n.value="",T="",N=0,C=0):(n.msGetInputContext&&(g.context=n.msGetInputContext()),n.getInputContext&&(g.context=n.getInputContext()));},U=function(){if(!g||!t.onCompositionUpdate||t.$readOnly)return;if(S)return W();if(g.useTextareaForIME)t.onCompositionUpdate(n.value);else{var e=n.value;P(e),g.markerRange&&(g.context&&(g.markerRange.start.column=g.selectionStart=g.context.compositionStartOffset),g.markerRange.end.column=g.markerRange.start.column+C-g.selectionStart);}},z=function(e){if(!t.onCompositionEnd||t.$readOnly)return;g=!1,t.onCompositionEnd(),t.off("mousedown",W),e&&H();},X=o.delayedCall(U,50).schedule.bind(null,null);r.addListener(n,"compositionstart",R),r.addListener(n,"compositionupdate",U),r.addListener(n,"keyup",V),r.addListener(n,"keydown",X),r.addListener(n,"compositionend",z),this.getElement=function(){return n},this.setCommandMode=function(e){S=e,n.readOnly=!1;},this.setReadOnly=function(e){S||(n.readOnly=e);},this.setCopyWithEmptySelection=function(e){},this.onContextMenu=function(e){D=!0,A(),t._emit("nativecontextmenu",{target:t,domEvent:e}),this.moveToMouse(e,!0);},this.moveToMouse=function(e,o){b||(b=n.style.cssText),n.style.cssText=(o?"z-index:100000;":"")+(i.isIE?"opacity:0.1;":"")+"text-indent: -"+(N+C)*t.renderer.characterWidth*.5+"px;";var u=t.container.getBoundingClientRect(),a=s.computedStyle(t.container),f=u.top+(parseInt(a.borderTopWidth)||0),l=u.left+(parseInt(u.borderLeftWidth)||0),c=u.bottom-f-n.clientHeight-2,h=function(e){n.style.left=e.clientX-l-2+"px",n.style.top=Math.min(e.clientY-f-2,c)+"px";};h(e);if(e.type!="mousedown")return;t.renderer.$keepTextAreaAtCursor&&(t.renderer.$keepTextAreaAtCursor=null),clearTimeout($),i.isWin&&r.capture(t.container,h,J);},this.onContextMenuClose=J;var $,K=function(e){t.textInput.onContextMenu(e),J();};r.addListener(n,"mouseup",K),r.addListener(n,"mousedown",function(e){e.preventDefault(),J();}),r.addListener(t.renderer.scroller,"contextmenu",K),r.addListener(n,"contextmenu",K),p&&Q(e,t,n);};t.TextInput=v;}),define("ace/mouse/default_handlers",["require","exports","module","ace/lib/useragent"],function(e,t,n){function o(e){e.$clickSelection=null;var t=e.editor;t.setDefaultHandler("mousedown",this.onMouseDown.bind(e)),t.setDefaultHandler("dblclick",this.onDoubleClick.bind(e)),t.setDefaultHandler("tripleclick",this.onTripleClick.bind(e)),t.setDefaultHandler("quadclick",this.onQuadClick.bind(e)),t.setDefaultHandler("mousewheel",this.onMouseWheel.bind(e)),t.setDefaultHandler("touchmove",this.onTouchMove.bind(e));var n=["select","startSelect","selectEnd","selectAllEnd","selectByWordsEnd","selectByLinesEnd","dragWait","dragWaitEnd","focusWait"];n.forEach(function(t){e[t]=this[t];},this),e.selectByLines=this.extendSelectionBy.bind(e,"getLineRange"),e.selectByWords=this.extendSelectionBy.bind(e,"getWordRange");}function u(e,t,n,r){return Math.sqrt(Math.pow(n-e,2)+Math.pow(r-t,2))}function a(e,t){if(e.start.row==e.end.row)var n=2*t.column-e.start.column-e.end.column;else if(e.start.row==e.end.row-1&&!e.start.column&&!e.end.column)var n=t.column-4;else var n=2*t.row-e.start.row-e.end.row;return n<0?{cursor:e.start,anchor:e.end}:{cursor:e.end,anchor:e.start}}var r=e("../lib/useragent"),i=0,s=550;(function(){this.onMouseDown=function(e){var t=e.inSelection(),n=e.getDocumentPosition();this.mousedownEvent=e;var i=this.editor,s=e.getButton();if(s!==0){var o=i.getSelectionRange(),u=o.isEmpty();(u||s==1)&&i.selection.moveToPosition(n),s==2&&(i.textInput.onContextMenu(e.domEvent),r.isMozilla||e.preventDefault());return}this.mousedownEvent.time=Date.now();if(t&&!i.isFocused()){i.focus();if(this.$focusTimeout&&!this.$clickSelection&&!i.inMultiSelectMode){this.setState("focusWait"),this.captureMouse(e);return}}return this.captureMouse(e),this.startSelect(n,e.domEvent._clicks>1),e.preventDefault()},this.startSelect=function(e,t){e=e||this.editor.renderer.screenToTextCoordinates(this.x,this.y);var n=this.editor;if(!this.mousedownEvent)return;this.mousedownEvent.getShiftKey()?n.selection.selectToPosition(e):t||n.selection.moveToPosition(e),t||this.select(),n.renderer.scroller.setCapture&&n.renderer.scroller.setCapture(),n.setStyle("ace_selecting"),this.setState("select");},this.select=function(){var e,t=this.editor,n=t.renderer.screenToTextCoordinates(this.x,this.y);if(this.$clickSelection){var r=this.$clickSelection.comparePoint(n);if(r==-1)e=this.$clickSelection.end;else if(r==1)e=this.$clickSelection.start;else{var i=a(this.$clickSelection,n);n=i.cursor,e=i.anchor;}t.selection.setSelectionAnchor(e.row,e.column);}t.selection.selectToPosition(n),t.renderer.scrollCursorIntoView();},this.extendSelectionBy=function(e){var t,n=this.editor,r=n.renderer.screenToTextCoordinates(this.x,this.y),i=n.selection[e](r.row,r.column);if(this.$clickSelection){var s=this.$clickSelection.comparePoint(i.start),o=this.$clickSelection.comparePoint(i.end);if(s==-1&&o<=0){t=this.$clickSelection.end;if(i.end.row!=r.row||i.end.column!=r.column)r=i.start;}else if(o==1&&s>=0){t=this.$clickSelection.start;if(i.start.row!=r.row||i.start.column!=r.column)r=i.end;}else if(s==-1&&o==1)r=i.end,t=i.start;else{var u=a(this.$clickSelection,r);r=u.cursor,t=u.anchor;}n.selection.setSelectionAnchor(t.row,t.column);}n.selection.selectToPosition(r),n.renderer.scrollCursorIntoView();},this.selectEnd=this.selectAllEnd=this.selectByWordsEnd=this.selectByLinesEnd=function(){this.$clickSelection=null,this.editor.unsetStyle("ace_selecting"),this.editor.renderer.scroller.releaseCapture&&this.editor.renderer.scroller.releaseCapture();},this.focusWait=function(){var e=u(this.mousedownEvent.x,this.mousedownEvent.y,this.x,this.y),t=Date.now();(e>i||t-this.mousedownEvent.time>this.$focusTimeout)&&this.startSelect(this.mousedownEvent.getDocumentPosition());},this.onDoubleClick=function(e){var t=e.getDocumentPosition(),n=this.editor,r=n.session,i=r.getBracketRange(t);i?(i.isEmpty()&&(i.start.column--,i.end.column++),this.setState("select")):(i=n.selection.getWordRange(t.row,t.column),this.setState("selectByWords")),this.$clickSelection=i,this.select();},this.onTripleClick=function(e){var t=e.getDocumentPosition(),n=this.editor;this.setState("selectByLines");var r=n.getSelectionRange();r.isMultiLine()&&r.contains(t.row,t.column)?(this.$clickSelection=n.selection.getLineRange(r.start.row),this.$clickSelection.end=n.selection.getLineRange(r.end.row).end):this.$clickSelection=n.selection.getLineRange(t.row),this.select();},this.onQuadClick=function(e){var t=this.editor;t.selectAll(),this.$clickSelection=t.getSelectionRange(),this.setState("selectAll");},this.onMouseWheel=function(e){if(e.getAccelKey())return;e.getShiftKey()&&e.wheelY&&!e.wheelX&&(e.wheelX=e.wheelY,e.wheelY=0);var t=this.editor;this.$lastScroll||(this.$lastScroll={t:0,vx:0,vy:0,allowed:0});var n=this.$lastScroll,r=e.domEvent.timeStamp,i=r-n.t,o=i?e.wheelX/i:n.vx,u=i?e.wheelY/i:n.vy;i<s&&(o=(o+n.vx)/2,u=(u+n.vy)/2);var a=Math.abs(o/u),f=!1;a>=1&&t.renderer.isScrollableBy(e.wheelX*e.speed,0)&&(f=!0),a<=1&&t.renderer.isScrollableBy(0,e.wheelY*e.speed)&&(f=!0);if(f)n.allowed=r;else if(r-n.allowed<s){var l=Math.abs(o)<=1.5*Math.abs(n.vx)&&Math.abs(u)<=1.5*Math.abs(n.vy);l?(f=!0,n.allowed=r):n.allowed=0;}n.t=r,n.vx=o,n.vy=u;if(f)return t.renderer.scrollBy(e.wheelX*e.speed,e.wheelY*e.speed),e.stop()},this.onTouchMove=function(e){this.editor._emit("mousewheel",e);};}).call(o.prototype),t.DefaultHandlers=o;}),define("ace/tooltip",["require","exports","module","ace/lib/oop","ace/lib/dom"],function(e,t,n){function s(e){this.isOpen=!1,this.$element=null,this.$parentNode=e;}var r=e("./lib/oop"),i=e("./lib/dom");(function(){this.$init=function(){return this.$element=i.createElement("div"),this.$element.className="ace_tooltip",this.$element.style.display="none",this.$parentNode.appendChild(this.$element),this.$element},this.getElement=function(){return this.$element||this.$init()},this.setText=function(e){this.getElement().textContent=e;},this.setHtml=function(e){this.getElement().innerHTML=e;},this.setPosition=function(e,t){this.getElement().style.left=e+"px",this.getElement().style.top=t+"px";},this.setClassName=function(e){i.addCssClass(this.getElement(),e);},this.show=function(e,t,n){e!=null&&this.setText(e),t!=null&&n!=null&&this.setPosition(t,n),this.isOpen||(this.getElement().style.display="block",this.isOpen=!0);},this.hide=function(){this.isOpen&&(this.getElement().style.display="none",this.isOpen=!1);},this.getHeight=function(){return this.getElement().offsetHeight},this.getWidth=function(){return this.getElement().offsetWidth},this.destroy=function(){this.isOpen=!1,this.$element&&this.$element.parentNode&&this.$element.parentNode.removeChild(this.$element);};}).call(s.prototype),t.Tooltip=s;}),define("ace/mouse/default_gutter_handler",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event","ace/tooltip"],function(e,t,n){function u(e){function l(){var r=u.getDocumentPosition().row,s=n.$annotations[r];if(!s)return c();var o=t.session.getLength();if(r==o){var a=t.renderer.pixelToScreenCoordinates(0,u.y).row,l=u.$pos;if(a>t.session.documentToScreenRow(l.row,l.column))return c()}if(f==s)return;f=s.text.join("<br/>"),i.setHtml(f),i.show(),t._signal("showGutterTooltip",i),t.on("mousewheel",c);if(e.$tooltipFollowsMouse)h(u);else{var p=u.domEvent.target,d=p.getBoundingClientRect(),v=i.getElement().style;v.left=d.right+"px",v.top=d.bottom+"px";}}function c(){o&&(o=clearTimeout(o)),f&&(i.hide(),f=null,t._signal("hideGutterTooltip",i),t.removeEventListener("mousewheel",c));}function h(e){i.setPosition(e.x,e.y);}var t=e.editor,n=t.renderer.$gutterLayer,i=new a(t.container);e.editor.setDefaultHandler("guttermousedown",function(r){if(!t.isFocused()||r.getButton()!=0)return;var i=n.getRegion(r);if(i=="foldWidgets")return;var s=r.getDocumentPosition().row,o=t.session.selection;if(r.getShiftKey())o.selectTo(s,0);else{if(r.domEvent.detail==2)return t.selectAll(),r.preventDefault();e.$clickSelection=t.selection.getLineRange(s);}return e.setState("selectByLines"),e.captureMouse(r),r.preventDefault()});var o,u,f;e.editor.setDefaultHandler("guttermousemove",function(t){var n=t.domEvent.target||t.domEvent.srcElement;if(r.hasCssClass(n,"ace_fold-widget"))return c();f&&e.$tooltipFollowsMouse&&h(t),u=t;if(o)return;o=setTimeout(function(){o=null,u&&!e.isMousePressed?l():c();},50);}),s.addListener(t.renderer.$gutter,"mouseout",function(e){u=null;if(!f||o)return;o=setTimeout(function(){o=null,c();},50);}),t.on("changeSession",c);}function a(e){o.call(this,e);}var r=e("../lib/dom"),i=e("../lib/oop"),s=e("../lib/event"),o=e("../tooltip").Tooltip;i.inherits(a,o),function(){this.setPosition=function(e,t){var n=window.innerWidth||document.documentElement.clientWidth,r=window.innerHeight||document.documentElement.clientHeight,i=this.getWidth(),s=this.getHeight();e+=15,t+=15,e+i>n&&(e-=e+i-n),t+s>r&&(t-=20+s),o.prototype.setPosition.call(this,e,t);};}.call(a.prototype),t.GutterHandler=u;}),define("ace/mouse/mouse_event",["require","exports","module","ace/lib/event","ace/lib/useragent"],function(e,t,n){var r=e("../lib/event"),i=e("../lib/useragent"),s=t.MouseEvent=function(e,t){this.domEvent=e,this.editor=t,this.x=this.clientX=e.clientX,this.y=this.clientY=e.clientY,this.$pos=null,this.$inSelection=null,this.propagationStopped=!1,this.defaultPrevented=!1;};(function(){this.stopPropagation=function(){r.stopPropagation(this.domEvent),this.propagationStopped=!0;},this.preventDefault=function(){r.preventDefault(this.domEvent),this.defaultPrevented=!0;},this.stop=function(){this.stopPropagation(),this.preventDefault();},this.getDocumentPosition=function(){return this.$pos?this.$pos:(this.$pos=this.editor.renderer.screenToTextCoordinates(this.clientX,this.clientY),this.$pos)},this.inSelection=function(){if(this.$inSelection!==null)return this.$inSelection;var e=this.editor,t=e.getSelectionRange();if(t.isEmpty())this.$inSelection=!1;else{var n=this.getDocumentPosition();this.$inSelection=t.contains(n.row,n.column);}return this.$inSelection},this.getButton=function(){return r.getButton(this.domEvent)},this.getShiftKey=function(){return this.domEvent.shiftKey},this.getAccelKey=i.isMac?function(){return this.domEvent.metaKey}:function(){return this.domEvent.ctrlKey};}).call(s.prototype);}),define("ace/mouse/dragdrop_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"],function(e,t,n){function f(e){function T(e,n){var r=Date.now(),i=!n||e.row!=n.row,s=!n||e.column!=n.column;if(!S||i||s)t.moveCursorToPosition(e),S=r,x={x:p,y:d};else{var o=l(x.x,x.y,p,d);o>a?S=null:r-S>=u&&(t.renderer.scrollCursorIntoView(),S=null);}}function N(e,n){var r=Date.now(),i=t.renderer.layerConfig.lineHeight,s=t.renderer.layerConfig.characterWidth,u=t.renderer.scroller.getBoundingClientRect(),a={x:{left:p-u.left,right:u.right-p},y:{top:d-u.top,bottom:u.bottom-d}},f=Math.min(a.x.left,a.x.right),l=Math.min(a.y.top,a.y.bottom),c={row:e.row,column:e.column};f/s<=2&&(c.column+=a.x.left<a.x.right?-3:2),l/i<=1&&(c.row+=a.y.top<a.y.bottom?-1:1);var h=e.row!=c.row,v=e.column!=c.column,m=!n||e.row!=n.row;h||v&&!m?E?r-E>=o&&t.renderer.scrollCursorIntoView(c):E=r:E=null;}function C(){var e=g;g=t.renderer.screenToTextCoordinates(p,d),T(g,e),N(g,e);}function k(){m=t.selection.toOrientedRange(),h=t.session.addMarker(m,"ace_selection",t.getSelectionStyle()),t.clearSelection(),t.isFocused()&&t.renderer.$cursorLayer.setBlinking(!1),clearInterval(v),C(),v=setInterval(C,20),y=0,i.addListener(document,"mousemove",O);}function L(){clearInterval(v),t.session.removeMarker(h),h=null,t.selection.fromOrientedRange(m),t.isFocused()&&!w&&t.renderer.$cursorLayer.setBlinking(!t.getReadOnly()),m=null,g=null,y=0,E=null,S=null,i.removeListener(document,"mousemove",O);}function O(){A==null&&(A=setTimeout(function(){A!=null&&h&&L();},20));}function M(e){var t=e.types;return !t||Array.prototype.some.call(t,function(e){return e=="text/plain"||e=="Text"})}function _(e){var t=["copy","copymove","all","uninitialized"],n=["move","copymove","linkmove","all","uninitialized"],r=s.isMac?e.altKey:e.ctrlKey,i="uninitialized";try{i=e.dataTransfer.effectAllowed.toLowerCase();}catch(e){}var o="none";return r&&t.indexOf(i)>=0?o="copy":n.indexOf(i)>=0?o="move":t.indexOf(i)>=0&&(o="copy"),o}var t=e.editor,n=r.createElement("img");n.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",s.isOpera&&(n.style.cssText="width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;");var f=["dragWait","dragWaitEnd","startDrag","dragReadyEnd","onMouseDrag"];f.forEach(function(t){e[t]=this[t];},this),t.addEventListener("mousedown",this.onMouseDown.bind(e));var c=t.container,h,p,d,v,m,g,y=0,b,w,E,S,x;this.onDragStart=function(e){if(this.cancelDrag||!c.draggable){var r=this;return setTimeout(function(){r.startSelect(),r.captureMouse(e);},0),e.preventDefault()}m=t.getSelectionRange();var i=e.dataTransfer;i.effectAllowed=t.getReadOnly()?"copy":"copyMove",s.isOpera&&(t.container.appendChild(n),n.scrollTop=0),i.setDragImage&&i.setDragImage(n,0,0),s.isOpera&&t.container.removeChild(n),i.clearData(),i.setData("Text",t.session.getTextRange()),w=!0,this.setState("drag");},this.onDragEnd=function(e){c.draggable=!1,w=!1,this.setState(null);if(!t.getReadOnly()){var n=e.dataTransfer.dropEffect;!b&&n=="move"&&t.session.remove(t.getSelectionRange()),t.renderer.$cursorLayer.setBlinking(!0);}this.editor.unsetStyle("ace_dragging"),this.editor.renderer.setCursorStyle("");},this.onDragEnter=function(e){if(t.getReadOnly()||!M(e.dataTransfer))return;return p=e.clientX,d=e.clientY,h||k(),y++,e.dataTransfer.dropEffect=b=_(e),i.preventDefault(e)},this.onDragOver=function(e){if(t.getReadOnly()||!M(e.dataTransfer))return;return p=e.clientX,d=e.clientY,h||(k(),y++),A!==null&&(A=null),e.dataTransfer.dropEffect=b=_(e),i.preventDefault(e)},this.onDragLeave=function(e){y--;if(y<=0&&h)return L(),b=null,i.preventDefault(e)},this.onDrop=function(e){if(!g)return;var n=e.dataTransfer;if(w)switch(b){case"move":m.contains(g.row,g.column)?m={start:g,end:g}:m=t.moveText(m,g);break;case"copy":m=t.moveText(m,g,!0);}else{var r=n.getData("Text");m={start:g,end:t.session.insert(g,r)},t.focus(),b=null;}return L(),i.preventDefault(e)},i.addListener(c,"dragstart",this.onDragStart.bind(e)),i.addListener(c,"dragend",this.onDragEnd.bind(e)),i.addListener(c,"dragenter",this.onDragEnter.bind(e)),i.addListener(c,"dragover",this.onDragOver.bind(e)),i.addListener(c,"dragleave",this.onDragLeave.bind(e)),i.addListener(c,"drop",this.onDrop.bind(e));var A=null;}function l(e,t,n,r){return Math.sqrt(Math.pow(n-e,2)+Math.pow(r-t,2))}var r=e("../lib/dom"),i=e("../lib/event"),s=e("../lib/useragent"),o=200,u=200,a=5;(function(){this.dragWait=function(){var e=Date.now()-this.mousedownEvent.time;e>this.editor.getDragDelay()&&this.startDrag();},this.dragWaitEnd=function(){var e=this.editor.container;e.draggable=!1,this.startSelect(this.mousedownEvent.getDocumentPosition()),this.selectEnd();},this.dragReadyEnd=function(e){this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly()),this.editor.unsetStyle("ace_dragging"),this.editor.renderer.setCursorStyle(""),this.dragWaitEnd();},this.startDrag=function(){this.cancelDrag=!1;var e=this.editor,t=e.container;t.draggable=!0,e.renderer.$cursorLayer.setBlinking(!1),e.setStyle("ace_dragging");var n=s.isWin?"default":"move";e.renderer.setCursorStyle(n),this.setState("dragReady");},this.onMouseDrag=function(e){var t=this.editor.container;if(s.isIE&&this.state=="dragReady"){var n=l(this.mousedownEvent.x,this.mousedownEvent.y,this.x,this.y);n>3&&t.dragDrop();}if(this.state==="dragWait"){var n=l(this.mousedownEvent.x,this.mousedownEvent.y,this.x,this.y);n>0&&(t.draggable=!1,this.startSelect(this.mousedownEvent.getDocumentPosition()));}},this.onMouseDown=function(e){if(!this.$dragEnabled)return;this.mousedownEvent=e;var t=this.editor,n=e.inSelection(),r=e.getButton(),i=e.domEvent.detail||1;if(i===1&&r===0&&n){if(e.editor.inMultiSelectMode&&(e.getAccelKey()||e.getShiftKey()))return;this.mousedownEvent.time=Date.now();var o=e.domEvent.target||e.domEvent.srcElement;"unselectable"in o&&(o.unselectable="on");if(t.getDragDelay()){if(s.isWebKit){this.cancelDrag=!0;var u=t.container;u.draggable=!0;}this.setState("dragWait");}else this.startDrag();this.captureMouse(e,this.onMouseDrag.bind(this)),e.defaultPrevented=!0;}};}).call(f.prototype),t.DragdropHandler=f;}),define("ace/lib/net",["require","exports","module","ace/lib/dom"],function(e,t,n){var r=e("./dom");t.get=function(e,t){var n=new XMLHttpRequest;n.open("GET",e,!0),n.onreadystatechange=function(){n.readyState===4&&t(n.responseText);},n.send(null);},t.loadScript=function(e,t){var n=r.getDocumentHead(),i=document.createElement("script");i.src=e,n.appendChild(i),i.onload=i.onreadystatechange=function(e,n){if(n||!i.readyState||i.readyState=="loaded"||i.readyState=="complete")i=i.onload=i.onreadystatechange=null,n||t();};},t.qualifyURL=function(e){var t=document.createElement("a");return t.href=e,t.href};}),define("ace/lib/event_emitter",["require","exports","module"],function(e,t,n){var r={},i=function(){this.propagationStopped=!0;},s=function(){this.defaultPrevented=!0;};r._emit=r._dispatchEvent=function(e,t){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var n=this._eventRegistry[e]||[],r=this._defaultHandlers[e];if(!n.length&&!r)return;if(typeof t!="object"||!t)t={};t.type||(t.type=e),t.stopPropagation||(t.stopPropagation=i),t.preventDefault||(t.preventDefault=s),n=n.slice();for(var o=0;o<n.length;o++){n[o](t,this);if(t.propagationStopped)break}if(r&&!t.defaultPrevented)return r(t,this)},r._signal=function(e,t){var n=(this._eventRegistry||{})[e];if(!n)return;n=n.slice();for(var r=0;r<n.length;r++)n[r](t,this);},r.once=function(e,t){var n=this;this.addEventListener(e,function r(){n.removeEventListener(e,r),t.apply(null,arguments);});if(!t)return new Promise(function(e){t=e;})},r.setDefaultHandler=function(e,t){var n=this._defaultHandlers;n||(n=this._defaultHandlers={_disabled_:{}});if(n[e]){var r=n[e],i=n._disabled_[e];i||(n._disabled_[e]=i=[]),i.push(r);var s=i.indexOf(t);s!=-1&&i.splice(s,1);}n[e]=t;},r.removeDefaultHandler=function(e,t){var n=this._defaultHandlers;if(!n)return;var r=n._disabled_[e];if(n[e]==t)r&&this.setDefaultHandler(e,r.pop());else if(r){var i=r.indexOf(t);i!=-1&&r.splice(i,1);}},r.on=r.addEventListener=function(e,t,n){this._eventRegistry=this._eventRegistry||{};var r=this._eventRegistry[e];return r||(r=this._eventRegistry[e]=[]),r.indexOf(t)==-1&&r[n?"unshift":"push"](t),t},r.off=r.removeListener=r.removeEventListener=function(e,t){this._eventRegistry=this._eventRegistry||{};var n=this._eventRegistry[e];if(!n)return;var r=n.indexOf(t);r!==-1&&n.splice(r,1);},r.removeAllListeners=function(e){this._eventRegistry&&(this._eventRegistry[e]=[]);},t.EventEmitter=r;}),define("ace/lib/app_config",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"],function(e,t,n){"no use strict";function o(e){typeof console!="undefined"&&console.warn&&console.warn.apply(console,arguments);}function u(e,t){var n=new Error(e);n.data=t,typeof console=="object"&&console.error&&console.error(n),setTimeout(function(){throw n});}var r=e("./oop"),i=e("./event_emitter").EventEmitter,s={setOptions:function(e){Object.keys(e).forEach(function(t){this.setOption(t,e[t]);},this);},getOptions:function(e){var t={};if(!e){var n=this.$options;e=Object.keys(n).filter(function(e){return !n[e].hidden});}else Array.isArray(e)||(t=e,e=Object.keys(t));return e.forEach(function(e){t[e]=this.getOption(e);},this),t},setOption:function(e,t){if(this["$"+e]===t)return;var n=this.$options[e];if(!n)return o('misspelled option "'+e+'"');if(n.forwardTo)return this[n.forwardTo]&&this[n.forwardTo].setOption(e,t);n.handlesSet||(this["$"+e]=t),n&&n.set&&n.set.call(this,t);},getOption:function(e){var t=this.$options[e];return t?t.forwardTo?this[t.forwardTo]&&this[t.forwardTo].getOption(e):t&&t.get?t.get.call(this):this["$"+e]:o('misspelled option "'+e+'"')}},a=function(){this.$defaultOptions={};};(function(){r.implement(this,i),this.defineOptions=function(e,t,n){return e.$options||(this.$defaultOptions[t]=e.$options={}),Object.keys(n).forEach(function(t){var r=n[t];typeof r=="string"&&(r={forwardTo:r}),r.name||(r.name=t),e.$options[r.name]=r,"initialValue"in r&&(e["$"+r.name]=r.initialValue);}),r.implement(e,s),this},this.resetOptions=function(e){Object.keys(e.$options).forEach(function(t){var n=e.$options[t];"value"in n&&e.setOption(t,n.value);});},this.setDefaultValue=function(e,t,n){var r=this.$defaultOptions[e]||(this.$defaultOptions[e]={});r[t]&&(r.forwardTo?this.setDefaultValue(r.forwardTo,t,n):r[t].value=n);},this.setDefaultValues=function(e,t){Object.keys(t).forEach(function(n){this.setDefaultValue(e,n,t[n]);},this);},this.warn=o,this.reportError=u;}).call(a.prototype),t.AppConfig=a;}),define("ace/config",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/lib/net","ace/lib/app_config"],function(e,t,n){"no use strict";function l(r){if(!u||!u.document)return;a.packaged=r||e.packaged||n.packaged||u.define&&define.packaged;var i={},s="",o=document.currentScript||document._currentScript,f=o&&o.ownerDocument||document,l=f.getElementsByTagName("script");for(var h=0;h<l.length;h++){var p=l[h],d=p.src||p.getAttribute("src");if(!d)continue;var v=p.attributes;for(var m=0,g=v.length;m<g;m++){var y=v[m];y.name.indexOf("data-ace-")===0&&(i[c(y.name.replace(/^data-ace-/,""))]=y.value);}var b=d.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);b&&(s=b[1]);}s&&(i.base=i.base||s,i.packaged=!0),i.basePath=i.base,i.workerPath=i.workerPath||i.base,i.modePath=i.modePath||i.base,i.themePath=i.themePath||i.base,delete i.base;for(var w in i)typeof i[w]!="undefined"&&t.set(w,i[w]);}function c(e){return e.replace(/-(.)/g,function(e,t){return t.toUpperCase()})}var r=e("./lib/lang"),i=e("./lib/oop"),s=e("./lib/net"),o=e("./lib/app_config").AppConfig;n.exports=t=new o;var u=function(){return this||typeof window!="undefined"&&window}(),a={packaged:!1,workerPath:null,modePath:null,themePath:null,basePath:"",suffix:".js",$moduleUrls:{},loadWorkerFromBlob:!0};t.get=function(e){if(!a.hasOwnProperty(e))throw new Error("Unknown config key: "+e);return a[e]},t.set=function(e,t){if(!a.hasOwnProperty(e))throw new Error("Unknown config key: "+e);a[e]=t;},t.all=function(){return r.copyObject(a)},t.$modes={},t.moduleUrl=function(e,t){if(a.$moduleUrls[e])return a.$moduleUrls[e];var n=e.split("/");t=t||n[n.length-2]||"";var r=t=="snippets"?"/":"-",i=n[n.length-1];if(t=="worker"&&r=="-"){var s=new RegExp("^"+t+"[\\-_]|[\\-_]"+t+"$","g");i=i.replace(s,"");}(!i||i==t)&&n.length>1&&(i=n[n.length-2]);var o=a[t+"Path"];return o==null?o=a.basePath:r=="/"&&(t=r=""),o&&o.slice(-1)!="/"&&(o+="/"),o+t+r+i+this.get("suffix")},t.setModuleUrl=function(e,t){return a.$moduleUrls[e]=t},t.$loading={},t.loadModule=function(n,r){var i,o;Array.isArray(n)&&(o=n[0],n=n[1]);try{i=e(n);}catch(u){}if(i&&!t.$loading[n])return r&&r(i);t.$loading[n]||(t.$loading[n]=[]),t.$loading[n].push(r);if(t.$loading[n].length>1)return;var a=function(){e([n],function(e){t._emit("load.module",{name:n,module:e});var r=t.$loading[n];t.$loading[n]=null,r.forEach(function(t){t&&t(e);});});};if(!t.get("packaged"))return a();s.loadScript(t.moduleUrl(n,o),a),f();};var f=function(){!a.basePath&&!a.workerPath&&!a.modePath&&!a.themePath&&!Object.keys(a.$moduleUrls).length&&(console.error("Unable to infer path to ace from script src,","use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes","or with webpack use ace/webpack-resolver"),f=function(){});};t.init=l;}),define("ace/mouse/mouse_handler",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/mouse/default_handlers","ace/mouse/default_gutter_handler","ace/mouse/mouse_event","ace/mouse/dragdrop_handler","ace/config"],function(e,t,n){var r=e("../lib/event"),i=e("../lib/useragent"),s=e("./default_handlers").DefaultHandlers,o=e("./default_gutter_handler").GutterHandler,u=e("./mouse_event").MouseEvent,a=e("./dragdrop_handler").DragdropHandler,f=e("../config"),l=function(e){var t=this;this.editor=e,new s(this),new o(this),new a(this);var n=function(t){var n=!document.hasFocus||!document.hasFocus()||!e.isFocused()&&document.activeElement==(e.textInput&&e.textInput.getElement());n&&window.focus(),e.focus();},u=e.renderer.getMouseEventTarget();r.addListener(u,"click",this.onMouseEvent.bind(this,"click")),r.addListener(u,"mousemove",this.onMouseMove.bind(this,"mousemove")),r.addMultiMouseDownListener([u,e.renderer.scrollBarV&&e.renderer.scrollBarV.inner,e.renderer.scrollBarH&&e.renderer.scrollBarH.inner,e.textInput&&e.textInput.getElement()].filter(Boolean),[400,300,250],this,"onMouseEvent"),r.addMouseWheelListener(e.container,this.onMouseWheel.bind(this,"mousewheel")),r.addTouchMoveListener(e.container,this.onTouchMove.bind(this,"touchmove"));var f=e.renderer.$gutter;r.addListener(f,"mousedown",this.onMouseEvent.bind(this,"guttermousedown")),r.addListener(f,"click",this.onMouseEvent.bind(this,"gutterclick")),r.addListener(f,"dblclick",this.onMouseEvent.bind(this,"gutterdblclick")),r.addListener(f,"mousemove",this.onMouseEvent.bind(this,"guttermousemove")),r.addListener(u,"mousedown",n),r.addListener(f,"mousedown",n),i.isIE&&e.renderer.scrollBarV&&(r.addListener(e.renderer.scrollBarV.element,"mousedown",n),r.addListener(e.renderer.scrollBarH.element,"mousedown",n)),e.on("mousemove",function(n){if(t.state||t.$dragDelay||!t.$dragEnabled)return;var r=e.renderer.screenToTextCoordinates(n.x,n.y),i=e.session.selection.getRange(),s=e.renderer;!i.isEmpty()&&i.insideStart(r.row,r.column)?s.setCursorStyle("default"):s.setCursorStyle("");});};(function(){this.onMouseEvent=function(e,t){this.editor._emit(e,new u(t,this.editor));},this.onMouseMove=function(e,t){var n=this.editor._eventRegistry&&this.editor._eventRegistry.mousemove;if(!n||!n.length)return;this.editor._emit(e,new u(t,this.editor));},this.onMouseWheel=function(e,t){var n=new u(t,this.editor);n.speed=this.$scrollSpeed*2,n.wheelX=t.wheelX,n.wheelY=t.wheelY,this.editor._emit(e,n);},this.onTouchMove=function(e,t){var n=new u(t,this.editor);n.speed=1,n.wheelX=t.wheelX,n.wheelY=t.wheelY,this.editor._emit(e,n);},this.setState=function(e){this.state=e;},this.captureMouse=function(e,t){this.x=e.x,this.y=e.y,this.isMousePressed=!0;var n=this.editor,s=this.editor.renderer;s.$keepTextAreaAtCursor&&(s.$keepTextAreaAtCursor=null);var o=this,a=function(e){if(!e)return;if(i.isWebKit&&!e.which&&o.releaseMouse)return o.releaseMouse();o.x=e.clientX,o.y=e.clientY,t&&t(e),o.mouseEvent=new u(e,o.editor),o.$mouseMoved=!0;},f=function(e){n.off("beforeEndOperation",c),clearInterval(h),l(),o[o.state+"End"]&&o[o.state+"End"](e),o.state="",s.$keepTextAreaAtCursor==null&&(s.$keepTextAreaAtCursor=!0,s.$moveTextAreaToCursor()),o.isMousePressed=!1,o.$onCaptureMouseMove=o.releaseMouse=null,e&&o.onMouseEvent("mouseup",e),n.endOperation();},l=function(){o[o.state]&&o[o.state](),o.$mouseMoved=!1;};if(i.isOldIE&&e.domEvent.type=="dblclick")return setTimeout(function(){f(e);});var c=function(e){if(!o.releaseMouse)return;n.curOp.command.name&&n.curOp.selectionChanged&&(o[o.state+"End"]&&o[o.state+"End"](),o.state="",o.releaseMouse());};n.on("beforeEndOperation",c),n.startOperation({command:{name:"mouse"}}),o.$onCaptureMouseMove=a,o.releaseMouse=r.capture(this.editor.container,a,f);var h=setInterval(l,20);},this.releaseMouse=null,this.cancelContextMenu=function(){var e=function(t){if(t&&t.domEvent&&t.domEvent.type!="contextmenu")return;this.editor.off("nativecontextmenu",e),t&&t.domEvent&&r.stopEvent(t.domEvent);}.bind(this);setTimeout(e,10),this.editor.on("nativecontextmenu",e);};}).call(l.prototype),f.defineOptions(l.prototype,"mouseHandler",{scrollSpeed:{initialValue:2},dragDelay:{initialValue:i.isMac?150:0},dragEnabled:{initialValue:!0},focusTimeout:{initialValue:0},tooltipFollowsMouse:{initialValue:!0}}),t.MouseHandler=l;}),define("ace/mouse/fold_handler",["require","exports","module","ace/lib/dom"],function(e,t,n){function i(e){e.on("click",function(t){var n=t.getDocumentPosition(),i=e.session,s=i.getFoldAt(n.row,n.column,1);s&&(t.getAccelKey()?i.removeFold(s):i.expandFold(s),t.stop());var o=t.domEvent&&t.domEvent.target;o&&r.hasCssClass(o,"ace_inline_button")&&r.hasCssClass(o,"ace_toggle_wrap")&&(i.setOption("wrap",!0),e.renderer.scrollCursorIntoView());}),e.on("gutterclick",function(t){var n=e.renderer.$gutterLayer.getRegion(t);if(n=="foldWidgets"){var r=t.getDocumentPosition().row,i=e.session;i.foldWidgets&&i.foldWidgets[r]&&e.session.onFoldWidgetClick(r,t),e.isFocused()||e.focus(),t.stop();}}),e.on("gutterdblclick",function(t){var n=e.renderer.$gutterLayer.getRegion(t);if(n=="foldWidgets"){var r=t.getDocumentPosition().row,i=e.session,s=i.getParentFoldRangeData(r,!0),o=s.range||s.firstRange;if(o){r=o.start.row;var u=i.getFoldAt(r,i.getLine(r).length,1);u?i.removeFold(u):(i.addFold("...",o),e.renderer.scrollCursorIntoView({row:o.start.row,column:0}));}t.stop();}});}var r=e("../lib/dom");t.FoldHandler=i;}),define("ace/keyboard/keybinding",["require","exports","module","ace/lib/keys","ace/lib/event"],function(e,t,n){var r=e("../lib/keys"),i=e("../lib/event"),s=function(e){this.$editor=e,this.$data={editor:e},this.$handlers=[],this.setDefaultHandler(e.commands);};(function(){this.setDefaultHandler=function(e){this.removeKeyboardHandler(this.$defaultHandler),this.$defaultHandler=e,this.addKeyboardHandler(e,0);},this.setKeyboardHandler=function(e){var t=this.$handlers;if(t[t.length-1]==e)return;while(t[t.length-1]&&t[t.length-1]!=this.$defaultHandler)this.removeKeyboardHandler(t[t.length-1]);this.addKeyboardHandler(e,1);},this.addKeyboardHandler=function(e,t){if(!e)return;typeof e=="function"&&!e.handleKeyboard&&(e.handleKeyboard=e);var n=this.$handlers.indexOf(e);n!=-1&&this.$handlers.splice(n,1),t==undefined?this.$handlers.push(e):this.$handlers.splice(t,0,e),n==-1&&e.attach&&e.attach(this.$editor);},this.removeKeyboardHandler=function(e){var t=this.$handlers.indexOf(e);return t==-1?!1:(this.$handlers.splice(t,1),e.detach&&e.detach(this.$editor),!0)},this.getKeyboardHandler=function(){return this.$handlers[this.$handlers.length-1]},this.getStatusText=function(){var e=this.$data,t=e.editor;return this.$handlers.map(function(n){return n.getStatusText&&n.getStatusText(t,e)||""}).filter(Boolean).join(" ")},this.$callKeyboardHandlers=function(e,t,n,r){var s,o=!1,u=this.$editor.commands;for(var a=this.$handlers.length;a--;){s=this.$handlers[a].handleKeyboard(this.$data,e,t,n,r);if(!s||!s.command)continue;s.command=="null"?o=!0:o=u.exec(s.command,this.$editor,s.args,r),o&&r&&e!=-1&&s.passEvent!=1&&s.command.passEvent!=1&&i.stopEvent(r);if(o)break}return !o&&e==-1&&(s={command:"insertstring"},o=u.exec("insertstring",this.$editor,t)),o&&this.$editor._signal&&this.$editor._signal("keyboardActivity",s),o},this.onCommandKey=function(e,t,n){var i=r.keyCodeToString(n);this.$callKeyboardHandlers(t,i,n,e);},this.onTextInput=function(e){this.$callKeyboardHandlers(-1,e);};}).call(s.prototype),t.KeyBinding=s;}),define("ace/lib/bidiutil",["require","exports","module"],function(e,t,n){function F(e,t,n,r){var i=s?d:p,c=null,h=null,v=null,m=0,g=null,y=null,b=-1,w=null,E=null,T=[];if(!r)for(w=0,r=[];w<n;w++)r[w]=R(e[w]);o=s,u=!1,f=!1,l=!1;for(E=0;E<n;E++){c=m,T[E]=h=q(e,r,T,E),m=i[c][h],g=m&240,m&=15,t[E]=v=i[m][5];if(g>0)if(g==16){for(w=b;w<E;w++)t[w]=1;b=-1;}else b=-1;y=i[m][6];if(y)b==-1&&(b=E);else if(b>-1){for(w=b;w<E;w++)t[w]=v;b=-1;}r[E]==S&&(t[E]=0),o|=v;}if(l)for(w=0;w<n;w++)if(r[w]==x){t[w]=s;for(var C=w-1;C>=0;C--){if(r[C]!=N)break;t[C]=s;}}}function I(e,t,n){if(o<e)return;if(e==1&&s==m&&!f){n.reverse();return}var r=n.length,i=0,u,a,l,c;while(i<r){if(t[i]>=e){u=i+1;while(u<r&&t[u]>=e)u++;for(a=i,l=u-1;a<l;a++,l--)c=n[a],n[a]=n[l],n[l]=c;i=u;}i++;}}function q(e,t,n,r){var i=t[r],o,c,h,p;switch(i){case g:case y:u=!1;case E:case w:return i;case b:return u?w:b;case T:return u=!0,y;case N:return E;case C:if(r<1||r+1>=t.length||(o=n[r-1])!=b&&o!=w||(c=t[r+1])!=b&&c!=w)return E;return u&&(c=w),c==o?c:E;case k:o=r>0?n[r-1]:S;if(o==b&&r+1<t.length&&t[r+1]==b)return b;return E;case L:if(r>0&&n[r-1]==b)return b;if(u)return E;p=r+1,h=t.length;while(p<h&&t[p]==L)p++;if(p<h&&t[p]==b)return b;return E;case A:h=t.length,p=r+1;while(p<h&&t[p]==A)p++;if(p<h){var d=e[r],v=d>=1425&&d<=2303||d==64286;o=t[p];if(v&&(o==y||o==T))return y}if(r<1||(o=t[r-1])==S)return E;return n[r-1];case S:return u=!1,f=!0,s;case x:return l=!0,E;case O:case M:case D:case P:case _:u=!1;case H:return E}}function R(e){var t=e.charCodeAt(0),n=t>>8;return n==0?t>191?g:B[t]:n==5?/[\u0591-\u05f4]/.test(e)?y:g:n==6?/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(e)?A:/[\u0660-\u0669\u066b-\u066c]/.test(e)?w:t==1642?L:/[\u06f0-\u06f9]/.test(e)?b:T:n==32&&t<=8287?j[t&255]:n==254?t>=65136?T:E:E}var s=0,o=0,u=!1,f=!1,l=!1,p=[[0,3,0,1,0,0,0],[0,3,0,1,2,2,0],[0,3,0,17,2,0,1],[0,3,5,5,4,1,0],[0,3,21,21,4,0,1],[0,3,5,5,4,2,0]],d=[[2,0,1,1,0,1,0],[2,0,1,1,0,2,0],[2,0,2,1,3,2,0],[2,0,2,33,3,1,1]],v=0,m=1,g=0,y=1,b=2,w=3,E=4,S=5,x=6,T=7,N=8,C=9,k=10,L=11,A=12,O=13,M=14,_=15,D=16,P=17,H=18,B=[H,H,H,H,H,H,H,H,H,x,S,x,N,S,H,H,H,H,H,H,H,H,H,H,H,H,H,H,S,S,S,x,N,E,E,L,L,L,E,E,E,E,E,k,C,k,C,C,b,b,b,b,b,b,b,b,b,b,C,E,E,E,E,E,E,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,E,E,E,E,E,E,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,E,E,E,E,H,H,H,H,H,H,S,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,C,E,L,L,L,L,E,E,E,E,g,E,E,H,E,E,L,L,b,b,E,g,E,E,E,b,g,E,E,E,E,E],j=[N,N,N,N,N,N,N,N,N,N,N,H,H,H,g,y,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,N,S,O,M,_,D,P,C,L,L,L,L,L,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,C,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,N];t.L=g,t.R=y,t.EN=b,t.ON_R=3,t.AN=4,t.R_H=5,t.B=6,t.RLE=7,t.DOT="\u00b7",t.doBidiReorder=function(e,n,r){if(e.length<2)return {};var i=e.split(""),o=new Array(i.length),u=new Array(i.length),a=[];s=r?m:v,F(i,a,i.length,n);for(var f=0;f<o.length;o[f]=f,f++);I(2,a,o),I(1,a,o);for(var f=0;f<o.length-1;f++)n[f]===w?a[f]=t.AN:a[f]===y&&(n[f]>T&&n[f]<O||n[f]===E||n[f]===H)?a[f]=t.ON_R:f>0&&i[f-1]==="\u0644"&&/\u0622|\u0623|\u0625|\u0627/.test(i[f])&&(a[f-1]=a[f]=t.R_H,f++);i[i.length-1]===t.DOT&&(a[i.length-1]=t.B),i[0]==="\u202b"&&(a[0]=t.RLE);for(var f=0;f<o.length;f++)u[f]=a[o[f]];return {logicalFromVisual:o,bidiLevels:u}},t.hasBidiCharacters=function(e,t){var n=!1;for(var r=0;r<e.length;r++)t[r]=R(e.charAt(r)),!n&&(t[r]==y||t[r]==T||t[r]==w)&&(n=!0);return n},t.getVisualFromLogicalIdx=function(e,t){for(var n=0;n<t.logicalFromVisual.length;n++)if(t.logicalFromVisual[n]==e)return n;return 0};}),define("ace/bidihandler",["require","exports","module","ace/lib/bidiutil","ace/lib/lang"],function(e,t,n){var r=e("./lib/bidiutil"),i=e("./lib/lang"),s=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/,o=function(e){this.session=e,this.bidiMap={},this.currentRow=null,this.bidiUtil=r,this.charWidths=[],this.EOL="\u00ac",this.showInvisibles=!0,this.isRtlDir=!1,this.$isRtl=!1,this.line="",this.wrapIndent=0,this.EOF="\u00b6",this.RLE="\u202b",this.contentWidth=0,this.fontMetrics=null,this.rtlLineOffset=0,this.wrapOffset=0,this.isMoveLeftOperation=!1,this.seenBidi=s.test(e.getValue());};(function(){this.isBidiRow=function(e,t,n){return this.seenBidi?(e!==this.currentRow&&(this.currentRow=e,this.updateRowLine(t,n),this.updateBidiMap()),this.bidiMap.bidiLevels):!1},this.onChange=function(e){this.seenBidi?this.currentRow=null:e.action=="insert"&&s.test(e.lines.join("\n"))&&(this.seenBidi=!0,this.currentRow=null);},this.getDocumentRow=function(){var e=0,t=this.session.$screenRowCache;if(t.length){var n=this.session.$getRowCacheIndex(t,this.currentRow);n>=0&&(e=this.session.$docRowCache[n]);}return e},this.getSplitIndex=function(){var e=0,t=this.session.$screenRowCache;if(t.length){var n,r=this.session.$getRowCacheIndex(t,this.currentRow);while(this.currentRow-e>0){n=this.session.$getRowCacheIndex(t,this.currentRow-e-1);if(n!==r)break;r=n,e++;}}else e=this.currentRow;return e},this.updateRowLine=function(e,t){e===undefined&&(e=this.getDocumentRow());var n=e===this.session.getLength()-1,s=n?this.EOF:this.EOL;this.wrapIndent=0,this.line=this.session.getLine(e),this.isRtlDir=this.$isRtl||this.line.charAt(0)===this.RLE;if(this.session.$useWrapMode){var o=this.session.$wrapData[e];o&&(t===undefined&&(t=this.getSplitIndex()),t>0&&o.length?(this.wrapIndent=o.indent,this.wrapOffset=this.wrapIndent*this.charWidths[r.L],this.line=t<o.length?this.line.substring(o[t-1],o[t]):this.line.substring(o[o.length-1])):this.line=this.line.substring(0,o[t])),t==o.length&&(this.line+=this.showInvisibles?s:r.DOT);}else this.line+=this.showInvisibles?s:r.DOT;var u=this.session,a=0,f;this.line=this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g,function(e,t){return e==="	"||u.isFullWidth(e.charCodeAt(0))?(f=e==="	"?u.getScreenTabSize(t+a):2,a+=f-1,i.stringRepeat(r.DOT,f)):e}),this.isRtlDir&&(this.fontMetrics.$main.textContent=this.line.charAt(this.line.length-1)==r.DOT?this.line.substr(0,this.line.length-1):this.line,this.rtlLineOffset=this.contentWidth-this.fontMetrics.$main.getBoundingClientRect().width);},this.updateBidiMap=function(){var e=[];r.hasBidiCharacters(this.line,e)||this.isRtlDir?this.bidiMap=r.doBidiReorder(this.line,e,this.isRtlDir):this.bidiMap={};},this.markAsDirty=function(){this.currentRow=null;},this.updateCharacterWidths=function(e){if(this.characterWidth===e.$characterSize.width)return;this.fontMetrics=e;var t=this.characterWidth=e.$characterSize.width,n=e.$measureCharWidth("\u05d4");this.charWidths[r.L]=this.charWidths[r.EN]=this.charWidths[r.ON_R]=t,this.charWidths[r.R]=this.charWidths[r.AN]=n,this.charWidths[r.R_H]=n*.45,this.charWidths[r.B]=this.charWidths[r.RLE]=0,this.currentRow=null;},this.setShowInvisibles=function(e){this.showInvisibles=e,this.currentRow=null;},this.setEolChar=function(e){this.EOL=e;},this.setContentWidth=function(e){this.contentWidth=e;},this.isRtlLine=function(e){return this.$isRtl?!0:e!=undefined?this.session.getLine(e).charAt(0)==this.RLE:this.isRtlDir},this.setRtlDirection=function(e,t){var n=e.getCursorPosition();for(var r=e.selection.getSelectionAnchor().row;r<=n.row;r++)!t&&e.session.getLine(r).charAt(0)===e.session.$bidiHandler.RLE?e.session.doc.removeInLine(r,0,1):t&&e.session.getLine(r).charAt(0)!==e.session.$bidiHandler.RLE&&e.session.doc.insert({column:0,row:r},e.session.$bidiHandler.RLE);},this.getPosLeft=function(e){e-=this.wrapIndent;var t=this.line.charAt(0)===this.RLE?1:0,n=e>t?this.session.getOverwrite()?e:e-1:t,i=r.getVisualFromLogicalIdx(n,this.bidiMap),s=this.bidiMap.bidiLevels,o=0;!this.session.getOverwrite()&&e<=t&&s[i]%2!==0&&i++;for(var u=0;u<i;u++)o+=this.charWidths[s[u]];return !this.session.getOverwrite()&&e>t&&s[i]%2===0&&(o+=this.charWidths[s[i]]),this.wrapIndent&&(o+=this.isRtlDir?-1*this.wrapOffset:this.wrapOffset),this.isRtlDir&&(o+=this.rtlLineOffset),o},this.getSelections=function(e,t){var n=this.bidiMap,r=n.bidiLevels,i,s=[],o=0,u=Math.min(e,t)-this.wrapIndent,a=Math.max(e,t)-this.wrapIndent,f=!1,l=!1,c=0;this.wrapIndent&&(o+=this.isRtlDir?-1*this.wrapOffset:this.wrapOffset);for(var h,p=0;p<r.length;p++)h=n.logicalFromVisual[p],i=r[p],f=h>=u&&h<a,f&&!l?c=o:!f&&l&&s.push({left:c,width:o-c}),o+=this.charWidths[i],l=f;f&&p===r.length&&s.push({left:c,width:o-c});if(this.isRtlDir)for(var d=0;d<s.length;d++)s[d].left+=this.rtlLineOffset;return s},this.offsetToCol=function(e){this.isRtlDir&&(e-=this.rtlLineOffset);var t=0,e=Math.max(e,0),n=0,r=0,i=this.bidiMap.bidiLevels,s=this.charWidths[i[r]];this.wrapIndent&&(e-=this.isRtlDir?-1*this.wrapOffset:this.wrapOffset);while(e>n+s/2){n+=s;if(r===i.length-1){s=0;break}s=this.charWidths[i[++r]];}return r>0&&i[r-1]%2!==0&&i[r]%2===0?(e<n&&r--,t=this.bidiMap.logicalFromVisual[r]):r>0&&i[r-1]%2===0&&i[r]%2!==0?t=1+(e>n?this.bidiMap.logicalFromVisual[r]:this.bidiMap.logicalFromVisual[r-1]):this.isRtlDir&&r===i.length-1&&s===0&&i[r-1]%2===0||!this.isRtlDir&&r===0&&i[r]%2!==0?t=1+this.bidiMap.logicalFromVisual[r]:(r>0&&i[r-1]%2!==0&&s!==0&&r--,t=this.bidiMap.logicalFromVisual[r]),t===0&&this.isRtlDir&&t++,t+this.wrapIndent};}).call(o.prototype),t.BidiHandler=o;}),define("ace/selection",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/range"],function(e,t,n){var r=e("./lib/oop"),i=e("./lib/lang"),s=e("./lib/event_emitter").EventEmitter,o=e("./range").Range,u=function(e){this.session=e,this.doc=e.getDocument(),this.clearSelection(),this.cursor=this.lead=this.doc.createAnchor(0,0),this.anchor=this.doc.createAnchor(0,0),this.$silent=!1;var t=this;this.cursor.on("change",function(e){t.$cursorChanged=!0,t.$silent||t._emit("changeCursor"),!t.$isEmpty&&!t.$silent&&t._emit("changeSelection"),!t.$keepDesiredColumnOnChange&&e.old.column!=e.value.column&&(t.$desiredColumn=null);}),this.anchor.on("change",function(){t.$anchorChanged=!0,!t.$isEmpty&&!t.$silent&&t._emit("changeSelection");});};(function(){r.implement(this,s),this.isEmpty=function(){return this.$isEmpty||this.anchor.row==this.lead.row&&this.anchor.column==this.lead.column},this.isMultiLine=function(){return !this.$isEmpty&&this.anchor.row!=this.cursor.row},this.getCursor=function(){return this.lead.getPosition()},this.setSelectionAnchor=function(e,t){this.$isEmpty=!1,this.anchor.setPosition(e,t);},this.getAnchor=this.getSelectionAnchor=function(){return this.$isEmpty?this.getSelectionLead():this.anchor.getPosition()},this.getSelectionLead=function(){return this.lead.getPosition()},this.isBackwards=function(){var e=this.anchor,t=this.lead;return e.row>t.row||e.row==t.row&&e.column>t.column},this.getRange=function(){var e=this.anchor,t=this.lead;return this.$isEmpty?o.fromPoints(t,t):this.isBackwards()?o.fromPoints(t,e):o.fromPoints(e,t)},this.clearSelection=function(){this.$isEmpty||(this.$isEmpty=!0,this._emit("changeSelection"));},this.selectAll=function(){this.$setSelection(0,0,Number.MAX_VALUE,Number.MAX_VALUE);},this.setRange=this.setSelectionRange=function(e,t){var n=t?e.end:e.start,r=t?e.start:e.end;this.$setSelection(n.row,n.column,r.row,r.column);},this.$setSelection=function(e,t,n,r){var i=this.$isEmpty,s=this.inMultiSelectMode;this.$silent=!0,this.$cursorChanged=this.$anchorChanged=!1,this.anchor.setPosition(e,t),this.cursor.setPosition(n,r),this.$isEmpty=!o.comparePoints(this.anchor,this.cursor),this.$silent=!1,this.$cursorChanged&&this._emit("changeCursor"),(this.$cursorChanged||this.$anchorChanged||i!=this.$isEmpty||s)&&this._emit("changeSelection");},this.$moveSelection=function(e){var t=this.lead;this.$isEmpty&&this.setSelectionAnchor(t.row,t.column),e.call(this);},this.selectTo=function(e,t){this.$moveSelection(function(){this.moveCursorTo(e,t);});},this.selectToPosition=function(e){this.$moveSelection(function(){this.moveCursorToPosition(e);});},this.moveTo=function(e,t){this.clearSelection(),this.moveCursorTo(e,t);},this.moveToPosition=function(e){this.clearSelection(),this.moveCursorToPosition(e);},this.selectUp=function(){this.$moveSelection(this.moveCursorUp);},this.selectDown=function(){this.$moveSelection(this.moveCursorDown);},this.selectRight=function(){this.$moveSelection(this.moveCursorRight);},this.selectLeft=function(){this.$moveSelection(this.moveCursorLeft);},this.selectLineStart=function(){this.$moveSelection(this.moveCursorLineStart);},this.selectLineEnd=function(){this.$moveSelection(this.moveCursorLineEnd);},this.selectFileEnd=function(){this.$moveSelection(this.moveCursorFileEnd);},this.selectFileStart=function(){this.$moveSelection(this.moveCursorFileStart);},this.selectWordRight=function(){this.$moveSelection(this.moveCursorWordRight);},this.selectWordLeft=function(){this.$moveSelection(this.moveCursorWordLeft);},this.getWordRange=function(e,t){if(typeof t=="undefined"){var n=e||this.lead;e=n.row,t=n.column;}return this.session.getWordRange(e,t)},this.selectWord=function(){this.setSelectionRange(this.getWordRange());},this.selectAWord=function(){var e=this.getCursor(),t=this.session.getAWordRange(e.row,e.column);this.setSelectionRange(t);},this.getLineRange=function(e,t){var n=typeof e=="number"?e:this.lead.row,r,i=this.session.getFoldLine(n);return i?(n=i.start.row,r=i.end.row):r=n,t===!0?new o(n,0,r,this.session.getLine(r).length):new o(n,0,r+1,0)},this.selectLine=function(){this.setSelectionRange(this.getLineRange());},this.moveCursorUp=function(){this.moveCursorBy(-1,0);},this.moveCursorDown=function(){this.moveCursorBy(1,0);},this.wouldMoveIntoSoftTab=function(e,t,n){var r=e.column,i=e.column+t;return n<0&&(r=e.column-t,i=e.column),this.session.isTabStop(e)&&this.doc.getLine(e.row).slice(r,i).split(" ").length-1==t},this.moveCursorLeft=function(){var e=this.lead.getPosition(),t;if(t=this.session.getFoldAt(e.row,e.column,-1))this.moveCursorTo(t.start.row,t.start.column);else if(e.column===0)e.row>0&&this.moveCursorTo(e.row-1,this.doc.getLine(e.row-1).length);else{var n=this.session.getTabSize();this.wouldMoveIntoSoftTab(e,n,-1)&&!this.session.getNavigateWithinSoftTabs()?this.moveCursorBy(0,-n):this.moveCursorBy(0,-1);}},this.moveCursorRight=function(){var e=this.lead.getPosition(),t;if(t=this.session.getFoldAt(e.row,e.column,1))this.moveCursorTo(t.end.row,t.end.column);else if(this.lead.column==this.doc.getLine(this.lead.row).length)this.lead.row<this.doc.getLength()-1&&this.moveCursorTo(this.lead.row+1,0);else{var n=this.session.getTabSize(),e=this.lead;this.wouldMoveIntoSoftTab(e,n,1)&&!this.session.getNavigateWithinSoftTabs()?this.moveCursorBy(0,n):this.moveCursorBy(0,1);}},this.moveCursorLineStart=function(){var e=this.lead.row,t=this.lead.column,n=this.session.documentToScreenRow(e,t),r=this.session.screenToDocumentPosition(n,0),i=this.session.getDisplayLine(e,null,r.row,r.column),s=i.match(/^\s*/);s[0].length!=t&&!this.session.$useEmacsStyleLineStart&&(r.column+=s[0].length),this.moveCursorToPosition(r);},this.moveCursorLineEnd=function(){var e=this.lead,t=this.session.getDocumentLastRowColumnPosition(e.row,e.column);if(this.lead.column==t.column){var n=this.session.getLine(t.row);if(t.column==n.length){var r=n.search(/\s+$/);r>0&&(t.column=r);}}this.moveCursorTo(t.row,t.column);},this.moveCursorFileEnd=function(){var e=this.doc.getLength()-1,t=this.doc.getLine(e).length;this.moveCursorTo(e,t);},this.moveCursorFileStart=function(){this.moveCursorTo(0,0);},this.moveCursorLongWordRight=function(){var e=this.lead.row,t=this.lead.column,n=this.doc.getLine(e),r=n.substring(t);this.session.nonTokenRe.lastIndex=0,this.session.tokenRe.lastIndex=0;var i=this.session.getFoldAt(e,t,1);if(i){this.moveCursorTo(i.end.row,i.end.column);return}this.session.nonTokenRe.exec(r)&&(t+=this.session.nonTokenRe.lastIndex,this.session.nonTokenRe.lastIndex=0,r=n.substring(t));if(t>=n.length){this.moveCursorTo(e,n.length),this.moveCursorRight(),e<this.doc.getLength()-1&&this.moveCursorWordRight();return}this.session.tokenRe.exec(r)&&(t+=this.session.tokenRe.lastIndex,this.session.tokenRe.lastIndex=0),this.moveCursorTo(e,t);},this.moveCursorLongWordLeft=function(){var e=this.lead.row,t=this.lead.column,n;if(n=this.session.getFoldAt(e,t,-1)){this.moveCursorTo(n.start.row,n.start.column);return}var r=this.session.getFoldStringAt(e,t,-1);r==null&&(r=this.doc.getLine(e).substring(0,t));var s=i.stringReverse(r);this.session.nonTokenRe.lastIndex=0,this.session.tokenRe.lastIndex=0,this.session.nonTokenRe.exec(s)&&(t-=this.session.nonTokenRe.lastIndex,s=s.slice(this.session.nonTokenRe.lastIndex),this.session.nonTokenRe.lastIndex=0);if(t<=0){this.moveCursorTo(e,0),this.moveCursorLeft(),e>0&&this.moveCursorWordLeft();return}this.session.tokenRe.exec(s)&&(t-=this.session.tokenRe.lastIndex,this.session.tokenRe.lastIndex=0),this.moveCursorTo(e,t);},this.$shortWordEndIndex=function(e){var t=0,n,r=/\s/,i=this.session.tokenRe;i.lastIndex=0;if(this.session.tokenRe.exec(e))t=this.session.tokenRe.lastIndex;else{while((n=e[t])&&r.test(n))t++;if(t<1){i.lastIndex=0;while((n=e[t])&&!i.test(n)){i.lastIndex=0,t++;if(r.test(n)){if(t>2){t--;break}while((n=e[t])&&r.test(n))t++;if(t>2)break}}}}return i.lastIndex=0,t},this.moveCursorShortWordRight=function(){var e=this.lead.row,t=this.lead.column,n=this.doc.getLine(e),r=n.substring(t),i=this.session.getFoldAt(e,t,1);if(i)return this.moveCursorTo(i.end.row,i.end.column);if(t==n.length){var s=this.doc.getLength();do e++,r=this.doc.getLine(e);while(e<s&&/^\s*$/.test(r));/^\s+/.test(r)||(r=""),t=0;}var o=this.$shortWordEndIndex(r);this.moveCursorTo(e,t+o);},this.moveCursorShortWordLeft=function(){var e=this.lead.row,t=this.lead.column,n;if(n=this.session.getFoldAt(e,t,-1))return this.moveCursorTo(n.start.row,n.start.column);var r=this.session.getLine(e).substring(0,t);if(t===0){do e--,r=this.doc.getLine(e);while(e>0&&/^\s*$/.test(r));t=r.length,/\s+$/.test(r)||(r="");}var s=i.stringReverse(r),o=this.$shortWordEndIndex(s);return this.moveCursorTo(e,t-o)},this.moveCursorWordRight=function(){this.session.$selectLongWords?this.moveCursorLongWordRight():this.moveCursorShortWordRight();},this.moveCursorWordLeft=function(){this.session.$selectLongWords?this.moveCursorLongWordLeft():this.moveCursorShortWordLeft();},this.moveCursorBy=function(e,t){var n=this.session.documentToScreenPosition(this.lead.row,this.lead.column),r;t===0&&(e!==0&&(this.session.$bidiHandler.isBidiRow(n.row,this.lead.row)?(r=this.session.$bidiHandler.getPosLeft(n.column),n.column=Math.round(r/this.session.$bidiHandler.charWidths[0])):r=n.column*this.session.$bidiHandler.charWidths[0]),this.$desiredColumn?n.column=this.$desiredColumn:this.$desiredColumn=n.column);var i=this.session.screenToDocumentPosition(n.row+e,n.column,r);e!==0&&t===0&&i.row===this.lead.row&&i.column===this.lead.column&&this.session.lineWidgets&&this.session.lineWidgets[i.row]&&(i.row>0||e>0)&&i.row++,this.moveCursorTo(i.row,i.column+t,t===0);},this.moveCursorToPosition=function(e){this.moveCursorTo(e.row,e.column);},this.moveCursorTo=function(e,t,n){var r=this.session.getFoldAt(e,t,1);r&&(e=r.start.row,t=r.start.column),this.$keepDesiredColumnOnChange=!0;var i=this.session.getLine(e);/[\uDC00-\uDFFF]/.test(i.charAt(t))&&i.charAt(t-1)&&(this.lead.row==e&&this.lead.column==t+1?t-=1:t+=1),this.lead.setPosition(e,t),this.$keepDesiredColumnOnChange=!1,n||(this.$desiredColumn=null);},this.moveCursorToScreen=function(e,t,n){var r=this.session.screenToDocumentPosition(e,t);this.moveCursorTo(r.row,r.column,n);},this.detach=function(){this.lead.detach(),this.anchor.detach(),this.session=this.doc=null;},this.fromOrientedRange=function(e){this.setSelectionRange(e,e.cursor==e.start),this.$desiredColumn=e.desiredColumn||this.$desiredColumn;},this.toOrientedRange=function(e){var t=this.getRange();return e?(e.start.column=t.start.column,e.start.row=t.start.row,e.end.column=t.end.column,e.end.row=t.end.row):e=t,e.cursor=this.isBackwards()?e.start:e.end,e.desiredColumn=this.$desiredColumn,e},this.getRangeOfMovements=function(e){var t=this.getCursor();try{e(this);var n=this.getCursor();return o.fromPoints(t,n)}catch(r){return o.fromPoints(t,t)}finally{this.moveCursorToPosition(t);}},this.toJSON=function(){if(this.rangeCount)var e=this.ranges.map(function(e){var t=e.clone();return t.isBackwards=e.cursor==e.start,t});else{var e=this.getRange();e.isBackwards=this.isBackwards();}return e},this.fromJSON=function(e){if(e.start==undefined){if(this.rangeList){this.toSingleRange(e[0]);for(var t=e.length;t--;){var n=o.fromPoints(e[t].start,e[t].end);e[t].isBackwards&&(n.cursor=n.start),this.addRange(n,!0);}return}e=e[0];}this.rangeList&&this.toSingleRange(e),this.setSelectionRange(e,e.isBackwards);},this.isEqual=function(e){if((e.length||this.rangeCount)&&e.length!=this.rangeCount)return !1;if(!e.length||!this.ranges)return this.getRange().isEqual(e);for(var t=this.ranges.length;t--;)if(!this.ranges[t].isEqual(e[t]))return !1;return !0};}).call(u.prototype),t.Selection=u;}),define("ace/tokenizer",["require","exports","module","ace/config"],function(e,t,n){var r=e("./config"),i=2e3,s=function(e){this.states=e,this.regExps={},this.matchMappings={};for(var t in this.states){var n=this.states[t],r=[],i=0,s=this.matchMappings[t]={defaultToken:"text"},o="g",u=[];for(var a=0;a<n.length;a++){var f=n[a];f.defaultToken&&(s.defaultToken=f.defaultToken),f.caseInsensitive&&(o="gi");if(f.regex==null)continue;f.regex instanceof RegExp&&(f.regex=f.regex.toString().slice(1,-1));var l=f.regex,c=(new RegExp("(?:("+l+")|(.))")).exec("a").length-2;Array.isArray(f.token)?f.token.length==1||c==1?f.token=f.token[0]:c-1!=f.token.length?(this.reportError("number of classes and regexp groups doesn't match",{rule:f,groupCount:c-1}),f.token=f.token[0]):(f.tokenArray=f.token,f.token=null,f.onMatch=this.$arrayTokens):typeof f.token=="function"&&!f.onMatch&&(c>1?f.onMatch=this.$applyToken:f.onMatch=f.token),c>1&&(/\\\d/.test(f.regex)?l=f.regex.replace(/\\([0-9]+)/g,function(e,t){return "\\"+(parseInt(t,10)+i+1)}):(c=1,l=this.removeCapturingGroups(f.regex)),!f.splitRegex&&typeof f.token!="string"&&u.push(f)),s[i]=a,i+=c,r.push(l),f.onMatch||(f.onMatch=null);}r.length||(s[0]=0,r.push("$")),u.forEach(function(e){e.splitRegex=this.createSplitterRegexp(e.regex,o);},this),this.regExps[t]=new RegExp("("+r.join(")|(")+")|($)",o);}};(function(){this.$setMaxTokenCount=function(e){i=e|0;},this.$applyToken=function(e){var t=this.splitRegex.exec(e).slice(1),n=this.token.apply(this,t);if(typeof n=="string")return [{type:n,value:e}];var r=[];for(var i=0,s=n.length;i<s;i++)t[i]&&(r[r.length]={type:n[i],value:t[i]});return r},this.$arrayTokens=function(e){if(!e)return [];var t=this.splitRegex.exec(e);if(!t)return "text";var n=[],r=this.tokenArray;for(var i=0,s=r.length;i<s;i++)t[i+1]&&(n[n.length]={type:r[i],value:t[i+1]});return n},this.removeCapturingGroups=function(e){var t=e.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!]|(\()/g,function(e,t){return t?"(?:":e});return t},this.createSplitterRegexp=function(e,t){if(e.indexOf("(?=")!=-1){var n=0,r=!1,i={};e.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g,function(e,t,s,o,u,a){return r?r=u!="]":u?r=!0:o?(n==i.stack&&(i.end=a+1,i.stack=-1),n--):s&&(n++,s.length!=1&&(i.stack=n,i.start=a)),e}),i.end!=null&&/^\)*$/.test(e.substr(i.end))&&(e=e.substring(0,i.start)+e.substr(i.end));}return e.charAt(0)!="^"&&(e="^"+e),e.charAt(e.length-1)!="$"&&(e+="$"),new RegExp(e,(t||"").replace("g",""))},this.getLineTokens=function(e,t){if(t&&typeof t!="string"){var n=t.slice(0);t=n[0],t==="#tmp"&&(n.shift(),t=n.shift());}else var n=[];var r=t||"start",s=this.states[r];s||(r="start",s=this.states[r]);var o=this.matchMappings[r],u=this.regExps[r];u.lastIndex=0;var a,f=[],l=0,c=0,h={type:null,value:""};while(a=u.exec(e)){var p=o.defaultToken,d=null,v=a[0],m=u.lastIndex;if(m-v.length>l){var g=e.substring(l,m-v.length);h.type==p?h.value+=g:(h.type&&f.push(h),h={type:p,value:g});}for(var y=0;y<a.length-2;y++){if(a[y+1]===undefined)continue;d=s[o[y]],d.onMatch?p=d.onMatch(v,r,n,e):p=d.token,d.next&&(typeof d.next=="string"?r=d.next:r=d.next(r,n),s=this.states[r],s||(this.reportError("state doesn't exist",r),r="start",s=this.states[r]),o=this.matchMappings[r],l=m,u=this.regExps[r],u.lastIndex=m),d.consumeLineEnd&&(l=m);break}if(v)if(typeof p=="string")!!d&&d.merge===!1||h.type!==p?(h.type&&f.push(h),h={type:p,value:v}):h.value+=v;else if(p){h.type&&f.push(h),h={type:null,value:""};for(var y=0;y<p.length;y++)f.push(p[y]);}if(l==e.length)break;l=m;if(c++>i){c>2*e.length&&this.reportError("infinite loop with in ace tokenizer",{startState:t,line:e});while(l<e.length)h.type&&f.push(h),h={value:e.substring(l,l+=2e3),type:"overflow"};r="start",n=[];break}}return h.type&&f.push(h),n.length>1&&n[0]!==r&&n.unshift("#tmp",r),{tokens:f,state:n.length?n:r}},this.reportError=r.reportError;}).call(s.prototype),t.Tokenizer=s;}),define("ace/mode/text_highlight_rules",["require","exports","module","ace/lib/lang"],function(e,t,n){var r=e("../lib/lang"),i=function(){this.$rules={start:[{token:"empty_line",regex:"^$"},{defaultToken:"text"}]};};(function(){this.addRules=function(e,t){if(!t){for(var n in e)this.$rules[n]=e[n];return}for(var n in e){var r=e[n];for(var i=0;i<r.length;i++){var s=r[i];if(s.next||s.onMatch)typeof s.next=="string"&&s.next.indexOf(t)!==0&&(s.next=t+s.next),s.nextState&&s.nextState.indexOf(t)!==0&&(s.nextState=t+s.nextState);}this.$rules[t+n]=r;}},this.getRules=function(){return this.$rules},this.embedRules=function(e,t,n,i,s){var o=typeof e=="function"?(new e).getRules():e;if(i)for(var u=0;u<i.length;u++)i[u]=t+i[u];else{i=[];for(var a in o)i.push(t+a);}this.addRules(o,t);if(n){var f=Array.prototype[s?"push":"unshift"];for(var u=0;u<i.length;u++)f.apply(this.$rules[i[u]],r.deepCopy(n));}this.$embeds||(this.$embeds=[]),this.$embeds.push(t);},this.getEmbeds=function(){return this.$embeds};var e=function(e,t){return (e!="start"||t.length)&&t.unshift(this.nextState,e),this.nextState},t=function(e,t){return t.shift(),t.shift()||"start"};this.normalizeRules=function(){function i(s){var o=r[s];o.processed=!0;for(var u=0;u<o.length;u++){var a=o[u],f=null;Array.isArray(a)&&(f=a,a={}),!a.regex&&a.start&&(a.regex=a.start,a.next||(a.next=[]),a.next.push({defaultToken:a.token},{token:a.token+".end",regex:a.end||a.start,next:"pop"}),a.token=a.token+".start",a.push=!0);var l=a.next||a.push;if(l&&Array.isArray(l)){var c=a.stateName;c||(c=a.token,typeof c!="string"&&(c=c[0]||""),r[c]&&(c+=n++)),r[c]=l,a.next=c,i(c);}else l=="pop"&&(a.next=t);a.push&&(a.nextState=a.next||a.push,a.next=e,delete a.push);if(a.rules)for(var h in a.rules)r[h]?r[h].push&&r[h].push.apply(r[h],a.rules[h]):r[h]=a.rules[h];var p=typeof a=="string"?a:a.include;p&&(Array.isArray(p)?f=p.map(function(e){return r[e]}):f=r[p]);if(f){var d=[u,1].concat(f);a.noEscape&&(d=d.filter(function(e){return !e.next})),o.splice.apply(o,d),u--;}a.keywordMap&&(a.token=this.createKeywordMapper(a.keywordMap,a.defaultToken||"text",a.caseInsensitive),delete a.defaultToken);}}var n=0,r=this.$rules;Object.keys(r).forEach(i,this);},this.createKeywordMapper=function(e,t,n,r){var i=Object.create(null);return Object.keys(e).forEach(function(t){var s=e[t];n&&(s=s.toLowerCase());var o=s.split(r||"|");for(var u=o.length;u--;)i[o[u]]=t;}),Object.getPrototypeOf(i)&&(i.__proto__=null),this.$keywordList=Object.keys(i),e=null,n?function(e){return i[e.toLowerCase()]||t}:function(e){return i[e]||t}},this.getKeywords=function(){return this.$keywords};}).call(i.prototype),t.TextHighlightRules=i;}),define("ace/mode/behaviour",["require","exports","module"],function(e,t,n){var r=function(){this.$behaviours={};};(function(){this.add=function(e,t,n){switch(undefined){case this.$behaviours:this.$behaviours={};case this.$behaviours[e]:this.$behaviours[e]={};}this.$behaviours[e][t]=n;},this.addBehaviours=function(e){for(var t in e)for(var n in e[t])this.add(t,n,e[t][n]);},this.remove=function(e){this.$behaviours&&this.$behaviours[e]&&delete this.$behaviours[e];},this.inherit=function(e,t){if(typeof e=="function")var n=(new e).getBehaviours(t);else var n=e.getBehaviours(t);this.addBehaviours(n);},this.getBehaviours=function(e){if(!e)return this.$behaviours;var t={};for(var n=0;n<e.length;n++)this.$behaviours[e[n]]&&(t[e[n]]=this.$behaviours[e[n]]);return t};}).call(r.prototype),t.Behaviour=r;}),define("ace/token_iterator",["require","exports","module","ace/range"],function(e,t,n){var r=e("./range").Range,i=function(e,t,n){this.$session=e,this.$row=t,this.$rowTokens=e.getTokens(t);var r=e.getTokenAt(t,n);this.$tokenIndex=r?r.index:-1;};(function(){this.stepBackward=function(){this.$tokenIndex-=1;while(this.$tokenIndex<0){this.$row-=1;if(this.$row<0)return this.$row=0,null;this.$rowTokens=this.$session.getTokens(this.$row),this.$tokenIndex=this.$rowTokens.length-1;}return this.$rowTokens[this.$tokenIndex]},this.stepForward=function(){this.$tokenIndex+=1;var e;while(this.$tokenIndex>=this.$rowTokens.length){this.$row+=1,e||(e=this.$session.getLength());if(this.$row>=e)return this.$row=e-1,null;this.$rowTokens=this.$session.getTokens(this.$row),this.$tokenIndex=0;}return this.$rowTokens[this.$tokenIndex]},this.getCurrentToken=function(){return this.$rowTokens[this.$tokenIndex]},this.getCurrentTokenRow=function(){return this.$row},this.getCurrentTokenColumn=function(){var e=this.$rowTokens,t=this.$tokenIndex,n=e[t].start;if(n!==undefined)return n;n=0;while(t>0)t-=1,n+=e[t].value.length;return n},this.getCurrentTokenPosition=function(){return {row:this.$row,column:this.getCurrentTokenColumn()}},this.getCurrentTokenRange=function(){var e=this.$rowTokens[this.$tokenIndex],t=this.getCurrentTokenColumn();return new r(this.$row,t,this.$row,t+e.value.length)};}).call(i.prototype),t.TokenIterator=i;}),define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"],function(e,t,n){var r=e("../../lib/oop"),i=e("../behaviour").Behaviour,s=e("../../token_iterator").TokenIterator,o=e("../../lib/lang"),u=["text","paren.rparen","punctuation.operator"],a=["text","paren.rparen","punctuation.operator","comment"],f,l={},c={'"':'"',"'":"'"},h=function(e){var t=-1;e.multiSelect&&(t=e.selection.index,l.rangeCount!=e.multiSelect.rangeCount&&(l={rangeCount:e.multiSelect.rangeCount}));if(l[t])return f=l[t];f=l[t]={autoInsertedBrackets:0,autoInsertedRow:-1,autoInsertedLineEnd:"",maybeInsertedBrackets:0,maybeInsertedRow:-1,maybeInsertedLineStart:"",maybeInsertedLineEnd:""};},p=function(e,t,n,r){var i=e.end.row-e.start.row;return {text:n+t+r,selection:[0,e.start.column+1,i,e.end.column+(i?0:1)]}},d=function(e){this.add("braces","insertion",function(t,n,r,i,s){var u=r.getCursorPosition(),a=i.doc.getLine(u.row);if(s=="{"){h(r);var l=r.getSelectionRange(),c=i.doc.getTextRange(l);if(c!==""&&c!=="{"&&r.getWrapBehavioursEnabled())return p(l,c,"{","}");if(d.isSaneInsertion(r,i))return /[\]\}\)]/.test(a[u.column])||r.inMultiSelectMode||e&&e.braces?(d.recordAutoInsert(r,i,"}"),{text:"{}",selection:[1,1]}):(d.recordMaybeInsert(r,i,"{"),{text:"{",selection:[1,1]})}else if(s=="}"){h(r);var v=a.substring(u.column,u.column+1);if(v=="}"){var m=i.$findOpeningBracket("}",{column:u.column+1,row:u.row});if(m!==null&&d.isAutoInsertedClosing(u,a,s))return d.popAutoInsertedClosing(),{text:"",selection:[1,1]}}}else{if(s=="\n"||s=="\r\n"){h(r);var g="";d.isMaybeInsertedClosing(u,a)&&(g=o.stringRepeat("}",f.maybeInsertedBrackets),d.clearMaybeInsertedClosing());var v=a.substring(u.column,u.column+1);if(v==="}"){var y=i.findMatchingBracket({row:u.row,column:u.column+1},"}");if(!y)return null;var b=this.$getIndent(i.getLine(y.row));}else{if(!g){d.clearMaybeInsertedClosing();return}var b=this.$getIndent(a);}var w=b+i.getTabString();return {text:"\n"+w+"\n"+b+g,selection:[1,w.length,1,w.length]}}d.clearMaybeInsertedClosing();}}),this.add("braces","deletion",function(e,t,n,r,i){var s=r.doc.getTextRange(i);if(!i.isMultiLine()&&s=="{"){h(n);var o=r.doc.getLine(i.start.row),u=o.substring(i.end.column,i.end.column+1);if(u=="}")return i.end.column++,i;f.maybeInsertedBrackets--;}}),this.add("parens","insertion",function(e,t,n,r,i){if(i=="("){h(n);var s=n.getSelectionRange(),o=r.doc.getTextRange(s);if(o!==""&&n.getWrapBehavioursEnabled())return p(s,o,"(",")");if(d.isSaneInsertion(n,r))return d.recordAutoInsert(n,r,")"),{text:"()",selection:[1,1]}}else if(i==")"){h(n);var u=n.getCursorPosition(),a=r.doc.getLine(u.row),f=a.substring(u.column,u.column+1);if(f==")"){var l=r.$findOpeningBracket(")",{column:u.column+1,row:u.row});if(l!==null&&d.isAutoInsertedClosing(u,a,i))return d.popAutoInsertedClosing(),{text:"",selection:[1,1]}}}}),this.add("parens","deletion",function(e,t,n,r,i){var s=r.doc.getTextRange(i);if(!i.isMultiLine()&&s=="("){h(n);var o=r.doc.getLine(i.start.row),u=o.substring(i.start.column+1,i.start.column+2);if(u==")")return i.end.column++,i}}),this.add("brackets","insertion",function(e,t,n,r,i){if(i=="["){h(n);var s=n.getSelectionRange(),o=r.doc.getTextRange(s);if(o!==""&&n.getWrapBehavioursEnabled())return p(s,o,"[","]");if(d.isSaneInsertion(n,r))return d.recordAutoInsert(n,r,"]"),{text:"[]",selection:[1,1]}}else if(i=="]"){h(n);var u=n.getCursorPosition(),a=r.doc.getLine(u.row),f=a.substring(u.column,u.column+1);if(f=="]"){var l=r.$findOpeningBracket("]",{column:u.column+1,row:u.row});if(l!==null&&d.isAutoInsertedClosing(u,a,i))return d.popAutoInsertedClosing(),{text:"",selection:[1,1]}}}}),this.add("brackets","deletion",function(e,t,n,r,i){var s=r.doc.getTextRange(i);if(!i.isMultiLine()&&s=="["){h(n);var o=r.doc.getLine(i.start.row),u=o.substring(i.start.column+1,i.start.column+2);if(u=="]")return i.end.column++,i}}),this.add("string_dquotes","insertion",function(e,t,n,r,i){var s=r.$mode.$quotes||c;if(i.length==1&&s[i]){if(this.lineCommentStart&&this.lineCommentStart.indexOf(i)!=-1)return;h(n);var o=i,u=n.getSelectionRange(),a=r.doc.getTextRange(u);if(a!==""&&(a.length!=1||!s[a])&&n.getWrapBehavioursEnabled())return p(u,a,o,o);if(!a){var f=n.getCursorPosition(),l=r.doc.getLine(f.row),d=l.substring(f.column-1,f.column),v=l.substring(f.column,f.column+1),m=r.getTokenAt(f.row,f.column),g=r.getTokenAt(f.row,f.column+1);if(d=="\\"&&m&&/escape/.test(m.type))return null;var y=m&&/string|escape/.test(m.type),b=!g||/string|escape/.test(g.type),w;if(v==o)w=y!==b,w&&/string\.end/.test(g.type)&&(w=!1);else{if(y&&!b)return null;if(y&&b)return null;var E=r.$mode.tokenRe;E.lastIndex=0;var S=E.test(d);E.lastIndex=0;var x=E.test(d);if(S||x)return null;if(v&&!/[\s;,.})\]\\]/.test(v))return null;w=!0;}return {text:w?o+o:"",selection:[1,1]}}}}),this.add("string_dquotes","deletion",function(e,t,n,r,i){var s=r.$mode.$quotes||c,o=r.doc.getTextRange(i);if(!i.isMultiLine()&&s.hasOwnProperty(o)){h(n);var u=r.doc.getLine(i.start.row),a=u.substring(i.start.column+1,i.start.column+2);if(a==o)return i.end.column++,i}});};d.isSaneInsertion=function(e,t){var n=e.getCursorPosition(),r=new s(t,n.row,n.column);if(!this.$matchTokenType(r.getCurrentToken()||"text",u)){var i=new s(t,n.row,n.column+1);if(!this.$matchTokenType(i.getCurrentToken()||"text",u))return !1}return r.stepForward(),r.getCurrentTokenRow()!==n.row||this.$matchTokenType(r.getCurrentToken()||"text",a)},d.$matchTokenType=function(e,t){return t.indexOf(e.type||e)>-1},d.recordAutoInsert=function(e,t,n){var r=e.getCursorPosition(),i=t.doc.getLine(r.row);this.isAutoInsertedClosing(r,i,f.autoInsertedLineEnd[0])||(f.autoInsertedBrackets=0),f.autoInsertedRow=r.row,f.autoInsertedLineEnd=n+i.substr(r.column),f.autoInsertedBrackets++;},d.recordMaybeInsert=function(e,t,n){var r=e.getCursorPosition(),i=t.doc.getLine(r.row);this.isMaybeInsertedClosing(r,i)||(f.maybeInsertedBrackets=0),f.maybeInsertedRow=r.row,f.maybeInsertedLineStart=i.substr(0,r.column)+n,f.maybeInsertedLineEnd=i.substr(r.column),f.maybeInsertedBrackets++;},d.isAutoInsertedClosing=function(e,t,n){return f.autoInsertedBrackets>0&&e.row===f.autoInsertedRow&&n===f.autoInsertedLineEnd[0]&&t.substr(e.column)===f.autoInsertedLineEnd},d.isMaybeInsertedClosing=function(e,t){return f.maybeInsertedBrackets>0&&e.row===f.maybeInsertedRow&&t.substr(e.column)===f.maybeInsertedLineEnd&&t.substr(0,e.column)==f.maybeInsertedLineStart},d.popAutoInsertedClosing=function(){f.autoInsertedLineEnd=f.autoInsertedLineEnd.substr(1),f.autoInsertedBrackets--;},d.clearMaybeInsertedClosing=function(){f&&(f.maybeInsertedBrackets=0,f.maybeInsertedRow=-1);},r.inherits(d,i),t.CstyleBehaviour=d;}),define("ace/unicode",["require","exports","module"],function(e,t,n){var r=[48,9,8,25,5,0,2,25,48,0,11,0,5,0,6,22,2,30,2,457,5,11,15,4,8,0,2,0,18,116,2,1,3,3,9,0,2,2,2,0,2,19,2,82,2,138,2,4,3,155,12,37,3,0,8,38,10,44,2,0,2,1,2,1,2,0,9,26,6,2,30,10,7,61,2,9,5,101,2,7,3,9,2,18,3,0,17,58,3,100,15,53,5,0,6,45,211,57,3,18,2,5,3,11,3,9,2,1,7,6,2,2,2,7,3,1,3,21,2,6,2,0,4,3,3,8,3,1,3,3,9,0,5,1,2,4,3,11,16,2,2,5,5,1,3,21,2,6,2,1,2,1,2,1,3,0,2,4,5,1,3,2,4,0,8,3,2,0,8,15,12,2,2,8,2,2,2,21,2,6,2,1,2,4,3,9,2,2,2,2,3,0,16,3,3,9,18,2,2,7,3,1,3,21,2,6,2,1,2,4,3,8,3,1,3,2,9,1,5,1,2,4,3,9,2,0,17,1,2,5,4,2,2,3,4,1,2,0,2,1,4,1,4,2,4,11,5,4,4,2,2,3,3,0,7,0,15,9,18,2,2,7,2,2,2,22,2,9,2,4,4,7,2,2,2,3,8,1,2,1,7,3,3,9,19,1,2,7,2,2,2,22,2,9,2,4,3,8,2,2,2,3,8,1,8,0,2,3,3,9,19,1,2,7,2,2,2,22,2,15,4,7,2,2,2,3,10,0,9,3,3,9,11,5,3,1,2,17,4,23,2,8,2,0,3,6,4,0,5,5,2,0,2,7,19,1,14,57,6,14,2,9,40,1,2,0,3,1,2,0,3,0,7,3,2,6,2,2,2,0,2,0,3,1,2,12,2,2,3,4,2,0,2,5,3,9,3,1,35,0,24,1,7,9,12,0,2,0,2,0,5,9,2,35,5,19,2,5,5,7,2,35,10,0,58,73,7,77,3,37,11,42,2,0,4,328,2,3,3,6,2,0,2,3,3,40,2,3,3,32,2,3,3,6,2,0,2,3,3,14,2,56,2,3,3,66,5,0,33,15,17,84,13,619,3,16,2,25,6,74,22,12,2,6,12,20,12,19,13,12,2,2,2,1,13,51,3,29,4,0,5,1,3,9,34,2,3,9,7,87,9,42,6,69,11,28,4,11,5,11,11,39,3,4,12,43,5,25,7,10,38,27,5,62,2,28,3,10,7,9,14,0,89,75,5,9,18,8,13,42,4,11,71,55,9,9,4,48,83,2,2,30,14,230,23,280,3,5,3,37,3,5,3,7,2,0,2,0,2,0,2,30,3,52,2,6,2,0,4,2,2,6,4,3,3,5,5,12,6,2,2,6,67,1,20,0,29,0,14,0,17,4,60,12,5,0,4,11,18,0,5,0,3,9,2,0,4,4,7,0,2,0,2,0,2,3,2,10,3,3,6,4,5,0,53,1,2684,46,2,46,2,132,7,6,15,37,11,53,10,0,17,22,10,6,2,6,2,6,2,6,2,6,2,6,2,6,2,6,2,31,48,0,470,1,36,5,2,4,6,1,5,85,3,1,3,2,2,89,2,3,6,40,4,93,18,23,57,15,513,6581,75,20939,53,1164,68,45,3,268,4,27,21,31,3,13,13,1,2,24,9,69,11,1,38,8,3,102,3,1,111,44,25,51,13,68,12,9,7,23,4,0,5,45,3,35,13,28,4,64,15,10,39,54,10,13,3,9,7,22,4,1,5,66,25,2,227,42,2,1,3,9,7,11171,13,22,5,48,8453,301,3,61,3,105,39,6,13,4,6,11,2,12,2,4,2,0,2,1,2,1,2,107,34,362,19,63,3,53,41,11,5,15,17,6,13,1,25,2,33,4,2,134,20,9,8,25,5,0,2,25,12,88,4,5,3,5,3,5,3,2],i=0,s=[];for(var o=0;o<r.length;o+=2)s.push(i+=r[o]),r[o+1]&&s.push(45,i+=r[o+1]);t.wordChars=String.fromCharCode.apply(null,s);}),define("ace/mode/text",["require","exports","module","ace/config","ace/tokenizer","ace/mode/text_highlight_rules","ace/mode/behaviour/cstyle","ace/unicode","ace/lib/lang","ace/token_iterator","ace/range"],function(e,t,n){var r=e("../config"),i=e("../tokenizer").Tokenizer,s=e("./text_highlight_rules").TextHighlightRules,o=e("./behaviour/cstyle").CstyleBehaviour,u=e("../unicode"),a=e("../lib/lang"),f=e("../token_iterator").TokenIterator,l=e("../range").Range,c=function(){this.HighlightRules=s;};(function(){this.$defaultBehaviour=new o,this.tokenRe=new RegExp("^["+u.wordChars+"\\$_]+","g"),this.nonTokenRe=new RegExp("^(?:[^"+u.wordChars+"\\$_]|\\s])+","g"),this.getTokenizer=function(){return this.$tokenizer||(this.$highlightRules=this.$highlightRules||new this.HighlightRules(this.$highlightRuleConfig),this.$tokenizer=new i(this.$highlightRules.getRules())),this.$tokenizer},this.lineCommentStart="",this.blockComment="",this.toggleCommentLines=function(e,t,n,r){function w(e){for(var t=n;t<=r;t++)e(i.getLine(t),t);}var i=t.doc,s=!0,o=!0,u=Infinity,f=t.getTabSize(),l=!1;if(!this.lineCommentStart){if(!this.blockComment)return !1;var c=this.blockComment.start,h=this.blockComment.end,p=new RegExp("^(\\s*)(?:"+a.escapeRegExp(c)+")"),d=new RegExp("(?:"+a.escapeRegExp(h)+")\\s*$"),v=function(e,t){if(g(e,t))return;if(!s||/\S/.test(e))i.insertInLine({row:t,column:e.length},h),i.insertInLine({row:t,column:u},c);},m=function(e,t){var n;(n=e.match(d))&&i.removeInLine(t,e.length-n[0].length,e.length),(n=e.match(p))&&i.removeInLine(t,n[1].length,n[0].length);},g=function(e,n){if(p.test(e))return !0;var r=t.getTokens(n);for(var i=0;i<r.length;i++)if(r[i].type==="comment")return !0};}else{if(Array.isArray(this.lineCommentStart))var p=this.lineCommentStart.map(a.escapeRegExp).join("|"),c=this.lineCommentStart[0];else var p=a.escapeRegExp(this.lineCommentStart),c=this.lineCommentStart;p=new RegExp("^(\\s*)(?:"+p+") ?"),l=t.getUseSoftTabs();var m=function(e,t){var n=e.match(p);if(!n)return;var r=n[1].length,s=n[0].length;!b(e,r,s)&&n[0][s-1]==" "&&s--,i.removeInLine(t,r,s);},y=c+" ",v=function(e,t){if(!s||/\S/.test(e))b(e,u,u)?i.insertInLine({row:t,column:u},y):i.insertInLine({row:t,column:u},c);},g=function(e,t){return p.test(e)},b=function(e,t,n){var r=0;while(t--&&e.charAt(t)==" ")r++;if(r%f!=0)return !1;var r=0;while(e.charAt(n++)==" ")r++;return f>2?r%f!=f-1:r%f==0};}var E=Infinity;w(function(e,t){var n=e.search(/\S/);n!==-1?(n<u&&(u=n),o&&!g(e,t)&&(o=!1)):E>e.length&&(E=e.length);}),u==Infinity&&(u=E,s=!1,o=!1),l&&u%f!=0&&(u=Math.floor(u/f)*f),w(o?m:v);},this.toggleBlockComment=function(e,t,n,r){var i=this.blockComment;if(!i)return;!i.start&&i[0]&&(i=i[0]);var s=new f(t,r.row,r.column),o=s.getCurrentToken(),u=t.selection,a=t.selection.toOrientedRange(),c,h;if(o&&/comment/.test(o.type)){var p,d;while(o&&/comment/.test(o.type)){var v=o.value.indexOf(i.start);if(v!=-1){var m=s.getCurrentTokenRow(),g=s.getCurrentTokenColumn()+v;p=new l(m,g,m,g+i.start.length);break}o=s.stepBackward();}var s=new f(t,r.row,r.column),o=s.getCurrentToken();while(o&&/comment/.test(o.type)){var v=o.value.indexOf(i.end);if(v!=-1){var m=s.getCurrentTokenRow(),g=s.getCurrentTokenColumn()+v;d=new l(m,g,m,g+i.end.length);break}o=s.stepForward();}d&&t.remove(d),p&&(t.remove(p),c=p.start.row,h=-i.start.length);}else h=i.start.length,c=n.start.row,t.insert(n.end,i.end),t.insert(n.start,i.start);a.start.row==c&&(a.start.column+=h),a.end.row==c&&(a.end.column+=h),t.selection.fromOrientedRange(a);},this.getNextLineIndent=function(e,t,n){return this.$getIndent(t)},this.checkOutdent=function(e,t,n){return !1},this.autoOutdent=function(e,t,n){},this.$getIndent=function(e){return e.match(/^\s*/)[0]},this.createWorker=function(e){return null},this.createModeDelegates=function(e){this.$embeds=[],this.$modes={};for(var t in e)if(e[t]){var n=e[t],i=n.prototype.$id,s=r.$modes[i];s||(r.$modes[i]=s=new n),r.$modes[t]||(r.$modes[t]=s),this.$embeds.push(t),this.$modes[t]=s;}var o=["toggleBlockComment","toggleCommentLines","getNextLineIndent","checkOutdent","autoOutdent","transformAction","getCompletions"];for(var t=0;t<o.length;t++)(function(e){var n=o[t],r=e[n];e[o[t]]=function(){return this.$delegator(n,arguments,r)};})(this);},this.$delegator=function(e,t,n){var r=t[0]||"start";if(typeof r!="string"){if(Array.isArray(r[2])){var i=r[2][r[2].length-1],s=this.$modes[i];if(s)return s[e].apply(s,[r[1]].concat([].slice.call(t,1)))}r=r[0]||"start";}for(var o=0;o<this.$embeds.length;o++){if(!this.$modes[this.$embeds[o]])continue;var u=r.split(this.$embeds[o]);if(!u[0]&&u[1]){t[0]=u[1];var s=this.$modes[this.$embeds[o]];return s[e].apply(s,t)}}var a=n.apply(this,t);return n?a:undefined},this.transformAction=function(e,t,n,r,i){if(this.$behaviour){var s=this.$behaviour.getBehaviours();for(var o in s)if(s[o][t]){var u=s[o][t].apply(this,arguments);if(u)return u}}},this.getKeywords=function(e){if(!this.completionKeywords){var t=this.$tokenizer.rules,n=[];for(var r in t){var i=t[r];for(var s=0,o=i.length;s<o;s++)if(typeof i[s].token=="string")/keyword|support|storage/.test(i[s].token)&&n.push(i[s].regex);else if(typeof i[s].token=="object")for(var u=0,a=i[s].token.length;u<a;u++)if(/keyword|support|storage/.test(i[s].token[u])){var r=i[s].regex.match(/\(.+?\)/g)[u];n.push(r.substr(1,r.length-2));}}this.completionKeywords=n;}return e?n.concat(this.$keywordList||[]):this.$keywordList},this.$createKeywordList=function(){return this.$highlightRules||this.getTokenizer(),this.$keywordList=this.$highlightRules.$keywordList||[]},this.getCompletions=function(e,t,n,r){var i=this.$keywordList||this.$createKeywordList();return i.map(function(e){return {name:e,value:e,score:0,meta:"keyword"}})},this.$id="ace/mode/text";}).call(c.prototype),t.Mode=c;}),define("ace/apply_delta",["require","exports","module"],function(e,t,n){t.applyDelta=function(e,t,n){var r=t.start.row,i=t.start.column,s=e[r]||"";switch(t.action){case"insert":var o=t.lines;if(o.length===1)e[r]=s.substring(0,i)+t.lines[0]+s.substring(i);else{var u=[r,1].concat(t.lines);e.splice.apply(e,u),e[r]=s.substring(0,i)+e[r],e[r+t.lines.length-1]+=s.substring(i);}break;case"remove":var a=t.end.column,f=t.end.row;r===f?e[r]=s.substring(0,i)+s.substring(a):e.splice(r,f-r+1,s.substring(0,i)+e[f].substring(a));}};}),define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"],function(e,t,n){var r=e("./lib/oop"),i=e("./lib/event_emitter").EventEmitter,s=t.Anchor=function(e,t,n){this.$onChange=this.onChange.bind(this),this.attach(e),typeof n=="undefined"?this.setPosition(t.row,t.column):this.setPosition(t,n);};(function(){function e(e,t,n){var r=n?e.column<=t.column:e.column<t.column;return e.row<t.row||e.row==t.row&&r}function t(t,n,r){var i=t.action=="insert",s=(i?1:-1)*(t.end.row-t.start.row),o=(i?1:-1)*(t.end.column-t.start.column),u=t.start,a=i?u:t.end;return e(n,u,r)?{row:n.row,column:n.column}:e(a,n,!r)?{row:n.row+s,column:n.column+(n.row==a.row?o:0)}:{row:u.row,column:u.column}}r.implement(this,i),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(e){if(e.start.row==e.end.row&&e.start.row!=this.row)return;if(e.start.row>this.row)return;var n=t(e,{row:this.row,column:this.column},this.$insertRight);this.setPosition(n.row,n.column,!0);},this.setPosition=function(e,t,n){var r;n?r={row:e,column:t}:r=this.$clipPositionToDocument(e,t);if(this.row==r.row&&this.column==r.column)return;var i={row:this.row,column:this.column};this.row=r.row,this.column=r.column,this._signal("change",{old:i,value:r});},this.detach=function(){this.document.removeEventListener("change",this.$onChange);},this.attach=function(e){this.document=e||this.document,this.document.on("change",this.$onChange);},this.$clipPositionToDocument=function(e,t){var n={};return e>=this.document.getLength()?(n.row=Math.max(0,this.document.getLength()-1),n.column=this.document.getLine(n.row).length):e<0?(n.row=0,n.column=0):(n.row=e,n.column=Math.min(this.document.getLine(n.row).length,Math.max(0,t))),t<0&&(n.column=0),n};}).call(s.prototype);}),define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"],function(e,t,n){var r=e("./lib/oop"),i=e("./apply_delta").applyDelta,s=e("./lib/event_emitter").EventEmitter,o=e("./range").Range,u=e("./anchor").Anchor,a=function(e){this.$lines=[""],e.length===0?this.$lines=[""]:Array.isArray(e)?this.insertMergedLines({row:0,column:0},e):this.insert({row:0,column:0},e);};(function(){r.implement(this,s),this.setValue=function(e){var t=this.getLength()-1;this.remove(new o(0,0,t,this.getLine(t).length)),this.insert({row:0,column:0},e);},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(e,t){return new u(this,e,t)},"aaa".split(/a/).length===0?this.$split=function(e){return e.replace(/\r\n|\r/g,"\n").split("\n")}:this.$split=function(e){return e.split(/\r\n|\r|\n/)},this.$detectNewLine=function(e){var t=e.match(/^.*?(\r\n|\r|\n)/m);this.$autoNewLine=t?t[1]:"\n",this._signal("changeNewLineMode");},this.getNewLineCharacter=function(){switch(this.$newLineMode){case"windows":return "\r\n";case"unix":return "\n";default:return this.$autoNewLine||"\n"}},this.$autoNewLine="",this.$newLineMode="auto",this.setNewLineMode=function(e){if(this.$newLineMode===e)return;this.$newLineMode=e,this._signal("changeNewLineMode");},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(e){return e=="\r\n"||e=="\r"||e=="\n"},this.getLine=function(e){return this.$lines[e]||""},this.getLines=function(e,t){return this.$lines.slice(e,t+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(e){return this.getLinesForRange(e).join(this.getNewLineCharacter())},this.getLinesForRange=function(e){var t;if(e.start.row===e.end.row)t=[this.getLine(e.start.row).substring(e.start.column,e.end.column)];else{t=this.getLines(e.start.row,e.end.row),t[0]=(t[0]||"").substring(e.start.column);var n=t.length-1;e.end.row-e.start.row==n&&(t[n]=t[n].substring(0,e.end.column));}return t},this.insertLines=function(e,t){return console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead."),this.insertFullLines(e,t)},this.removeLines=function(e,t){return console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead."),this.removeFullLines(e,t)},this.insertNewLine=function(e){return console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead."),this.insertMergedLines(e,["",""])},this.insert=function(e,t){return this.getLength()<=1&&this.$detectNewLine(t),this.insertMergedLines(e,this.$split(t))},this.insertInLine=function(e,t){var n=this.clippedPos(e.row,e.column),r=this.pos(e.row,e.column+t.length);return this.applyDelta({start:n,end:r,action:"insert",lines:[t]},!0),this.clonePos(r)},this.clippedPos=function(e,t){var n=this.getLength();e===undefined?e=n:e<0?e=0:e>=n&&(e=n-1,t=undefined);var r=this.getLine(e);return t==undefined&&(t=r.length),t=Math.min(Math.max(t,0),r.length),{row:e,column:t}},this.clonePos=function(e){return {row:e.row,column:e.column}},this.pos=function(e,t){return {row:e,column:t}},this.$clipPosition=function(e){var t=this.getLength();return e.row>=t?(e.row=Math.max(0,t-1),e.column=this.getLine(t-1).length):(e.row=Math.max(0,e.row),e.column=Math.min(Math.max(e.column,0),this.getLine(e.row).length)),e},this.insertFullLines=function(e,t){e=Math.min(Math.max(e,0),this.getLength());var n=0;e<this.getLength()?(t=t.concat([""]),n=0):(t=[""].concat(t),e--,n=this.$lines[e].length),this.insertMergedLines({row:e,column:n},t);},this.insertMergedLines=function(e,t){var n=this.clippedPos(e.row,e.column),r={row:n.row+t.length-1,column:(t.length==1?n.column:0)+t[t.length-1].length};return this.applyDelta({start:n,end:r,action:"insert",lines:t}),this.clonePos(r)},this.remove=function(e){var t=this.clippedPos(e.start.row,e.start.column),n=this.clippedPos(e.end.row,e.end.column);return this.applyDelta({start:t,end:n,action:"remove",lines:this.getLinesForRange({start:t,end:n})}),this.clonePos(t)},this.removeInLine=function(e,t,n){var r=this.clippedPos(e,t),i=this.clippedPos(e,n);return this.applyDelta({start:r,end:i,action:"remove",lines:this.getLinesForRange({start:r,end:i})},!0),this.clonePos(r)},this.removeFullLines=function(e,t){e=Math.min(Math.max(0,e),this.getLength()-1),t=Math.min(Math.max(0,t),this.getLength()-1);var n=t==this.getLength()-1&&e>0,r=t<this.getLength()-1,i=n?e-1:e,s=n?this.getLine(i).length:0,u=r?t+1:t,a=r?0:this.getLine(u).length,f=new o(i,s,u,a),l=this.$lines.slice(e,t+1);return this.applyDelta({start:f.start,end:f.end,action:"remove",lines:this.getLinesForRange(f)}),l},this.removeNewLine=function(e){e<this.getLength()-1&&e>=0&&this.applyDelta({start:this.pos(e,this.getLine(e).length),end:this.pos(e+1,0),action:"remove",lines:["",""]});},this.replace=function(e,t){e instanceof o||(e=o.fromPoints(e.start,e.end));if(t.length===0&&e.isEmpty())return e.start;if(t==this.getTextRange(e))return e.end;this.remove(e);var n;return t?n=this.insert(e.start,t):n=e.start,n},this.applyDeltas=function(e){for(var t=0;t<e.length;t++)this.applyDelta(e[t]);},this.revertDeltas=function(e){for(var t=e.length-1;t>=0;t--)this.revertDelta(e[t]);},this.applyDelta=function(e,t){var n=e.action=="insert";if(n?e.lines.length<=1&&!e.lines[0]:!o.comparePoints(e.start,e.end))return;n&&e.lines.length>2e4?this.$splitAndapplyLargeDelta(e,2e4):(i(this.$lines,e,t),this._signal("change",e));},this.$splitAndapplyLargeDelta=function(e,t){var n=e.lines,r=n.length-t+1,i=e.start.row,s=e.start.column;for(var o=0,u=0;o<r;o=u){u+=t-1;var a=n.slice(o,u);a.push(""),this.applyDelta({start:this.pos(i+o,s),end:this.pos(i+u,s=0),action:e.action,lines:a},!0);}e.lines=n.slice(o),e.start.row=i+o,e.start.column=s,this.applyDelta(e,!0);},this.revertDelta=function(e){this.applyDelta({start:this.clonePos(e.start),end:this.clonePos(e.end),action:e.action=="insert"?"remove":"insert",lines:e.lines.slice()});},this.indexToPosition=function(e,t){var n=this.$lines||this.getAllLines(),r=this.getNewLineCharacter().length;for(var i=t||0,s=n.length;i<s;i++){e-=n[i].length+r;if(e<0)return {row:i,column:e+n[i].length+r}}return {row:s-1,column:e+n[s-1].length+r}},this.positionToIndex=function(e,t){var n=this.$lines||this.getAllLines(),r=this.getNewLineCharacter().length,i=0,s=Math.min(e.row,n.length);for(var o=t||0;o<s;++o)i+=n[o].length+r;return i+e.column};}).call(a.prototype),t.Document=a;}),define("ace/background_tokenizer",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"],function(e,t,n){var r=e("./lib/oop"),i=e("./lib/event_emitter").EventEmitter,s=function(e,t){this.running=!1,this.lines=[],this.states=[],this.currentLine=0,this.tokenizer=e;var n=this;this.$worker=function(){if(!n.running)return;var e=new Date,t=n.currentLine,r=-1,i=n.doc,s=t;while(n.lines[t])t++;var o=i.getLength(),u=0;n.running=!1;while(t<o){n.$tokenizeRow(t),r=t;do t++;while(n.lines[t]);u++;if(u%5===0&&new Date-e>20){n.running=setTimeout(n.$worker,20);break}}n.currentLine=t,r==-1&&(r=t),s<=r&&n.fireUpdateEvent(s,r);};};(function(){r.implement(this,i),this.setTokenizer=function(e){this.tokenizer=e,this.lines=[],this.states=[],this.start(0);},this.setDocument=function(e){this.doc=e,this.lines=[],this.states=[],this.stop();},this.fireUpdateEvent=function(e,t){var n={first:e,last:t};this._signal("update",{data:n});},this.start=function(e){this.currentLine=Math.min(e||0,this.currentLine,this.doc.getLength()),this.lines.splice(this.currentLine,this.lines.length),this.states.splice(this.currentLine,this.states.length),this.stop(),this.running=setTimeout(this.$worker,700);},this.scheduleStart=function(){this.running||(this.running=setTimeout(this.$worker,700));},this.$updateOnChange=function(e){var t=e.start.row,n=e.end.row-t;if(n===0)this.lines[t]=null;else if(e.action=="remove")this.lines.splice(t,n+1,null),this.states.splice(t,n+1,null);else{var r=Array(n+1);r.unshift(t,1),this.lines.splice.apply(this.lines,r),this.states.splice.apply(this.states,r);}this.currentLine=Math.min(t,this.currentLine,this.doc.getLength()),this.stop();},this.stop=function(){this.running&&clearTimeout(this.running),this.running=!1;},this.getTokens=function(e){return this.lines[e]||this.$tokenizeRow(e)},this.getState=function(e){return this.currentLine==e&&this.$tokenizeRow(e),this.states[e]||"start"},this.$tokenizeRow=function(e){var t=this.doc.getLine(e),n=this.states[e-1],r=this.tokenizer.getLineTokens(t,n,e);return this.states[e]+""!=r.state+""?(this.states[e]=r.state,this.lines[e+1]=null,this.currentLine>e+1&&(this.currentLine=e+1)):this.currentLine==e&&(this.currentLine=e+1),this.lines[e]=r.tokens};}).call(s.prototype),t.BackgroundTokenizer=s;}),define("ace/search_highlight",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"],function(e,t,n){var r=e("./lib/lang"),i=e("./lib/oop"),s=e("./range").Range,o=function(e,t,n){this.setRegexp(e),this.clazz=t,this.type=n||"text";};(function(){this.MAX_RANGES=500,this.setRegexp=function(e){if(this.regExp+""==e+"")return;this.regExp=e,this.cache=[];},this.update=function(e,t,n,i){if(!this.regExp)return;var o=i.firstRow,u=i.lastRow;for(var a=o;a<=u;a++){var f=this.cache[a];f==null&&(f=r.getMatchOffsets(n.getLine(a),this.regExp),f.length>this.MAX_RANGES&&(f=f.slice(0,this.MAX_RANGES)),f=f.map(function(e){return new s(a,e.offset,a,e.offset+e.length)}),this.cache[a]=f.length?f:"");for(var l=f.length;l--;)t.drawSingleLineMarker(e,f[l].toScreenRange(n),this.clazz,i);}};}).call(o.prototype),t.SearchHighlight=o;}),define("ace/edit_session/fold_line",["require","exports","module","ace/range"],function(e,t,n){function i(e,t){this.foldData=e,Array.isArray(t)?this.folds=t:t=this.folds=[t];var n=t[t.length-1];this.range=new r(t[0].start.row,t[0].start.column,n.end.row,n.end.column),this.start=this.range.start,this.end=this.range.end,this.folds.forEach(function(e){e.setFoldLine(this);},this);}var r=e("../range").Range;(function(){this.shiftRow=function(e){this.start.row+=e,this.end.row+=e,this.folds.forEach(function(t){t.start.row+=e,t.end.row+=e;});},this.addFold=function(e){if(e.sameRow){if(e.start.row<this.startRow||e.endRow>this.endRow)throw new Error("Can't add a fold to this FoldLine as it has no connection");this.folds.push(e),this.folds.sort(function(e,t){return -e.range.compareEnd(t.start.row,t.start.column)}),this.range.compareEnd(e.start.row,e.start.column)>0?(this.end.row=e.end.row,this.end.column=e.end.column):this.range.compareStart(e.end.row,e.end.column)<0&&(this.start.row=e.start.row,this.start.column=e.start.column);}else if(e.start.row==this.end.row)this.folds.push(e),this.end.row=e.end.row,this.end.column=e.end.column;else{if(e.end.row!=this.start.row)throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");this.folds.unshift(e),this.start.row=e.start.row,this.start.column=e.start.column;}e.foldLine=this;},this.containsRow=function(e){return e>=this.start.row&&e<=this.end.row},this.walk=function(e,t,n){var r=0,i=this.folds,s,o,u,a=!0;t==null&&(t=this.end.row,n=this.end.column);for(var f=0;f<i.length;f++){s=i[f],o=s.range.compareStart(t,n);if(o==-1){e(null,t,n,r,a);return}u=e(null,s.start.row,s.start.column,r,a),u=!u&&e(s.placeholder,s.start.row,s.start.column,r);if(u||o===0)return;a=!s.sameRow,r=s.end.column;}e(null,t,n,r,a);},this.getNextFoldTo=function(e,t){var n,r;for(var i=0;i<this.folds.length;i++){n=this.folds[i],r=n.range.compareEnd(e,t);if(r==-1)return {fold:n,kind:"after"};if(r===0)return {fold:n,kind:"inside"}}return null},this.addRemoveChars=function(e,t,n){var r=this.getNextFoldTo(e,t),i,s;if(r){i=r.fold;if(r.kind=="inside"&&i.start.column!=t&&i.start.row!=e)window.console&&window.console.log(e,t,i);else if(i.start.row==e){s=this.folds;var o=s.indexOf(i);o===0&&(this.start.column+=n);for(o;o<s.length;o++){i=s[o],i.start.column+=n;if(!i.sameRow)return;i.end.column+=n;}this.end.column+=n;}}},this.split=function(e,t){var n=this.getNextFoldTo(e,t);if(!n||n.kind=="inside")return null;var r=n.fold,s=this.folds,o=this.foldData,u=s.indexOf(r),a=s[u-1];this.end.row=a.end.row,this.end.column=a.end.column,s=s.splice(u,s.length-u);var f=new i(o,s);return o.splice(o.indexOf(this)+1,0,f),f},this.merge=function(e){var t=e.folds;for(var n=0;n<t.length;n++)this.addFold(t[n]);var r=this.foldData;r.splice(r.indexOf(e),1);},this.toString=function(){var e=[this.range.toString()+": ["];return this.folds.forEach(function(t){e.push("  "+t.toString());}),e.push("]"),e.join("\n")},this.idxToPosition=function(e){var t=0;for(var n=0;n<this.folds.length;n++){var r=this.folds[n];e-=r.start.column-t;if(e<0)return {row:r.start.row,column:r.start.column+e};e-=r.placeholder.length;if(e<0)return r.start;t=r.end.column;}return {row:this.end.row,column:this.end.column+e}};}).call(i.prototype),t.FoldLine=i;}),define("ace/range_list",["require","exports","module","ace/range"],function(e,t,n){var r=e("./range").Range,i=r.comparePoints,s=function(){this.ranges=[];};(function(){this.comparePoints=i,this.pointIndex=function(e,t,n){var r=this.ranges;for(var s=n||0;s<r.length;s++){var o=r[s],u=i(e,o.end);if(u>0)continue;var a=i(e,o.start);return u===0?t&&a!==0?-s-2:s:a>0||a===0&&!t?s:-s-1}return -s-1},this.add=function(e){var t=!e.isEmpty(),n=this.pointIndex(e.start,t);n<0&&(n=-n-1);var r=this.pointIndex(e.end,t,n);return r<0?r=-r-1:r++,this.ranges.splice(n,r-n,e)},this.addList=function(e){var t=[];for(var n=e.length;n--;)t.push.apply(t,this.add(e[n]));return t},this.substractPoint=function(e){var t=this.pointIndex(e);if(t>=0)return this.ranges.splice(t,1)},this.merge=function(){var e=[],t=this.ranges;t=t.sort(function(e,t){return i(e.start,t.start)});var n=t[0],r;for(var s=1;s<t.length;s++){r=n,n=t[s];var o=i(r.end,n.start);if(o<0)continue;if(o==0&&!r.isEmpty()&&!n.isEmpty())continue;i(r.end,n.end)<0&&(r.end.row=n.end.row,r.end.column=n.end.column),t.splice(s,1),e.push(n),n=r,s--;}return this.ranges=t,e},this.contains=function(e,t){return this.pointIndex({row:e,column:t})>=0},this.containsPoint=function(e){return this.pointIndex(e)>=0},this.rangeAtPoint=function(e){var t=this.pointIndex(e);if(t>=0)return this.ranges[t]},this.clipRows=function(e,t){var n=this.ranges;if(n[0].start.row>t||n[n.length-1].start.row<e)return [];var r=this.pointIndex({row:e,column:0});r<0&&(r=-r-1);var i=this.pointIndex({row:t,column:0},r);i<0&&(i=-i-1);var s=[];for(var o=r;o<i;o++)s.push(n[o]);return s},this.removeAll=function(){return this.ranges.splice(0,this.ranges.length)},this.attach=function(e){this.session&&this.detach(),this.session=e,this.onChange=this.$onChange.bind(this),this.session.on("change",this.onChange);},this.detach=function(){if(!this.session)return;this.session.removeListener("change",this.onChange),this.session=null;},this.$onChange=function(e){var t=e.start,n=e.end,r=t.row,i=n.row,s=this.ranges;for(var o=0,u=s.length;o<u;o++){var a=s[o];if(a.end.row>=r)break}if(e.action=="insert"){var f=i-r,l=-t.column+n.column;for(;o<u;o++){var a=s[o];if(a.start.row>r)break;a.start.row==r&&a.start.column>=t.column&&(a.start.column!=t.column||!this.$insertRight)&&(a.start.column+=l,a.start.row+=f);if(a.end.row==r&&a.end.column>=t.column){if(a.end.column==t.column&&this.$insertRight)continue;a.end.column==t.column&&l>0&&o<u-1&&a.end.column>a.start.column&&a.end.column==s[o+1].start.column&&(a.end.column-=l),a.end.column+=l,a.end.row+=f;}}}else{var f=r-i,l=t.column-n.column;for(;o<u;o++){var a=s[o];if(a.start.row>i)break;if(a.end.row<i&&(r<a.end.row||r==a.end.row&&t.column<a.end.column))a.end.row=r,a.end.column=t.column;else if(a.end.row==i)if(a.end.column<=n.column){if(f||a.end.column>t.column)a.end.column=t.column,a.end.row=t.row;}else a.end.column+=l,a.end.row+=f;else a.end.row>i&&(a.end.row+=f);if(a.start.row<i&&(r<a.start.row||r==a.start.row&&t.column<a.start.column))a.start.row=r,a.start.column=t.column;else if(a.start.row==i)if(a.start.column<=n.column){if(f||a.start.column>t.column)a.start.column=t.column,a.start.row=t.row;}else a.start.column+=l,a.start.row+=f;else a.start.row>i&&(a.start.row+=f);}}if(f!=0&&o<u)for(;o<u;o++){var a=s[o];a.start.row+=f,a.end.row+=f;}};}).call(s.prototype),t.RangeList=s;}),define("ace/edit_session/fold",["require","exports","module","ace/range","ace/range_list","ace/lib/oop"],function(e,t,n){function u(e,t){e.row-=t.row,e.row==0&&(e.column-=t.column);}function a(e,t){u(e.start,t),u(e.end,t);}function f(e,t){e.row==0&&(e.column+=t.column),e.row+=t.row;}function l(e,t){f(e.start,t),f(e.end,t);}var r=e("../range").Range,i=e("../range_list").RangeList,s=e("../lib/oop"),o=t.Fold=function(e,t){this.foldLine=null,this.placeholder=t,this.range=e,this.start=e.start,this.end=e.end,this.sameRow=e.start.row==e.end.row,this.subFolds=this.ranges=[];};s.inherits(o,i),function(){this.toString=function(){return '"'+this.placeholder+'" '+this.range.toString()},this.setFoldLine=function(e){this.foldLine=e,this.subFolds.forEach(function(t){t.setFoldLine(e);});},this.clone=function(){var e=this.range.clone(),t=new o(e,this.placeholder);return this.subFolds.forEach(function(e){t.subFolds.push(e.clone());}),t.collapseChildren=this.collapseChildren,t},this.addSubFold=function(e){if(this.range.isEqual(e))return;if(!this.range.containsRange(e))throw new Error("A fold can't intersect already existing fold"+e.range+this.range);a(e,this.start);var t=e.start.row,n=e.start.column;for(var r=0,i=-1;r<this.subFolds.length;r++){i=this.subFolds[r].range.compare(t,n);if(i!=1)break}var s=this.subFolds[r];if(i==0)return s.addSubFold(e);var t=e.range.end.row,n=e.range.end.column;for(var o=r,i=-1;o<this.subFolds.length;o++){i=this.subFolds[o].range.compare(t,n);if(i!=1)break}var u=this.subFolds[o];if(i==0)throw new Error("A fold can't intersect already existing fold"+e.range+this.range);var f=this.subFolds.splice(r,o-r,e);return e.setFoldLine(this.foldLine),e},this.restoreRange=function(e){return l(e,this.start)};}.call(o.prototype);}),define("ace/edit_session/folding",["require","exports","module","ace/range","ace/edit_session/fold_line","ace/edit_session/fold","ace/token_iterator"],function(e,t,n){function u(){this.getFoldAt=function(e,t,n){var r=this.getFoldLine(e);if(!r)return null;var i=r.folds;for(var s=0;s<i.length;s++){var o=i[s];if(o.range.contains(e,t)){if(n==1&&o.range.isEnd(e,t))continue;if(n==-1&&o.range.isStart(e,t))continue;return o}}},this.getFoldsInRange=function(e){var t=e.start,n=e.end,r=this.$foldData,i=[];t.column+=1,n.column-=1;for(var s=0;s<r.length;s++){var o=r[s].range.compareRange(e);if(o==2)continue;if(o==-2)break;var u=r[s].folds;for(var a=0;a<u.length;a++){var f=u[a];o=f.range.compareRange(e);if(o==-2)break;if(o==2)continue;if(o==42)break;i.push(f);}}return t.column-=1,n.column+=1,i},this.getFoldsInRangeList=function(e){if(Array.isArray(e)){var t=[];e.forEach(function(e){t=t.concat(this.getFoldsInRange(e));},this);}else var t=this.getFoldsInRange(e);return t},this.getAllFolds=function(){var e=[],t=this.$foldData;for(var n=0;n<t.length;n++)for(var r=0;r<t[n].folds.length;r++)e.push(t[n].folds[r]);return e},this.getFoldStringAt=function(e,t,n,r){r=r||this.getFoldLine(e);if(!r)return null;var i={end:{column:0}},s,o;for(var u=0;u<r.folds.length;u++){o=r.folds[u];var a=o.range.compareEnd(e,t);if(a==-1){s=this.getLine(o.start.row).substring(i.end.column,o.start.column);break}if(a===0)return null;i=o;}return s||(s=this.getLine(o.start.row).substring(i.end.column)),n==-1?s.substring(0,t-i.end.column):n==1?s.substring(t-i.end.column):s},this.getFoldLine=function(e,t){var n=this.$foldData,r=0;t&&(r=n.indexOf(t)),r==-1&&(r=0);for(r;r<n.length;r++){var i=n[r];if(i.start.row<=e&&i.end.row>=e)return i;if(i.end.row>e)return null}return null},this.getNextFoldLine=function(e,t){var n=this.$foldData,r=0;t&&(r=n.indexOf(t)),r==-1&&(r=0);for(r;r<n.length;r++){var i=n[r];if(i.end.row>=e)return i}return null},this.getFoldedRowCount=function(e,t){var n=this.$foldData,r=t-e+1;for(var i=0;i<n.length;i++){var s=n[i],o=s.end.row,u=s.start.row;if(o>=t){u<t&&(u>=e?r-=t-u:r=0);break}o>=e&&(u>=e?r-=o-u:r-=o-e+1);}return r},this.$addFoldLine=function(e){return this.$foldData.push(e),this.$foldData.sort(function(e,t){return e.start.row-t.start.row}),e},this.addFold=function(e,t){var n=this.$foldData,r=!1,o;e instanceof s?o=e:(o=new s(t,e),o.collapseChildren=t.collapseChildren),this.$clipRangeToDocument(o.range);var u=o.start.row,a=o.start.column,f=o.end.row,l=o.end.column;if(u<f||u==f&&a<=l-2){var c=this.getFoldAt(u,a,1),h=this.getFoldAt(f,l,-1);if(c&&h==c)return c.addSubFold(o);c&&!c.range.isStart(u,a)&&this.removeFold(c),h&&!h.range.isEnd(f,l)&&this.removeFold(h);var p=this.getFoldsInRange(o.range);p.length>0&&(this.removeFolds(p),p.forEach(function(e){o.addSubFold(e);}));for(var d=0;d<n.length;d++){var v=n[d];if(f==v.start.row){v.addFold(o),r=!0;break}if(u==v.end.row){v.addFold(o),r=!0;if(!o.sameRow){var m=n[d+1];if(m&&m.start.row==f){v.merge(m);break}}break}if(f<=v.start.row)break}return r||(v=this.$addFoldLine(new i(this.$foldData,o))),this.$useWrapMode?this.$updateWrapData(v.start.row,v.start.row):this.$updateRowLengthCache(v.start.row,v.start.row),this.$modified=!0,this._signal("changeFold",{data:o,action:"add"}),o}throw new Error("The range has to be at least 2 characters width")},this.addFolds=function(e){e.forEach(function(e){this.addFold(e);},this);},this.removeFold=function(e){var t=e.foldLine,n=t.start.row,r=t.end.row,i=this.$foldData,s=t.folds;if(s.length==1)i.splice(i.indexOf(t),1);else if(t.range.isEnd(e.end.row,e.end.column))s.pop(),t.end.row=s[s.length-1].end.row,t.end.column=s[s.length-1].end.column;else if(t.range.isStart(e.start.row,e.start.column))s.shift(),t.start.row=s[0].start.row,t.start.column=s[0].start.column;else if(e.sameRow)s.splice(s.indexOf(e),1);else{var o=t.split(e.start.row,e.start.column);s=o.folds,s.shift(),o.start.row=s[0].start.row,o.start.column=s[0].start.column;}this.$updating||(this.$useWrapMode?this.$updateWrapData(n,r):this.$updateRowLengthCache(n,r)),this.$modified=!0,this._signal("changeFold",{data:e,action:"remove"});},this.removeFolds=function(e){var t=[];for(var n=0;n<e.length;n++)t.push(e[n]);t.forEach(function(e){this.removeFold(e);},this),this.$modified=!0;},this.expandFold=function(e){this.removeFold(e),e.subFolds.forEach(function(t){e.restoreRange(t),this.addFold(t);},this),e.collapseChildren>0&&this.foldAll(e.start.row+1,e.end.row,e.collapseChildren-1),e.subFolds=[];},this.expandFolds=function(e){e.forEach(function(e){this.expandFold(e);},this);},this.unfold=function(e,t){var n,i;e==null?(n=new r(0,0,this.getLength(),0),t=!0):typeof e=="number"?n=new r(e,0,e,this.getLine(e).length):"row"in e?n=r.fromPoints(e,e):n=e,i=this.getFoldsInRangeList(n);if(t)this.removeFolds(i);else{var s=i;while(s.length)this.expandFolds(s),s=this.getFoldsInRangeList(n);}if(i.length)return i},this.isRowFolded=function(e,t){return !!this.getFoldLine(e,t)},this.getRowFoldEnd=function(e,t){var n=this.getFoldLine(e,t);return n?n.end.row:e},this.getRowFoldStart=function(e,t){var n=this.getFoldLine(e,t);return n?n.start.row:e},this.getFoldDisplayLine=function(e,t,n,r,i){r==null&&(r=e.start.row),i==null&&(i=0),t==null&&(t=e.end.row),n==null&&(n=this.getLine(t).length);var s=this.doc,o="";return e.walk(function(e,t,n,u){if(t<r)return;if(t==r){if(n<i)return;u=Math.max(i,u);}e!=null?o+=e:o+=s.getLine(t).substring(u,n);},t,n),o},this.getDisplayLine=function(e,t,n,r){var i=this.getFoldLine(e);if(!i){var s;return s=this.doc.getLine(e),s.substring(r||0,t||s.length)}return this.getFoldDisplayLine(i,e,t,n,r)},this.$cloneFoldData=function(){var e=[];return e=this.$foldData.map(function(t){var n=t.folds.map(function(e){return e.clone()});return new i(e,n)}),e},this.toggleFold=function(e){var t=this.selection,n=t.getRange(),r,i;if(n.isEmpty()){var s=n.start;r=this.getFoldAt(s.row,s.column);if(r){this.expandFold(r);return}(i=this.findMatchingBracket(s))?n.comparePoint(i)==1?n.end=i:(n.start=i,n.start.column++,n.end.column--):(i=this.findMatchingBracket({row:s.row,column:s.column+1}))?(n.comparePoint(i)==1?n.end=i:n.start=i,n.start.column++):n=this.getCommentFoldRange(s.row,s.column)||n;}else{var o=this.getFoldsInRange(n);if(e&&o.length){this.expandFolds(o);return}o.length==1&&(r=o[0]);}r||(r=this.getFoldAt(n.start.row,n.start.column));if(r&&r.range.toString()==n.toString()){this.expandFold(r);return}var u="...";if(!n.isMultiLine()){u=this.getTextRange(n);if(u.length<4)return;u=u.trim().substring(0,2)+"..";}this.addFold(u,n);},this.getCommentFoldRange=function(e,t,n){var i=new o(this,e,t),s=i.getCurrentToken(),u=s.type;if(s&&/^comment|string/.test(u)){u=u.match(/comment|string/)[0],u=="comment"&&(u+="|doc-start");var a=new RegExp(u),f=new r;if(n!=1){do s=i.stepBackward();while(s&&a.test(s.type));i.stepForward();}f.start.row=i.getCurrentTokenRow(),f.start.column=i.getCurrentTokenColumn()+2,i=new o(this,e,t);if(n!=-1){var l=-1;do{s=i.stepForward();if(l==-1){var c=this.getState(i.$row);a.test(c)||(l=i.$row);}else if(i.$row>l)break}while(s&&a.test(s.type));s=i.stepBackward();}else s=i.getCurrentToken();return f.end.row=i.getCurrentTokenRow(),f.end.column=i.getCurrentTokenColumn()+s.value.length-2,f}},this.foldAll=function(e,t,n){n==undefined&&(n=1e5);var r=this.foldWidgets;if(!r)return;t=t||this.getLength(),e=e||0;for(var i=e;i<t;i++){r[i]==null&&(r[i]=this.getFoldWidget(i));if(r[i]!="start")continue;var s=this.getFoldWidgetRange(i);if(s&&s.isMultiLine()&&s.end.row<=t&&s.start.row>=e){i=s.end.row;try{var o=this.addFold("...",s);o&&(o.collapseChildren=n);}catch(u){}}}},this.$foldStyles={manual:1,markbegin:1,markbeginend:1},this.$foldStyle="markbegin",this.setFoldStyle=function(e){if(!this.$foldStyles[e])throw new Error("invalid fold style: "+e+"["+Object.keys(this.$foldStyles).join(", ")+"]");if(this.$foldStyle==e)return;this.$foldStyle=e,e=="manual"&&this.unfold();var t=this.$foldMode;this.$setFolding(null),this.$setFolding(t);},this.$setFolding=function(e){if(this.$foldMode==e)return;this.$foldMode=e,this.off("change",this.$updateFoldWidgets),this.off("tokenizerUpdate",this.$tokenizerUpdateFoldWidgets),this._signal("changeAnnotation");if(!e||this.$foldStyle=="manual"){this.foldWidgets=null;return}this.foldWidgets=[],this.getFoldWidget=e.getFoldWidget.bind(e,this,this.$foldStyle),this.getFoldWidgetRange=e.getFoldWidgetRange.bind(e,this,this.$foldStyle),this.$updateFoldWidgets=this.updateFoldWidgets.bind(this),this.$tokenizerUpdateFoldWidgets=this.tokenizerUpdateFoldWidgets.bind(this),this.on("change",this.$updateFoldWidgets),this.on("tokenizerUpdate",this.$tokenizerUpdateFoldWidgets);},this.getParentFoldRangeData=function(e,t){var n=this.foldWidgets;if(!n||t&&n[e])return {};var r=e-1,i;while(r>=0){var s=n[r];s==null&&(s=n[r]=this.getFoldWidget(r));if(s=="start"){var o=this.getFoldWidgetRange(r);i||(i=o);if(o&&o.end.row>=e)break}r--;}return {range:r!==-1&&o,firstRange:i}},this.onFoldWidgetClick=function(e,t){t=t.domEvent;var n={children:t.shiftKey,all:t.ctrlKey||t.metaKey,siblings:t.altKey},r=this.$toggleFoldWidget(e,n);if(!r){var i=t.target||t.srcElement;i&&/ace_fold-widget/.test(i.className)&&(i.className+=" ace_invalid");}},this.$toggleFoldWidget=function(e,t){if(!this.getFoldWidget)return;var n=this.getFoldWidget(e),r=this.getLine(e),i=n==="end"?-1:1,s=this.getFoldAt(e,i===-1?0:r.length,i);if(s)return t.children||t.all?this.removeFold(s):this.expandFold(s),s;var o=this.getFoldWidgetRange(e,!0);if(o&&!o.isMultiLine()){s=this.getFoldAt(o.start.row,o.start.column,1);if(s&&o.isEqual(s.range))return this.removeFold(s),s}if(t.siblings){var u=this.getParentFoldRangeData(e);if(u.range)var a=u.range.start.row+1,f=u.range.end.row;this.foldAll(a,f,t.all?1e4:0);}else t.children?(f=o?o.end.row:this.getLength(),this.foldAll(e+1,f,t.all?1e4:0)):o&&(t.all&&(o.collapseChildren=1e4),this.addFold("...",o));return o},this.toggleFoldWidget=function(e){var t=this.selection.getCursor().row;t=this.getRowFoldStart(t);var n=this.$toggleFoldWidget(t,{});if(n)return;var r=this.getParentFoldRangeData(t,!0);n=r.range||r.firstRange;if(n){t=n.start.row;var i=this.getFoldAt(t,this.getLine(t).length,1);i?this.removeFold(i):this.addFold("...",n);}},this.updateFoldWidgets=function(e){var t=e.start.row,n=e.end.row-t;if(n===0)this.foldWidgets[t]=null;else if(e.action=="remove")this.foldWidgets.splice(t,n+1,null);else{var r=Array(n+1);r.unshift(t,1),this.foldWidgets.splice.apply(this.foldWidgets,r);}},this.tokenizerUpdateFoldWidgets=function(e){var t=e.data;t.first!=t.last&&this.foldWidgets.length>t.first&&this.foldWidgets.splice(t.first,this.foldWidgets.length);};}var r=e("../range").Range,i=e("./fold_line").FoldLine,s=e("./fold").Fold,o=e("../token_iterator").TokenIterator;t.Folding=u;}),define("ace/edit_session/bracket_match",["require","exports","module","ace/token_iterator","ace/range"],function(e,t,n){function s(){this.findMatchingBracket=function(e,t){if(e.column==0)return null;var n=t||this.getLine(e.row).charAt(e.column-1);if(n=="")return null;var r=n.match(/([\(\[\{])|([\)\]\}])/);return r?r[1]?this.$findClosingBracket(r[1],e):this.$findOpeningBracket(r[2],e):null},this.getBracketRange=function(e){var t=this.getLine(e.row),n=!0,r,s=t.charAt(e.column-1),o=s&&s.match(/([\(\[\{])|([\)\]\}])/);o||(s=t.charAt(e.column),e={row:e.row,column:e.column+1},o=s&&s.match(/([\(\[\{])|([\)\]\}])/),n=!1);if(!o)return null;if(o[1]){var u=this.$findClosingBracket(o[1],e);if(!u)return null;r=i.fromPoints(e,u),n||(r.end.column++,r.start.column--),r.cursor=r.end;}else{var u=this.$findOpeningBracket(o[2],e);if(!u)return null;r=i.fromPoints(u,e),n||(r.start.column++,r.end.column--),r.cursor=r.start;}return r},this.$brackets={")":"(","(":")","]":"[","[":"]","{":"}","}":"{","<":">",">":"<"},this.$findOpeningBracket=function(e,t,n){var i=this.$brackets[e],s=1,o=new r(this,t.row,t.column),u=o.getCurrentToken();u||(u=o.stepForward());if(!u)return;n||(n=new RegExp("(\\.?"+u.type.replace(".","\\.").replace("rparen",".paren").replace(/\b(?:end)\b/,"(?:start|begin|end)")+")+"));var a=t.column-o.getCurrentTokenColumn()-2,f=u.value;for(;;){while(a>=0){var l=f.charAt(a);if(l==i){s-=1;if(s==0)return {row:o.getCurrentTokenRow(),column:a+o.getCurrentTokenColumn()}}else l==e&&(s+=1);a-=1;}do u=o.stepBackward();while(u&&!n.test(u.type));if(u==null)break;f=u.value,a=f.length-1;}return null},this.$findClosingBracket=function(e,t,n){var i=this.$brackets[e],s=1,o=new r(this,t.row,t.column),u=o.getCurrentToken();u||(u=o.stepForward());if(!u)return;n||(n=new RegExp("(\\.?"+u.type.replace(".","\\.").replace("lparen",".paren").replace(/\b(?:start|begin)\b/,"(?:start|begin|end)")+")+"));var a=t.column-o.getCurrentTokenColumn();for(;;){var f=u.value,l=f.length;while(a<l){var c=f.charAt(a);if(c==i){s-=1;if(s==0)return {row:o.getCurrentTokenRow(),column:a+o.getCurrentTokenColumn()}}else c==e&&(s+=1);a+=1;}do u=o.stepForward();while(u&&!n.test(u.type));if(u==null)break;a=0;}return null};}var r=e("../token_iterator").TokenIterator,i=e("../range").Range;t.BracketMatch=s;}),define("ace/edit_session",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/bidihandler","ace/config","ace/lib/event_emitter","ace/selection","ace/mode/text","ace/range","ace/document","ace/background_tokenizer","ace/search_highlight","ace/edit_session/folding","ace/edit_session/bracket_match"],function(e,t,n){var r=e("./lib/oop"),i=e("./lib/lang"),s=e("./bidihandler").BidiHandler,o=e("./config"),u=e("./lib/event_emitter").EventEmitter,a=e("./selection").Selection,f=e("./mode/text").Mode,l=e("./range").Range,c=e("./document").Document,h=e("./background_tokenizer").BackgroundTokenizer,p=e("./search_highlight").SearchHighlight,d=function(e,t){this.$breakpoints=[],this.$decorations=[],this.$frontMarkers={},this.$backMarkers={},this.$markerId=1,this.$undoSelect=!0,this.$foldData=[],this.id="session"+ ++d.$uid,this.$foldData.toString=function(){return this.join("\n")},this.on("changeFold",this.onChangeFold.bind(this)),this.$onChange=this.onChange.bind(this);if(typeof e!="object"||!e.getLine)e=new c(e);this.setDocument(e),this.selection=new a(this),this.$bidiHandler=new s(this),o.resetOptions(this),this.setMode(t),o._signal("session",this);};d.$uid=0,function(){function m(e){return e<4352?!1:e>=4352&&e<=4447||e>=4515&&e<=4519||e>=4602&&e<=4607||e>=9001&&e<=9002||e>=11904&&e<=11929||e>=11931&&e<=12019||e>=12032&&e<=12245||e>=12272&&e<=12283||e>=12288&&e<=12350||e>=12353&&e<=12438||e>=12441&&e<=12543||e>=12549&&e<=12589||e>=12593&&e<=12686||e>=12688&&e<=12730||e>=12736&&e<=12771||e>=12784&&e<=12830||e>=12832&&e<=12871||e>=12880&&e<=13054||e>=13056&&e<=19903||e>=19968&&e<=42124||e>=42128&&e<=42182||e>=43360&&e<=43388||e>=44032&&e<=55203||e>=55216&&e<=55238||e>=55243&&e<=55291||e>=63744&&e<=64255||e>=65040&&e<=65049||e>=65072&&e<=65106||e>=65108&&e<=65126||e>=65128&&e<=65131||e>=65281&&e<=65376||e>=65504&&e<=65510}r.implement(this,u),this.setDocument=function(e){this.doc&&this.doc.removeListener("change",this.$onChange),this.doc=e,e.on("change",this.$onChange),this.bgTokenizer&&this.bgTokenizer.setDocument(this.getDocument()),this.resetCaches();},this.getDocument=function(){return this.doc},this.$resetRowCache=function(e){if(!e){this.$docRowCache=[],this.$screenRowCache=[];return}var t=this.$docRowCache.length,n=this.$getRowCacheIndex(this.$docRowCache,e)+1;t>n&&(this.$docRowCache.splice(n,t),this.$screenRowCache.splice(n,t));},this.$getRowCacheIndex=function(e,t){var n=0,r=e.length-1;while(n<=r){var i=n+r>>1,s=e[i];if(t>s)n=i+1;else{if(!(t<s))return i;r=i-1;}}return n-1},this.resetCaches=function(){this.$modified=!0,this.$wrapData=[],this.$rowLengthCache=[],this.$resetRowCache(0),this.bgTokenizer&&this.bgTokenizer.start(0);},this.onChangeFold=function(e){var t=e.data;this.$resetRowCache(t.start.row);},this.onChange=function(e){this.$modified=!0,this.$bidiHandler.onChange(e),this.$resetRowCache(e.start.row);var t=this.$updateInternalDataOnChange(e);!this.$fromUndo&&this.$undoManager&&(t&&t.length&&(this.$undoManager.add({action:"removeFolds",folds:t},this.mergeUndoDeltas),this.mergeUndoDeltas=!0),this.$undoManager.add(e,this.mergeUndoDeltas),this.mergeUndoDeltas=!0,this.$informUndoManager.schedule()),this.bgTokenizer&&this.bgTokenizer.$updateOnChange(e),this._signal("change",e);},this.setValue=function(e){this.doc.setValue(e),this.selection.moveTo(0,0),this.$resetRowCache(0),this.setUndoManager(this.$undoManager),this.getUndoManager().reset();},this.getValue=this.toString=function(){return this.doc.getValue()},this.getSelection=function(){return this.selection},this.getState=function(e){return this.bgTokenizer.getState(e)},this.getTokens=function(e){return this.bgTokenizer.getTokens(e)},this.getTokenAt=function(e,t){var n=this.bgTokenizer.getTokens(e),r,i=0;if(t==null){var s=n.length-1;i=this.getLine(e).length;}else for(var s=0;s<n.length;s++){i+=n[s].value.length;if(i>=t)break}return r=n[s],r?(r.index=s,r.start=i-r.value.length,r):null},this.setUndoManager=function(e){this.$undoManager=e,this.$informUndoManager&&this.$informUndoManager.cancel();if(e){var t=this;e.addSession(this),this.$syncInformUndoManager=function(){t.$informUndoManager.cancel(),t.mergeUndoDeltas=!1;},this.$informUndoManager=i.delayedCall(this.$syncInformUndoManager);}else this.$syncInformUndoManager=function(){};},this.markUndoGroup=function(){this.$syncInformUndoManager&&this.$syncInformUndoManager();},this.$defaultUndoManager={undo:function(){},redo:function(){},reset:function(){},add:function(){},addSelection:function(){},startNewGroup:function(){},addSession:function(){}},this.getUndoManager=function(){return this.$undoManager||this.$defaultUndoManager},this.getTabString=function(){return this.getUseSoftTabs()?i.stringRepeat(" ",this.getTabSize()):"	"},this.setUseSoftTabs=function(e){this.setOption("useSoftTabs",e);},this.getUseSoftTabs=function(){return this.$useSoftTabs&&!this.$mode.$indentWithTabs},this.setTabSize=function(e){this.setOption("tabSize",e);},this.getTabSize=function(){return this.$tabSize},this.isTabStop=function(e){return this.$useSoftTabs&&e.column%this.$tabSize===0},this.setNavigateWithinSoftTabs=function(e){this.setOption("navigateWithinSoftTabs",e);},this.getNavigateWithinSoftTabs=function(){return this.$navigateWithinSoftTabs},this.$overwrite=!1,this.setOverwrite=function(e){this.setOption("overwrite",e);},this.getOverwrite=function(){return this.$overwrite},this.toggleOverwrite=function(){this.setOverwrite(!this.$overwrite);},this.addGutterDecoration=function(e,t){this.$decorations[e]||(this.$decorations[e]=""),this.$decorations[e]+=" "+t,this._signal("changeBreakpoint",{});},this.removeGutterDecoration=function(e,t){this.$decorations[e]=(this.$decorations[e]||"").replace(" "+t,""),this._signal("changeBreakpoint",{});},this.getBreakpoints=function(){return this.$breakpoints},this.setBreakpoints=function(e){this.$breakpoints=[];for(var t=0;t<e.length;t++)this.$breakpoints[e[t]]="ace_breakpoint";this._signal("changeBreakpoint",{});},this.clearBreakpoints=function(){this.$breakpoints=[],this._signal("changeBreakpoint",{});},this.setBreakpoint=function(e,t){t===undefined&&(t="ace_breakpoint"),t?this.$breakpoints[e]=t:delete this.$breakpoints[e],this._signal("changeBreakpoint",{});},this.clearBreakpoint=function(e){delete this.$breakpoints[e],this._signal("changeBreakpoint",{});},this.addMarker=function(e,t,n,r){var i=this.$markerId++,s={range:e,type:n||"line",renderer:typeof n=="function"?n:null,clazz:t,inFront:!!r,id:i};return r?(this.$frontMarkers[i]=s,this._signal("changeFrontMarker")):(this.$backMarkers[i]=s,this._signal("changeBackMarker")),i},this.addDynamicMarker=function(e,t){if(!e.update)return;var n=this.$markerId++;return e.id=n,e.inFront=!!t,t?(this.$frontMarkers[n]=e,this._signal("changeFrontMarker")):(this.$backMarkers[n]=e,this._signal("changeBackMarker")),e},this.removeMarker=function(e){var t=this.$frontMarkers[e]||this.$backMarkers[e];if(!t)return;var n=t.inFront?this.$frontMarkers:this.$backMarkers;delete n[e],this._signal(t.inFront?"changeFrontMarker":"changeBackMarker");},this.getMarkers=function(e){return e?this.$frontMarkers:this.$backMarkers},this.highlight=function(e){if(!this.$searchHighlight){var t=new p(null,"ace_selected-word","text");this.$searchHighlight=this.addDynamicMarker(t);}this.$searchHighlight.setRegexp(e);},this.highlightLines=function(e,t,n,r){typeof t!="number"&&(n=t,t=e),n||(n="ace_step");var i=new l(e,0,t,Infinity);return i.id=this.addMarker(i,n,"fullLine",r),i},this.setAnnotations=function(e){this.$annotations=e,this._signal("changeAnnotation",{});},this.getAnnotations=function(){return this.$annotations||[]},this.clearAnnotations=function(){this.setAnnotations([]);},this.$detectNewLine=function(e){var t=e.match(/^.*?(\r?\n)/m);t?this.$autoNewLine=t[1]:this.$autoNewLine="\n";},this.getWordRange=function(e,t){var n=this.getLine(e),r=!1;t>0&&(r=!!n.charAt(t-1).match(this.tokenRe)),r||(r=!!n.charAt(t).match(this.tokenRe));if(r)var i=this.tokenRe;else if(/^\s+$/.test(n.slice(t-1,t+1)))var i=/\s/;else var i=this.nonTokenRe;var s=t;if(s>0){do s--;while(s>=0&&n.charAt(s).match(i));s++;}var o=t;while(o<n.length&&n.charAt(o).match(i))o++;return new l(e,s,e,o)},this.getAWordRange=function(e,t){var n=this.getWordRange(e,t),r=this.getLine(n.end.row);while(r.charAt(n.end.column).match(/[ \t]/))n.end.column+=1;return n},this.setNewLineMode=function(e){this.doc.setNewLineMode(e);},this.getNewLineMode=function(){return this.doc.getNewLineMode()},this.setUseWorker=function(e){this.setOption("useWorker",e);},this.getUseWorker=function(){return this.$useWorker},this.onReloadTokenizer=function(e){var t=e.data;this.bgTokenizer.start(t.first),this._signal("tokenizerUpdate",e);},this.$modes=o.$modes,this.$mode=null,this.$modeId=null,this.setMode=function(e,t){if(e&&typeof e=="object"){if(e.getTokenizer)return this.$onChangeMode(e);var n=e,r=n.path;}else r=e||"ace/mode/text";this.$modes["ace/mode/text"]||(this.$modes["ace/mode/text"]=new f);if(this.$modes[r]&&!n){this.$onChangeMode(this.$modes[r]),t&&t();return}this.$modeId=r,o.loadModule(["mode",r],function(e){if(this.$modeId!==r)return t&&t();this.$modes[r]&&!n?this.$onChangeMode(this.$modes[r]):e&&e.Mode&&(e=new e.Mode(n),n||(this.$modes[r]=e,e.$id=r),this.$onChangeMode(e)),t&&t();}.bind(this)),this.$mode||this.$onChangeMode(this.$modes["ace/mode/text"],!0);},this.$onChangeMode=function(e,t){t||(this.$modeId=e.$id);if(this.$mode===e)return;this.$mode=e,this.$stopWorker(),this.$useWorker&&this.$startWorker();var n=e.getTokenizer();if(n.addEventListener!==undefined){var r=this.onReloadTokenizer.bind(this);n.addEventListener("update",r);}if(!this.bgTokenizer){this.bgTokenizer=new h(n);var i=this;this.bgTokenizer.addEventListener("update",function(e){i._signal("tokenizerUpdate",e);});}else this.bgTokenizer.setTokenizer(n);this.bgTokenizer.setDocument(this.getDocument()),this.tokenRe=e.tokenRe,this.nonTokenRe=e.nonTokenRe,t||(e.attachToSession&&e.attachToSession(this),this.$options.wrapMethod.set.call(this,this.$wrapMethod),this.$setFolding(e.foldingRules),this.bgTokenizer.start(0),this._emit("changeMode"));},this.$stopWorker=function(){this.$worker&&(this.$worker.terminate(),this.$worker=null);},this.$startWorker=function(){try{this.$worker=this.$mode.createWorker(this);}catch(e){o.warn("Could not load worker",e),this.$worker=null;}},this.getMode=function(){return this.$mode},this.$scrollTop=0,this.setScrollTop=function(e){if(this.$scrollTop===e||isNaN(e))return;this.$scrollTop=e,this._signal("changeScrollTop",e);},this.getScrollTop=function(){return this.$scrollTop},this.$scrollLeft=0,this.setScrollLeft=function(e){if(this.$scrollLeft===e||isNaN(e))return;this.$scrollLeft=e,this._signal("changeScrollLeft",e);},this.getScrollLeft=function(){return this.$scrollLeft},this.getScreenWidth=function(){return this.$computeWidth(),this.lineWidgets?Math.max(this.getLineWidgetMaxWidth(),this.screenWidth):this.screenWidth},this.getLineWidgetMaxWidth=function(){if(this.lineWidgetsWidth!=null)return this.lineWidgetsWidth;var e=0;return this.lineWidgets.forEach(function(t){t&&t.screenWidth>e&&(e=t.screenWidth);}),this.lineWidgetWidth=e},this.$computeWidth=function(e){if(this.$modified||e){this.$modified=!1;if(this.$useWrapMode)return this.screenWidth=this.$wrapLimit;var t=this.doc.getAllLines(),n=this.$rowLengthCache,r=0,i=0,s=this.$foldData[i],o=s?s.start.row:Infinity,u=t.length;for(var a=0;a<u;a++){if(a>o){a=s.end.row+1;if(a>=u)break;s=this.$foldData[i++],o=s?s.start.row:Infinity;}n[a]==null&&(n[a]=this.$getStringScreenWidth(t[a])[0]),n[a]>r&&(r=n[a]);}this.screenWidth=r;}},this.getLine=function(e){return this.doc.getLine(e)},this.getLines=function(e,t){return this.doc.getLines(e,t)},this.getLength=function(){return this.doc.getLength()},this.getTextRange=function(e){return this.doc.getTextRange(e||this.selection.getRange())},this.insert=function(e,t){return this.doc.insert(e,t)},this.remove=function(e){return this.doc.remove(e)},this.removeFullLines=function(e,t){return this.doc.removeFullLines(e,t)},this.undoChanges=function(e,t){if(!e.length)return;this.$fromUndo=!0;for(var n=e.length-1;n!=-1;n--){var r=e[n];r.action=="insert"||r.action=="remove"?this.doc.revertDelta(r):r.folds&&this.addFolds(r.folds);}!t&&this.$undoSelect&&(e.selectionBefore?this.selection.fromJSON(e.selectionBefore):this.selection.setRange(this.$getUndoSelection(e,!0))),this.$fromUndo=!1;},this.redoChanges=function(e,t){if(!e.length)return;this.$fromUndo=!0;for(var n=0;n<e.length;n++){var r=e[n];(r.action=="insert"||r.action=="remove")&&this.doc.applyDelta(r);}!t&&this.$undoSelect&&(e.selectionAfter?this.selection.fromJSON(e.selectionAfter):this.selection.setRange(this.$getUndoSelection(e,!1))),this.$fromUndo=!1;},this.setUndoSelect=function(e){this.$undoSelect=e;},this.$getUndoSelection=function(e,t){function n(e){return t?e.action!=="insert":e.action==="insert"}var r,i,s;for(var o=0;o<e.length;o++){var u=e[o];if(!u.start)continue;if(!r){n(u)?(r=l.fromPoints(u.start,u.end),s=!0):(r=l.fromPoints(u.start,u.start),s=!1);continue}n(u)?(i=u.start,r.compare(i.row,i.column)==-1&&r.setStart(i),i=u.end,r.compare(i.row,i.column)==1&&r.setEnd(i),s=!0):(i=u.start,r.compare(i.row,i.column)==-1&&(r=l.fromPoints(u.start,u.start)),s=!1);}return r},this.replace=function(e,t){return this.doc.replace(e,t)},this.moveText=function(e,t,n){var r=this.getTextRange(e),i=this.getFoldsInRange(e),s=l.fromPoints(t,t);if(!n){this.remove(e);var o=e.start.row-e.end.row,u=o?-e.end.column:e.start.column-e.end.column;u&&(s.start.row==e.end.row&&s.start.column>e.end.column&&(s.start.column+=u),s.end.row==e.end.row&&s.end.column>e.end.column&&(s.end.column+=u)),o&&s.start.row>=e.end.row&&(s.start.row+=o,s.end.row+=o);}s.end=this.insert(s.start,r);if(i.length){var a=e.start,f=s.start,o=f.row-a.row,u=f.column-a.column;this.addFolds(i.map(function(e){return e=e.clone(),e.start.row==a.row&&(e.start.column+=u),e.end.row==a.row&&(e.end.column+=u),e.start.row+=o,e.end.row+=o,e}));}return s},this.indentRows=function(e,t,n){n=n.replace(/\t/g,this.getTabString());for(var r=e;r<=t;r++)this.doc.insertInLine({row:r,column:0},n);},this.outdentRows=function(e){var t=e.collapseRows(),n=new l(0,0,0,0),r=this.getTabSize();for(var i=t.start.row;i<=t.end.row;++i){var s=this.getLine(i);n.start.row=i,n.end.row=i;for(var o=0;o<r;++o)if(s.charAt(o)!=" ")break;o<r&&s.charAt(o)=="	"?(n.start.column=o,n.end.column=o+1):(n.start.column=0,n.end.column=o),this.remove(n);}},this.$moveLines=function(e,t,n){e=this.getRowFoldStart(e),t=this.getRowFoldEnd(t);if(n<0){var r=this.getRowFoldStart(e+n);if(r<0)return 0;var i=r-e;}else if(n>0){var r=this.getRowFoldEnd(t+n);if(r>this.doc.getLength()-1)return 0;var i=r-t;}else{e=this.$clipRowToDocument(e),t=this.$clipRowToDocument(t);var i=t-e+1;}var s=new l(e,0,t,Number.MAX_VALUE),o=this.getFoldsInRange(s).map(function(e){return e=e.clone(),e.start.row+=i,e.end.row+=i,e}),u=n==0?this.doc.getLines(e,t):this.doc.removeFullLines(e,t);return this.doc.insertFullLines(e+i,u),o.length&&this.addFolds(o),i},this.moveLinesUp=function(e,t){return this.$moveLines(e,t,-1)},this.moveLinesDown=function(e,t){return this.$moveLines(e,t,1)},this.duplicateLines=function(e,t){return this.$moveLines(e,t,0)},this.$clipRowToDocument=function(e){return Math.max(0,Math.min(e,this.doc.getLength()-1))},this.$clipColumnToRow=function(e,t){return t<0?0:Math.min(this.doc.getLine(e).length,t)},this.$clipPositionToDocument=function(e,t){t=Math.max(0,t);if(e<0)e=0,t=0;else{var n=this.doc.getLength();e>=n?(e=n-1,t=this.doc.getLine(n-1).length):t=Math.min(this.doc.getLine(e).length,t);}return {row:e,column:t}},this.$clipRangeToDocument=function(e){e.start.row<0?(e.start.row=0,e.start.column=0):e.start.column=this.$clipColumnToRow(e.start.row,e.start.column);var t=this.doc.getLength()-1;return e.end.row>t?(e.end.row=t,e.end.column=this.doc.getLine(t).length):e.end.column=this.$clipColumnToRow(e.end.row,e.end.column),e},this.$wrapLimit=80,this.$useWrapMode=!1,this.$wrapLimitRange={min:null,max:null},this.setUseWrapMode=function(e){if(e!=this.$useWrapMode){this.$useWrapMode=e,this.$modified=!0,this.$resetRowCache(0);if(e){var t=this.getLength();this.$wrapData=Array(t),this.$updateWrapData(0,t-1);}this._signal("changeWrapMode");}},this.getUseWrapMode=function(){return this.$useWrapMode},this.setWrapLimitRange=function(e,t){if(this.$wrapLimitRange.min!==e||this.$wrapLimitRange.max!==t)this.$wrapLimitRange={min:e,max:t},this.$modified=!0,this.$bidiHandler.markAsDirty(),this.$useWrapMode&&this._signal("changeWrapMode");},this.adjustWrapLimit=function(e,t){var n=this.$wrapLimitRange;n.max<0&&(n={min:t,max:t});var r=this.$constrainWrapLimit(e,n.min,n.max);return r!=this.$wrapLimit&&r>1?(this.$wrapLimit=r,this.$modified=!0,this.$useWrapMode&&(this.$updateWrapData(0,this.getLength()-1),this.$resetRowCache(0),this._signal("changeWrapLimit")),!0):!1},this.$constrainWrapLimit=function(e,t,n){return t&&(e=Math.max(t,e)),n&&(e=Math.min(n,e)),e},this.getWrapLimit=function(){return this.$wrapLimit},this.setWrapLimit=function(e){this.setWrapLimitRange(e,e);},this.getWrapLimitRange=function(){return {min:this.$wrapLimitRange.min,max:this.$wrapLimitRange.max}},this.$updateInternalDataOnChange=function(e){var t=this.$useWrapMode,n=e.action,r=e.start,i=e.end,s=r.row,o=i.row,u=o-s,a=null;this.$updating=!0;if(u!=0)if(n==="remove"){this[t?"$wrapData":"$rowLengthCache"].splice(s,u);var f=this.$foldData;a=this.getFoldsInRange(e),this.removeFolds(a);var l=this.getFoldLine(i.row),c=0;if(l){l.addRemoveChars(i.row,i.column,r.column-i.column),l.shiftRow(-u);var h=this.getFoldLine(s);h&&h!==l&&(h.merge(l),l=h),c=f.indexOf(l)+1;}for(c;c<f.length;c++){var l=f[c];l.start.row>=i.row&&l.shiftRow(-u);}o=s;}else{var p=Array(u);p.unshift(s,0);var d=t?this.$wrapData:this.$rowLengthCache;d.splice.apply(d,p);var f=this.$foldData,l=this.getFoldLine(s),c=0;if(l){var v=l.range.compareInside(r.row,r.column);v==0?(l=l.split(r.row,r.column),l&&(l.shiftRow(u),l.addRemoveChars(o,0,i.column-r.column))):v==-1&&(l.addRemoveChars(s,0,i.column-r.column),l.shiftRow(u)),c=f.indexOf(l)+1;}for(c;c<f.length;c++){var l=f[c];l.start.row>=s&&l.shiftRow(u);}}else{u=Math.abs(e.start.column-e.end.column),n==="remove"&&(a=this.getFoldsInRange(e),this.removeFolds(a),u=-u);var l=this.getFoldLine(s);l&&l.addRemoveChars(s,r.column,u);}return t&&this.$wrapData.length!=this.doc.getLength()&&console.error("doc.getLength() and $wrapData.length have to be the same!"),this.$updating=!1,t?this.$updateWrapData(s,o):this.$updateRowLengthCache(s,o),a},this.$updateRowLengthCache=function(e,t,n){this.$rowLengthCache[e]=null,this.$rowLengthCache[t]=null;},this.$updateWrapData=function(e,t){var r=this.doc.getAllLines(),i=this.getTabSize(),o=this.$wrapData,u=this.$wrapLimit,a,f,l=e;t=Math.min(t,r.length-1);while(l<=t)f=this.getFoldLine(l,f),f?(a=[],f.walk(function(e,t,i,o){var u;if(e!=null){u=this.$getDisplayTokens(e,a.length),u[0]=n;for(var f=1;f<u.length;f++)u[f]=s;}else u=this.$getDisplayTokens(r[t].substring(o,i),a.length);a=a.concat(u);}.bind(this),f.end.row,r[f.end.row].length+1),o[f.start.row]=this.$computeWrapSplits(a,u,i),l=f.end.row+1):(a=this.$getDisplayTokens(r[l]),o[l]=this.$computeWrapSplits(a,u,i),l++);};var e=1,t=2,n=3,s=4,a=9,c=10,d=11,v=12;this.$computeWrapSplits=function(e,r,i){function g(){var t=0;if(m===0)return t;if(p)for(var n=0;n<e.length;n++){var r=e[n];if(r==c)t+=1;else{if(r!=d){if(r==v)continue;break}t+=i;}}return h&&p!==!1&&(t+=i),Math.min(t,m)}function y(t){var n=t-f;for(var r=f;r<t;r++){var i=e[r];if(i===12||i===2)n-=1;}o.length||(b=g(),o.indent=b),l+=n,o.push(l),f=t;}if(e.length==0)return [];var o=[],u=e.length,f=0,l=0,h=this.$wrapAsCode,p=this.$indentedSoftWrap,m=r<=Math.max(2*i,8)||p===!1?0:Math.floor(r/2),b=0;while(u-f>r-b){var w=f+r-b;if(e[w-1]>=c&&e[w]>=c){y(w);continue}if(e[w]==n||e[w]==s){for(w;w!=f-1;w--)if(e[w]==n)break;if(w>f){y(w);continue}w=f+r;for(w;w<e.length;w++)if(e[w]!=s)break;if(w==e.length)break;y(w);continue}var E=Math.max(w-(r-(r>>2)),f-1);while(w>E&&e[w]<n)w--;if(h){while(w>E&&e[w]<n)w--;while(w>E&&e[w]==a)w--;}else while(w>E&&e[w]<c)w--;if(w>E){y(++w);continue}w=f+r,e[w]==t&&w--,y(w-b);}return o},this.$getDisplayTokens=function(n,r){var i=[],s;r=r||0;for(var o=0;o<n.length;o++){var u=n.charCodeAt(o);if(u==9){s=this.getScreenTabSize(i.length+r),i.push(d);for(var f=1;f<s;f++)i.push(v);}else u==32?i.push(c):u>39&&u<48||u>57&&u<64?i.push(a):u>=4352&&m(u)?i.push(e,t):i.push(e);}return i},this.$getStringScreenWidth=function(e,t,n){if(t==0)return [0,0];t==null&&(t=Infinity),n=n||0;var r,i;for(i=0;i<e.length;i++){r=e.charCodeAt(i),r==9?n+=this.getScreenTabSize(n):r>=4352&&m(r)?n+=2:n+=1;if(n>t)break}return [n,i]},this.lineWidgets=null,this.getRowLength=function(e){if(this.lineWidgets)var t=this.lineWidgets[e]&&this.lineWidgets[e].rowCount||0;else t=0;return !this.$useWrapMode||!this.$wrapData[e]?1+t:this.$wrapData[e].length+1+t},this.getRowLineCount=function(e){return !this.$useWrapMode||!this.$wrapData[e]?1:this.$wrapData[e].length+1},this.getRowWrapIndent=function(e){if(this.$useWrapMode){var t=this.screenToDocumentPosition(e,Number.MAX_VALUE),n=this.$wrapData[t.row];return n.length&&n[0]<t.column?n.indent:0}return 0},this.getScreenLastRowColumn=function(e){var t=this.screenToDocumentPosition(e,Number.MAX_VALUE);return this.documentToScreenColumn(t.row,t.column)},this.getDocumentLastRowColumn=function(e,t){var n=this.documentToScreenRow(e,t);return this.getScreenLastRowColumn(n)},this.getDocumentLastRowColumnPosition=function(e,t){var n=this.documentToScreenRow(e,t);return this.screenToDocumentPosition(n,Number.MAX_VALUE/10)},this.getRowSplitData=function(e){return this.$useWrapMode?this.$wrapData[e]:undefined},this.getScreenTabSize=function(e){return this.$tabSize-e%this.$tabSize},this.screenToDocumentRow=function(e,t){return this.screenToDocumentPosition(e,t).row},this.screenToDocumentColumn=function(e,t){return this.screenToDocumentPosition(e,t).column},this.screenToDocumentPosition=function(e,t,n){if(e<0)return {row:0,column:0};var r,i=0,s=0,o,u=0,a=0,f=this.$screenRowCache,l=this.$getRowCacheIndex(f,e),c=f.length;if(c&&l>=0)var u=f[l],i=this.$docRowCache[l],h=e>f[c-1];else var h=!c;var p=this.getLength()-1,d=this.getNextFoldLine(i),v=d?d.start.row:Infinity;while(u<=e){a=this.getRowLength(i);if(u+a>e||i>=p)break;u+=a,i++,i>v&&(i=d.end.row+1,d=this.getNextFoldLine(i,d),v=d?d.start.row:Infinity),h&&(this.$docRowCache.push(i),this.$screenRowCache.push(u));}if(d&&d.start.row<=i)r=this.getFoldDisplayLine(d),i=d.start.row;else{if(u+a<=e||i>p)return {row:p,column:this.getLine(p).length};r=this.getLine(i),d=null;}var m=0,g=Math.floor(e-u);if(this.$useWrapMode){var y=this.$wrapData[i];y&&(o=y[g],g>0&&y.length&&(m=y.indent,s=y[g-1]||y[y.length-1],r=r.substring(s)));}return n!==undefined&&this.$bidiHandler.isBidiRow(u+g,i,g)&&(t=this.$bidiHandler.offsetToCol(n)),s+=this.$getStringScreenWidth(r,t-m)[1],this.$useWrapMode&&s>=o&&(s=o-1),d?d.idxToPosition(s):{row:i,column:s}},this.documentToScreenPosition=function(e,t){if(typeof t=="undefined")var n=this.$clipPositionToDocument(e.row,e.column);else n=this.$clipPositionToDocument(e,t);e=n.row,t=n.column;var r=0,i=null,s=null;s=this.getFoldAt(e,t,1),s&&(e=s.start.row,t=s.start.column);var o,u=0,a=this.$docRowCache,f=this.$getRowCacheIndex(a,e),l=a.length;if(l&&f>=0)var u=a[f],r=this.$screenRowCache[f],c=e>a[l-1];else var c=!l;var h=this.getNextFoldLine(u),p=h?h.start.row:Infinity;while(u<e){if(u>=p){o=h.end.row+1;if(o>e)break;h=this.getNextFoldLine(o,h),p=h?h.start.row:Infinity;}else o=u+1;r+=this.getRowLength(u),u=o,c&&(this.$docRowCache.push(u),this.$screenRowCache.push(r));}var d="";h&&u>=p?(d=this.getFoldDisplayLine(h,e,t),i=h.start.row):(d=this.getLine(e).substring(0,t),i=e);var v=0;if(this.$useWrapMode){var m=this.$wrapData[i];if(m){var g=0;while(d.length>=m[g])r++,g++;d=d.substring(m[g-1]||0,d.length),v=g>0?m.indent:0;}}return {row:r,column:v+this.$getStringScreenWidth(d)[0]}},this.documentToScreenColumn=function(e,t){return this.documentToScreenPosition(e,t).column},this.documentToScreenRow=function(e,t){return this.documentToScreenPosition(e,t).row},this.getScreenLength=function(){var e=0,t=null;if(!this.$useWrapMode){e=this.getLength();var n=this.$foldData;for(var r=0;r<n.length;r++)t=n[r],e-=t.end.row-t.start.row;}else{var i=this.$wrapData.length,s=0,r=0,t=this.$foldData[r++],o=t?t.start.row:Infinity;while(s<i){var u=this.$wrapData[s];e+=u?u.length+1:1,s++,s>o&&(s=t.end.row+1,t=this.$foldData[r++],o=t?t.start.row:Infinity);}}return this.lineWidgets&&(e+=this.$getWidgetScreenLength()),e},this.$setFontMetrics=function(e){if(!this.$enableVarChar)return;this.$getStringScreenWidth=function(t,n,r){if(n===0)return [0,0];n||(n=Infinity),r=r||0;var i,s;for(s=0;s<t.length;s++){i=t.charAt(s),i==="	"?r+=this.getScreenTabSize(r):r+=e.getCharacterWidth(i);if(r>n)break}return [r,s]};},this.destroy=function(){this.bgTokenizer&&(this.bgTokenizer.setDocument(null),this.bgTokenizer=null),this.$stopWorker();},this.isFullWidth=m;}.call(d.prototype),e("./edit_session/folding").Folding.call(d.prototype),e("./edit_session/bracket_match").BracketMatch.call(d.prototype),o.defineOptions(d.prototype,"session",{wrap:{set:function(e){!e||e=="off"?e=!1:e=="free"?e=!0:e=="printMargin"?e=-1:typeof e=="string"&&(e=parseInt(e,10)||!1);if(this.$wrap==e)return;this.$wrap=e;if(!e)this.setUseWrapMode(!1);else{var t=typeof e=="number"?e:null;this.setWrapLimitRange(t,t),this.setUseWrapMode(!0);}},get:function(){return this.getUseWrapMode()?this.$wrap==-1?"printMargin":this.getWrapLimitRange().min?this.$wrap:"free":"off"},handlesSet:!0},wrapMethod:{set:function(e){e=e=="auto"?this.$mode.type!="text":e!="text",e!=this.$wrapAsCode&&(this.$wrapAsCode=e,this.$useWrapMode&&(this.$useWrapMode=!1,this.setUseWrapMode(!0)));},initialValue:"auto"},indentedSoftWrap:{set:function(){this.$useWrapMode&&(this.$useWrapMode=!1,this.setUseWrapMode(!0));},initialValue:!0},firstLineNumber:{set:function(){this._signal("changeBreakpoint");},initialValue:1},useWorker:{set:function(e){this.$useWorker=e,this.$stopWorker(),e&&this.$startWorker();},initialValue:!0},useSoftTabs:{initialValue:!0},tabSize:{set:function(e){e=parseInt(e);if(isNaN(e)||this.$tabSize===e)return;this.$modified=!0,this.$rowLengthCache=[],this.$tabSize=e,this._signal("changeTabSize");},initialValue:4,handlesSet:!0},navigateWithinSoftTabs:{initialValue:!1},foldStyle:{set:function(e){this.setFoldStyle(e);},handlesSet:!0},overwrite:{set:function(e){this._signal("changeOverwrite");},initialValue:!1},newLineMode:{set:function(e){this.doc.setNewLineMode(e);},get:function(){return this.doc.getNewLineMode()},handlesSet:!0},mode:{set:function(e){this.setMode(e);},get:function(){return this.$modeId},handlesSet:!0}}),t.EditSession=d;}),define("ace/search",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"],function(e,t,n){function u(e,t){function n(e){return /\w/.test(e)||t.regExp?"\\b":""}return n(e[0])+e+n(e[e.length-1])}var r=e("./lib/lang"),i=e("./lib/oop"),s=e("./range").Range,o=function(){this.$options={};};(function(){this.set=function(e){return i.mixin(this.$options,e),this},this.getOptions=function(){return r.copyObject(this.$options)},this.setOptions=function(e){this.$options=e;},this.find=function(e){var t=this.$options,n=this.$matchIterator(e,t);if(!n)return !1;var r=null;return n.forEach(function(e,n,i,o){return r=new s(e,n,i,o),n==o&&t.start&&t.start.start&&t.skipCurrent!=0&&r.isEqual(t.start)?(r=null,!1):!0}),r},this.findAll=function(e){var t=this.$options;if(!t.needle)return [];this.$assembleRegExp(t);var n=t.range,i=n?e.getLines(n.start.row,n.end.row):e.doc.getAllLines(),o=[],u=t.re;if(t.$isMultiLine){var a=u.length,f=i.length-a,l;e:for(var c=u.offset||0;c<=f;c++){for(var h=0;h<a;h++)if(i[c+h].search(u[h])==-1)continue e;var p=i[c],d=i[c+a-1],v=p.length-p.match(u[0])[0].length,m=d.match(u[a-1])[0].length;if(l&&l.end.row===c&&l.end.column>v)continue;o.push(l=new s(c,v,c+a-1,m)),a>2&&(c=c+a-2);}}else for(var g=0;g<i.length;g++){var y=r.getMatchOffsets(i[g],u);for(var h=0;h<y.length;h++){var b=y[h];o.push(new s(g,b.offset,g,b.offset+b.length));}}if(n){var w=n.start.column,E=n.start.column,g=0,h=o.length-1;while(g<h&&o[g].start.column<w&&o[g].start.row==n.start.row)g++;while(g<h&&o[h].end.column>E&&o[h].end.row==n.end.row)h--;o=o.slice(g,h+1);for(g=0,h=o.length;g<h;g++)o[g].start.row+=n.start.row,o[g].end.row+=n.start.row;}return o},this.replace=function(e,t){var n=this.$options,r=this.$assembleRegExp(n);if(n.$isMultiLine)return t;if(!r)return;var i=r.exec(e);if(!i||i[0].length!=e.length)return null;t=e.replace(r,t);if(n.preserveCase){t=t.split("");for(var s=Math.min(e.length,e.length);s--;){var o=e[s];o&&o.toLowerCase()!=o?t[s]=t[s].toUpperCase():t[s]=t[s].toLowerCase();}t=t.join("");}return t},this.$assembleRegExp=function(e,t){if(e.needle instanceof RegExp)return e.re=e.needle;var n=e.needle;if(!e.needle)return e.re=!1;e.regExp||(n=r.escapeRegExp(n)),e.wholeWord&&(n=u(n,e));var i=e.caseSensitive?"gm":"gmi";e.$isMultiLine=!t&&/[\n\r]/.test(n);if(e.$isMultiLine)return e.re=this.$assembleMultilineRegExp(n,i);try{var s=new RegExp(n,i);}catch(o){s=!1;}return e.re=s},this.$assembleMultilineRegExp=function(e,t){var n=e.replace(/\r\n|\r|\n/g,"$\n^").split("\n"),r=[];for(var i=0;i<n.length;i++)try{r.push(new RegExp(n[i],t));}catch(s){return !1}return r},this.$matchIterator=function(e,t){var n=this.$assembleRegExp(t);if(!n)return !1;var r=t.backwards==1,i=t.skipCurrent!=0,s=t.range,o=t.start;o||(o=s?s[r?"end":"start"]:e.selection.getRange()),o.start&&(o=o[i!=r?"end":"start"]);var u=s?s.start.row:0,a=s?s.end.row:e.getLength()-1;if(r)var f=function(e){var n=o.row;if(c(n,o.column,e))return;for(n--;n>=u;n--)if(c(n,Number.MAX_VALUE,e))return;if(t.wrap==0)return;for(n=a,u=o.row;n>=u;n--)if(c(n,Number.MAX_VALUE,e))return};else var f=function(e){var n=o.row;if(c(n,o.column,e))return;for(n+=1;n<=a;n++)if(c(n,0,e))return;if(t.wrap==0)return;for(n=u,a=o.row;n<=a;n++)if(c(n,0,e))return};if(t.$isMultiLine)var l=n.length,c=function(t,i,s){var o=r?t-l+1:t;if(o<0)return;var u=e.getLine(o),a=u.search(n[0]);if(!r&&a<i||a===-1)return;for(var f=1;f<l;f++){u=e.getLine(o+f);if(u.search(n[f])==-1)return}var c=u.match(n[l-1])[0].length;if(r&&c>i)return;if(s(o,a,o+l-1,c))return !0};else if(r)var c=function(t,r,i){var s=e.getLine(t),o=[],u,a=0;n.lastIndex=0;while(u=n.exec(s)){var f=u[0].length;a=u.index;if(!f){if(a>=s.length)break;n.lastIndex=a+=1;}if(u.index+f>r)break;o.push(u.index,f);}for(var l=o.length-1;l>=0;l-=2){var c=o[l-1],f=o[l];if(i(t,c,t,c+f))return !0}};else var c=function(t,r,i){var s=e.getLine(t),o,u;n.lastIndex=r;while(u=n.exec(s)){var a=u[0].length;o=u.index;if(i(t,o,t,o+a))return !0;if(!a){n.lastIndex=o+=1;if(o>=s.length)return !1}}};return {forEach:f}};}).call(o.prototype),t.Search=o;}),define("ace/keyboard/hash_handler",["require","exports","module","ace/lib/keys","ace/lib/useragent"],function(e,t,n){function o(e,t){this.platform=t||(i.isMac?"mac":"win"),this.commands={},this.commandKeyBinding={},this.addCommands(e),this.$singleCommand=!0;}function u(e,t){o.call(this,e,t),this.$singleCommand=!1;}var r=e("../lib/keys"),i=e("../lib/useragent"),s=r.KEY_MODS;u.prototype=o.prototype,function(){function e(e){return typeof e=="object"&&e.bindKey&&e.bindKey.position||(e.isDefault?-100:0)}this.addCommand=function(e){this.commands[e.name]&&this.removeCommand(e),this.commands[e.name]=e,e.bindKey&&this._buildKeyHash(e);},this.removeCommand=function(e,t){var n=e&&(typeof e=="string"?e:e.name);e=this.commands[n],t||delete this.commands[n];var r=this.commandKeyBinding;for(var i in r){var s=r[i];if(s==e)delete r[i];else if(Array.isArray(s)){var o=s.indexOf(e);o!=-1&&(s.splice(o,1),s.length==1&&(r[i]=s[0]));}}},this.bindKey=function(e,t,n){typeof e=="object"&&e&&(n==undefined&&(n=e.position),e=e[this.platform]);if(!e)return;if(typeof t=="function")return this.addCommand({exec:t,bindKey:e,name:t.name||e});e.split("|").forEach(function(e){var r="";if(e.indexOf(" ")!=-1){var i=e.split(/\s+/);e=i.pop(),i.forEach(function(e){var t=this.parseKeys(e),n=s[t.hashId]+t.key;r+=(r?" ":"")+n,this._addCommandToBinding(r,"chainKeys");},this),r+=" ";}var o=this.parseKeys(e),u=s[o.hashId]+o.key;this._addCommandToBinding(r+u,t,n);},this);},this._addCommandToBinding=function(t,n,r){var i=this.commandKeyBinding,s;if(!n)delete i[t];else if(!i[t]||this.$singleCommand)i[t]=n;else{Array.isArray(i[t])?(s=i[t].indexOf(n))!=-1&&i[t].splice(s,1):i[t]=[i[t]],typeof r!="number"&&(r=e(n));var o=i[t];for(s=0;s<o.length;s++){var u=o[s],a=e(u);if(a>r)break}o.splice(s,0,n);}},this.addCommands=function(e){e&&Object.keys(e).forEach(function(t){var n=e[t];if(!n)return;if(typeof n=="string")return this.bindKey(n,t);typeof n=="function"&&(n={exec:n});if(typeof n!="object")return;n.name||(n.name=t),this.addCommand(n);},this);},this.removeCommands=function(e){Object.keys(e).forEach(function(t){this.removeCommand(e[t]);},this);},this.bindKeys=function(e){Object.keys(e).forEach(function(t){this.bindKey(t,e[t]);},this);},this._buildKeyHash=function(e){this.bindKey(e.bindKey,e);},this.parseKeys=function(e){var t=e.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(e){return e}),n=t.pop(),i=r[n];if(r.FUNCTION_KEYS[i])n=r.FUNCTION_KEYS[i].toLowerCase();else{if(!t.length)return {key:n,hashId:-1};if(t.length==1&&t[0]=="shift")return {key:n.toUpperCase(),hashId:-1}}var s=0;for(var o=t.length;o--;){var u=r.KEY_MODS[t[o]];if(u==null)return typeof console!="undefined"&&console.error("invalid modifier "+t[o]+" in "+e),!1;s|=u;}return {key:n,hashId:s}},this.findKeyCommand=function(t,n){var r=s[t]+n;return this.commandKeyBinding[r]},this.handleKeyboard=function(e,t,n,r){if(r<0)return;var i=s[t]+n,o=this.commandKeyBinding[i];e.$keyChain&&(e.$keyChain+=" "+i,o=this.commandKeyBinding[e.$keyChain]||o);if(o)if(o=="chainKeys"||o[o.length-1]=="chainKeys")return e.$keyChain=e.$keyChain||i,{command:"null"};if(e.$keyChain)if(!!t&&t!=4||n.length!=1){if(t==-1||r>0)e.$keyChain="";}else e.$keyChain=e.$keyChain.slice(0,-i.length-1);return {command:o}},this.getStatusText=function(e,t){return t.$keyChain||""};}.call(o.prototype),t.HashHandler=o,t.MultiHashHandler=u;}),define("ace/commands/command_manager",["require","exports","module","ace/lib/oop","ace/keyboard/hash_handler","ace/lib/event_emitter"],function(e,t,n){var r=e("../lib/oop"),i=e("../keyboard/hash_handler").MultiHashHandler,s=e("../lib/event_emitter").EventEmitter,o=function(e,t){i.call(this,t,e),this.byName=this.commands,this.setDefaultHandler("exec",function(e){return e.command.exec(e.editor,e.args||{})});};r.inherits(o,i),function(){r.implement(this,s),this.exec=function(e,t,n){if(Array.isArray(e)){for(var r=e.length;r--;)if(this.exec(e[r],t,n))return !0;return !1}typeof e=="string"&&(e=this.commands[e]);if(!e)return !1;if(t&&t.$readOnly&&!e.readOnly)return !1;if(this.$checkCommandState!=0&&e.isAvailable&&!e.isAvailable(t))return !1;var i={editor:t,command:e,args:n};return i.returnValue=this._emit("exec",i),this._signal("afterExec",i),i.returnValue===!1?!1:!0},this.toggleRecording=function(e){if(this.$inReplay)return;return e&&e._emit("changeStatus"),this.recording?(this.macro.pop(),this.removeEventListener("exec",this.$addCommandToMacro),this.macro.length||(this.macro=this.oldMacro),this.recording=!1):(this.$addCommandToMacro||(this.$addCommandToMacro=function(e){this.macro.push([e.command,e.args]);}.bind(this)),this.oldMacro=this.macro,this.macro=[],this.on("exec",this.$addCommandToMacro),this.recording=!0)},this.replay=function(e){if(this.$inReplay||!this.macro)return;if(this.recording)return this.toggleRecording(e);try{this.$inReplay=!0,this.macro.forEach(function(t){typeof t=="string"?this.exec(t,e):this.exec(t[0],e,t[1]);},this);}finally{this.$inReplay=!1;}},this.trimMacro=function(e){return e.map(function(e){return typeof e[0]!="string"&&(e[0]=e[0].name),e[1]||(e=e[0]),e})};}.call(o.prototype),t.CommandManager=o;}),define("ace/commands/default_commands",["require","exports","module","ace/lib/lang","ace/config","ace/range"],function(e,t,n){function o(e,t){return {win:e,mac:t}}var r=e("../lib/lang"),i=e("../config"),s=e("../range").Range;t.commands=[{name:"showSettingsMenu",bindKey:o("Ctrl-,","Command-,"),exec:function(e){i.loadModule("ace/ext/settings_menu",function(t){t.init(e),e.showSettingsMenu();});},readOnly:!0},{name:"goToNextError",bindKey:o("Alt-E","F4"),exec:function(e){i.loadModule("./ext/error_marker",function(t){t.showErrorMarker(e,1);});},scrollIntoView:"animate",readOnly:!0},{name:"goToPreviousError",bindKey:o("Alt-Shift-E","Shift-F4"),exec:function(e){i.loadModule("./ext/error_marker",function(t){t.showErrorMarker(e,-1);});},scrollIntoView:"animate",readOnly:!0},{name:"selectall",bindKey:o("Ctrl-A","Command-A"),exec:function(e){e.selectAll();},readOnly:!0},{name:"centerselection",bindKey:o(null,"Ctrl-L"),exec:function(e){e.centerSelection();},readOnly:!0},{name:"gotoline",bindKey:o("Ctrl-L","Command-L"),exec:function(e,t){typeof t!="number"&&(t=parseInt(prompt("Enter line number:"),10)),isNaN(t)||e.gotoLine(t);},readOnly:!0},{name:"fold",bindKey:o("Alt-L|Ctrl-F1","Command-Alt-L|Command-F1"),exec:function(e){e.session.toggleFold(!1);},multiSelectAction:"forEach",scrollIntoView:"center",readOnly:!0},{name:"unfold",bindKey:o("Alt-Shift-L|Ctrl-Shift-F1","Command-Alt-Shift-L|Command-Shift-F1"),exec:function(e){e.session.toggleFold(!0);},multiSelectAction:"forEach",scrollIntoView:"center",readOnly:!0},{name:"toggleFoldWidget",bindKey:o("F2","F2"),exec:function(e){e.session.toggleFoldWidget();},multiSelectAction:"forEach",scrollIntoView:"center",readOnly:!0},{name:"toggleParentFoldWidget",bindKey:o("Alt-F2","Alt-F2"),exec:function(e){e.session.toggleFoldWidget(!0);},multiSelectAction:"forEach",scrollIntoView:"center",readOnly:!0},{name:"foldall",bindKey:o(null,"Ctrl-Command-Option-0"),exec:function(e){e.session.foldAll();},scrollIntoView:"center",readOnly:!0},{name:"foldOther",bindKey:o("Alt-0","Command-Option-0"),exec:function(e){e.session.foldAll(),e.session.unfold(e.selection.getAllRanges());},scrollIntoView:"center",readOnly:!0},{name:"unfoldall",bindKey:o("Alt-Shift-0","Command-Option-Shift-0"),exec:function(e){e.session.unfold();},scrollIntoView:"center",readOnly:!0},{name:"findnext",bindKey:o("Ctrl-K","Command-G"),exec:function(e){e.findNext();},multiSelectAction:"forEach",scrollIntoView:"center",readOnly:!0},{name:"findprevious",bindKey:o("Ctrl-Shift-K","Command-Shift-G"),exec:function(e){e.findPrevious();},multiSelectAction:"forEach",scrollIntoView:"center",readOnly:!0},{name:"selectOrFindNext",bindKey:o("Alt-K","Ctrl-G"),exec:function(e){e.selection.isEmpty()?e.selection.selectWord():e.findNext();},readOnly:!0},{name:"selectOrFindPrevious",bindKey:o("Alt-Shift-K","Ctrl-Shift-G"),exec:function(e){e.selection.isEmpty()?e.selection.selectWord():e.findPrevious();},readOnly:!0},{name:"find",bindKey:o("Ctrl-F","Command-F"),exec:function(e){i.loadModule("ace/ext/searchbox",function(t){t.Search(e);});},readOnly:!0},{name:"overwrite",bindKey:"Insert",exec:function(e){e.toggleOverwrite();},readOnly:!0},{name:"selecttostart",bindKey:o("Ctrl-Shift-Home","Command-Shift-Home|Command-Shift-Up"),exec:function(e){e.getSelection().selectFileStart();},multiSelectAction:"forEach",readOnly:!0,scrollIntoView:"animate",aceCommandGroup:"fileJump"},{name:"gotostart",bindKey:o("Ctrl-Home","Command-Home|Command-Up"),exec:function(e){e.navigateFileStart();},multiSelectAction:"forEach",readOnly:!0,scrollIntoView:"animate",aceCommandGroup:"fileJump"},{name:"selectup",bindKey:o("Shift-Up","Shift-Up|Ctrl-Shift-P"),exec:function(e){e.getSelection().selectUp();},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"golineup",bindKey:o("Up","Up|Ctrl-P"),exec:function(e,t){e.navigateUp(t.times);},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selecttoend",bindKey:o("Ctrl-Shift-End","Command-Shift-End|Command-Shift-Down"),exec:function(e){e.getSelection().selectFileEnd();},multiSelectAction:"forEach",readOnly:!0,scrollIntoView:"animate",aceCommandGroup:"fileJump"},{name:"gotoend",bindKey:o("Ctrl-End","Command-End|Command-Down"),exec:function(e){e.navigateFileEnd();},multiSelectAction:"forEach",readOnly:!0,scrollIntoView:"animate",aceCommandGroup:"fileJump"},{name:"selectdown",bindKey:o("Shift-Down","Shift-Down|Ctrl-Shift-N"),exec:function(e){e.getSelection().selectDown();},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"golinedown",bindKey:o("Down","Down|Ctrl-N"),exec:function(e,t){e.navigateDown(t.times);},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selectwordleft",bindKey:o("Ctrl-Shift-Left","Option-Shift-Left"),exec:function(e){e.getSelection().selectWordLeft();},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"gotowordleft",bindKey:o("Ctrl-Left","Option-Left"),exec:function(e){e.navigateWordLeft();},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selecttolinestart",bindKey:o("Alt-Shift-Left","Command-Shift-Left|Ctrl-Shift-A"),exec:function(e){e.getSelection().selectLineStart();},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"gotolinestart",bindKey:o("Alt-Left|Home","Command-Left|Home|Ctrl-A"),exec:function(e){e.navigateLineStart();},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selectleft",bindKey:o("Shift-Left","Shift-Left|Ctrl-Shift-B"),exec:function(e){e.getSelection().selectLeft();},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"gotoleft",bindKey:o("Left","Left|Ctrl-B"),exec:function(e,t){e.navigateLeft(t.times);},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selectwordright",bindKey:o("Ctrl-Shift-Right","Option-Shift-Right"),exec:function(e){e.getSelection().selectWordRight();},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"gotowordright",bindKey:o("Ctrl-Right","Option-Right"),exec:function(e){e.navigateWordRight();},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selecttolineend",bindKey:o("Alt-Shift-Right","Command-Shift-Right|Shift-End|Ctrl-Shift-E"),exec:function(e){e.getSelection().selectLineEnd();},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"gotolineend",bindKey:o("Alt-Right|End","Command-Right|End|Ctrl-E"),exec:function(e){e.navigateLineEnd();},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selectright",bindKey:o("Shift-Right","Shift-Right"),exec:function(e){e.getSelection().selectRight();},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"gotoright",bindKey:o("Right","Right|Ctrl-F"),exec:function(e,t){e.navigateRight(t.times);},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selectpagedown",bindKey:"Shift-PageDown",exec:function(e){e.selectPageDown();},readOnly:!0},{name:"pagedown",bindKey:o(null,"Option-PageDown"),exec:function(e){e.scrollPageDown();},readOnly:!0},{name:"gotopagedown",bindKey:o("PageDown","PageDown|Ctrl-V"),exec:function(e){e.gotoPageDown();},readOnly:!0},{name:"selectpageup",bindKey:"Shift-PageUp",exec:function(e){e.selectPageUp();},readOnly:!0},{name:"pageup",bindKey:o(null,"Option-PageUp"),exec:function(e){e.scrollPageUp();},readOnly:!0},{name:"gotopageup",bindKey:"PageUp",exec:function(e){e.gotoPageUp();},readOnly:!0},{name:"scrollup",bindKey:o("Ctrl-Up",null),exec:function(e){e.renderer.scrollBy(0,-2*e.renderer.layerConfig.lineHeight);},readOnly:!0},{name:"scrolldown",bindKey:o("Ctrl-Down",null),exec:function(e){e.renderer.scrollBy(0,2*e.renderer.layerConfig.lineHeight);},readOnly:!0},{name:"selectlinestart",bindKey:"Shift-Home",exec:function(e){e.getSelection().selectLineStart();},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selectlineend",bindKey:"Shift-End",exec:function(e){e.getSelection().selectLineEnd();},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"togglerecording",bindKey:o("Ctrl-Alt-E","Command-Option-E"),exec:function(e){e.commands.toggleRecording(e);},readOnly:!0},{name:"replaymacro",bindKey:o("Ctrl-Shift-E","Command-Shift-E"),exec:function(e){e.commands.replay(e);},readOnly:!0},{name:"jumptomatching",bindKey:o("Ctrl-P","Ctrl-P"),exec:function(e){e.jumpToMatching();},multiSelectAction:"forEach",scrollIntoView:"animate",readOnly:!0},{name:"selecttomatching",bindKey:o("Ctrl-Shift-P","Ctrl-Shift-P"),exec:function(e){e.jumpToMatching(!0);},multiSelectAction:"forEach",scrollIntoView:"animate",readOnly:!0},{name:"expandToMatching",bindKey:o("Ctrl-Shift-M","Ctrl-Shift-M"),exec:function(e){e.jumpToMatching(!0,!0);},multiSelectAction:"forEach",scrollIntoView:"animate",readOnly:!0},{name:"passKeysToBrowser",bindKey:o(null,null),exec:function(){},passEvent:!0,readOnly:!0},{name:"copy",exec:function(e){},readOnly:!0},{name:"cut",exec:function(e){var t=e.$copyWithEmptySelection&&e.selection.isEmpty(),n=t?e.selection.getLineRange():e.selection.getRange();e._emit("cut",n),n.isEmpty()||e.session.remove(n),e.clearSelection();},scrollIntoView:"cursor",multiSelectAction:"forEach"},{name:"paste",exec:function(e,t){e.$handlePaste(t);},scrollIntoView:"cursor"},{name:"removeline",bindKey:o("Ctrl-D","Command-D"),exec:function(e){e.removeLines();},scrollIntoView:"cursor",multiSelectAction:"forEachLine"},{name:"duplicateSelection",bindKey:o("Ctrl-Shift-D","Command-Shift-D"),exec:function(e){e.duplicateSelection();},scrollIntoView:"cursor",multiSelectAction:"forEach"},{name:"sortlines",bindKey:o("Ctrl-Alt-S","Command-Alt-S"),exec:function(e){e.sortLines();},scrollIntoView:"selection",multiSelectAction:"forEachLine"},{name:"togglecomment",bindKey:o("Ctrl-/","Command-/"),exec:function(e){e.toggleCommentLines();},multiSelectAction:"forEachLine",scrollIntoView:"selectionPart"},{name:"toggleBlockComment",bindKey:o("Ctrl-Shift-/","Command-Shift-/"),exec:function(e){e.toggleBlockComment();},multiSelectAction:"forEach",scrollIntoView:"selectionPart"},{name:"modifyNumberUp",bindKey:o("Ctrl-Shift-Up","Alt-Shift-Up"),exec:function(e){e.modifyNumber(1);},scrollIntoView:"cursor",multiSelectAction:"forEach"},{name:"modifyNumberDown",bindKey:o("Ctrl-Shift-Down","Alt-Shift-Down"),exec:function(e){e.modifyNumber(-1);},scrollIntoView:"cursor",multiSelectAction:"forEach"},{name:"replace",bindKey:o("Ctrl-H","Command-Option-F"),exec:function(e){i.loadModule("ace/ext/searchbox",function(t){t.Search(e,!0);});}},{name:"undo",bindKey:o("Ctrl-Z","Command-Z"),exec:function(e){e.undo();}},{name:"redo",bindKey:o("Ctrl-Shift-Z|Ctrl-Y","Command-Shift-Z|Command-Y"),exec:function(e){e.redo();}},{name:"copylinesup",bindKey:o("Alt-Shift-Up","Command-Option-Up"),exec:function(e){e.copyLinesUp();},scrollIntoView:"cursor"},{name:"movelinesup",bindKey:o("Alt-Up","Option-Up"),exec:function(e){e.moveLinesUp();},scrollIntoView:"cursor"},{name:"copylinesdown",bindKey:o("Alt-Shift-Down","Command-Option-Down"),exec:function(e){e.copyLinesDown();},scrollIntoView:"cursor"},{name:"movelinesdown",bindKey:o("Alt-Down","Option-Down"),exec:function(e){e.moveLinesDown();},scrollIntoView:"cursor"},{name:"del",bindKey:o("Delete","Delete|Ctrl-D|Shift-Delete"),exec:function(e){e.remove("right");},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"backspace",bindKey:o("Shift-Backspace|Backspace","Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),exec:function(e){e.remove("left");},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"cut_or_delete",bindKey:o("Shift-Delete",null),exec:function(e){if(!e.selection.isEmpty())return !1;e.remove("left");},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"removetolinestart",bindKey:o("Alt-Backspace","Command-Backspace"),exec:function(e){e.removeToLineStart();},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"removetolineend",bindKey:o("Alt-Delete","Ctrl-K|Command-Delete"),exec:function(e){e.removeToLineEnd();},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"removetolinestarthard",bindKey:o("Ctrl-Shift-Backspace",null),exec:function(e){var t=e.selection.getRange();t.start.column=0,e.session.remove(t);},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"removetolineendhard",bindKey:o("Ctrl-Shift-Delete",null),exec:function(e){var t=e.selection.getRange();t.end.column=Number.MAX_VALUE,e.session.remove(t);},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"removewordleft",bindKey:o("Ctrl-Backspace","Alt-Backspace|Ctrl-Alt-Backspace"),exec:function(e){e.removeWordLeft();},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"removewordright",bindKey:o("Ctrl-Delete","Alt-Delete"),exec:function(e){e.removeWordRight();},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"outdent",bindKey:o("Shift-Tab","Shift-Tab"),exec:function(e){e.blockOutdent();},multiSelectAction:"forEach",scrollIntoView:"selectionPart"},{name:"indent",bindKey:o("Tab","Tab"),exec:function(e){e.indent();},multiSelectAction:"forEach",scrollIntoView:"selectionPart"},{name:"blockoutdent",bindKey:o("Ctrl-[","Ctrl-["),exec:function(e){e.blockOutdent();},multiSelectAction:"forEachLine",scrollIntoView:"selectionPart"},{name:"blockindent",bindKey:o("Ctrl-]","Ctrl-]"),exec:function(e){e.blockIndent();},multiSelectAction:"forEachLine",scrollIntoView:"selectionPart"},{name:"insertstring",exec:function(e,t){e.insert(t);},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"inserttext",exec:function(e,t){e.insert(r.stringRepeat(t.text||"",t.times||1));},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"splitline",bindKey:o(null,"Ctrl-O"),exec:function(e){e.splitLine();},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"transposeletters",bindKey:o("Alt-Shift-X","Ctrl-T"),exec:function(e){e.transposeLetters();},multiSelectAction:function(e){e.transposeSelections(1);},scrollIntoView:"cursor"},{name:"touppercase",bindKey:o("Ctrl-U","Ctrl-U"),exec:function(e){e.toUpperCase();},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"tolowercase",bindKey:o("Ctrl-Shift-U","Ctrl-Shift-U"),exec:function(e){e.toLowerCase();},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"expandtoline",bindKey:o("Ctrl-Shift-L","Command-Shift-L"),exec:function(e){var t=e.selection.getRange();t.start.column=t.end.column=0,t.end.row++,e.selection.setRange(t,!1);},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"joinlines",bindKey:o(null,null),exec:function(e){var t=e.selection.isBackwards(),n=t?e.selection.getSelectionLead():e.selection.getSelectionAnchor(),i=t?e.selection.getSelectionAnchor():e.selection.getSelectionLead(),o=e.session.doc.getLine(n.row).length,u=e.session.doc.getTextRange(e.selection.getRange()),a=u.replace(/\n\s*/," ").length,f=e.session.doc.getLine(n.row);for(var l=n.row+1;l<=i.row+1;l++){var c=r.stringTrimLeft(r.stringTrimRight(e.session.doc.getLine(l)));c.length!==0&&(c=" "+c),f+=c;}i.row+1<e.session.doc.getLength()-1&&(f+=e.session.doc.getNewLineCharacter()),e.clearSelection(),e.session.doc.replace(new s(n.row,0,i.row+2,0),f),a>0?(e.selection.moveCursorTo(n.row,n.column),e.selection.selectTo(n.row,n.column+a)):(o=e.session.doc.getLine(n.row).length>o?o+1:o,e.selection.moveCursorTo(n.row,o));},multiSelectAction:"forEach",readOnly:!0},{name:"invertSelection",bindKey:o(null,null),exec:function(e){var t=e.session.doc.getLength()-1,n=e.session.doc.getLine(t).length,r=e.selection.rangeList.ranges,i=[];r.length<1&&(r=[e.selection.getRange()]);for(var o=0;o<r.length;o++)o==r.length-1&&(r[o].end.row!==t||r[o].end.column!==n)&&i.push(new s(r[o].end.row,r[o].end.column,t,n)),o===0?(r[o].start.row!==0||r[o].start.column!==0)&&i.push(new s(0,0,r[o].start.row,r[o].start.column)):i.push(new s(r[o-1].end.row,r[o-1].end.column,r[o].start.row,r[o].start.column));e.exitMultiSelectMode(),e.clearSelection();for(var o=0;o<i.length;o++)e.selection.addRange(i[o],!1);},readOnly:!0,scrollIntoView:"none"}];}),define("ace/clipboard",["require","exports","module"],function(e,t,n){n.exports={lineMode:!1};}),define("ace/editor",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/keyboard/textinput","ace/mouse/mouse_handler","ace/mouse/fold_handler","ace/keyboard/keybinding","ace/edit_session","ace/search","ace/range","ace/lib/event_emitter","ace/commands/command_manager","ace/commands/default_commands","ace/config","ace/token_iterator","ace/clipboard"],function(e,t,n){e("./lib/fixoldbrowsers");var r=e("./lib/oop"),i=e("./lib/dom"),s=e("./lib/lang"),o=e("./lib/useragent"),u=e("./keyboard/textinput").TextInput,a=e("./mouse/mouse_handler").MouseHandler,f=e("./mouse/fold_handler").FoldHandler,l=e("./keyboard/keybinding").KeyBinding,c=e("./edit_session").EditSession,h=e("./search").Search,p=e("./range").Range,d=e("./lib/event_emitter").EventEmitter,v=e("./commands/command_manager").CommandManager,m=e("./commands/default_commands").commands,g=e("./config"),y=e("./token_iterator").TokenIterator,b=e("./clipboard"),w=function(e,t,n){var r=e.getContainerElement();this.container=r,this.renderer=e,this.id="editor"+ ++w.$uid,this.commands=new v(o.isMac?"mac":"win",m),typeof document=="object"&&(this.textInput=new u(e.getTextAreaContainer(),this),this.renderer.textarea=this.textInput.getElement(),this.$mouseHandler=new a(this),new f(this)),this.keyBinding=new l(this),this.$search=(new h).set({wrap:!0}),this.$historyTracker=this.$historyTracker.bind(this),this.commands.on("exec",this.$historyTracker),this.$initOperationListeners(),this._$emitInputEvent=s.delayedCall(function(){this._signal("input",{}),this.session&&this.session.bgTokenizer&&this.session.bgTokenizer.scheduleStart();}.bind(this)),this.on("change",function(e,t){t._$emitInputEvent.schedule(31);}),this.setSession(t||n&&n.session||new c("")),g.resetOptions(this),n&&this.setOptions(n),g._signal("editor",this);};w.$uid=0,function(){r.implement(this,d),this.$initOperationListeners=function(){this.commands.on("exec",this.startOperation.bind(this),!0),this.commands.on("afterExec",this.endOperation.bind(this),!0),this.$opResetTimer=s.delayedCall(this.endOperation.bind(this,!0)),this.on("change",function(){this.curOp||(this.startOperation(),this.curOp.selectionBefore=this.$lastSel),this.curOp.docChanged=!0;}.bind(this),!0),this.on("changeSelection",function(){this.curOp||(this.startOperation(),this.curOp.selectionBefore=this.$lastSel),this.curOp.selectionChanged=!0;}.bind(this),!0);},this.curOp=null,this.prevOp={},this.startOperation=function(e){if(this.curOp){if(!e||this.curOp.command)return;this.prevOp=this.curOp;}e||(this.previousCommand=null,e={}),this.$opResetTimer.schedule(),this.curOp=this.session.curOp={command:e.command||{},args:e.args,scrollTop:this.renderer.scrollTop},this.curOp.selectionBefore=this.selection.toJSON();},this.endOperation=function(e){if(this.curOp){if(e&&e.returnValue===!1)return this.curOp=null;if(e==1&&this.curOp.command&&this.curOp.command.name=="mouse")return;this._signal("beforeEndOperation");if(!this.curOp)return;var t=this.curOp.command,n=t&&t.scrollIntoView;if(n){switch(n){case"center-animate":n="animate";case"center":this.renderer.scrollCursorIntoView(null,.5);break;case"animate":case"cursor":this.renderer.scrollCursorIntoView();break;case"selectionPart":var r=this.selection.getRange(),i=this.renderer.layerConfig;(r.start.row>=i.lastRow||r.end.row<=i.firstRow)&&this.renderer.scrollSelectionIntoView(this.selection.anchor,this.selection.lead);break;}n=="animate"&&this.renderer.animateScrolling(this.curOp.scrollTop);}var s=this.selection.toJSON();this.curOp.selectionAfter=s,this.$lastSel=this.selection.toJSON(),this.session.getUndoManager().addSelection(s),this.prevOp=this.curOp,this.curOp=null;}},this.$mergeableCommands=["backspace","del","insertstring"],this.$historyTracker=function(e){if(!this.$mergeUndoDeltas)return;var t=this.prevOp,n=this.$mergeableCommands,r=t.command&&e.command.name==t.command.name;if(e.command.name=="insertstring"){var i=e.args;this.mergeNextCommand===undefined&&(this.mergeNextCommand=!0),r=r&&this.mergeNextCommand&&(!/\s/.test(i)||/\s/.test(t.args)),this.mergeNextCommand=!0;}else r=r&&n.indexOf(e.command.name)!==-1;this.$mergeUndoDeltas!="always"&&Date.now()-this.sequenceStartTime>2e3&&(r=!1),r?this.session.mergeUndoDeltas=!0:n.indexOf(e.command.name)!==-1&&(this.sequenceStartTime=Date.now());},this.setKeyboardHandler=function(e,t){if(e&&typeof e=="string"&&e!="ace"){this.$keybindingId=e;var n=this;g.loadModule(["keybinding",e],function(r){n.$keybindingId==e&&n.keyBinding.setKeyboardHandler(r&&r.handler),t&&t();});}else this.$keybindingId=null,this.keyBinding.setKeyboardHandler(e),t&&t();},this.getKeyboardHandler=function(){return this.keyBinding.getKeyboardHandler()},this.setSession=function(e){if(this.session==e)return;this.curOp&&this.endOperation(),this.curOp={};var t=this.session;if(t){this.session.off("change",this.$onDocumentChange),this.session.off("changeMode",this.$onChangeMode),this.session.off("tokenizerUpdate",this.$onTokenizerUpdate),this.session.off("changeTabSize",this.$onChangeTabSize),this.session.off("changeWrapLimit",this.$onChangeWrapLimit),this.session.off("changeWrapMode",this.$onChangeWrapMode),this.session.off("changeFold",this.$onChangeFold),this.session.off("changeFrontMarker",this.$onChangeFrontMarker),this.session.off("changeBackMarker",this.$onChangeBackMarker),this.session.off("changeBreakpoint",this.$onChangeBreakpoint),this.session.off("changeAnnotation",this.$onChangeAnnotation),this.session.off("changeOverwrite",this.$onCursorChange),this.session.off("changeScrollTop",this.$onScrollTopChange),this.session.off("changeScrollLeft",this.$onScrollLeftChange);var n=this.session.getSelection();n.off("changeCursor",this.$onCursorChange),n.off("changeSelection",this.$onSelectionChange);}this.session=e,e?(this.$onDocumentChange=this.onDocumentChange.bind(this),e.on("change",this.$onDocumentChange),this.renderer.setSession(e),this.$onChangeMode=this.onChangeMode.bind(this),e.on("changeMode",this.$onChangeMode),this.$onTokenizerUpdate=this.onTokenizerUpdate.bind(this),e.on("tokenizerUpdate",this.$onTokenizerUpdate),this.$onChangeTabSize=this.renderer.onChangeTabSize.bind(this.renderer),e.on("changeTabSize",this.$onChangeTabSize),this.$onChangeWrapLimit=this.onChangeWrapLimit.bind(this),e.on("changeWrapLimit",this.$onChangeWrapLimit),this.$onChangeWrapMode=this.onChangeWrapMode.bind(this),e.on("changeWrapMode",this.$onChangeWrapMode),this.$onChangeFold=this.onChangeFold.bind(this),e.on("changeFold",this.$onChangeFold),this.$onChangeFrontMarker=this.onChangeFrontMarker.bind(this),this.session.on("changeFrontMarker",this.$onChangeFrontMarker),this.$onChangeBackMarker=this.onChangeBackMarker.bind(this),this.session.on("changeBackMarker",this.$onChangeBackMarker),this.$onChangeBreakpoint=this.onChangeBreakpoint.bind(this),this.session.on("changeBreakpoint",this.$onChangeBreakpoint),this.$onChangeAnnotation=this.onChangeAnnotation.bind(this),this.session.on("changeAnnotation",this.$onChangeAnnotation),this.$onCursorChange=this.onCursorChange.bind(this),this.session.on("changeOverwrite",this.$onCursorChange),this.$onScrollTopChange=this.onScrollTopChange.bind(this),this.session.on("changeScrollTop",this.$onScrollTopChange),this.$onScrollLeftChange=this.onScrollLeftChange.bind(this),this.session.on("changeScrollLeft",this.$onScrollLeftChange),this.selection=e.getSelection(),this.selection.on("changeCursor",this.$onCursorChange),this.$onSelectionChange=this.onSelectionChange.bind(this),this.selection.on("changeSelection",this.$onSelectionChange),this.onChangeMode(),this.onCursorChange(),this.onScrollTopChange(),this.onScrollLeftChange(),this.onSelectionChange(),this.onChangeFrontMarker(),this.onChangeBackMarker(),this.onChangeBreakpoint(),this.onChangeAnnotation(),this.session.getUseWrapMode()&&this.renderer.adjustWrapLimit(),this.renderer.updateFull()):(this.selection=null,this.renderer.setSession(e)),this._signal("changeSession",{session:e,oldSession:t}),this.curOp=null,t&&t._signal("changeEditor",{oldEditor:this}),e&&e._signal("changeEditor",{editor:this}),e&&e.bgTokenizer&&e.bgTokenizer.scheduleStart();},this.getSession=function(){return this.session},this.setValue=function(e,t){return this.session.doc.setValue(e),t?t==1?this.navigateFileEnd():t==-1&&this.navigateFileStart():this.selectAll(),e},this.getValue=function(){return this.session.getValue()},this.getSelection=function(){return this.selection},this.resize=function(e){this.renderer.onResize(e);},this.setTheme=function(e,t){this.renderer.setTheme(e,t);},this.getTheme=function(){return this.renderer.getTheme()},this.setStyle=function(e){this.renderer.setStyle(e);},this.unsetStyle=function(e){this.renderer.unsetStyle(e);},this.getFontSize=function(){return this.getOption("fontSize")||i.computedStyle(this.container).fontSize},this.setFontSize=function(e){this.setOption("fontSize",e);},this.$highlightBrackets=function(){this.session.$bracketHighlight&&(this.session.removeMarker(this.session.$bracketHighlight),this.session.$bracketHighlight=null);if(this.$highlightPending)return;var e=this;this.$highlightPending=!0,setTimeout(function(){e.$highlightPending=!1;var t=e.session;if(!t||!t.bgTokenizer)return;var n=t.findMatchingBracket(e.getCursorPosition());if(n)var r=new p(n.row,n.column,n.row,n.column+1);else if(t.$mode.getMatching)var r=t.$mode.getMatching(e.session);r&&(t.$bracketHighlight=t.addMarker(r,"ace_bracket","text"));},50);},this.$highlightTags=function(){if(this.$highlightTagPending)return;var e=this;this.$highlightTagPending=!0,setTimeout(function(){e.$highlightTagPending=!1;var t=e.session;if(!t||!t.bgTokenizer)return;var n=e.getCursorPosition(),r=new y(e.session,n.row,n.column),i=r.getCurrentToken();if(!i||!/\b(?:tag-open|tag-name)/.test(i.type)){t.removeMarker(t.$tagHighlight),t.$tagHighlight=null;return}if(i.type.indexOf("tag-open")!=-1){i=r.stepForward();if(!i)return}var s=i.value,o=0,u=r.stepBackward();if(u.value=="<"){do u=i,i=r.stepForward(),i&&i.value===s&&i.type.indexOf("tag-name")!==-1&&(u.value==="<"?o++:u.value==="</"&&o--);while(i&&o>=0)}else{do i=u,u=r.stepBackward(),i&&i.value===s&&i.type.indexOf("tag-name")!==-1&&(u.value==="<"?o++:u.value==="</"&&o--);while(u&&o<=0);r.stepForward();}if(!i){t.removeMarker(t.$tagHighlight),t.$tagHighlight=null;return}var a=r.getCurrentTokenRow(),f=r.getCurrentTokenColumn(),l=new p(a,f,a,f+i.value.length),c=t.$backMarkers[t.$tagHighlight];t.$tagHighlight&&c!=undefined&&l.compareRange(c.range)!==0&&(t.removeMarker(t.$tagHighlight),t.$tagHighlight=null),t.$tagHighlight||(t.$tagHighlight=t.addMarker(l,"ace_bracket","text"));},50);},this.focus=function(){var e=this;setTimeout(function(){e.isFocused()||e.textInput.focus();}),this.textInput.focus();},this.isFocused=function(){return this.textInput.isFocused()},this.blur=function(){this.textInput.blur();},this.onFocus=function(e){if(this.$isFocused)return;this.$isFocused=!0,this.renderer.showCursor(),this.renderer.visualizeFocus(),this._emit("focus",e);},this.onBlur=function(e){if(!this.$isFocused)return;this.$isFocused=!1,this.renderer.hideCursor(),this.renderer.visualizeBlur(),this._emit("blur",e);},this.$cursorChange=function(){this.renderer.updateCursor();},this.onDocumentChange=function(e){var t=this.session.$useWrapMode,n=e.start.row==e.end.row?e.end.row:Infinity;this.renderer.updateLines(e.start.row,n,t),this._signal("change",e),this.$cursorChange(),this.$updateHighlightActiveLine();},this.onTokenizerUpdate=function(e){var t=e.data;this.renderer.updateLines(t.first,t.last);},this.onScrollTopChange=function(){this.renderer.scrollToY(this.session.getScrollTop());},this.onScrollLeftChange=function(){this.renderer.scrollToX(this.session.getScrollLeft());},this.onCursorChange=function(){this.$cursorChange(),this.$highlightBrackets(),this.$highlightTags(),this.$updateHighlightActiveLine(),this._signal("changeSelection");},this.$updateHighlightActiveLine=function(){var e=this.getSession(),t;if(this.$highlightActiveLine){if(this.$selectionStyle!="line"||!this.selection.isMultiLine())t=this.getCursorPosition();this.renderer.theme&&this.renderer.theme.$selectionColorConflict&&!this.selection.isEmpty()&&(t=!1),this.renderer.$maxLines&&this.session.getLength()===1&&!(this.renderer.$minLines>1)&&(t=!1);}if(e.$highlightLineMarker&&!t)e.removeMarker(e.$highlightLineMarker.id),e.$highlightLineMarker=null;else if(!e.$highlightLineMarker&&t){var n=new p(t.row,t.column,t.row,Infinity);n.id=e.addMarker(n,"ace_active-line","screenLine"),e.$highlightLineMarker=n;}else t&&(e.$highlightLineMarker.start.row=t.row,e.$highlightLineMarker.end.row=t.row,e.$highlightLineMarker.start.column=t.column,e._signal("changeBackMarker"));},this.onSelectionChange=function(e){var t=this.session;t.$selectionMarker&&t.removeMarker(t.$selectionMarker),t.$selectionMarker=null;if(!this.selection.isEmpty()){var n=this.selection.getRange(),r=this.getSelectionStyle();t.$selectionMarker=t.addMarker(n,"ace_selection",r);}else this.$updateHighlightActiveLine();var i=this.$highlightSelectedWord&&this.$getSelectionHighLightRegexp();this.session.highlight(i),this._signal("changeSelection");},this.$getSelectionHighLightRegexp=function(){var e=this.session,t=this.getSelectionRange();if(t.isEmpty()||t.isMultiLine())return;var n=t.start.column,r=t.end.column,i=e.getLine(t.start.row),s=i.substring(n,r);if(s.length>5e3||!/[\w\d]/.test(s))return;var o=this.$search.$assembleRegExp({wholeWord:!0,caseSensitive:!0,needle:s}),u=i.substring(n-1,r+1);if(!o.test(u))return;return o},this.onChangeFrontMarker=function(){this.renderer.updateFrontMarkers();},this.onChangeBackMarker=function(){this.renderer.updateBackMarkers();},this.onChangeBreakpoint=function(){this.renderer.updateBreakpoints();},this.onChangeAnnotation=function(){this.renderer.setAnnotations(this.session.getAnnotations());},this.onChangeMode=function(e){this.renderer.updateText(),this._emit("changeMode",e);},this.onChangeWrapLimit=function(){this.renderer.updateFull();},this.onChangeWrapMode=function(){this.renderer.onResize(!0);},this.onChangeFold=function(){this.$updateHighlightActiveLine(),this.renderer.updateFull();},this.getSelectedText=function(){return this.session.getTextRange(this.getSelectionRange())},this.getCopyText=function(){var e=this.getSelectedText(),t=this.session.doc.getNewLineCharacter(),n=!1;if(!e&&this.$copyWithEmptySelection){n=!0;var r=this.selection.getAllRanges();for(var i=0;i<r.length;i++){var s=r[i];if(i&&r[i-1].start.row==s.start.row)continue;e+=this.session.getLine(s.start.row)+t;}}var o={text:e};return this._signal("copy",o),b.lineMode=n?o.text:"",o.text},this.onCopy=function(){this.commands.exec("copy",this);},this.onCut=function(){this.commands.exec("cut",this);},this.onPaste=function(e,t){var n={text:e,event:t};this.commands.exec("paste",this,n);},this.$handlePaste=function(e){typeof e=="string"&&(e={text:e}),this._signal("paste",e);var t=e.text,n=t==b.lineMode,r=this.session;if(!this.inMultiSelectMode||this.inVirtualSelectionMode)n?r.insert({row:this.selection.lead.row,column:0},t):this.insert(t);else if(n)this.selection.rangeList.ranges.forEach(function(e){r.insert({row:e.start.row,column:0},t);});else{var i=t.split(/\r\n|\r|\n/),s=this.selection.rangeList.ranges;if(i.length>s.length||i.length<2||!i[1])return this.commands.exec("insertstring",this,t);for(var o=s.length;o--;){var u=s[o];u.isEmpty()||r.remove(u),r.insert(u.start,i[o]);}}},this.execCommand=function(e,t){return this.commands.exec(e,this,t)},this.insert=function(e,t){var n=this.session,r=n.getMode(),i=this.getCursorPosition();if(this.getBehavioursEnabled()&&!t){var s=r.transformAction(n.getState(i.row),"insertion",this,n,e);s&&(e!==s.text&&(this.inVirtualSelectionMode||(this.session.mergeUndoDeltas=!1,this.mergeNextCommand=!1)),e=s.text);}e=="	"&&(e=this.session.getTabString());if(!this.selection.isEmpty()){var o=this.getSelectionRange();i=this.session.remove(o),this.clearSelection();}else if(this.session.getOverwrite()&&e.indexOf("\n")==-1){var o=new p.fromPoints(i,i);o.end.column+=e.length,this.session.remove(o);}if(e=="\n"||e=="\r\n"){var u=n.getLine(i.row);if(i.column>u.search(/\S|$/)){var a=u.substr(i.column).search(/\S|$/);n.doc.removeInLine(i.row,i.column,i.column+a);}}this.clearSelection();var f=i.column,l=n.getState(i.row),u=n.getLine(i.row),c=r.checkOutdent(l,u,e),h=n.insert(i,e);s&&s.selection&&(s.selection.length==2?this.selection.setSelectionRange(new p(i.row,f+s.selection[0],i.row,f+s.selection[1])):this.selection.setSelectionRange(new p(i.row+s.selection[0],s.selection[1],i.row+s.selection[2],s.selection[3])));if(n.getDocument().isNewLine(e)){var d=r.getNextLineIndent(l,u.slice(0,i.column),n.getTabString());n.insert({row:i.row+1,column:0},d);}c&&r.autoOutdent(l,n,i.row);},this.onTextInput=function(e,t){if(!t)return this.keyBinding.onTextInput(e);this.startOperation({command:{name:"insertstring"}});var n=this.applyComposition.bind(this,e,t);this.selection.rangeCount?this.forEachSelection(n):n(),this.endOperation();},this.applyComposition=function(e,t){if(t.extendLeft||t.extendRight){var n=this.selection.getRange();n.start.column-=t.extendLeft,n.end.column+=t.extendRight,this.selection.setRange(n),!e&&!n.isEmpty()&&this.remove();}(e||!this.selection.isEmpty())&&this.insert(e,!0);if(t.restoreStart||t.restoreEnd){var n=this.selection.getRange();n.start.column-=t.restoreStart,n.end.column-=t.restoreEnd,this.selection.setRange(n);}},this.onCommandKey=function(e,t,n){this.keyBinding.onCommandKey(e,t,n);},this.setOverwrite=function(e){this.session.setOverwrite(e);},this.getOverwrite=function(){return this.session.getOverwrite()},this.toggleOverwrite=function(){this.session.toggleOverwrite();},this.setScrollSpeed=function(e){this.setOption("scrollSpeed",e);},this.getScrollSpeed=function(){return this.getOption("scrollSpeed")},this.setDragDelay=function(e){this.setOption("dragDelay",e);},this.getDragDelay=function(){return this.getOption("dragDelay")},this.setSelectionStyle=function(e){this.setOption("selectionStyle",e);},this.getSelectionStyle=function(){return this.getOption("selectionStyle")},this.setHighlightActiveLine=function(e){this.setOption("highlightActiveLine",e);},this.getHighlightActiveLine=function(){return this.getOption("highlightActiveLine")},this.setHighlightGutterLine=function(e){this.setOption("highlightGutterLine",e);},this.getHighlightGutterLine=function(){return this.getOption("highlightGutterLine")},this.setHighlightSelectedWord=function(e){this.setOption("highlightSelectedWord",e);},this.getHighlightSelectedWord=function(){return this.$highlightSelectedWord},this.setAnimatedScroll=function(e){this.renderer.setAnimatedScroll(e);},this.getAnimatedScroll=function(){return this.renderer.getAnimatedScroll()},this.setShowInvisibles=function(e){this.renderer.setShowInvisibles(e);},this.getShowInvisibles=function(){return this.renderer.getShowInvisibles()},this.setDisplayIndentGuides=function(e){this.renderer.setDisplayIndentGuides(e);},this.getDisplayIndentGuides=function(){return this.renderer.getDisplayIndentGuides()},this.setShowPrintMargin=function(e){this.renderer.setShowPrintMargin(e);},this.getShowPrintMargin=function(){return this.renderer.getShowPrintMargin()},this.setPrintMarginColumn=function(e){this.renderer.setPrintMarginColumn(e);},this.getPrintMarginColumn=function(){return this.renderer.getPrintMarginColumn()},this.setReadOnly=function(e){this.setOption("readOnly",e);},this.getReadOnly=function(){return this.getOption("readOnly")},this.setBehavioursEnabled=function(e){this.setOption("behavioursEnabled",e);},this.getBehavioursEnabled=function(){return this.getOption("behavioursEnabled")},this.setWrapBehavioursEnabled=function(e){this.setOption("wrapBehavioursEnabled",e);},this.getWrapBehavioursEnabled=function(){return this.getOption("wrapBehavioursEnabled")},this.setShowFoldWidgets=function(e){this.setOption("showFoldWidgets",e);},this.getShowFoldWidgets=function(){return this.getOption("showFoldWidgets")},this.setFadeFoldWidgets=function(e){this.setOption("fadeFoldWidgets",e);},this.getFadeFoldWidgets=function(){return this.getOption("fadeFoldWidgets")},this.remove=function(e){this.selection.isEmpty()&&(e=="left"?this.selection.selectLeft():this.selection.selectRight());var t=this.getSelectionRange();if(this.getBehavioursEnabled()){var n=this.session,r=n.getState(t.start.row),i=n.getMode().transformAction(r,"deletion",this,n,t);if(t.end.column===0){var s=n.getTextRange(t);if(s[s.length-1]=="\n"){var o=n.getLine(t.end.row);/^\s+$/.test(o)&&(t.end.column=o.length);}}i&&(t=i);}this.session.remove(t),this.clearSelection();},this.removeWordRight=function(){this.selection.isEmpty()&&this.selection.selectWordRight(),this.session.remove(this.getSelectionRange()),this.clearSelection();},this.removeWordLeft=function(){this.selection.isEmpty()&&this.selection.selectWordLeft(),this.session.remove(this.getSelectionRange()),this.clearSelection();},this.removeToLineStart=function(){this.selection.isEmpty()&&this.selection.selectLineStart(),this.selection.isEmpty()&&this.selection.selectLeft(),this.session.remove(this.getSelectionRange()),this.clearSelection();},this.removeToLineEnd=function(){this.selection.isEmpty()&&this.selection.selectLineEnd();var e=this.getSelectionRange();e.start.column==e.end.column&&e.start.row==e.end.row&&(e.end.column=0,e.end.row++),this.session.remove(e),this.clearSelection();},this.splitLine=function(){this.selection.isEmpty()||(this.session.remove(this.getSelectionRange()),this.clearSelection());var e=this.getCursorPosition();this.insert("\n"),this.moveCursorToPosition(e);},this.transposeLetters=function(){if(!this.selection.isEmpty())return;var e=this.getCursorPosition(),t=e.column;if(t===0)return;var n=this.session.getLine(e.row),r,i;t<n.length?(r=n.charAt(t)+n.charAt(t-1),i=new p(e.row,t-1,e.row,t+1)):(r=n.charAt(t-1)+n.charAt(t-2),i=new p(e.row,t-2,e.row,t)),this.session.replace(i,r),this.session.selection.moveToPosition(i.end);},this.toLowerCase=function(){var e=this.getSelectionRange();this.selection.isEmpty()&&this.selection.selectWord();var t=this.getSelectionRange(),n=this.session.getTextRange(t);this.session.replace(t,n.toLowerCase()),this.selection.setSelectionRange(e);},this.toUpperCase=function(){var e=this.getSelectionRange();this.selection.isEmpty()&&this.selection.selectWord();var t=this.getSelectionRange(),n=this.session.getTextRange(t);this.session.replace(t,n.toUpperCase()),this.selection.setSelectionRange(e);},this.indent=function(){var e=this.session,t=this.getSelectionRange();if(t.start.row<t.end.row){var n=this.$getSelectedRows();e.indentRows(n.first,n.last,"	");return}if(t.start.column<t.end.column){var r=e.getTextRange(t);if(!/^\s+$/.test(r)){var n=this.$getSelectedRows();e.indentRows(n.first,n.last,"	");return}}var i=e.getLine(t.start.row),o=t.start,u=e.getTabSize(),a=e.documentToScreenColumn(o.row,o.column);if(this.session.getUseSoftTabs())var f=u-a%u,l=s.stringRepeat(" ",f);else{var f=a%u;while(i[t.start.column-1]==" "&&f)t.start.column--,f--;this.selection.setSelectionRange(t),l="	";}return this.insert(l)},this.blockIndent=function(){var e=this.$getSelectedRows();this.session.indentRows(e.first,e.last,"	");},this.blockOutdent=function(){var e=this.session.getSelection();this.session.outdentRows(e.getRange());},this.sortLines=function(){var e=this.$getSelectedRows(),t=this.session,n=[];for(var r=e.first;r<=e.last;r++)n.push(t.getLine(r));n.sort(function(e,t){return e.toLowerCase()<t.toLowerCase()?-1:e.toLowerCase()>t.toLowerCase()?1:0});var i=new p(0,0,0,0);for(var r=e.first;r<=e.last;r++){var s=t.getLine(r);i.start.row=r,i.end.row=r,i.end.column=s.length,t.replace(i,n[r-e.first]);}},this.toggleCommentLines=function(){var e=this.session.getState(this.getCursorPosition().row),t=this.$getSelectedRows();this.session.getMode().toggleCommentLines(e,this.session,t.first,t.last);},this.toggleBlockComment=function(){var e=this.getCursorPosition(),t=this.session.getState(e.row),n=this.getSelectionRange();this.session.getMode().toggleBlockComment(t,this.session,n,e);},this.getNumberAt=function(e,t){var n=/[\-]?[0-9]+(?:\.[0-9]+)?/g;n.lastIndex=0;var r=this.session.getLine(e);while(n.lastIndex<t){var i=n.exec(r);if(i.index<=t&&i.index+i[0].length>=t){var s={value:i[0],start:i.index,end:i.index+i[0].length};return s}}return null},this.modifyNumber=function(e){var t=this.selection.getCursor().row,n=this.selection.getCursor().column,r=new p(t,n-1,t,n),i=this.session.getTextRange(r);if(!isNaN(parseFloat(i))&&isFinite(i)){var s=this.getNumberAt(t,n);if(s){var o=s.value.indexOf(".")>=0?s.start+s.value.indexOf(".")+1:s.end,u=s.start+s.value.length-o,a=parseFloat(s.value);a*=Math.pow(10,u),o!==s.end&&n<o?e*=Math.pow(10,s.end-n-1):e*=Math.pow(10,s.end-n),a+=e,a/=Math.pow(10,u);var f=a.toFixed(u),l=new p(t,s.start,t,s.end);this.session.replace(l,f),this.moveCursorTo(t,Math.max(s.start+1,n+f.length-s.value.length));}}else this.toggleWord();},this.$toggleWordPairs=[["first","last"],["true","false"],["yes","no"],["width","height"],["top","bottom"],["right","left"],["on","off"],["x","y"],["get","set"],["max","min"],["horizontal","vertical"],["show","hide"],["add","remove"],["up","down"],["before","after"],["even","odd"],["inside","outside"],["next","previous"],["increase","decrease"],["attach","detach"],["&&","||"],["==","!="]],this.toggleWord=function(){var e=this.selection.getCursor().row,t=this.selection.getCursor().column;this.selection.selectWord();var n=this.getSelectedText(),r=this.selection.getWordRange().start.column,i=n.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g,"$1 ").split(/\s/),o=t-r-1;o<0&&(o=0);var u=0,a=0,f=this;n.match(/[A-Za-z0-9_]+/)&&i.forEach(function(t,i){a=u+t.length,o>=u&&o<=a&&(n=t,f.selection.clearSelection(),f.moveCursorTo(e,u+r),f.selection.selectTo(e,a+r)),u=a;});var l=this.$toggleWordPairs,c;for(var h=0;h<l.length;h++){var p=l[h];for(var d=0;d<=1;d++){var v=+!d,m=n.match(new RegExp("^\\s?_?("+s.escapeRegExp(p[d])+")\\s?$","i"));if(m){var g=n.match(new RegExp("([_]|^|\\s)("+s.escapeRegExp(m[1])+")($|\\s)","g"));g&&(c=n.replace(new RegExp(s.escapeRegExp(p[d]),"i"),function(e){var t=p[v];return e.toUpperCase()==e?t=t.toUpperCase():e.charAt(0).toUpperCase()==e.charAt(0)&&(t=t.substr(0,0)+p[v].charAt(0).toUpperCase()+t.substr(1)),t}),this.insert(c),c="");}}}},this.removeLines=function(){var e=this.$getSelectedRows();this.session.removeFullLines(e.first,e.last),this.clearSelection();},this.duplicateSelection=function(){var e=this.selection,t=this.session,n=e.getRange(),r=e.isBackwards();if(n.isEmpty()){var i=n.start.row;t.duplicateLines(i,i);}else{var s=r?n.start:n.end,o=t.insert(s,t.getTextRange(n),!1);n.start=s,n.end=o,e.setSelectionRange(n,r);}},this.moveLinesDown=function(){this.$moveLines(1,!1);},this.moveLinesUp=function(){this.$moveLines(-1,!1);},this.moveText=function(e,t,n){return this.session.moveText(e,t,n)},this.copyLinesUp=function(){this.$moveLines(-1,!0);},this.copyLinesDown=function(){this.$moveLines(1,!0);},this.$moveLines=function(e,t){var n,r,i=this.selection;if(!i.inMultiSelectMode||this.inVirtualSelectionMode){var s=i.toOrientedRange();n=this.$getSelectedRows(s),r=this.session.$moveLines(n.first,n.last,t?0:e),t&&e==-1&&(r=0),s.moveBy(r,0),i.fromOrientedRange(s);}else{var o=i.rangeList.ranges;i.rangeList.detach(this.session),this.inVirtualSelectionMode=!0;var u=0,a=0,f=o.length;for(var l=0;l<f;l++){var c=l;o[l].moveBy(u,0),n=this.$getSelectedRows(o[l]);var h=n.first,p=n.last;while(++l<f){a&&o[l].moveBy(a,0);var d=this.$getSelectedRows(o[l]);if(t&&d.first!=p)break;if(!t&&d.first>p+1)break;p=d.last;}l--,u=this.session.$moveLines(h,p,t?0:e),t&&e==-1&&(c=l+1);while(c<=l)o[c].moveBy(u,0),c++;t||(u=0),a+=u;}i.fromOrientedRange(i.ranges[0]),i.rangeList.attach(this.session),this.inVirtualSelectionMode=!1;}},this.$getSelectedRows=function(e){return e=(e||this.getSelectionRange()).collapseRows(),{first:this.session.getRowFoldStart(e.start.row),last:this.session.getRowFoldEnd(e.end.row)}},this.onCompositionStart=function(e){this.renderer.showComposition(e);},this.onCompositionUpdate=function(e){this.renderer.setCompositionText(e);},this.onCompositionEnd=function(){this.renderer.hideComposition();},this.getFirstVisibleRow=function(){return this.renderer.getFirstVisibleRow()},this.getLastVisibleRow=function(){return this.renderer.getLastVisibleRow()},this.isRowVisible=function(e){return e>=this.getFirstVisibleRow()&&e<=this.getLastVisibleRow()},this.isRowFullyVisible=function(e){return e>=this.renderer.getFirstFullyVisibleRow()&&e<=this.renderer.getLastFullyVisibleRow()},this.$getVisibleRowCount=function(){return this.renderer.getScrollBottomRow()-this.renderer.getScrollTopRow()+1},this.$moveByPage=function(e,t){var n=this.renderer,r=this.renderer.layerConfig,i=e*Math.floor(r.height/r.lineHeight);t===!0?this.selection.$moveSelection(function(){this.moveCursorBy(i,0);}):t===!1&&(this.selection.moveCursorBy(i,0),this.selection.clearSelection());var s=n.scrollTop;n.scrollBy(0,i*r.lineHeight),t!=null&&n.scrollCursorIntoView(null,.5),n.animateScrolling(s);},this.selectPageDown=function(){this.$moveByPage(1,!0);},this.selectPageUp=function(){this.$moveByPage(-1,!0);},this.gotoPageDown=function(){this.$moveByPage(1,!1);},this.gotoPageUp=function(){this.$moveByPage(-1,!1);},this.scrollPageDown=function(){this.$moveByPage(1);},this.scrollPageUp=function(){this.$moveByPage(-1);},this.scrollToRow=function(e){this.renderer.scrollToRow(e);},this.scrollToLine=function(e,t,n,r){this.renderer.scrollToLine(e,t,n,r);},this.centerSelection=function(){var e=this.getSelectionRange(),t={row:Math.floor(e.start.row+(e.end.row-e.start.row)/2),column:Math.floor(e.start.column+(e.end.column-e.start.column)/2)};this.renderer.alignCursor(t,.5);},this.getCursorPosition=function(){return this.selection.getCursor()},this.getCursorPositionScreen=function(){return this.session.documentToScreenPosition(this.getCursorPosition())},this.getSelectionRange=function(){return this.selection.getRange()},this.selectAll=function(){this.selection.selectAll();},this.clearSelection=function(){this.selection.clearSelection();},this.moveCursorTo=function(e,t){this.selection.moveCursorTo(e,t);},this.moveCursorToPosition=function(e){this.selection.moveCursorToPosition(e);},this.jumpToMatching=function(e,t){var n=this.getCursorPosition(),r=new y(this.session,n.row,n.column),i=r.getCurrentToken(),s=i||r.stepForward();if(!s)return;var o,u=!1,a={},f=n.column-s.start,l,c={")":"(","(":"(","]":"[","[":"[","{":"{","}":"{"};do{if(s.value.match(/[{}()\[\]]/g))for(;f<s.value.length&&!u;f++){if(!c[s.value[f]])continue;l=c[s.value[f]]+"."+s.type.replace("rparen","lparen"),isNaN(a[l])&&(a[l]=0);switch(s.value[f]){case"(":case"[":case"{":a[l]++;break;case")":case"]":case"}":a[l]--,a[l]===-1&&(o="bracket",u=!0);}}else s.type.indexOf("tag-name")!==-1&&(isNaN(a[s.value])&&(a[s.value]=0),i.value==="<"?a[s.value]++:i.value==="</"&&a[s.value]--,a[s.value]===-1&&(o="tag",u=!0));u||(i=s,s=r.stepForward(),f=0);}while(s&&!u);if(!o)return;var h,d;if(o==="bracket"){h=this.session.getBracketRange(n);if(!h){h=new p(r.getCurrentTokenRow(),r.getCurrentTokenColumn()+f-1,r.getCurrentTokenRow(),r.getCurrentTokenColumn()+f-1),d=h.start;if(t||d.row===n.row&&Math.abs(d.column-n.column)<2)h=this.session.getBracketRange(d);}}else if(o==="tag"){if(!s||s.type.indexOf("tag-name")===-1)return;var v=s.value;h=new p(r.getCurrentTokenRow(),r.getCurrentTokenColumn()-2,r.getCurrentTokenRow(),r.getCurrentTokenColumn()-2);if(h.compare(n.row,n.column)===0){u=!1;do s=i,i=r.stepBackward(),i&&(i.type.indexOf("tag-close")!==-1&&h.setEnd(r.getCurrentTokenRow(),r.getCurrentTokenColumn()+1),s.value===v&&s.type.indexOf("tag-name")!==-1&&(i.value==="<"?a[v]++:i.value==="</"&&a[v]--,a[v]===0&&(u=!0)));while(i&&!u)}s&&s.type.indexOf("tag-name")&&(d=h.start,d.row==n.row&&Math.abs(d.column-n.column)<2&&(d=h.end));}d=h&&h.cursor||d,d&&(e?h&&t?this.selection.setRange(h):h&&h.isEqual(this.getSelectionRange())?this.clearSelection():this.selection.selectTo(d.row,d.column):this.selection.moveTo(d.row,d.column));},this.gotoLine=function(e,t,n){this.selection.clearSelection(),this.session.unfold({row:e-1,column:t||0}),this.exitMultiSelectMode&&this.exitMultiSelectMode(),this.moveCursorTo(e-1,t||0),this.isRowFullyVisible(e-1)||this.scrollToLine(e-1,!0,n);},this.navigateTo=function(e,t){this.selection.moveTo(e,t);},this.navigateUp=function(e){if(this.selection.isMultiLine()&&!this.selection.isBackwards()){var t=this.selection.anchor.getPosition();return this.moveCursorToPosition(t)}this.selection.clearSelection(),this.selection.moveCursorBy(-e||-1,0);},this.navigateDown=function(e){if(this.selection.isMultiLine()&&this.selection.isBackwards()){var t=this.selection.anchor.getPosition();return this.moveCursorToPosition(t)}this.selection.clearSelection(),this.selection.moveCursorBy(e||1,0);},this.navigateLeft=function(e){if(!this.selection.isEmpty()){var t=this.getSelectionRange().start;this.moveCursorToPosition(t);}else{e=e||1;while(e--)this.selection.moveCursorLeft();}this.clearSelection();},this.navigateRight=function(e){if(!this.selection.isEmpty()){var t=this.getSelectionRange().end;this.moveCursorToPosition(t);}else{e=e||1;while(e--)this.selection.moveCursorRight();}this.clearSelection();},this.navigateLineStart=function(){this.selection.moveCursorLineStart(),this.clearSelection();},this.navigateLineEnd=function(){this.selection.moveCursorLineEnd(),this.clearSelection();},this.navigateFileEnd=function(){this.selection.moveCursorFileEnd(),this.clearSelection();},this.navigateFileStart=function(){this.selection.moveCursorFileStart(),this.clearSelection();},this.navigateWordRight=function(){this.selection.moveCursorWordRight(),this.clearSelection();},this.navigateWordLeft=function(){this.selection.moveCursorWordLeft(),this.clearSelection();},this.replace=function(e,t){t&&this.$search.set(t);var n=this.$search.find(this.session),r=0;return n?(this.$tryReplace(n,e)&&(r=1),this.selection.setSelectionRange(n),this.renderer.scrollSelectionIntoView(n.start,n.end),r):r},this.replaceAll=function(e,t){t&&this.$search.set(t);var n=this.$search.findAll(this.session),r=0;if(!n.length)return r;var i=this.getSelectionRange();this.selection.moveTo(0,0);for(var s=n.length-1;s>=0;--s)this.$tryReplace(n[s],e)&&r++;return this.selection.setSelectionRange(i),r},this.$tryReplace=function(e,t){var n=this.session.getTextRange(e);return t=this.$search.replace(n,t),t!==null?(e.end=this.session.replace(e,t),e):null},this.getLastSearchOptions=function(){return this.$search.getOptions()},this.find=function(e,t,n){t||(t={}),typeof e=="string"||e instanceof RegExp?t.needle=e:typeof e=="object"&&r.mixin(t,e);var i=this.selection.getRange();t.needle==null&&(e=this.session.getTextRange(i)||this.$search.$options.needle,e||(i=this.session.getWordRange(i.start.row,i.start.column),e=this.session.getTextRange(i)),this.$search.set({needle:e})),this.$search.set(t),t.start||this.$search.set({start:i});var s=this.$search.find(this.session);if(t.preventScroll)return s;if(s)return this.revealRange(s,n),s;t.backwards?i.start=i.end:i.end=i.start,this.selection.setRange(i);},this.findNext=function(e,t){this.find({skipCurrent:!0,backwards:!1},e,t);},this.findPrevious=function(e,t){this.find(e,{skipCurrent:!0,backwards:!0},t);},this.revealRange=function(e,t){this.session.unfold(e),this.selection.setSelectionRange(e);var n=this.renderer.scrollTop;this.renderer.scrollSelectionIntoView(e.start,e.end,.5),t!==!1&&this.renderer.animateScrolling(n);},this.undo=function(){this.session.getUndoManager().undo(this.session),this.renderer.scrollCursorIntoView(null,.5);},this.redo=function(){this.session.getUndoManager().redo(this.session),this.renderer.scrollCursorIntoView(null,.5);},this.destroy=function(){this.renderer.destroy(),this._signal("destroy",this),this.session&&this.session.destroy();},this.setAutoScrollEditorIntoView=function(e){if(!e)return;var t,n=this,r=!1;this.$scrollAnchor||(this.$scrollAnchor=document.createElement("div"));var i=this.$scrollAnchor;i.style.cssText="position:absolute",this.container.insertBefore(i,this.container.firstChild);var s=this.on("changeSelection",function(){r=!0;}),o=this.renderer.on("beforeRender",function(){r&&(t=n.renderer.container.getBoundingClientRect());}),u=this.renderer.on("afterRender",function(){if(r&&t&&(n.isFocused()||n.searchBox&&n.searchBox.isFocused())){var e=n.renderer,s=e.$cursorLayer.$pixelPos,o=e.layerConfig,u=s.top-o.offset;s.top>=0&&u+t.top<0?r=!0:s.top<o.height&&s.top+t.top+o.lineHeight>window.innerHeight?r=!1:r=null,r!=null&&(i.style.top=u+"px",i.style.left=s.left+"px",i.style.height=o.lineHeight+"px",i.scrollIntoView(r)),r=t=null;}});this.setAutoScrollEditorIntoView=function(e){if(e)return;delete this.setAutoScrollEditorIntoView,this.off("changeSelection",s),this.renderer.off("afterRender",u),this.renderer.off("beforeRender",o);};},this.$resetCursorStyle=function(){var e=this.$cursorStyle||"ace",t=this.renderer.$cursorLayer;if(!t)return;t.setSmoothBlinking(/smooth/.test(e)),t.isBlinking=!this.$readOnly&&e!="wide",i.setCssClass(t.element,"ace_slim-cursors",/slim/.test(e));};}.call(w.prototype),g.defineOptions(w.prototype,"editor",{selectionStyle:{set:function(e){this.onSelectionChange(),this._signal("changeSelectionStyle",{data:e});},initialValue:"line"},highlightActiveLine:{set:function(){this.$updateHighlightActiveLine();},initialValue:!0},highlightSelectedWord:{set:function(e){this.$onSelectionChange();},initialValue:!0},readOnly:{set:function(e){this.textInput.setReadOnly(e),this.$resetCursorStyle();},initialValue:!1},copyWithEmptySelection:{set:function(e){this.textInput.setCopyWithEmptySelection(e);},initialValue:!1},cursorStyle:{set:function(e){this.$resetCursorStyle();},values:["ace","slim","smooth","wide"],initialValue:"ace"},mergeUndoDeltas:{values:[!1,!0,"always"],initialValue:!0},behavioursEnabled:{initialValue:!0},wrapBehavioursEnabled:{initialValue:!0},autoScrollEditorIntoView:{set:function(e){this.setAutoScrollEditorIntoView(e);}},keyboardHandler:{set:function(e){this.setKeyboardHandler(e);},get:function(){return this.$keybindingId},handlesSet:!0},value:{set:function(e){this.session.setValue(e);},get:function(){return this.getValue()},handlesSet:!0,hidden:!0},session:{set:function(e){this.setSession(e);},get:function(){return this.session},handlesSet:!0,hidden:!0},showLineNumbers:{set:function(e){this.renderer.$gutterLayer.setShowLineNumbers(e),this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER),e&&this.$relativeLineNumbers?E.attach(this):E.detach(this);},initialValue:!0},relativeLineNumbers:{set:function(e){this.$showLineNumbers&&e?E.attach(this):E.detach(this);}},hScrollBarAlwaysVisible:"renderer",vScrollBarAlwaysVisible:"renderer",highlightGutterLine:"renderer",animatedScroll:"renderer",showInvisibles:"renderer",showPrintMargin:"renderer",printMarginColumn:"renderer",printMargin:"renderer",fadeFoldWidgets:"renderer",showFoldWidgets:"renderer",displayIndentGuides:"renderer",showGutter:"renderer",fontSize:"renderer",fontFamily:"renderer",maxLines:"renderer",minLines:"renderer",scrollPastEnd:"renderer",fixedWidthGutter:"renderer",theme:"renderer",hasCssTransforms:"renderer",maxPixelHeight:"renderer",useTextareaForIME:"renderer",scrollSpeed:"$mouseHandler",dragDelay:"$mouseHandler",dragEnabled:"$mouseHandler",focusTimeout:"$mouseHandler",tooltipFollowsMouse:"$mouseHandler",firstLineNumber:"session",overwrite:"session",newLineMode:"session",useWorker:"session",useSoftTabs:"session",navigateWithinSoftTabs:"session",tabSize:"session",wrap:"session",indentedSoftWrap:"session",foldStyle:"session",mode:"session"});var E={getText:function(e,t){return (Math.abs(e.selection.lead.row-t)||t+1+(t<9?"\u00b7":""))+""},getWidth:function(e,t,n){return Math.max(t.toString().length,(n.lastRow+1).toString().length,2)*n.characterWidth},update:function(e,t){t.renderer.$loop.schedule(t.renderer.CHANGE_GUTTER);},attach:function(e){e.renderer.$gutterLayer.$renderer=this,e.on("changeSelection",this.update),this.update(null,e);},detach:function(e){e.renderer.$gutterLayer.$renderer==this&&(e.renderer.$gutterLayer.$renderer=null),e.off("changeSelection",this.update),this.update(null,e);}};t.Editor=w;}),define("ace/undomanager",["require","exports","module","ace/range"],function(e,t,n){function i(e,t){for(var n=t;n--;){var r=e[n];if(r&&!r[0].ignore){while(n<t-1){var i=d(e[n],e[n+1]);e[n]=i[0],e[n+1]=i[1],n++;}return !0}}}function f(e){return {row:e.row,column:e.column}}function l(e){return {start:f(e.start),end:f(e.end),action:e.action,lines:e.lines.slice()}}function c(e){e=e||this;if(Array.isArray(e))return e.map(c).join("\n");var t="";e.action?(t=e.action=="insert"?"+":"-",t+="["+e.lines+"]"):e.value&&(Array.isArray(e.value)?t=e.value.map(h).join("\n"):t=h(e.value)),e.start&&(t+=h(e));if(e.id||e.rev)t+="	("+(e.id||e.rev)+")";return t}function h(e){return e.start.row+":"+e.start.column+"=>"+e.end.row+":"+e.end.column}function p(e,t){var n=e.action=="insert",r=t.action=="insert";if(n&&r)if(o(t.start,e.end)>=0)m(t,e,-1);else{if(!(o(t.start,e.start)<=0))return null;m(e,t,1);}else if(n&&!r)if(o(t.start,e.end)>=0)m(t,e,-1);else{if(!(o(t.end,e.start)<=0))return null;m(e,t,-1);}else if(!n&&r)if(o(t.start,e.start)>=0)m(t,e,1);else{if(!(o(t.start,e.start)<=0))return null;m(e,t,1);}else if(!n&&!r)if(o(t.start,e.start)>=0)m(t,e,1);else{if(!(o(t.end,e.start)<=0))return null;m(e,t,-1);}return [t,e]}function d(e,t){for(var n=e.length;n--;)for(var r=0;r<t.length;r++)if(!p(e[n],t[r])){while(n<e.length){while(r--)p(t[r],e[n]);r=t.length,n++;}return [e,t]}return e.selectionBefore=t.selectionBefore=e.selectionAfter=t.selectionAfter=null,[t,e]}function v(e,t){var n=e.action=="insert",r=t.action=="insert";if(n&&r)o(e.start,t.start)<0?m(t,e,1):m(e,t,1);else if(n&&!r)o(e.start,t.end)>=0?m(e,t,-1):o(e.start,t.start)<=0?m(t,e,1):(m(e,s.fromPoints(t.start,e.start),-1),m(t,e,1));else if(!n&&r)o(t.start,e.end)>=0?m(t,e,-1):o(t.start,e.start)<=0?m(e,t,1):(m(t,s.fromPoints(e.start,t.start),-1),m(e,t,1));else if(!n&&!r)if(o(t.start,e.end)>=0)m(t,e,-1);else{if(!(o(t.end,e.start)<=0)){var i,u;return o(e.start,t.start)<0&&(i=e,e=y(e,t.start)),o(e.end,t.end)>0&&(u=y(e,t.end)),g(t.end,e.start,e.end,-1),u&&!i&&(e.lines=u.lines,e.start=u.start,e.end=u.end,u=e),[t,i,u].filter(Boolean)}m(e,t,-1);}return [t,e]}function m(e,t,n){g(e.start,t.start,t.end,n),g(e.end,t.start,t.end,n);}function g(e,t,n,r){e.row==(r==1?t:n).row&&(e.column+=r*(n.column-t.column)),e.row+=r*(n.row-t.row);}function y(e,t){var n=e.lines,r=e.end;e.end=f(t);var i=e.end.row-e.start.row,s=n.splice(i,n.length),o=i?t.column:t.column-e.start.column;n.push(s[0].substring(0,o)),s[0]=s[0].substr(o);var u={start:f(t),end:r,lines:s,action:e.action};return u}function b(e,t){t=l(t);for(var n=e.length;n--;){var r=e[n];for(var i=0;i<r.length;i++){var s=r[i],o=v(s,t);t=o[0],o.length!=2&&(o[2]?(r.splice(i+1,1,o[1],o[2]),i++):o[1]||(r.splice(i,1),i--));}r.length||e.splice(n,1);}return e}function w(e,t){for(var n=0;n<t.length;n++){var r=t[n];for(var i=0;i<r.length;i++)b(e,r[i]);}}var r=function(){this.$maxRev=0,this.$fromUndo=!1,this.reset();};(function(){this.addSession=function(e){this.$session=e;},this.add=function(e,t,n){if(this.$fromUndo)return;if(e==this.$lastDelta)return;if(t===!1||!this.lastDeltas)this.lastDeltas=[],this.$undoStack.push(this.lastDeltas),e.id=this.$rev=++this.$maxRev;if(e.action=="remove"||e.action=="insert")this.$lastDelta=e;this.lastDeltas.push(e);},this.addSelection=function(e,t){this.selections.push({value:e,rev:t||this.$rev});},this.startNewGroup=function(){return this.lastDeltas=null,this.$rev},this.markIgnored=function(e,t){t==null&&(t=this.$rev+1);var n=this.$undoStack;for(var r=n.length;r--;){var i=n[r][0];if(i.id<=e)break;i.id<t&&(i.ignore=!0);}this.lastDeltas=null;},this.getSelection=function(e,t){var n=this.selections;for(var r=n.length;r--;){var i=n[r];if(i.rev<e)return t&&(i=n[r+1]),i}},this.getRevision=function(){return this.$rev},this.getDeltas=function(e,t){t==null&&(t=this.$rev+1);var n=this.$undoStack,r=null,i=0;for(var s=n.length;s--;){var o=n[s][0];o.id<t&&!r&&(r=s+1);if(o.id<=e){i=s+1;break}}return n.slice(i,r)},this.getChangedRanges=function(e,t){t==null&&(t=this.$rev+1);},this.getChangedLines=function(e,t){t==null&&(t=this.$rev+1);},this.undo=function(e,t){this.lastDeltas=null;var n=this.$undoStack;if(!i(n,n.length))return;e||(e=this.$session),this.$redoStackBaseRev!==this.$rev&&this.$redoStack.length&&(this.$redoStack=[]),this.$fromUndo=!0;var r=n.pop(),s=null;return r&&r.length&&(s=e.undoChanges(r,t),this.$redoStack.push(r),this.$syncRev()),this.$fromUndo=!1,s},this.redo=function(e,t){this.lastDeltas=null,e||(e=this.$session),this.$fromUndo=!0;if(this.$redoStackBaseRev!=this.$rev){var n=this.getDeltas(this.$redoStackBaseRev,this.$rev+1);w(this.$redoStack,n),this.$redoStackBaseRev=this.$rev,this.$redoStack.forEach(function(e){e[0].id=++this.$maxRev;},this);}var r=this.$redoStack.pop(),i=null;return r&&(i=e.redoChanges(r,t),this.$undoStack.push(r),this.$syncRev()),this.$fromUndo=!1,i},this.$syncRev=function(){var e=this.$undoStack,t=e[e.length-1],n=t&&t[0].id||0;this.$redoStackBaseRev=n,this.$rev=n;},this.reset=function(){this.lastDeltas=null,this.$lastDelta=null,this.$undoStack=[],this.$redoStack=[],this.$rev=0,this.mark=0,this.$redoStackBaseRev=this.$rev,this.selections=[];},this.canUndo=function(){return this.$undoStack.length>0},this.canRedo=function(){return this.$redoStack.length>0},this.bookmark=function(e){e==undefined&&(e=this.$rev),this.mark=e;},this.isAtBookmark=function(){return this.$rev===this.mark},this.toJSON=function(){},this.fromJSON=function(){},this.hasUndo=this.canUndo,this.hasRedo=this.canRedo,this.isClean=this.isAtBookmark,this.markClean=this.bookmark,this.$prettyPrint=function(e){return e?c(e):c(this.$undoStack)+"\n---\n"+c(this.$redoStack)};}).call(r.prototype);var s=e("./range").Range,o=s.comparePoints,u=s.comparePoints;t.UndoManager=r;}),define("ace/layer/lines",["require","exports","module","ace/lib/dom"],function(e,t,n){var r=e("../lib/dom"),i=function(e,t){this.element=e,this.canvasHeight=t||5e5,this.element.style.height=this.canvasHeight*2+"px",this.cells=[],this.cellCache=[],this.$offsetCoefficient=0;};(function(){this.moveContainer=function(e){r.translate(this.element,0,-(e.firstRowScreen*e.lineHeight%this.canvasHeight)-e.offset*this.$offsetCoefficient);},this.pageChanged=function(e,t){return Math.floor(e.firstRowScreen*e.lineHeight/this.canvasHeight)!==Math.floor(t.firstRowScreen*t.lineHeight/this.canvasHeight)},this.computeLineTop=function(e,t,n){var r=t.firstRowScreen*t.lineHeight,i=Math.floor(r/this.canvasHeight),s=n.documentToScreenRow(e,0)*t.lineHeight;return s-i*this.canvasHeight},this.computeLineHeight=function(e,t,n){return t.lineHeight*n.getRowLength(e)},this.getLength=function(){return this.cells.length},this.get=function(e){return this.cells[e]},this.shift=function(){this.$cacheCell(this.cells.shift());},this.pop=function(){this.$cacheCell(this.cells.pop());},this.push=function(e){if(Array.isArray(e)){this.cells.push.apply(this.cells,e);var t=r.createFragment(this.element);for(var n=0;n<e.length;n++)t.appendChild(e[n].element);this.element.appendChild(t);}else this.cells.push(e),this.element.appendChild(e.element);},this.unshift=function(e){if(Array.isArray(e)){this.cells.unshift.apply(this.cells,e);var t=r.createFragment(this.element);for(var n=0;n<e.length;n++)t.appendChild(e[n].element);this.element.firstChild?this.element.insertBefore(t,this.element.firstChild):this.element.appendChild(t);}else this.cells.unshift(e),this.element.insertAdjacentElement("afterbegin",e.element);},this.last=function(){return this.cells.length?this.cells[this.cells.length-1]:null},this.$cacheCell=function(e){if(!e)return;e.element.remove(),this.cellCache.push(e);},this.createCell=function(e,t,n,i){var s=this.cellCache.pop();if(!s){var o=r.createElement("div");i&&i(o),this.element.appendChild(o),s={element:o,text:"",row:e};}return s.row=e,s};}).call(i.prototype),t.Lines=i;}),define("ace/layer/gutter",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/layer/lines"],function(e,t,n){function f(e){var t=document.createTextNode("");e.appendChild(t);var n=r.createElement("span");return e.appendChild(n),e}var r=e("../lib/dom"),i=e("../lib/oop"),s=e("../lib/lang"),o=e("../lib/event_emitter").EventEmitter,u=e("./lines").Lines,a=function(e){this.element=r.createElement("div"),this.element.className="ace_layer ace_gutter-layer",e.appendChild(this.element),this.setShowFoldWidgets(this.$showFoldWidgets),this.gutterWidth=0,this.$annotations=[],this.$updateAnnotations=this.$updateAnnotations.bind(this),this.$lines=new u(this.element),this.$lines.$offsetCoefficient=1;};(function(){i.implement(this,o),this.setSession=function(e){this.session&&this.session.removeEventListener("change",this.$updateAnnotations),this.session=e,e&&e.on("change",this.$updateAnnotations);},this.addGutterDecoration=function(e,t){window.console&&console.warn&&console.warn("deprecated use session.addGutterDecoration"),this.session.addGutterDecoration(e,t);},this.removeGutterDecoration=function(e,t){window.console&&console.warn&&console.warn("deprecated use session.removeGutterDecoration"),this.session.removeGutterDecoration(e,t);},this.setAnnotations=function(e){this.$annotations=[];for(var t=0;t<e.length;t++){var n=e[t],r=n.row,i=this.$annotations[r];i||(i=this.$annotations[r]={text:[]});var o=n.text;o=o?s.escapeHTML(o):n.html||"",i.text.indexOf(o)===-1&&i.text.push(o);var u=n.type;u=="error"?i.className=" ace_error":u=="warning"&&i.className!=" ace_error"?i.className=" ace_warning":u=="info"&&!i.className&&(i.className=" ace_info");}},this.$updateAnnotations=function(e){if(!this.$annotations.length)return;var t=e.start.row,n=e.end.row-t;if(n!==0)if(e.action=="remove")this.$annotations.splice(t,n+1,null);else{var r=new Array(n+1);r.unshift(t,1),this.$annotations.splice.apply(this.$annotations,r);}},this.update=function(e){this.config=e;var t=this.session,n=e.firstRow,r=Math.min(e.lastRow+e.gutterOffset,t.getLength()-1);this.oldLastRow=r,this.config=e,this.$lines.moveContainer(e),this.$updateCursorRow();var i=t.getNextFoldLine(n),s=i?i.start.row:Infinity,o=null,u=-1,a=n;for(;;){a>s&&(a=i.end.row+1,i=t.getNextFoldLine(a,i),s=i?i.start.row:Infinity);if(a>r){while(this.$lines.getLength()>u+1)this.$lines.pop();break}o=this.$lines.get(++u),o?o.row=a:(o=this.$lines.createCell(a,e,this.session,f),this.$lines.push(o)),this.$renderCell(o,e,i,a),a++;}this._signal("afterRender"),this.$updateGutterWidth(e);},this.$updateGutterWidth=function(e){var t=this.session,n=t.gutterRenderer||this.$renderer,r=t.$firstLineNumber,i=this.$lines.last()?this.$lines.last().text:"";if(this.$fixedWidth||t.$useWrapMode)i=t.getLength()+r-1;var s=n?n.getWidth(t,i,e):i.toString().length*e.characterWidth,o=this.$padding||this.$computePadding();s+=o.left+o.right,s!==this.gutterWidth&&!isNaN(s)&&(this.gutterWidth=s,this.element.parentNode.style.width=this.element.style.width=Math.ceil(this.gutterWidth)+"px",this._signal("changeGutterWidth",s));},this.$updateCursorRow=function(){if(!this.$highlightGutterLine)return;var e=this.session.selection.getCursor();if(this.$cursorRow===e.row)return;this.$cursorRow=e.row;},this.updateLineHighlight=function(){if(!this.$highlightGutterLine)return;var e=this.session.selection.cursor.row;this.$cursorRow=e;if(this.$cursorCell&&this.$cursorCell.row==e)return;this.$cursorCell&&(this.$cursorCell.element.className=this.$cursorCell.element.className.replace("ace_gutter-active-line ",""));var t=this.$lines.cells;this.$cursorCell=null;for(var n=0;n<t.length;n++){var r=t[n];if(r.row>=this.$cursorRow){if(r.row>this.$cursorRow){var i=this.session.getFoldLine(this.$cursorRow);if(!(n>0&&i&&i.start.row==t[n-1].row))break;r=t[n-1];}r.element.className="ace_gutter-active-line "+r.element.className,this.$cursorCell=r;break}}},this.scrollLines=function(e){var t=this.config;this.config=e,this.$updateCursorRow();if(this.$lines.pageChanged(t,e))return this.update(e);this.$lines.moveContainer(e);var n=Math.min(e.lastRow+e.gutterOffset,this.session.getLength()-1),r=this.oldLastRow;this.oldLastRow=n;if(!t||r<e.firstRow)return this.update(e);if(n<t.firstRow)return this.update(e);if(t.firstRow<e.firstRow)for(var i=this.session.getFoldedRowCount(t.firstRow,e.firstRow-1);i>0;i--)this.$lines.shift();if(r>n)for(var i=this.session.getFoldedRowCount(n+1,r);i>0;i--)this.$lines.pop();e.firstRow<t.firstRow&&this.$lines.unshift(this.$renderLines(e,e.firstRow,t.firstRow-1)),n>r&&this.$lines.push(this.$renderLines(e,r+1,n)),this.updateLineHighlight(),this._signal("afterRender"),this.$updateGutterWidth(e);},this.$renderLines=function(e,t,n){var r=[],i=t,s=this.session.getNextFoldLine(i),o=s?s.start.row:Infinity;for(;;){i>o&&(i=s.end.row+1,s=this.session.getNextFoldLine(i,s),o=s?s.start.row:Infinity);if(i>n)break;var u=this.$lines.createCell(i,e,this.session,f);this.$renderCell(u,e,s,i),r.push(u),i++;}return r},this.$renderCell=function(e,t,n,i){var s=e.element,o=this.session,u=s.childNodes[0],a=s.childNodes[1],f=o.$firstLineNumber,l=o.$breakpoints,c=o.$decorations,h=o.gutterRenderer||this.$renderer,p=this.$showFoldWidgets&&o.foldWidgets,d=n?n.start.row:Number.MAX_VALUE,v="ace_gutter-cell ";this.$highlightGutterLine&&(i==this.$cursorRow||n&&i<this.$cursorRow&&i>=d&&this.$cursorRow<=n.end.row)&&(v+="ace_gutter-active-line ",this.$cursorCell!=e&&(this.$cursorCell&&(this.$cursorCell.element.className=this.$cursorCell.element.className.replace("ace_gutter-active-line ","")),this.$cursorCell=e)),l[i]&&(v+=l[i]),c[i]&&(v+=c[i]),this.$annotations[i]&&(v+=this.$annotations[i].className),s.className!=v&&(s.className=v);if(p){var m=p[i];m==null&&(m=p[i]=o.getFoldWidget(i));}if(m){var v="ace_fold-widget ace_"+m;m=="start"&&i==d&&i<n.end.row?v+=" ace_closed":v+=" ace_open",a.className!=v&&(a.className=v);var g=t.lineHeight+"px";r.setStyle(a.style,"height",g),r.setStyle(a.style,"display","inline-block");}else a&&r.setStyle(a.style,"display","none");var y=(h?h.getText(o,i):i+f).toString();return y!==u.data&&(u.data=y),r.setStyle(e.element.style,"height",this.$lines.computeLineHeight(i,t,o)+"px"),r.setStyle(e.element.style,"top",this.$lines.computeLineTop(i,t,o)+"px"),e.text=y,e},this.$fixedWidth=!1,this.$highlightGutterLine=!0,this.$renderer="",this.setHighlightGutterLine=function(e){this.$highlightGutterLine=e;},this.$showLineNumbers=!0,this.$renderer="",this.setShowLineNumbers=function(e){this.$renderer=!e&&{getWidth:function(){return 0},getText:function(){return ""}};},this.getShowLineNumbers=function(){return this.$showLineNumbers},this.$showFoldWidgets=!0,this.setShowFoldWidgets=function(e){e?r.addCssClass(this.element,"ace_folding-enabled"):r.removeCssClass(this.element,"ace_folding-enabled"),this.$showFoldWidgets=e,this.$padding=null;},this.getShowFoldWidgets=function(){return this.$showFoldWidgets},this.$computePadding=function(){if(!this.element.firstChild)return {left:0,right:0};var e=r.computedStyle(this.element.firstChild);return this.$padding={},this.$padding.left=(parseInt(e.borderLeftWidth)||0)+(parseInt(e.paddingLeft)||0)+1,this.$padding.right=(parseInt(e.borderRightWidth)||0)+(parseInt(e.paddingRight)||0),this.$padding},this.getRegion=function(e){var t=this.$padding||this.$computePadding(),n=this.element.getBoundingClientRect();if(e.x<t.left+n.left)return "markers";if(this.$showFoldWidgets&&e.x>n.right-t.right)return "foldWidgets"};}).call(a.prototype),t.Gutter=a;}),define("ace/layer/marker",["require","exports","module","ace/range","ace/lib/dom"],function(e,t,n){var r=e("../range").Range,i=e("../lib/dom"),s=function(e){this.element=i.createElement("div"),this.element.className="ace_layer ace_marker-layer",e.appendChild(this.element);};(function(){function e(e,t,n,r){return (e?1:0)|(t?2:0)|(n?4:0)|(r?8:0)}this.$padding=0,this.setPadding=function(e){this.$padding=e;},this.setSession=function(e){this.session=e;},this.setMarkers=function(e){this.markers=e;},this.elt=function(e,t){var n=this.i!=-1&&this.element.childNodes[this.i];n?this.i++:(n=document.createElement("div"),this.element.appendChild(n),this.i=-1),n.style.cssText=t,n.className=e;},this.update=function(e){if(!e)return;this.config=e,this.i=0;var t;for(var n in this.markers){var r=this.markers[n];if(!r.range){r.update(t,this,this.session,e);continue}var i=r.range.clipRows(e.firstRow,e.lastRow);if(i.isEmpty())continue;i=i.toScreenRange(this.session);if(r.renderer){var s=this.$getTop(i.start.row,e),o=this.$padding+i.start.column*e.characterWidth;r.renderer(t,i,o,s,e);}else r.type=="fullLine"?this.drawFullLineMarker(t,i,r.clazz,e):r.type=="screenLine"?this.drawScreenLineMarker(t,i,r.clazz,e):i.isMultiLine()?r.type=="text"?this.drawTextMarker(t,i,r.clazz,e):this.drawMultiLineMarker(t,i,r.clazz,e):this.drawSingleLineMarker(t,i,r.clazz+" ace_start"+" ace_br15",e);}if(this.i!=-1)while(this.i<this.element.childElementCount)this.element.removeChild(this.element.lastChild);},this.$getTop=function(e,t){return (e-t.firstRowScreen)*t.lineHeight},this.drawTextMarker=function(t,n,i,s,o){var u=this.session,a=n.start.row,f=n.end.row,l=a,c=0,h=0,p=u.getScreenLastRowColumn(l),d=new r(l,n.start.column,l,h);for(;l<=f;l++)d.start.row=d.end.row=l,d.start.column=l==a?n.start.column:u.getRowWrapIndent(l),d.end.column=p,c=h,h=p,p=l+1<f?u.getScreenLastRowColumn(l+1):l==f?0:n.end.column,this.drawSingleLineMarker(t,d,i+(l==a?" ace_start":"")+" ace_br"+e(l==a||l==a+1&&n.start.column,c<h,h>p,l==f),s,l==f?0:1,o);},this.drawMultiLineMarker=function(e,t,n,r,i){var s=this.$padding,o=r.lineHeight,u=this.$getTop(t.start.row,r),a=s+t.start.column*r.characterWidth;i=i||"";if(this.session.$bidiHandler.isBidiRow(t.start.row)){var f=t.clone();f.end.row=f.start.row,f.end.column=this.session.getLine(f.start.row).length,this.drawBidiSingleLineMarker(e,f,n+" ace_br1 ace_start",r,null,i);}else this.elt(n+" ace_br1 ace_start","height:"+o+"px;"+"right:0;"+"top:"+u+"px;left:"+a+"px;"+(i||""));if(this.session.$bidiHandler.isBidiRow(t.end.row)){var f=t.clone();f.start.row=f.end.row,f.start.column=0,this.drawBidiSingleLineMarker(e,f,n+" ace_br12",r,null,i);}else{u=this.$getTop(t.end.row,r);var l=t.end.column*r.characterWidth;this.elt(n+" ace_br12","height:"+o+"px;"+"width:"+l+"px;"+"top:"+u+"px;"+"left:"+s+"px;"+(i||""));}o=(t.end.row-t.start.row-1)*r.lineHeight;if(o<=0)return;u=this.$getTop(t.start.row+1,r);var c=(t.start.column?1:0)|(t.end.column?0:8);this.elt(n+(c?" ace_br"+c:""),"height:"+o+"px;"+"right:0;"+"top:"+u+"px;"+"left:"+s+"px;"+(i||""));},this.drawSingleLineMarker=function(e,t,n,r,i,s){if(this.session.$bidiHandler.isBidiRow(t.start.row))return this.drawBidiSingleLineMarker(e,t,n,r,i,s);var o=r.lineHeight,u=(t.end.column+(i||0)-t.start.column)*r.characterWidth,a=this.$getTop(t.start.row,r),f=this.$padding+t.start.column*r.characterWidth;this.elt(n,"height:"+o+"px;"+"width:"+u+"px;"+"top:"+a+"px;"+"left:"+f+"px;"+(s||""));},this.drawBidiSingleLineMarker=function(e,t,n,r,i,s){var o=r.lineHeight,u=this.$getTop(t.start.row,r),a=this.$padding,f=this.session.$bidiHandler.getSelections(t.start.column,t.end.column);f.forEach(function(e){this.elt(n,"height:"+o+"px;"+"width:"+e.width+(i||0)+"px;"+"top:"+u+"px;"+"left:"+(a+e.left)+"px;"+(s||""));},this);},this.drawFullLineMarker=function(e,t,n,r,i){var s=this.$getTop(t.start.row,r),o=r.lineHeight;t.start.row!=t.end.row&&(o+=this.$getTop(t.end.row,r)-s),this.elt(n,"height:"+o+"px;"+"top:"+s+"px;"+"left:0;right:0;"+(i||""));},this.drawScreenLineMarker=function(e,t,n,r,i){var s=this.$getTop(t.start.row,r),o=r.lineHeight;this.elt(n,"height:"+o+"px;"+"top:"+s+"px;"+"left:0;right:0;"+(i||""));};}).call(s.prototype),t.Marker=s;}),define("ace/layer/text",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/layer/lines","ace/lib/event_emitter"],function(e,t,n){var r=e("../lib/oop"),i=e("../lib/dom"),s=e("../lib/lang"),o=e("./lines").Lines,u=e("../lib/event_emitter").EventEmitter,a=function(e){this.dom=i,this.element=this.dom.createElement("div"),this.element.className="ace_layer ace_text-layer",e.appendChild(this.element),this.$updateEolChar=this.$updateEolChar.bind(this),this.$lines=new o(this.element);};(function(){r.implement(this,u),this.EOF_CHAR="\u00b6",this.EOL_CHAR_LF="\u00ac",this.EOL_CHAR_CRLF="\u00a4",this.EOL_CHAR=this.EOL_CHAR_LF,this.TAB_CHAR="\u2014",this.SPACE_CHAR="\u00b7",this.$padding=0,this.MAX_LINE_LENGTH=1e4,this.$updateEolChar=function(){var e=this.session.doc,t=e.getNewLineCharacter()=="\n"&&e.getNewLineMode()!="windows",n=t?this.EOL_CHAR_LF:this.EOL_CHAR_CRLF;if(this.EOL_CHAR!=n)return this.EOL_CHAR=n,!0},this.setPadding=function(e){this.$padding=e,this.element.style.margin="0 "+e+"px";},this.getLineHeight=function(){return this.$fontMetrics.$characterSize.height||0},this.getCharacterWidth=function(){return this.$fontMetrics.$characterSize.width||0},this.$setFontMetrics=function(e){this.$fontMetrics=e,this.$fontMetrics.on("changeCharacterSize",function(e){this._signal("changeCharacterSize",e);}.bind(this)),this.$pollSizeChanges();},this.checkForSizeChanges=function(){this.$fontMetrics.checkForSizeChanges();},this.$pollSizeChanges=function(){return this.$pollSizeChangesTimer=this.$fontMetrics.$pollSizeChanges()},this.setSession=function(e){this.session=e,e&&this.$computeTabString();},this.showInvisibles=!1,this.setShowInvisibles=function(e){return this.showInvisibles==e?!1:(this.showInvisibles=e,this.$computeTabString(),!0)},this.displayIndentGuides=!0,this.setDisplayIndentGuides=function(e){return this.displayIndentGuides==e?!1:(this.displayIndentGuides=e,this.$computeTabString(),!0)},this.$tabStrings=[],this.onChangeTabSize=this.$computeTabString=function(){var e=this.session.getTabSize();this.tabSize=e;var t=this.$tabStrings=[0];for(var n=1;n<e+1;n++)if(this.showInvisibles){var r=this.dom.createElement("span");r.className="ace_invisible ace_invisible_tab",r.textContent=s.stringRepeat(this.TAB_CHAR,n),t.push(r);}else t.push(this.dom.createTextNode(s.stringRepeat(" ",n),this.element));if(this.displayIndentGuides){this.$indentGuideRe=/\s\S| \t|\t |\s$/;var i="ace_indent-guide",o="",u="";if(this.showInvisibles){i+=" ace_invisible",o=" ace_invisible_space",u=" ace_invisible_tab";var a=s.stringRepeat(this.SPACE_CHAR,this.tabSize),f=s.stringRepeat(this.TAB_CHAR,this.tabSize);}else var a=s.stringRepeat(" ",this.tabSize),f=a;var r=this.dom.createElement("span");r.className=i+o,r.textContent=a,this.$tabStrings[" "]=r;var r=this.dom.createElement("span");r.className=i+u,r.textContent=f,this.$tabStrings["	"]=r;}},this.updateLines=function(e,t,n){if(this.config.lastRow!=e.lastRow||this.config.firstRow!=e.firstRow)return this.update(e);this.config=e;var r=Math.max(t,e.firstRow),i=Math.min(n,e.lastRow),s=this.element.childNodes,o=0;for(var u=e.firstRow;u<r;u++){var a=this.session.getFoldLine(u);if(a){if(a.containsRow(r)){r=a.start.row;break}u=a.end.row;}o++;}var f=!1,u=r,a=this.session.getNextFoldLine(u),l=a?a.start.row:Infinity;for(;;){u>l&&(u=a.end.row+1,a=this.session.getNextFoldLine(u,a),l=a?a.start.row:Infinity);if(u>i)break;var c=s[o++];if(c){this.dom.removeChildren(c),this.$renderLine(c,u,u==l?a:!1);var h=e.lineHeight*this.session.getRowLength(u)+"px";c.style.height!=h&&(f=!0,c.style.height=h);}u++;}if(f)while(o<this.$lines.cells.length){var p=this.$lines.cells[o++];p.element.style.top=this.$lines.computeLineTop(p.row,e,this.session)+"px";}},this.scrollLines=function(e){var t=this.config;this.config=e;if(this.$lines.pageChanged(t,e))return this.update(e);this.$lines.moveContainer(e);var n=e.lastRow,r=t?t.lastRow:-1;if(!t||r<e.firstRow)return this.update(e);if(n<t.firstRow)return this.update(e);if(!t||t.lastRow<e.firstRow)return this.update(e);if(e.lastRow<t.firstRow)return this.update(e);if(t.firstRow<e.firstRow)for(var i=this.session.getFoldedRowCount(t.firstRow,e.firstRow-1);i>0;i--)this.$lines.shift();if(t.lastRow>e.lastRow)for(var i=this.session.getFoldedRowCount(e.lastRow+1,t.lastRow);i>0;i--)this.$lines.pop();e.firstRow<t.firstRow&&this.$lines.unshift(this.$renderLinesFragment(e,e.firstRow,t.firstRow-1)),e.lastRow>t.lastRow&&this.$lines.push(this.$renderLinesFragment(e,t.lastRow+1,e.lastRow));},this.$renderLinesFragment=function(e,t,n){var r=[],s=t,o=this.session.getNextFoldLine(s),u=o?o.start.row:Infinity;for(;;){s>u&&(s=o.end.row+1,o=this.session.getNextFoldLine(s,o),u=o?o.start.row:Infinity);if(s>n)break;var a=this.$lines.createCell(s,e,this.session),f=a.element;this.dom.removeChildren(f),i.setStyle(f.style,"height",this.$lines.computeLineHeight(s,e,this.session)+"px"),i.setStyle(f.style,"top",this.$lines.computeLineTop(s,e,this.session)+"px"),this.$renderLine(f,s,s==u?o:!1),this.$useLineGroups()?f.className="ace_line_group":f.className="ace_line",r.push(a),s++;}return r},this.update=function(e){this.$lines.moveContainer(e),this.config=e;var t=e.firstRow,n=e.lastRow,r=this.$lines;while(r.getLength())r.pop();r.push(this.$renderLinesFragment(e,t,n));},this.$textToken={text:!0,rparen:!0,lparen:!0},this.$renderToken=function(e,t,n,r){var o=this,u=/(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g,a=this.dom.createFragment(this.element),f,l=0;while(f=u.exec(r)){var c=f[1],h=f[2],p=f[3],d=f[4],v=f[5];if(!o.showInvisibles&&h)continue;var m=l!=f.index?r.slice(l,f.index):"";l=f.index+f[0].length,m&&a.appendChild(this.dom.createTextNode(m,this.element));if(c){var g=o.session.getScreenTabSize(t+f.index);a.appendChild(o.$tabStrings[g].cloneNode(!0)),t+=g-1;}else if(h)if(o.showInvisibles){var y=this.dom.createElement("span");y.className="ace_invisible ace_invisible_space",y.textContent=s.stringRepeat(o.SPACE_CHAR,h.length),a.appendChild(y);}else a.appendChild(this.com.createTextNode(h,this.element));else if(p){var y=this.dom.createElement("span");y.className="ace_invisible ace_invisible_space ace_invalid",y.textContent=s.stringRepeat(o.SPACE_CHAR,p.length),a.appendChild(y);}else if(d){var b=o.showInvisibles?o.SPACE_CHAR:"";t+=1;var y=this.dom.createElement("span");y.style.width=o.config.characterWidth*2+"px",y.className=o.showInvisibles?"ace_cjk ace_invisible ace_invisible_space":"ace_cjk",y.textContent=o.showInvisibles?o.SPACE_CHAR:"",a.appendChild(y);}else if(v){t+=1;var y=i.createElement("span");y.style.width=o.config.characterWidth*2+"px",y.className="ace_cjk",y.textContent=v,a.appendChild(y);}}a.appendChild(this.dom.createTextNode(l?r.slice(l):r,this.element));if(!this.$textToken[n.type]){var w="ace_"+n.type.replace(/\./g," ace_"),y=this.dom.createElement("span");n.type=="fold"&&(y.style.width=n.value.length*this.config.characterWidth+"px"),y.className=w,y.appendChild(a),e.appendChild(y);}else e.appendChild(a);return t+r.length},this.renderIndentGuide=function(e,t,n){var r=t.search(this.$indentGuideRe);if(r<=0||r>=n)return t;if(t[0]==" "){r-=r%this.tabSize;var i=r/this.tabSize;for(var s=0;s<i;s++)e.appendChild(this.$tabStrings[" "].cloneNode(!0));return t.substr(r)}if(t[0]=="	"){for(var s=0;s<r;s++)e.appendChild(this.$tabStrings["	"].cloneNode(!0));return t.substr(r)}return t},this.$createLineElement=function(e){var t=this.dom.createElement("div");return t.className="ace_line",t.style.height=this.config.lineHeight+"px",t},this.$renderWrappedLine=function(e,t,n){var r=0,i=0,o=n[0],u=0,a=this.$createLineElement();e.appendChild(a);for(var f=0;f<t.length;f++){var l=t[f],c=l.value;if(f==0&&this.displayIndentGuides){r=c.length,c=this.renderIndentGuide(a,c,o);if(!c)continue;r-=c.length;}if(r+c.length<o)u=this.$renderToken(a,u,l,c),r+=c.length;else{while(r+c.length>=o)u=this.$renderToken(a,u,l,c.substring(0,o-r)),c=c.substring(o-r),r=o,a=this.$createLineElement(),e.appendChild(a),a.appendChild(this.dom.createTextNode(s.stringRepeat("\u00a0",n.indent),this.element)),i++,u=0,o=n[i]||Number.MAX_VALUE;c.length!=0&&(r+=c.length,u=this.$renderToken(a,u,l,c));}}},this.$renderSimpleLine=function(e,t){var n=0,r=t[0],i=r.value;this.displayIndentGuides&&(i=this.renderIndentGuide(e,i)),i&&(n=this.$renderToken(e,n,r,i));for(var s=1;s<t.length;s++){r=t[s],i=r.value;if(n+i.length>this.MAX_LINE_LENGTH)return this.$renderOverflowMessage(e,n,r,i);n=this.$renderToken(e,n,r,i);}},this.$renderOverflowMessage=function(e,t,n,r){this.$renderToken(e,t,n,r.slice(0,this.MAX_LINE_LENGTH-t));var i=this.dom.createElement("span");i.className="ace_inline_button ace_keyword ace_toggle_wrap",i.style.position="absolute",i.style.right="0",i.textContent="<click to see more...>",e.appendChild(i);},this.$renderLine=function(e,t,n){!n&&n!=0&&(n=this.session.getFoldLine(t));if(n)var r=this.$getFoldLineTokens(t,n);else var r=this.session.getTokens(t);var i=e;if(r.length){var s=this.session.getRowSplitData(t);if(s&&s.length){this.$renderWrappedLine(e,r,s);var i=e.lastChild;}else{var i=e;this.$useLineGroups()&&(i=this.$createLineElement(),e.appendChild(i)),this.$renderSimpleLine(i,r);}}else this.$useLineGroups()&&(i=this.$createLineElement(),e.appendChild(i));if(this.showInvisibles&&i){n&&(t=n.end.row);var o=this.dom.createElement("span");o.className="ace_invisible ace_invisible_eol",o.textContent=t==this.session.getLength()-1?this.EOF_CHAR:this.EOL_CHAR,i.appendChild(o);}},this.$getFoldLineTokens=function(e,t){function i(e,t,n){var i=0,s=0;while(s+e[i].value.length<t){s+=e[i].value.length,i++;if(i==e.length)return}if(s!=t){var o=e[i].value.substring(t-s);o.length>n-t&&(o=o.substring(0,n-t)),r.push({type:e[i].type,value:o}),s=t+o.length,i+=1;}while(s<n&&i<e.length){var o=e[i].value;o.length+s>n?r.push({type:e[i].type,value:o.substring(0,n-s)}):r.push(e[i]),s+=o.length,i+=1;}}var n=this.session,r=[],s=n.getTokens(e);return t.walk(function(e,t,o,u,a){e!=null?r.push({type:"fold",value:e}):(a&&(s=n.getTokens(t)),s.length&&i(s,u,o));},t.end.row,this.session.getLine(t.end.row).length),r},this.$useLineGroups=function(){return this.session.getUseWrapMode()},this.destroy=function(){};}).call(a.prototype),t.Text=a;}),define("ace/layer/cursor",["require","exports","module","ace/lib/dom"],function(e,t,n){var r=e("../lib/dom"),i=function(e){this.element=r.createElement("div"),this.element.className="ace_layer ace_cursor-layer",e.appendChild(this.element),this.isVisible=!1,this.isBlinking=!0,this.blinkInterval=1e3,this.smoothBlinking=!1,this.cursors=[],this.cursor=this.addCursor(),r.addCssClass(this.element,"ace_hidden-cursors"),this.$updateCursors=this.$updateOpacity.bind(this);};(function(){this.$updateOpacity=function(e){var t=this.cursors;for(var n=t.length;n--;)r.setStyle(t[n].style,"opacity",e?"":"0");},this.$startCssAnimation=function(){var e=this.cursors;for(var t=e.length;t--;)e[t].style.animationDuration=this.blinkInterval+"ms";setTimeout(function(){r.addCssClass(this.element,"ace_animate-blinking");}.bind(this));},this.$stopCssAnimation=function(){r.removeCssClass(this.element,"ace_animate-blinking");},this.$padding=0,this.setPadding=function(e){this.$padding=e;},this.setSession=function(e){this.session=e;},this.setBlinking=function(e){e!=this.isBlinking&&(this.isBlinking=e,this.restartTimer());},this.setBlinkInterval=function(e){e!=this.blinkInterval&&(this.blinkInterval=e,this.restartTimer());},this.setSmoothBlinking=function(e){e!=this.smoothBlinking&&(this.smoothBlinking=e,r.setCssClass(this.element,"ace_smooth-blinking",e),this.$updateCursors(!0),this.restartTimer());},this.addCursor=function(){var e=r.createElement("div");return e.className="ace_cursor",this.element.appendChild(e),this.cursors.push(e),e},this.removeCursor=function(){if(this.cursors.length>1){var e=this.cursors.pop();return e.parentNode.removeChild(e),e}},this.hideCursor=function(){this.isVisible=!1,r.addCssClass(this.element,"ace_hidden-cursors"),this.restartTimer();},this.showCursor=function(){this.isVisible=!0,r.removeCssClass(this.element,"ace_hidden-cursors"),this.restartTimer();},this.restartTimer=function(){var e=this.$updateCursors;clearInterval(this.intervalId),clearTimeout(this.timeoutId),this.$stopCssAnimation(),this.smoothBlinking&&r.removeCssClass(this.element,"ace_smooth-blinking"),e(!0);if(!this.isBlinking||!this.blinkInterval||!this.isVisible){this.$stopCssAnimation();return}this.smoothBlinking&&setTimeout(function(){r.addCssClass(this.element,"ace_smooth-blinking");}.bind(this));if(r.HAS_CSS_ANIMATION)this.$startCssAnimation();else{var t=function(){this.timeoutId=setTimeout(function(){e(!1);},.6*this.blinkInterval);}.bind(this);this.intervalId=setInterval(function(){e(!0),t();},this.blinkInterval),t();}},this.getPixelPosition=function(e,t){if(!this.config||!this.session)return {left:0,top:0};e||(e=this.session.selection.getCursor());var n=this.session.documentToScreenPosition(e),r=this.$padding+(this.session.$bidiHandler.isBidiRow(n.row,e.row)?this.session.$bidiHandler.getPosLeft(n.column):n.column*this.config.characterWidth),i=(n.row-(t?this.config.firstRowScreen:0))*this.config.lineHeight;return {left:r,top:i}},this.isCursorInView=function(e,t){return e.top>=0&&e.top<t.maxHeight},this.update=function(e){this.config=e;var t=this.session.$selectionMarkers,n=0,i=0;if(t===undefined||t.length===0)t=[{cursor:null}];for(var n=0,s=t.length;n<s;n++){var o=this.getPixelPosition(t[n].cursor,!0);if((o.top>e.height+e.offset||o.top<0)&&n>1)continue;var u=this.cursors[i++]||this.addCursor(),a=u.style;this.drawCursor?this.drawCursor(u,o,e,t[n],this.session):this.isCursorInView(o,e)?(r.setStyle(a,"display","block"),r.translate(u,o.left,o.top),r.setStyle(a,"width",Math.round(e.characterWidth)+"px"),r.setStyle(a,"height",e.lineHeight+"px")):r.setStyle(a,"display","none");}while(this.cursors.length>i)this.removeCursor();var f=this.session.getOverwrite();this.$setOverwrite(f),this.$pixelPos=o,this.restartTimer();},this.drawCursor=null,this.$setOverwrite=function(e){e!=this.overwrite&&(this.overwrite=e,e?r.addCssClass(this.element,"ace_overwrite-cursors"):r.removeCssClass(this.element,"ace_overwrite-cursors"));},this.destroy=function(){clearInterval(this.intervalId),clearTimeout(this.timeoutId);};}).call(i.prototype),t.Cursor=i;}),define("ace/scrollbar",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"],function(e,t,n){var r=e("./lib/oop"),i=e("./lib/dom"),s=e("./lib/event"),o=e("./lib/event_emitter").EventEmitter,u=32768,a=function(e){this.element=i.createElement("div"),this.element.className="ace_scrollbar ace_scrollbar"+this.classSuffix,this.inner=i.createElement("div"),this.inner.className="ace_scrollbar-inner",this.element.appendChild(this.inner),e.appendChild(this.element),this.setVisible(!1),this.skipEvent=!1,s.addListener(this.element,"scroll",this.onScroll.bind(this)),s.addListener(this.element,"mousedown",s.preventDefault);};(function(){r.implement(this,o),this.setVisible=function(e){this.element.style.display=e?"":"none",this.isVisible=e,this.coeff=1;};}).call(a.prototype);var f=function(e,t){a.call(this,e),this.scrollTop=0,this.scrollHeight=0,t.$scrollbarWidth=this.width=i.scrollbarWidth(e.ownerDocument),this.inner.style.width=this.element.style.width=(this.width||15)+5+"px",this.$minWidth=0;};r.inherits(f,a),function(){this.classSuffix="-v",this.onScroll=function(){if(!this.skipEvent){this.scrollTop=this.element.scrollTop;if(this.coeff!=1){var e=this.element.clientHeight/this.scrollHeight;this.scrollTop=this.scrollTop*(1-e)/(this.coeff-e);}this._emit("scroll",{data:this.scrollTop});}this.skipEvent=!1;},this.getWidth=function(){return Math.max(this.isVisible?this.width:0,this.$minWidth||0)},this.setHeight=function(e){this.element.style.height=e+"px";},this.setInnerHeight=this.setScrollHeight=function(e){this.scrollHeight=e,e>u?(this.coeff=u/e,e=u):this.coeff!=1&&(this.coeff=1),this.inner.style.height=e+"px";},this.setScrollTop=function(e){this.scrollTop!=e&&(this.skipEvent=!0,this.scrollTop=e,this.element.scrollTop=e*this.coeff);};}.call(f.prototype);var l=function(e,t){a.call(this,e),this.scrollLeft=0,this.height=t.$scrollbarWidth,this.inner.style.height=this.element.style.height=(this.height||15)+5+"px";};r.inherits(l,a),function(){this.classSuffix="-h",this.onScroll=function(){this.skipEvent||(this.scrollLeft=this.element.scrollLeft,this._emit("scroll",{data:this.scrollLeft})),this.skipEvent=!1;},this.getHeight=function(){return this.isVisible?this.height:0},this.setWidth=function(e){this.element.style.width=e+"px";},this.setInnerWidth=function(e){this.inner.style.width=e+"px";},this.setScrollWidth=function(e){this.inner.style.width=e+"px";},this.setScrollLeft=function(e){this.scrollLeft!=e&&(this.skipEvent=!0,this.scrollLeft=this.element.scrollLeft=e);};}.call(l.prototype),t.ScrollBar=f,t.ScrollBarV=f,t.ScrollBarH=l,t.VScrollBar=f,t.HScrollBar=l;}),define("ace/renderloop",["require","exports","module","ace/lib/event"],function(e,t,n){var r=e("./lib/event"),i=function(e,t){this.onRender=e,this.pending=!1,this.changes=0,this.$recursionLimit=2,this.window=t||window;var n=this;this._flush=function(e){n.pending=!1;var t=n.changes;t&&(r.blockIdle(100),n.changes=0,n.onRender(t));if(n.changes){if(n.$recursionLimit--<0)return;n.schedule();}else n.$recursionLimit=2;};};(function(){this.schedule=function(e){this.changes=this.changes|e,this.changes&&!this.pending&&(r.nextFrame(this._flush),this.pending=!0);},this.clear=function(e){var t=this.changes;return this.changes=0,t};}).call(i.prototype),t.RenderLoop=i;}),define("ace/layer/font_metrics",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/event","ace/lib/useragent","ace/lib/event_emitter"],function(e,t,n){var r=e("../lib/oop"),i=e("../lib/dom"),s=e("../lib/lang"),o=e("../lib/event"),u=e("../lib/useragent"),a=e("../lib/event_emitter").EventEmitter,f=256,l=typeof ResizeObserver=="function",c=200,h=t.FontMetrics=function(e){this.el=i.createElement("div"),this.$setMeasureNodeStyles(this.el.style,!0),this.$main=i.createElement("div"),this.$setMeasureNodeStyles(this.$main.style),this.$measureNode=i.createElement("div"),this.$setMeasureNodeStyles(this.$measureNode.style),this.el.appendChild(this.$main),this.el.appendChild(this.$measureNode),e.appendChild(this.el),this.$measureNode.innerHTML=s.stringRepeat("X",f),this.$characterSize={width:0,height:0},l?this.$addObserver():this.checkForSizeChanges();};(function(){r.implement(this,a),this.$characterSize={width:0,height:0},this.$setMeasureNodeStyles=function(e,t){e.width=e.height="auto",e.left=e.top="0px",e.visibility="hidden",e.position="absolute",e.whiteSpace="pre",u.isIE<8?e["font-family"]="inherit":e.font="inherit",e.overflow=t?"hidden":"visible";},this.checkForSizeChanges=function(e){e===undefined&&(e=this.$measureSizes());if(e&&(this.$characterSize.width!==e.width||this.$characterSize.height!==e.height)){this.$measureNode.style.fontWeight="bold";var t=this.$measureSizes();this.$measureNode.style.fontWeight="",this.$characterSize=e,this.charSizes=Object.create(null),this.allowBoldFonts=t&&t.width===e.width&&t.height===e.height,this._emit("changeCharacterSize",{data:e});}},this.$addObserver=function(){var e=this;this.$observer=new window.ResizeObserver(function(t){var n=t[0].contentRect;e.checkForSizeChanges({height:n.height,width:n.width/f});}),this.$observer.observe(this.$measureNode);},this.$pollSizeChanges=function(){if(this.$pollSizeChangesTimer||this.$observer)return this.$pollSizeChangesTimer;var e=this;return this.$pollSizeChangesTimer=o.onIdle(function t(){e.checkForSizeChanges(),o.onIdle(t,500);},500)},this.setPolling=function(e){e?this.$pollSizeChanges():this.$pollSizeChangesTimer&&(clearInterval(this.$pollSizeChangesTimer),this.$pollSizeChangesTimer=0);},this.$measureSizes=function(e){var t={height:(e||this.$measureNode).clientHeight,width:(e||this.$measureNode).clientWidth/f};return t.width===0||t.height===0?null:t},this.$measureCharWidth=function(e){this.$main.innerHTML=s.stringRepeat(e,f);var t=this.$main.getBoundingClientRect();return t.width/f},this.getCharacterWidth=function(e){var t=this.charSizes[e];return t===undefined&&(t=this.charSizes[e]=this.$measureCharWidth(e)/this.$characterSize.width),t},this.destroy=function(){clearInterval(this.$pollSizeChangesTimer),this.$observer&&this.$observer.disconnect(),this.el&&this.el.parentNode&&this.el.parentNode.removeChild(this.el);},this.$getZoom=function e(t){return t?(window.getComputedStyle(t).zoom||1)*e(t.parentElement):1},this.$initTransformMeasureNodes=function(){var e=function(e,t){return ["div",{style:"position: absolute;top:"+e+"px;left:"+t+"px;"}]};this.els=i.buildDom([e(0,0),e(c,0),e(0,c),e(c,c)],this.el);},this.transformCoordinates=function(e,t){function r(e,t,n){var r=e[1]*t[0]-e[0]*t[1];return [(-t[1]*n[0]+t[0]*n[1])/r,(+e[1]*n[0]-e[0]*n[1])/r]}function i(e,t){return [e[0]-t[0],e[1]-t[1]]}function s(e,t){return [e[0]+t[0],e[1]+t[1]]}function o(e,t){return [e*t[0],e*t[1]]}function u(e){var t=e.getBoundingClientRect();return [t.left,t.top]}if(e){var n=this.$getZoom(this.el);e=o(1/n,e);}this.els||this.$initTransformMeasureNodes();var a=u(this.els[0]),f=u(this.els[1]),l=u(this.els[2]),h=u(this.els[3]),p=r(i(h,f),i(h,l),i(s(f,l),s(h,a))),d=o(1+p[0],i(f,a)),v=o(1+p[1],i(l,a));if(t){var m=t,g=p[0]*m[0]/c+p[1]*m[1]/c+1,y=s(o(m[0],d),o(m[1],v));return s(o(1/g/c,y),a)}var b=i(e,a),w=r(i(d,o(p[0],b)),i(v,o(p[1],b)),b);return o(c,w)};}).call(h.prototype);}),define("ace/virtual_renderer",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/config","ace/layer/gutter","ace/layer/marker","ace/layer/text","ace/layer/cursor","ace/scrollbar","ace/scrollbar","ace/renderloop","ace/layer/font_metrics","ace/lib/event_emitter","ace/lib/useragent"],function(e,t,n){var r=e("./lib/oop"),i=e("./lib/dom"),s=e("./config"),o=e("./layer/gutter").Gutter,u=e("./layer/marker").Marker,a=e("./layer/text").Text,f=e("./layer/cursor").Cursor,l=e("./scrollbar").HScrollBar,c=e("./scrollbar").VScrollBar,h=e("./renderloop").RenderLoop,p=e("./layer/font_metrics").FontMetrics,d=e("./lib/event_emitter").EventEmitter,v='.ace_br1 {border-top-left-radius    : 3px;}.ace_br2 {border-top-right-radius   : 3px;}.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}.ace_br4 {border-bottom-right-radius: 3px;}.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}.ace_br8 {border-bottom-left-radius : 3px;}.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}.ace_editor {position: relative;overflow: hidden;font: 12px/normal \'Monaco\', \'Menlo\', \'Ubuntu Mono\', \'Consolas\', \'source-code-pro\', monospace;direction: ltr;text-align: left;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);}.ace_scroller {position: absolute;overflow: hidden;top: 0;bottom: 0;background-color: inherit;-ms-user-select: none;-moz-user-select: none;-webkit-user-select: none;user-select: none;cursor: text;}.ace_content {position: absolute;box-sizing: border-box;min-width: 100%;contain: style size layout;}.ace_dragging .ace_scroller:before{position: absolute;top: 0;left: 0;right: 0;bottom: 0;content: \'\';background: rgba(250, 250, 250, 0.01);z-index: 1000;}.ace_dragging.ace_dark .ace_scroller:before{background: rgba(0, 0, 0, 0.01);}.ace_selecting, .ace_selecting * {cursor: text !important;}.ace_gutter {position: absolute;overflow : hidden;width: auto;top: 0;bottom: 0;left: 0;cursor: default;z-index: 4;-ms-user-select: none;-moz-user-select: none;-webkit-user-select: none;user-select: none;contain: style size layout;}.ace_gutter-active-line {position: absolute;left: 0;right: 0;}.ace_scroller.ace_scroll-left {box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;}.ace_gutter-cell {position: absolute;top: 0;left: 0;right: 0;padding-left: 19px;padding-right: 6px;background-repeat: no-repeat;}.ace_gutter-cell.ace_error {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");background-repeat: no-repeat;background-position: 2px center;}.ace_gutter-cell.ace_warning {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");background-position: 2px center;}.ace_gutter-cell.ace_info {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");background-position: 2px center;}.ace_dark .ace_gutter-cell.ace_info {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");}.ace_scrollbar {contain: strict;position: absolute;right: 0;bottom: 0;z-index: 6;}.ace_scrollbar-inner {position: absolute;cursor: text;left: 0;top: 0;}.ace_scrollbar-v{overflow-x: hidden;overflow-y: scroll;top: 0;}.ace_scrollbar-h {overflow-x: scroll;overflow-y: hidden;left: 0;}.ace_print-margin {position: absolute;height: 100%;}.ace_text-input {position: absolute;z-index: 0;width: 0.5em;height: 1em;opacity: 0;background: transparent;-moz-appearance: none;appearance: none;border: none;resize: none;outline: none;overflow: hidden;font: inherit;padding: 0 1px;margin: 0 -1px;contain: strict;-ms-user-select: text;-moz-user-select: text;-webkit-user-select: text;user-select: text;white-space: pre!important;}.ace_text-input.ace_composition {background: transparent;color: inherit;z-index: 1000;opacity: 1;}.ace_composition_placeholder { color: transparent }.ace_composition_marker { border-bottom: 1px solid;position: absolute;border-radius: 0;margin-top: 1px;}[ace_nocontext=true] {transform: none!important;filter: none!important;perspective: none!important;clip-path: none!important;mask : none!important;contain: none!important;perspective: none!important;mix-blend-mode: initial!important;z-index: auto;}.ace_layer {z-index: 1;position: absolute;overflow: hidden;word-wrap: normal;white-space: pre;height: 100%;width: 100%;box-sizing: border-box;pointer-events: none;}.ace_gutter-layer {position: relative;width: auto;text-align: right;pointer-events: auto;height: 1000000px;contain: style size layout;}.ace_text-layer {font: inherit !important;position: absolute;height: 1000000px;width: 1000000px;contain: style size layout;}.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {contain: style size layout;position: absolute;top: 0;left: 0;right: 0;}.ace_hidpi .ace_text-layer,.ace_hidpi .ace_gutter-layer,.ace_hidpi .ace_content,.ace_hidpi .ace_gutter {contain: strict;will-change: transform;}.ace_hidpi .ace_text-layer > .ace_line, .ace_hidpi .ace_text-layer > .ace_line_group {contain: strict;}.ace_cjk {display: inline-block;text-align: center;}.ace_cursor-layer {z-index: 4;}.ace_cursor {z-index: 4;position: absolute;box-sizing: border-box;border-left: 2px solid;transform: translatez(0);}.ace_multiselect .ace_cursor {border-left-width: 1px;}.ace_slim-cursors .ace_cursor {border-left-width: 1px;}.ace_overwrite-cursors .ace_cursor {border-left-width: 0;border-bottom: 1px solid;}.ace_hidden-cursors .ace_cursor {opacity: 0.2;}.ace_smooth-blinking .ace_cursor {transition: opacity 0.18s;}.ace_animate-blinking .ace_cursor {animation-duration: 1000ms;animation-timing-function: step-end;animation-name: blink-ace-animate;animation-iteration-count: infinite;}.ace_animate-blinking.ace_smooth-blinking .ace_cursor {animation-duration: 1000ms;animation-timing-function: ease-in-out;animation-name: blink-ace-animate-smooth;}@keyframes blink-ace-animate {from, to { opacity: 1; }60% { opacity: 0; }}@keyframes blink-ace-animate-smooth {from, to { opacity: 1; }45% { opacity: 1; }60% { opacity: 0; }85% { opacity: 0; }}.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {position: absolute;z-index: 3;}.ace_marker-layer .ace_selection {position: absolute;z-index: 5;}.ace_marker-layer .ace_bracket {position: absolute;z-index: 6;}.ace_marker-layer .ace_active-line {position: absolute;z-index: 2;}.ace_marker-layer .ace_selected-word {position: absolute;z-index: 4;box-sizing: border-box;}.ace_line .ace_fold {box-sizing: border-box;display: inline-block;height: 11px;margin-top: -2px;vertical-align: middle;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");background-repeat: no-repeat, repeat-x;background-position: center center, top left;color: transparent;border: 1px solid black;border-radius: 2px;cursor: pointer;pointer-events: auto;}.ace_dark .ace_fold {}.ace_fold:hover{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");}.ace_tooltip {background-color: #FFF;background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));border: 1px solid gray;border-radius: 1px;box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);color: black;max-width: 100%;padding: 3px 4px;position: fixed;z-index: 999999;box-sizing: border-box;cursor: default;white-space: pre;word-wrap: break-word;line-height: normal;font-style: normal;font-weight: normal;letter-spacing: normal;pointer-events: none;}.ace_folding-enabled > .ace_gutter-cell {padding-right: 13px;}.ace_fold-widget {box-sizing: border-box;margin: 0 -12px 0 1px;display: none;width: 11px;vertical-align: top;background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");background-repeat: no-repeat;background-position: center;border-radius: 3px;border: 1px solid transparent;cursor: pointer;}.ace_folding-enabled .ace_fold-widget {display: inline-block;   }.ace_fold-widget.ace_end {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");}.ace_fold-widget.ace_closed {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");}.ace_fold-widget:hover {border: 1px solid rgba(0, 0, 0, 0.3);background-color: rgba(255, 255, 255, 0.2);box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);}.ace_fold-widget:active {border: 1px solid rgba(0, 0, 0, 0.4);background-color: rgba(0, 0, 0, 0.05);box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);}.ace_dark .ace_fold-widget {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");}.ace_dark .ace_fold-widget.ace_end {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");}.ace_dark .ace_fold-widget.ace_closed {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");}.ace_dark .ace_fold-widget:hover {box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);background-color: rgba(255, 255, 255, 0.1);}.ace_dark .ace_fold-widget:active {box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);}.ace_inline_button {border: 1px solid lightgray;display: inline-block;margin: -1px 8px;padding: 0 5px;pointer-events: auto;cursor: pointer;}.ace_inline_button:hover {border-color: gray;background: rgba(200,200,200,0.2);display: inline-block;pointer-events: auto;}.ace_fold-widget.ace_invalid {background-color: #FFB4B4;border-color: #DE5555;}.ace_fade-fold-widgets .ace_fold-widget {transition: opacity 0.4s ease 0.05s;opacity: 0;}.ace_fade-fold-widgets:hover .ace_fold-widget {transition: opacity 0.05s ease 0.05s;opacity:1;}.ace_underline {text-decoration: underline;}.ace_bold {font-weight: bold;}.ace_nobold .ace_bold {font-weight: normal;}.ace_italic {font-style: italic;}.ace_error-marker {background-color: rgba(255, 0, 0,0.2);position: absolute;z-index: 9;}.ace_highlight-marker {background-color: rgba(255, 255, 0,0.2);position: absolute;z-index: 8;}',m=e("./lib/useragent"),g=m.isIE;i.importCssString(v,"ace_editor.css");var y=function(e,t){var n=this;this.container=e||i.createElement("div"),i.addCssClass(this.container,"ace_editor"),i.HI_DPI&&i.addCssClass(this.container,"ace_hidpi"),this.setTheme(t),this.$gutter=i.createElement("div"),this.$gutter.className="ace_gutter",this.container.appendChild(this.$gutter),this.$gutter.setAttribute("aria-hidden",!0),this.scroller=i.createElement("div"),this.scroller.className="ace_scroller",this.container.appendChild(this.scroller),this.content=i.createElement("div"),this.content.className="ace_content",this.scroller.appendChild(this.content),this.$gutterLayer=new o(this.$gutter),this.$gutterLayer.on("changeGutterWidth",this.onGutterResize.bind(this)),this.$markerBack=new u(this.content);var r=this.$textLayer=new a(this.content);this.canvas=r.element,this.$markerFront=new u(this.content),this.$cursorLayer=new f(this.content),this.$horizScroll=!1,this.$vScroll=!1,this.scrollBar=this.scrollBarV=new c(this.container,this),this.scrollBarH=new l(this.container,this),this.scrollBarV.addEventListener("scroll",function(e){n.$scrollAnimation||n.session.setScrollTop(e.data-n.scrollMargin.top);}),this.scrollBarH.addEventListener("scroll",function(e){n.$scrollAnimation||n.session.setScrollLeft(e.data-n.scrollMargin.left);}),this.scrollTop=0,this.scrollLeft=0,this.cursorPos={row:0,column:0},this.$fontMetrics=new p(this.container),this.$textLayer.$setFontMetrics(this.$fontMetrics),this.$textLayer.addEventListener("changeCharacterSize",function(e){n.updateCharacterSize(),n.onResize(!0,n.gutterWidth,n.$size.width,n.$size.height),n._signal("changeCharacterSize",e);}),this.$size={width:0,height:0,scrollerHeight:0,scrollerWidth:0,$dirty:!0},this.layerConfig={width:1,padding:0,firstRow:0,firstRowScreen:0,lastRow:0,lineHeight:0,characterWidth:0,minHeight:1,maxHeight:1,offset:0,height:1,gutterOffset:1},this.scrollMargin={left:0,right:0,top:0,bottom:0,v:0,h:0},this.margin={left:0,right:0,top:0,bottom:0,v:0,h:0},this.$keepTextAreaAtCursor=!m.isIOS,this.$loop=new h(this.$renderChanges.bind(this),this.container.ownerDocument.defaultView),this.$loop.schedule(this.CHANGE_FULL),this.updateCharacterSize(),this.setPadding(4),s.resetOptions(this),s._emit("renderer",this);};(function(){this.CHANGE_CURSOR=1,this.CHANGE_MARKER=2,this.CHANGE_GUTTER=4,this.CHANGE_SCROLL=8,this.CHANGE_LINES=16,this.CHANGE_TEXT=32,this.CHANGE_SIZE=64,this.CHANGE_MARKER_BACK=128,this.CHANGE_MARKER_FRONT=256,this.CHANGE_FULL=512,this.CHANGE_H_SCROLL=1024,r.implement(this,d),this.updateCharacterSize=function(){this.$textLayer.allowBoldFonts!=this.$allowBoldFonts&&(this.$allowBoldFonts=this.$textLayer.allowBoldFonts,this.setStyle("ace_nobold",!this.$allowBoldFonts)),this.layerConfig.characterWidth=this.characterWidth=this.$textLayer.getCharacterWidth(),this.layerConfig.lineHeight=this.lineHeight=this.$textLayer.getLineHeight(),this.$updatePrintMargin();},this.setSession=function(e){this.session&&this.session.doc.off("changeNewLineMode",this.onChangeNewLineMode),this.session=e,e&&this.scrollMargin.top&&e.getScrollTop()<=0&&e.setScrollTop(-this.scrollMargin.top),this.$cursorLayer.setSession(e),this.$markerBack.setSession(e),this.$markerFront.setSession(e),this.$gutterLayer.setSession(e),this.$textLayer.setSession(e);if(!e)return;this.$loop.schedule(this.CHANGE_FULL),this.session.$setFontMetrics(this.$fontMetrics),this.scrollBarH.scrollLeft=this.scrollBarV.scrollTop=null,this.onChangeNewLineMode=this.onChangeNewLineMode.bind(this),this.onChangeNewLineMode(),this.session.doc.on("changeNewLineMode",this.onChangeNewLineMode);},this.updateLines=function(e,t,n){t===undefined&&(t=Infinity),this.$changedLines?(this.$changedLines.firstRow>e&&(this.$changedLines.firstRow=e),this.$changedLines.lastRow<t&&(this.$changedLines.lastRow=t)):this.$changedLines={firstRow:e,lastRow:t};if(this.$changedLines.lastRow<this.layerConfig.firstRow){if(!n)return;this.$changedLines.lastRow=this.layerConfig.lastRow;}if(this.$changedLines.firstRow>this.layerConfig.lastRow)return;this.$loop.schedule(this.CHANGE_LINES);},this.onChangeNewLineMode=function(){this.$loop.schedule(this.CHANGE_TEXT),this.$textLayer.$updateEolChar(),this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);},this.onChangeTabSize=function(){this.$loop.schedule(this.CHANGE_TEXT|this.CHANGE_MARKER),this.$textLayer.onChangeTabSize();},this.updateText=function(){this.$loop.schedule(this.CHANGE_TEXT);},this.updateFull=function(e){e?this.$renderChanges(this.CHANGE_FULL,!0):this.$loop.schedule(this.CHANGE_FULL);},this.updateFontSize=function(){this.$textLayer.checkForSizeChanges();},this.$changes=0,this.$updateSizeAsync=function(){this.$loop.pending?this.$size.$dirty=!0:this.onResize();},this.onResize=function(e,t,n,r){if(this.resizing>2)return;this.resizing>0?this.resizing++:this.resizing=e?1:0;var i=this.container;r||(r=i.clientHeight||i.scrollHeight),n||(n=i.clientWidth||i.scrollWidth);var s=this.$updateCachedSize(e,t,n,r);if(!this.$size.scrollerHeight||!n&&!r)return this.resizing=0;e&&(this.$gutterLayer.$padding=null),e?this.$renderChanges(s|this.$changes,!0):this.$loop.schedule(s|this.$changes),this.resizing&&(this.resizing=0),this.scrollBarV.scrollLeft=this.scrollBarV.scrollTop=null;},this.$updateCachedSize=function(e,t,n,r){r-=this.$extraHeight||0;var s=0,o=this.$size,u={width:o.width,height:o.height,scrollerHeight:o.scrollerHeight,scrollerWidth:o.scrollerWidth};r&&(e||o.height!=r)&&(o.height=r,s|=this.CHANGE_SIZE,o.scrollerHeight=o.height,this.$horizScroll&&(o.scrollerHeight-=this.scrollBarH.getHeight()),this.scrollBarV.element.style.bottom=this.scrollBarH.getHeight()+"px",s|=this.CHANGE_SCROLL);if(n&&(e||o.width!=n)){s|=this.CHANGE_SIZE,o.width=n,t==null&&(t=this.$showGutter?this.$gutter.offsetWidth:0),this.gutterWidth=t,i.setStyle(this.scrollBarH.element.style,"left",t+"px"),i.setStyle(this.scroller.style,"left",t+this.margin.left+"px"),o.scrollerWidth=Math.max(0,n-t-this.scrollBarV.getWidth()-this.margin.h),i.setStyle(this.$gutter.style,"left",this.margin.left+"px");var a=this.scrollBarV.getWidth()+"px";i.setStyle(this.scrollBarH.element.style,"right",a),i.setStyle(this.scroller.style,"right",a),i.setStyle(this.scroller.style,"bottom",this.scrollBarH.getHeight());if(this.session&&this.session.getUseWrapMode()&&this.adjustWrapLimit()||e)s|=this.CHANGE_FULL;}return o.$dirty=!n||!r,s&&this._signal("resize",u),s},this.onGutterResize=function(e){var t=this.$showGutter?e:0;t!=this.gutterWidth&&(this.$changes|=this.$updateCachedSize(!0,t,this.$size.width,this.$size.height)),this.session.getUseWrapMode()&&this.adjustWrapLimit()?this.$loop.schedule(this.CHANGE_FULL):this.$size.$dirty?this.$loop.schedule(this.CHANGE_FULL):this.$computeLayerConfig();},this.adjustWrapLimit=function(){var e=this.$size.scrollerWidth-this.$padding*2,t=Math.floor(e/this.characterWidth);return this.session.adjustWrapLimit(t,this.$showPrintMargin&&this.$printMarginColumn)},this.setAnimatedScroll=function(e){this.setOption("animatedScroll",e);},this.getAnimatedScroll=function(){return this.$animatedScroll},this.setShowInvisibles=function(e){this.setOption("showInvisibles",e),this.session.$bidiHandler.setShowInvisibles(e);},this.getShowInvisibles=function(){return this.getOption("showInvisibles")},this.getDisplayIndentGuides=function(){return this.getOption("displayIndentGuides")},this.setDisplayIndentGuides=function(e){this.setOption("displayIndentGuides",e);},this.setShowPrintMargin=function(e){this.setOption("showPrintMargin",e);},this.getShowPrintMargin=function(){return this.getOption("showPrintMargin")},this.setPrintMarginColumn=function(e){this.setOption("printMarginColumn",e);},this.getPrintMarginColumn=function(){return this.getOption("printMarginColumn")},this.getShowGutter=function(){return this.getOption("showGutter")},this.setShowGutter=function(e){return this.setOption("showGutter",e)},this.getFadeFoldWidgets=function(){return this.getOption("fadeFoldWidgets")},this.setFadeFoldWidgets=function(e){this.setOption("fadeFoldWidgets",e);},this.setHighlightGutterLine=function(e){this.setOption("highlightGutterLine",e);},this.getHighlightGutterLine=function(){return this.getOption("highlightGutterLine")},this.$updatePrintMargin=function(){if(!this.$showPrintMargin&&!this.$printMarginEl)return;if(!this.$printMarginEl){var e=i.createElement("div");e.className="ace_layer ace_print-margin-layer",this.$printMarginEl=i.createElement("div"),this.$printMarginEl.className="ace_print-margin",e.appendChild(this.$printMarginEl),this.content.insertBefore(e,this.content.firstChild);}var t=this.$printMarginEl.style;t.left=Math.round(this.characterWidth*this.$printMarginColumn+this.$padding)+"px",t.visibility=this.$showPrintMargin?"visible":"hidden",this.session&&this.session.$wrap==-1&&this.adjustWrapLimit();},this.getContainerElement=function(){return this.container},this.getMouseEventTarget=function(){return this.scroller},this.getTextAreaContainer=function(){return this.container},this.$moveTextAreaToCursor=function(){var e=this.textarea.style;if(!this.$keepTextAreaAtCursor){i.translate(this.textarea,-100,0);return}var t=this.$cursorLayer.$pixelPos;if(!t)return;var n=this.$composition;n&&n.markerRange&&(t=this.$cursorLayer.getPixelPosition(n.markerRange.start,!0));var r=this.layerConfig,s=t.top,o=t.left;s-=r.offset;var u=n&&n.useTextareaForIME?this.lineHeight:g?0:1;if(s<0||s>r.height-u){i.translate(this.textarea,0,0);return}var a=1;if(!n)s+=this.lineHeight;else if(n.useTextareaForIME){var f=this.textarea.value;a=this.characterWidth*this.session.$getStringScreenWidth(f)[0],u+=2;}else s+=this.lineHeight+2;o-=this.scrollLeft,o>this.$size.scrollerWidth-a&&(o=this.$size.scrollerWidth-a),o+=this.gutterWidth+this.margin.left,i.setStyle(e,"height",u+"px"),i.setStyle(e,"width",a+"px"),i.translate(this.textarea,Math.min(o,this.$size.scrollerWidth-a),Math.min(s,this.$size.height-u));},this.getFirstVisibleRow=function(){return this.layerConfig.firstRow},this.getFirstFullyVisibleRow=function(){return this.layerConfig.firstRow+(this.layerConfig.offset===0?0:1)},this.getLastFullyVisibleRow=function(){var e=this.layerConfig,t=e.lastRow,n=this.session.documentToScreenRow(t,0)*e.lineHeight;return n-this.session.getScrollTop()>e.height-e.lineHeight?t-1:t},this.getLastVisibleRow=function(){return this.layerConfig.lastRow},this.$padding=null,this.setPadding=function(e){this.$padding=e,this.$textLayer.setPadding(e),this.$cursorLayer.setPadding(e),this.$markerFront.setPadding(e),this.$markerBack.setPadding(e),this.$loop.schedule(this.CHANGE_FULL),this.$updatePrintMargin();},this.setScrollMargin=function(e,t,n,r){var i=this.scrollMargin;i.top=e|0,i.bottom=t|0,i.right=r|0,i.left=n|0,i.v=i.top+i.bottom,i.h=i.left+i.right,i.top&&this.scrollTop<=0&&this.session&&this.session.setScrollTop(-i.top),this.updateFull();},this.setMargin=function(e,t,n,r){var i=this.margin;i.top=e|0,i.bottom=t|0,i.right=r|0,i.left=n|0,i.v=i.top+i.bottom,i.h=i.left+i.right,this.$updateCachedSize(!0,this.gutterWidth,this.$size.width,this.$size.height),this.updateFull();},this.getHScrollBarAlwaysVisible=function(){return this.$hScrollBarAlwaysVisible},this.setHScrollBarAlwaysVisible=function(e){this.setOption("hScrollBarAlwaysVisible",e);},this.getVScrollBarAlwaysVisible=function(){return this.$vScrollBarAlwaysVisible},this.setVScrollBarAlwaysVisible=function(e){this.setOption("vScrollBarAlwaysVisible",e);},this.$updateScrollBarV=function(){var e=this.layerConfig.maxHeight,t=this.$size.scrollerHeight;!this.$maxLines&&this.$scrollPastEnd&&(e-=(t-this.lineHeight)*this.$scrollPastEnd,this.scrollTop>e-t&&(e=this.scrollTop+t,this.scrollBarV.scrollTop=null)),this.scrollBarV.setScrollHeight(e+this.scrollMargin.v),this.scrollBarV.setScrollTop(this.scrollTop+this.scrollMargin.top);},this.$updateScrollBarH=function(){this.scrollBarH.setScrollWidth(this.layerConfig.width+2*this.$padding+this.scrollMargin.h),this.scrollBarH.setScrollLeft(this.scrollLeft+this.scrollMargin.left);},this.$frozen=!1,this.freeze=function(){this.$frozen=!0;},this.unfreeze=function(){this.$frozen=!1;},this.$renderChanges=function(e,t){this.$changes&&(e|=this.$changes,this.$changes=0);if(!this.session||!this.container.offsetWidth||this.$frozen||!e&&!t){this.$changes|=e;return}if(this.$size.$dirty)return this.$changes|=e,this.onResize(!0);this.lineHeight||this.$textLayer.checkForSizeChanges(),this._signal("beforeRender"),this.session&&this.session.$bidiHandler&&this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);var n=this.layerConfig;if(e&this.CHANGE_FULL||e&this.CHANGE_SIZE||e&this.CHANGE_TEXT||e&this.CHANGE_LINES||e&this.CHANGE_SCROLL||e&this.CHANGE_H_SCROLL){e|=this.$computeLayerConfig()|this.$loop.clear();if(n.firstRow!=this.layerConfig.firstRow&&n.firstRowScreen==this.layerConfig.firstRowScreen){var r=this.scrollTop+(n.firstRow-this.layerConfig.firstRow)*this.lineHeight;r>0&&(this.scrollTop=r,e|=this.CHANGE_SCROLL,e|=this.$computeLayerConfig()|this.$loop.clear());}n=this.layerConfig,this.$updateScrollBarV(),e&this.CHANGE_H_SCROLL&&this.$updateScrollBarH(),i.translate(this.content,-this.scrollLeft,-n.offset);var s=n.width+2*this.$padding+"px",o=n.minHeight+"px";i.setStyle(this.content.style,"width",s),i.setStyle(this.content.style,"height",o);}e&this.CHANGE_H_SCROLL&&(i.translate(this.content,-this.scrollLeft,-n.offset),this.scroller.className=this.scrollLeft<=0?"ace_scroller":"ace_scroller ace_scroll-left");if(e&this.CHANGE_FULL){this.$textLayer.update(n),this.$showGutter&&this.$gutterLayer.update(n),this.$markerBack.update(n),this.$markerFront.update(n),this.$cursorLayer.update(n),this.$moveTextAreaToCursor(),this._signal("afterRender");return}if(e&this.CHANGE_SCROLL){e&this.CHANGE_TEXT||e&this.CHANGE_LINES?this.$textLayer.update(n):this.$textLayer.scrollLines(n),this.$showGutter&&(e&this.CHANGE_GUTTER||e&this.CHANGE_LINES?this.$gutterLayer.update(n):this.$gutterLayer.scrollLines(n)),this.$markerBack.update(n),this.$markerFront.update(n),this.$cursorLayer.update(n),this.$moveTextAreaToCursor(),this._signal("afterRender");return}e&this.CHANGE_TEXT?(this.$textLayer.update(n),this.$showGutter&&this.$gutterLayer.update(n)):e&this.CHANGE_LINES?(this.$updateLines()||e&this.CHANGE_GUTTER&&this.$showGutter)&&this.$gutterLayer.update(n):e&this.CHANGE_TEXT||e&this.CHANGE_GUTTER?this.$showGutter&&this.$gutterLayer.update(n):e&this.CHANGE_CURSOR&&this.$highlightGutterLine&&this.$gutterLayer.updateLineHighlight(n),e&this.CHANGE_CURSOR&&(this.$cursorLayer.update(n),this.$moveTextAreaToCursor()),e&(this.CHANGE_MARKER|this.CHANGE_MARKER_FRONT)&&this.$markerFront.update(n),e&(this.CHANGE_MARKER|this.CHANGE_MARKER_BACK)&&this.$markerBack.update(n),this._signal("afterRender");},this.$autosize=function(){var e=this.session.getScreenLength()*this.lineHeight,t=this.$maxLines*this.lineHeight,n=Math.min(t,Math.max((this.$minLines||1)*this.lineHeight,e))+this.scrollMargin.v+(this.$extraHeight||0);this.$horizScroll&&(n+=this.scrollBarH.getHeight()),this.$maxPixelHeight&&n>this.$maxPixelHeight&&(n=this.$maxPixelHeight);var r=n<=2*this.lineHeight,i=!r&&e>t;if(n!=this.desiredHeight||this.$size.height!=this.desiredHeight||i!=this.$vScroll){i!=this.$vScroll&&(this.$vScroll=i,this.scrollBarV.setVisible(i));var s=this.container.clientWidth;this.container.style.height=n+"px",this.$updateCachedSize(!0,this.$gutterWidth,s,n),this.desiredHeight=n,this._signal("autosize");}},this.$computeLayerConfig=function(){var e=this.session,t=this.$size,n=t.height<=2*this.lineHeight,r=this.session.getScreenLength(),i=r*this.lineHeight,s=this.$getLongestLine(),o=!n&&(this.$hScrollBarAlwaysVisible||t.scrollerWidth-s-2*this.$padding<0),u=this.$horizScroll!==o;u&&(this.$horizScroll=o,this.scrollBarH.setVisible(o));var a=this.$vScroll;this.$maxLines&&this.lineHeight>1&&this.$autosize();var f=t.scrollerHeight+this.lineHeight,l=!this.$maxLines&&this.$scrollPastEnd?(t.scrollerHeight-this.lineHeight)*this.$scrollPastEnd:0;i+=l;var c=this.scrollMargin;this.session.setScrollTop(Math.max(-c.top,Math.min(this.scrollTop,i-t.scrollerHeight+c.bottom))),this.session.setScrollLeft(Math.max(-c.left,Math.min(this.scrollLeft,s+2*this.$padding-t.scrollerWidth+c.right)));var h=!n&&(this.$vScrollBarAlwaysVisible||t.scrollerHeight-i+l<0||this.scrollTop>c.top),p=a!==h;p&&(this.$vScroll=h,this.scrollBarV.setVisible(h));var d=this.scrollTop%this.lineHeight,v=Math.ceil(f/this.lineHeight)-1,m=Math.max(0,Math.round((this.scrollTop-d)/this.lineHeight)),g=m+v,y,b,w=this.lineHeight;m=e.screenToDocumentRow(m,0);var E=e.getFoldLine(m);E&&(m=E.start.row),y=e.documentToScreenRow(m,0),b=e.getRowLength(m)*w,g=Math.min(e.screenToDocumentRow(g,0),e.getLength()-1),f=t.scrollerHeight+e.getRowLength(g)*w+b,d=this.scrollTop-y*w;var S=0;if(this.layerConfig.width!=s||u)S=this.CHANGE_H_SCROLL;if(u||p)S=this.$updateCachedSize(!0,this.gutterWidth,t.width,t.height),this._signal("scrollbarVisibilityChanged"),p&&(s=this.$getLongestLine());return this.layerConfig={width:s,padding:this.$padding,firstRow:m,firstRowScreen:y,lastRow:g,lineHeight:w,characterWidth:this.characterWidth,minHeight:f,maxHeight:i,offset:d,gutterOffset:w?Math.max(0,Math.ceil((d+t.height-t.scrollerHeight)/w)):0,height:this.$size.scrollerHeight},this.session.$bidiHandler&&this.session.$bidiHandler.setContentWidth(s-this.$padding),S},this.$updateLines=function(){if(!this.$changedLines)return;var e=this.$changedLines.firstRow,t=this.$changedLines.lastRow;this.$changedLines=null;var n=this.layerConfig;if(e>n.lastRow+1)return;if(t<n.firstRow)return;if(t===Infinity){this.$showGutter&&this.$gutterLayer.update(n),this.$textLayer.update(n);return}return this.$textLayer.updateLines(n,e,t),!0},this.$getLongestLine=function(){var e=this.session.getScreenWidth();return this.showInvisibles&&!this.session.$useWrapMode&&(e+=1),this.$textLayer&&e>this.$textLayer.MAX_LINE_LENGTH&&(e=this.$textLayer.MAX_LINE_LENGTH+30),Math.max(this.$size.scrollerWidth-2*this.$padding,Math.round(e*this.characterWidth))},this.updateFrontMarkers=function(){this.$markerFront.setMarkers(this.session.getMarkers(!0)),this.$loop.schedule(this.CHANGE_MARKER_FRONT);},this.updateBackMarkers=function(){this.$markerBack.setMarkers(this.session.getMarkers()),this.$loop.schedule(this.CHANGE_MARKER_BACK);},this.addGutterDecoration=function(e,t){this.$gutterLayer.addGutterDecoration(e,t);},this.removeGutterDecoration=function(e,t){this.$gutterLayer.removeGutterDecoration(e,t);},this.updateBreakpoints=function(e){this.$loop.schedule(this.CHANGE_GUTTER);},this.setAnnotations=function(e){this.$gutterLayer.setAnnotations(e),this.$loop.schedule(this.CHANGE_GUTTER);},this.updateCursor=function(){this.$loop.schedule(this.CHANGE_CURSOR);},this.hideCursor=function(){this.$cursorLayer.hideCursor();},this.showCursor=function(){this.$cursorLayer.showCursor();},this.scrollSelectionIntoView=function(e,t,n){this.scrollCursorIntoView(e,n),this.scrollCursorIntoView(t,n);},this.scrollCursorIntoView=function(e,t,n){if(this.$size.scrollerHeight===0)return;var r=this.$cursorLayer.getPixelPosition(e),i=r.left,s=r.top,o=n&&n.top||0,u=n&&n.bottom||0,a=this.$scrollAnimation?this.session.getScrollTop():this.scrollTop;a+o>s?(t&&a+o>s+this.lineHeight&&(s-=t*this.$size.scrollerHeight),s===0&&(s=-this.scrollMargin.top),this.session.setScrollTop(s)):a+this.$size.scrollerHeight-u<s+this.lineHeight&&(t&&a+this.$size.scrollerHeight-u<s-this.lineHeight&&(s+=t*this.$size.scrollerHeight),this.session.setScrollTop(s+this.lineHeight+u-this.$size.scrollerHeight));var f=this.scrollLeft;f>i?(i<this.$padding+2*this.layerConfig.characterWidth&&(i=-this.scrollMargin.left),this.session.setScrollLeft(i)):f+this.$size.scrollerWidth<i+this.characterWidth?this.session.setScrollLeft(Math.round(i+this.characterWidth-this.$size.scrollerWidth)):f<=this.$padding&&i-f<this.characterWidth&&this.session.setScrollLeft(0);},this.getScrollTop=function(){return this.session.getScrollTop()},this.getScrollLeft=function(){return this.session.getScrollLeft()},this.getScrollTopRow=function(){return this.scrollTop/this.lineHeight},this.getScrollBottomRow=function(){return Math.max(0,Math.floor((this.scrollTop+this.$size.scrollerHeight)/this.lineHeight)-1)},this.scrollToRow=function(e){this.session.setScrollTop(e*this.lineHeight);},this.alignCursor=function(e,t){typeof e=="number"&&(e={row:e,column:0});var n=this.$cursorLayer.getPixelPosition(e),r=this.$size.scrollerHeight-this.lineHeight,i=n.top-r*(t||0);return this.session.setScrollTop(i),i},this.STEPS=8,this.$calcSteps=function(e,t){var n=0,r=this.STEPS,i=[],s=function(e,t,n){return n*(Math.pow(e-1,3)+1)+t};for(n=0;n<r;++n)i.push(s(n/this.STEPS,e,t-e));return i},this.scrollToLine=function(e,t,n,r){var i=this.$cursorLayer.getPixelPosition({row:e,column:0}),s=i.top;t&&(s-=this.$size.scrollerHeight/2);var o=this.scrollTop;this.session.setScrollTop(s),n!==!1&&this.animateScrolling(o,r);},this.animateScrolling=function(e,t){var n=this.scrollTop;if(!this.$animatedScroll)return;var r=this;if(e==n)return;if(this.$scrollAnimation){var i=this.$scrollAnimation.steps;if(i.length){e=i[0];if(e==n)return}}var s=r.$calcSteps(e,n);this.$scrollAnimation={from:e,to:n,steps:s},clearInterval(this.$timer),r.session.setScrollTop(s.shift()),r.session.$scrollTop=n,this.$timer=setInterval(function(){s.length?(r.session.setScrollTop(s.shift()),r.session.$scrollTop=n):n!=null?(r.session.$scrollTop=-1,r.session.setScrollTop(n),n=null):(r.$timer=clearInterval(r.$timer),r.$scrollAnimation=null,t&&t());},10);},this.scrollToY=function(e){this.scrollTop!==e&&(this.$loop.schedule(this.CHANGE_SCROLL),this.scrollTop=e);},this.scrollToX=function(e){this.scrollLeft!==e&&(this.scrollLeft=e),this.$loop.schedule(this.CHANGE_H_SCROLL);},this.scrollTo=function(e,t){this.session.setScrollTop(t),this.session.setScrollLeft(t);},this.scrollBy=function(e,t){t&&this.session.setScrollTop(this.session.getScrollTop()+t),e&&this.session.setScrollLeft(this.session.getScrollLeft()+e);},this.isScrollableBy=function(e,t){if(t<0&&this.session.getScrollTop()>=1-this.scrollMargin.top)return !0;if(t>0&&this.session.getScrollTop()+this.$size.scrollerHeight-this.layerConfig.maxHeight<-1+this.scrollMargin.bottom)return !0;if(e<0&&this.session.getScrollLeft()>=1-this.scrollMargin.left)return !0;if(e>0&&this.session.getScrollLeft()+this.$size.scrollerWidth-this.layerConfig.width<-1+this.scrollMargin.right)return !0},this.pixelToScreenCoordinates=function(e,t){var n;if(this.$hasCssTransforms){n={top:0,left:0};var r=this.$fontMetrics.transformCoordinates([e,t]);e=r[1]-this.gutterWidth-this.margin.left,t=r[0];}else n=this.scroller.getBoundingClientRect();var i=e+this.scrollLeft-n.left-this.$padding,s=i/this.characterWidth,o=Math.floor((t+this.scrollTop-n.top)/this.lineHeight),u=this.$blockCursor?Math.floor(s):Math.round(s);return {row:o,column:u,side:s-u>0?1:-1,offsetX:i}},this.screenToTextCoordinates=function(e,t){var n;if(this.$hasCssTransforms){n={top:0,left:0};var r=this.$fontMetrics.transformCoordinates([e,t]);e=r[1]-this.gutterWidth-this.margin.left,t=r[0];}else n=this.scroller.getBoundingClientRect();var i=e+this.scrollLeft-n.left-this.$padding,s=i/this.characterWidth,o=this.$blockCursor?Math.floor(s):Math.round(s),u=Math.floor((t+this.scrollTop-n.top)/this.lineHeight);return this.session.screenToDocumentPosition(u,Math.max(o,0),i)},this.textToScreenCoordinates=function(e,t){var n=this.scroller.getBoundingClientRect(),r=this.session.documentToScreenPosition(e,t),i=this.$padding+(this.session.$bidiHandler.isBidiRow(r.row,e)?this.session.$bidiHandler.getPosLeft(r.column):Math.round(r.column*this.characterWidth)),s=r.row*this.lineHeight;return {pageX:n.left+i-this.scrollLeft,pageY:n.top+s-this.scrollTop}},this.visualizeFocus=function(){i.addCssClass(this.container,"ace_focus");},this.visualizeBlur=function(){i.removeCssClass(this.container,"ace_focus");},this.showComposition=function(e){this.$composition=e,e.cssText||(e.cssText=this.textarea.style.cssText,e.keepTextAreaAtCursor=this.$keepTextAreaAtCursor),e.useTextareaForIME=this.$useTextareaForIME,this.$useTextareaForIME?(this.$keepTextAreaAtCursor=!0,i.addCssClass(this.textarea,"ace_composition"),this.textarea.style.cssText="",this.$moveTextAreaToCursor(),this.$cursorLayer.element.style.display="none"):e.markerId=this.session.addMarker(e.markerRange,"ace_composition_marker","text");},this.setCompositionText=function(e){var t=this.session.selection.cursor;this.addToken(e,"composition_placeholder",t.row,t.column),this.$moveTextAreaToCursor();},this.hideComposition=function(){if(!this.$composition)return;this.$composition.markerId&&this.session.removeMarker(this.$composition.markerId),i.removeCssClass(this.textarea,"ace_composition"),this.$keepTextAreaAtCursor=this.$composition.keepTextAreaAtCursor,this.textarea.style.cssText=this.$composition.cssText,this.$composition=null,this.$cursorLayer.element.style.display="";},this.addToken=function(e,t,n,r){var i=this.session;i.bgTokenizer.lines[n]=null;var s={type:t,value:e},o=i.getTokens(n);if(r==null)o.push(s);else{var u=0;for(var a=0;a<o.length;a++){var f=o[a];u+=f.value.length;if(r<=u){var l=f.value.length-(u-r),c=f.value.slice(0,l),h=f.value.slice(l);o.splice(a,1,{type:f.type,value:c},s,{type:f.type,value:h});break}}}this.updateLines(n,n);},this.setTheme=function(e,t){function o(r){if(n.$themeId!=e)return t&&t();if(!r||!r.cssClass)throw new Error("couldn't load module "+e+" or it didn't call define");r.$id&&(n.$themeId=r.$id),i.importCssString(r.cssText,r.cssClass,n.container),n.theme&&i.removeCssClass(n.container,n.theme.cssClass);var s="padding"in r?r.padding:"padding"in(n.theme||{})?4:n.$padding;n.$padding&&s!=n.$padding&&n.setPadding(s),n.$theme=r.cssClass,n.theme=r,i.addCssClass(n.container,r.cssClass),i.setCssClass(n.container,"ace_dark",r.isDark),n.$size&&(n.$size.width=0,n.$updateSizeAsync()),n._dispatchEvent("themeLoaded",{theme:r}),t&&t();}var n=this;this.$themeId=e,n._dispatchEvent("themeChange",{theme:e});if(!e||typeof e=="string"){var r=e||this.$options.theme.initialValue;s.loadModule(["theme",r],o);}else o(e);},this.getTheme=function(){return this.$themeId},this.setStyle=function(e,t){i.setCssClass(this.container,e,t!==!1);},this.unsetStyle=function(e){i.removeCssClass(this.container,e);},this.setCursorStyle=function(e){i.setStyle(this.scroller.style,"cursor",e);},this.setMouseCursor=function(e){i.setStyle(this.scroller.style,"cursor",e);},this.attachToShadowRoot=function(){i.importCssString(v,"ace_editor.css",this.container);},this.destroy=function(){this.$fontMetrics.destroy(),this.$cursorLayer.destroy();};}).call(y.prototype),s.defineOptions(y.prototype,"renderer",{animatedScroll:{initialValue:!1},showInvisibles:{set:function(e){this.$textLayer.setShowInvisibles(e)&&this.$loop.schedule(this.CHANGE_TEXT);},initialValue:!1},showPrintMargin:{set:function(){this.$updatePrintMargin();},initialValue:!0},printMarginColumn:{set:function(){this.$updatePrintMargin();},initialValue:80},printMargin:{set:function(e){typeof e=="number"&&(this.$printMarginColumn=e),this.$showPrintMargin=!!e,this.$updatePrintMargin();},get:function(){return this.$showPrintMargin&&this.$printMarginColumn}},showGutter:{set:function(e){this.$gutter.style.display=e?"block":"none",this.$loop.schedule(this.CHANGE_FULL),this.onGutterResize();},initialValue:!0},fadeFoldWidgets:{set:function(e){i.setCssClass(this.$gutter,"ace_fade-fold-widgets",e);},initialValue:!1},showFoldWidgets:{set:function(e){this.$gutterLayer.setShowFoldWidgets(e),this.$loop.schedule(this.CHANGE_GUTTER);},initialValue:!0},displayIndentGuides:{set:function(e){this.$textLayer.setDisplayIndentGuides(e)&&this.$loop.schedule(this.CHANGE_TEXT);},initialValue:!0},highlightGutterLine:{set:function(e){this.$gutterLayer.setHighlightGutterLine(e),this.$loop.schedule(this.CHANGE_GUTTER);},initialValue:!0},hScrollBarAlwaysVisible:{set:function(e){(!this.$hScrollBarAlwaysVisible||!this.$horizScroll)&&this.$loop.schedule(this.CHANGE_SCROLL);},initialValue:!1},vScrollBarAlwaysVisible:{set:function(e){(!this.$vScrollBarAlwaysVisible||!this.$vScroll)&&this.$loop.schedule(this.CHANGE_SCROLL);},initialValue:!1},fontSize:{set:function(e){typeof e=="number"&&(e+="px"),this.container.style.fontSize=e,this.updateFontSize();},initialValue:12},fontFamily:{set:function(e){this.container.style.fontFamily=e,this.updateFontSize();}},maxLines:{set:function(e){this.updateFull();}},minLines:{set:function(e){this.$minLines<562949953421311||(this.$minLines=0),this.updateFull();}},maxPixelHeight:{set:function(e){this.updateFull();},initialValue:0},scrollPastEnd:{set:function(e){e=+e||0;if(this.$scrollPastEnd==e)return;this.$scrollPastEnd=e,this.$loop.schedule(this.CHANGE_SCROLL);},initialValue:0,handlesSet:!0},fixedWidthGutter:{set:function(e){this.$gutterLayer.$fixedWidth=!!e,this.$loop.schedule(this.CHANGE_GUTTER);}},theme:{set:function(e){this.setTheme(e);},get:function(){return this.$themeId||this.theme},initialValue:"./theme/textmate",handlesSet:!0},hasCssTransforms:{},useTextareaForIME:{initialValue:!m.isMobile&&!m.isIE}}),t.VirtualRenderer=y;}),define("ace/worker/worker_client",["require","exports","module","ace/lib/oop","ace/lib/net","ace/lib/event_emitter","ace/config"],function(e,t,n){function u(e){var t="importScripts('"+i.qualifyURL(e)+"');";try{return new Blob([t],{type:"application/javascript"})}catch(n){var r=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder,s=new r;return s.append(t),s.getBlob("application/javascript")}}function a(e){if(typeof Worker=="undefined")return {postMessage:function(){},terminate:function(){}};if(o.get("loadWorkerFromBlob")){var t=u(e),n=window.URL||window.webkitURL,r=n.createObjectURL(t);return new Worker(r)}return new Worker(e)}var r=e("../lib/oop"),i=e("../lib/net"),s=e("../lib/event_emitter").EventEmitter,o=e("../config"),f=function(e){e.postMessage||(e=this.$createWorkerFromOldConfig.apply(this,arguments)),this.$worker=e,this.$sendDeltaQueue=this.$sendDeltaQueue.bind(this),this.changeListener=this.changeListener.bind(this),this.onMessage=this.onMessage.bind(this),this.callbackId=1,this.callbacks={},this.$worker.onmessage=this.onMessage;};(function(){r.implement(this,s),this.$createWorkerFromOldConfig=function(t,n,r,i,s){e.nameToUrl&&!e.toUrl&&(e.toUrl=e.nameToUrl);if(o.get("packaged")||!e.toUrl)i=i||o.moduleUrl(n,"worker");else{var u=this.$normalizePath;i=i||u(e.toUrl("ace/worker/worker.js",null,"_"));var f={};t.forEach(function(t){f[t]=u(e.toUrl(t,null,"_").replace(/(\.js)?(\?.*)?$/,""));});}return this.$worker=a(i),s&&this.send("importScripts",s),this.$worker.postMessage({init:!0,tlns:f,module:n,classname:r}),this.$worker},this.onMessage=function(e){var t=e.data;switch(t.type){case"event":this._signal(t.name,{data:t.data});break;case"call":var n=this.callbacks[t.id];n&&(n(t.data),delete this.callbacks[t.id]);break;case"error":this.reportError(t.data);break;case"log":window.console&&console.log&&console.log.apply(console,t.data);}},this.reportError=function(e){window.console&&console.error&&console.error(e);},this.$normalizePath=function(e){return i.qualifyURL(e)},this.terminate=function(){this._signal("terminate",{}),this.deltaQueue=null,this.$worker.terminate(),this.$worker=null,this.$doc&&this.$doc.off("change",this.changeListener),this.$doc=null;},this.send=function(e,t){this.$worker.postMessage({command:e,args:t});},this.call=function(e,t,n){if(n){var r=this.callbackId++;this.callbacks[r]=n,t.push(r);}this.send(e,t);},this.emit=function(e,t){try{t.data&&t.data.err&&(t.data.err={message:t.data.err.message,stack:t.data.err.stack,code:t.data.err.code}),this.$worker.postMessage({event:e,data:{data:t.data}});}catch(n){console.error(n.stack);}},this.attachToDocument=function(e){this.$doc&&this.terminate(),this.$doc=e,this.call("setValue",[e.getValue()]),e.on("change",this.changeListener);},this.changeListener=function(e){this.deltaQueue||(this.deltaQueue=[],setTimeout(this.$sendDeltaQueue,0)),e.action=="insert"?this.deltaQueue.push(e.start,e.lines):this.deltaQueue.push(e.start,e.end);},this.$sendDeltaQueue=function(){var e=this.deltaQueue;if(!e)return;this.deltaQueue=null,e.length>50&&e.length>this.$doc.getLength()>>1?this.call("setValue",[this.$doc.getValue()]):this.emit("change",{data:e});};}).call(f.prototype);var l=function(e,t,n){var r=null,i=!1,u=Object.create(s),a=[],l=new f({messageBuffer:a,terminate:function(){},postMessage:function(e){a.push(e);if(!r)return;i?setTimeout(c):c();}});l.setEmitSync=function(e){i=e;};var c=function(){var e=a.shift();e.command?r[e.command].apply(r,e.args):e.event&&u._signal(e.event,e.data);};return u.postMessage=function(e){l.onMessage({data:e});},u.callback=function(e,t){this.postMessage({type:"call",id:t,data:e});},u.emit=function(e,t){this.postMessage({type:"event",name:e,data:t});},o.loadModule(["worker",t],function(e){r=new e[n](u);while(a.length)c();}),l};t.UIWorkerClient=l,t.WorkerClient=f,t.createWorker=a;}),define("ace/placeholder",["require","exports","module","ace/range","ace/lib/event_emitter","ace/lib/oop"],function(e,t,n){var r=e("./range").Range,i=e("./lib/event_emitter").EventEmitter,s=e("./lib/oop"),o=function(e,t,n,r,i,s){var o=this;this.length=t,this.session=e,this.doc=e.getDocument(),this.mainClass=i,this.othersClass=s,this.$onUpdate=this.onUpdate.bind(this),this.doc.on("change",this.$onUpdate),this.$others=r,this.$onCursorChange=function(){setTimeout(function(){o.onCursorChange();});},this.$pos=n;var u=e.getUndoManager().$undoStack||e.getUndoManager().$undostack||{length:-1};this.$undoStackDepth=u.length,this.setup(),e.selection.on("changeCursor",this.$onCursorChange);};(function(){s.implement(this,i),this.setup=function(){var e=this,t=this.doc,n=this.session;this.selectionBefore=n.selection.toJSON(),n.selection.inMultiSelectMode&&n.selection.toSingleRange(),this.pos=t.createAnchor(this.$pos.row,this.$pos.column);var i=this.pos;i.$insertRight=!0,i.detach(),i.markerId=n.addMarker(new r(i.row,i.column,i.row,i.column+this.length),this.mainClass,null,!1),this.others=[],this.$others.forEach(function(n){var r=t.createAnchor(n.row,n.column);r.$insertRight=!0,r.detach(),e.others.push(r);}),n.setUndoSelect(!1);},this.showOtherMarkers=function(){if(this.othersActive)return;var e=this.session,t=this;this.othersActive=!0,this.others.forEach(function(n){n.markerId=e.addMarker(new r(n.row,n.column,n.row,n.column+t.length),t.othersClass,null,!1);});},this.hideOtherMarkers=function(){if(!this.othersActive)return;this.othersActive=!1;for(var e=0;e<this.others.length;e++)this.session.removeMarker(this.others[e].markerId);},this.onUpdate=function(e){if(this.$updating)return this.updateAnchors(e);var t=e;if(t.start.row!==t.end.row)return;if(t.start.row!==this.pos.row)return;this.$updating=!0;var n=e.action==="insert"?t.end.column-t.start.column:t.start.column-t.end.column,i=t.start.column>=this.pos.column&&t.start.column<=this.pos.column+this.length+1,s=t.start.column-this.pos.column;this.updateAnchors(e),i&&(this.length+=n);if(i&&!this.session.$fromUndo)if(e.action==="insert")for(var o=this.others.length-1;o>=0;o--){var u=this.others[o],a={row:u.row,column:u.column+s};this.doc.insertMergedLines(a,e.lines);}else if(e.action==="remove")for(var o=this.others.length-1;o>=0;o--){var u=this.others[o],a={row:u.row,column:u.column+s};this.doc.remove(new r(a.row,a.column,a.row,a.column-n));}this.$updating=!1,this.updateMarkers();},this.updateAnchors=function(e){this.pos.onChange(e);for(var t=this.others.length;t--;)this.others[t].onChange(e);this.updateMarkers();},this.updateMarkers=function(){if(this.$updating)return;var e=this,t=this.session,n=function(n,i){t.removeMarker(n.markerId),n.markerId=t.addMarker(new r(n.row,n.column,n.row,n.column+e.length),i,null,!1);};n(this.pos,this.mainClass);for(var i=this.others.length;i--;)n(this.others[i],this.othersClass);},this.onCursorChange=function(e){if(this.$updating||!this.session)return;var t=this.session.selection.getCursor();t.row===this.pos.row&&t.column>=this.pos.column&&t.column<=this.pos.column+this.length?(this.showOtherMarkers(),this._emit("cursorEnter",e)):(this.hideOtherMarkers(),this._emit("cursorLeave",e));},this.detach=function(){this.session.removeMarker(this.pos&&this.pos.markerId),this.hideOtherMarkers(),this.doc.removeEventListener("change",this.$onUpdate),this.session.selection.removeEventListener("changeCursor",this.$onCursorChange),this.session.setUndoSelect(!0),this.session=null;},this.cancel=function(){if(this.$undoStackDepth===-1)return;var e=this.session.getUndoManager(),t=(e.$undoStack||e.$undostack).length-this.$undoStackDepth;for(var n=0;n<t;n++)e.undo(this.session,!0);this.selectionBefore&&this.session.selection.fromJSON(this.selectionBefore);};}).call(o.prototype),t.PlaceHolder=o;}),define("ace/mouse/multi_select_handler",["require","exports","module","ace/lib/event","ace/lib/useragent"],function(e,t,n){function s(e,t){return e.row==t.row&&e.column==t.column}function o(e){var t=e.domEvent,n=t.altKey,o=t.shiftKey,u=t.ctrlKey,a=e.getAccelKey(),f=e.getButton();u&&i.isMac&&(f=t.button);if(e.editor.inMultiSelectMode&&f==2){e.editor.textInput.onContextMenu(e.domEvent);return}if(!u&&!n&&!a){f===0&&e.editor.inMultiSelectMode&&e.editor.exitMultiSelectMode();return}if(f!==0)return;var l=e.editor,c=l.selection,h=l.inMultiSelectMode,p=e.getDocumentPosition(),d=c.getCursor(),v=e.inSelection()||c.isEmpty()&&s(p,d),m=e.x,g=e.y,y=function(e){m=e.clientX,g=e.clientY;},b=l.session,w=l.renderer.pixelToScreenCoordinates(m,g),E=w,S;if(l.$mouseHandler.$enableJumpToDef)u&&n||a&&n?S=o?"block":"add":n&&l.$blockSelectEnabled&&(S="block");else if(a&&!n){S="add";if(!h&&o)return}else n&&l.$blockSelectEnabled&&(S="block");S&&i.isMac&&t.ctrlKey&&l.$mouseHandler.cancelContextMenu();if(S=="add"){if(!h&&v)return;if(!h){var x=c.toOrientedRange();l.addSelectionMarker(x);}var T=c.rangeList.rangeAtPoint(p);l.inVirtualSelectionMode=!0,o&&(T=null,x=c.ranges[0]||x,l.removeSelectionMarker(x)),l.once("mouseup",function(){var e=c.toOrientedRange();T&&e.isEmpty()&&s(T.cursor,e.cursor)?c.substractPoint(e.cursor):(o?c.substractPoint(x.cursor):x&&(l.removeSelectionMarker(x),c.addRange(x)),c.addRange(e)),l.inVirtualSelectionMode=!1;});}else if(S=="block"){e.stop(),l.inVirtualSelectionMode=!0;var N,C=[],k=function(){var e=l.renderer.pixelToScreenCoordinates(m,g),t=b.screenToDocumentPosition(e.row,e.column,e.offsetX);if(s(E,e)&&s(t,c.lead))return;E=e,l.selection.moveToPosition(t),l.renderer.scrollCursorIntoView(),l.removeSelectionMarkers(C),C=c.rectangularRangeBlock(E,w),l.$mouseHandler.$clickSelection&&C.length==1&&C[0].isEmpty()&&(C[0]=l.$mouseHandler.$clickSelection.clone()),C.forEach(l.addSelectionMarker,l),l.updateSelectionMarkers();};h&&!a?c.toSingleRange():!h&&a&&(N=c.toOrientedRange(),l.addSelectionMarker(N)),o?w=b.documentToScreenPosition(c.lead):c.moveToPosition(p),E={row:-1,column:-1};var L=function(e){k(),clearInterval(O),l.removeSelectionMarkers(C),C.length||(C=[c.toOrientedRange()]),N&&(l.removeSelectionMarker(N),c.toSingleRange(N));for(var t=0;t<C.length;t++)c.addRange(C[t]);l.inVirtualSelectionMode=!1,l.$mouseHandler.$clickSelection=null;},A=k;r.capture(l.container,y,L);var O=setInterval(function(){A();},20);return e.preventDefault()}}var r=e("../lib/event"),i=e("../lib/useragent");t.onMouseDown=o;}),define("ace/commands/multi_select_commands",["require","exports","module","ace/keyboard/hash_handler"],function(e,t,n){t.defaultCommands=[{name:"addCursorAbove",exec:function(e){e.selectMoreLines(-1);},bindKey:{win:"Ctrl-Alt-Up",mac:"Ctrl-Alt-Up"},scrollIntoView:"cursor",readOnly:!0},{name:"addCursorBelow",exec:function(e){e.selectMoreLines(1);},bindKey:{win:"Ctrl-Alt-Down",mac:"Ctrl-Alt-Down"},scrollIntoView:"cursor",readOnly:!0},{name:"addCursorAboveSkipCurrent",exec:function(e){e.selectMoreLines(-1,!0);},bindKey:{win:"Ctrl-Alt-Shift-Up",mac:"Ctrl-Alt-Shift-Up"},scrollIntoView:"cursor",readOnly:!0},{name:"addCursorBelowSkipCurrent",exec:function(e){e.selectMoreLines(1,!0);},bindKey:{win:"Ctrl-Alt-Shift-Down",mac:"Ctrl-Alt-Shift-Down"},scrollIntoView:"cursor",readOnly:!0},{name:"selectMoreBefore",exec:function(e){e.selectMore(-1);},bindKey:{win:"Ctrl-Alt-Left",mac:"Ctrl-Alt-Left"},scrollIntoView:"cursor",readOnly:!0},{name:"selectMoreAfter",exec:function(e){e.selectMore(1);},bindKey:{win:"Ctrl-Alt-Right",mac:"Ctrl-Alt-Right"},scrollIntoView:"cursor",readOnly:!0},{name:"selectNextBefore",exec:function(e){e.selectMore(-1,!0);},bindKey:{win:"Ctrl-Alt-Shift-Left",mac:"Ctrl-Alt-Shift-Left"},scrollIntoView:"cursor",readOnly:!0},{name:"selectNextAfter",exec:function(e){e.selectMore(1,!0);},bindKey:{win:"Ctrl-Alt-Shift-Right",mac:"Ctrl-Alt-Shift-Right"},scrollIntoView:"cursor",readOnly:!0},{name:"splitIntoLines",exec:function(e){e.multiSelect.splitIntoLines();},bindKey:{win:"Ctrl-Alt-L",mac:"Ctrl-Alt-L"},readOnly:!0},{name:"alignCursors",exec:function(e){e.alignCursors();},bindKey:{win:"Ctrl-Alt-A",mac:"Ctrl-Alt-A"},scrollIntoView:"cursor"},{name:"findAll",exec:function(e){e.findAll();},bindKey:{win:"Ctrl-Alt-K",mac:"Ctrl-Alt-G"},scrollIntoView:"cursor",readOnly:!0}],t.multiSelectCommands=[{name:"singleSelection",bindKey:"esc",exec:function(e){e.exitMultiSelectMode();},scrollIntoView:"cursor",readOnly:!0,isAvailable:function(e){return e&&e.inMultiSelectMode}}];var r=e("../keyboard/hash_handler").HashHandler;t.keyboardHandler=new r(t.multiSelectCommands);}),define("ace/multi_select",["require","exports","module","ace/range_list","ace/range","ace/selection","ace/mouse/multi_select_handler","ace/lib/event","ace/lib/lang","ace/commands/multi_select_commands","ace/search","ace/edit_session","ace/editor","ace/config"],function(e,t,n){function h(e,t,n){return c.$options.wrap=!0,c.$options.needle=t,c.$options.backwards=n==-1,c.find(e)}function v(e,t){return e.row==t.row&&e.column==t.column}function m(e){if(e.$multiselectOnSessionChange)return;e.$onAddRange=e.$onAddRange.bind(e),e.$onRemoveRange=e.$onRemoveRange.bind(e),e.$onMultiSelect=e.$onMultiSelect.bind(e),e.$onSingleSelect=e.$onSingleSelect.bind(e),e.$multiselectOnSessionChange=t.onSessionChange.bind(e),e.$checkMultiselectChange=e.$checkMultiselectChange.bind(e),e.$multiselectOnSessionChange(e),e.on("changeSession",e.$multiselectOnSessionChange),e.on("mousedown",o),e.commands.addCommands(f.defaultCommands),g(e);}function g(e){function r(t){n&&(e.renderer.setMouseCursor(""),n=!1);}var t=e.textInput.getElement(),n=!1;u.addListener(t,"keydown",function(t){var i=t.keyCode==18&&!(t.ctrlKey||t.shiftKey||t.metaKey);e.$blockSelectEnabled&&i?n||(e.renderer.setMouseCursor("crosshair"),n=!0):n&&r();}),u.addListener(t,"keyup",r),u.addListener(t,"blur",r);}var r=e("./range_list").RangeList,i=e("./range").Range,s=e("./selection").Selection,o=e("./mouse/multi_select_handler").onMouseDown,u=e("./lib/event"),a=e("./lib/lang"),f=e("./commands/multi_select_commands");t.commands=f.defaultCommands.concat(f.multiSelectCommands);var l=e("./search").Search,c=new l,p=e("./edit_session").EditSession;(function(){this.getSelectionMarkers=function(){return this.$selectionMarkers};}).call(p.prototype),function(){this.ranges=null,this.rangeList=null,this.addRange=function(e,t){if(!e)return;if(!this.inMultiSelectMode&&this.rangeCount===0){var n=this.toOrientedRange();this.rangeList.add(n),this.rangeList.add(e);if(this.rangeList.ranges.length!=2)return this.rangeList.removeAll(),t||this.fromOrientedRange(e);this.rangeList.removeAll(),this.rangeList.add(n),this.$onAddRange(n);}e.cursor||(e.cursor=e.end);var r=this.rangeList.add(e);return this.$onAddRange(e),r.length&&this.$onRemoveRange(r),this.rangeCount>1&&!this.inMultiSelectMode&&(this._signal("multiSelect"),this.inMultiSelectMode=!0,this.session.$undoSelect=!1,this.rangeList.attach(this.session)),t||this.fromOrientedRange(e)},this.toSingleRange=function(e){e=e||this.ranges[0];var t=this.rangeList.removeAll();t.length&&this.$onRemoveRange(t),e&&this.fromOrientedRange(e);},this.substractPoint=function(e){var t=this.rangeList.substractPoint(e);if(t)return this.$onRemoveRange(t),t[0]},this.mergeOverlappingRanges=function(){var e=this.rangeList.merge();e.length&&this.$onRemoveRange(e);},this.$onAddRange=function(e){this.rangeCount=this.rangeList.ranges.length,this.ranges.unshift(e),this._signal("addRange",{range:e});},this.$onRemoveRange=function(e){this.rangeCount=this.rangeList.ranges.length;if(this.rangeCount==1&&this.inMultiSelectMode){var t=this.rangeList.ranges.pop();e.push(t),this.rangeCount=0;}for(var n=e.length;n--;){var r=this.ranges.indexOf(e[n]);this.ranges.splice(r,1);}this._signal("removeRange",{ranges:e}),this.rangeCount===0&&this.inMultiSelectMode&&(this.inMultiSelectMode=!1,this._signal("singleSelect"),this.session.$undoSelect=!0,this.rangeList.detach(this.session)),t=t||this.ranges[0],t&&!t.isEqual(this.getRange())&&this.fromOrientedRange(t);},this.$initRangeList=function(){if(this.rangeList)return;this.rangeList=new r,this.ranges=[],this.rangeCount=0;},this.getAllRanges=function(){return this.rangeCount?this.rangeList.ranges.concat():[this.getRange()]},this.splitIntoLines=function(){if(this.rangeCount>1){var e=this.rangeList.ranges,t=e[e.length-1],n=i.fromPoints(e[0].start,t.end);this.toSingleRange(),this.setSelectionRange(n,t.cursor==t.start);}else{var n=this.getRange(),r=this.isBackwards(),s=n.start.row,o=n.end.row;if(s==o){if(r)var u=n.end,a=n.start;else var u=n.start,a=n.end;this.addRange(i.fromPoints(a,a)),this.addRange(i.fromPoints(u,u));return}var f=[],l=this.getLineRange(s,!0);l.start.column=n.start.column,f.push(l);for(var c=s+1;c<o;c++)f.push(this.getLineRange(c,!0));l=this.getLineRange(o,!0),l.end.column=n.end.column,f.push(l),f.forEach(this.addRange,this);}},this.toggleBlockSelection=function(){if(this.rangeCount>1){var e=this.rangeList.ranges,t=e[e.length-1],n=i.fromPoints(e[0].start,t.end);this.toSingleRange(),this.setSelectionRange(n,t.cursor==t.start);}else{var r=this.session.documentToScreenPosition(this.cursor),s=this.session.documentToScreenPosition(this.anchor),o=this.rectangularRangeBlock(r,s);o.forEach(this.addRange,this);}},this.rectangularRangeBlock=function(e,t,n){var r=[],s=e.column<t.column;if(s)var o=e.column,u=t.column,a=e.offsetX,f=t.offsetX;else var o=t.column,u=e.column,a=t.offsetX,f=e.offsetX;var l=e.row<t.row;if(l)var c=e.row,h=t.row;else var c=t.row,h=e.row;o<0&&(o=0),c<0&&(c=0),c==h&&(n=!0);var p;for(var d=c;d<=h;d++){var m=i.fromPoints(this.session.screenToDocumentPosition(d,o,a),this.session.screenToDocumentPosition(d,u,f));if(m.isEmpty()){if(p&&v(m.end,p))break;p=m.end;}m.cursor=s?m.start:m.end,r.push(m);}l&&r.reverse();if(!n){var g=r.length-1;while(r[g].isEmpty()&&g>0)g--;if(g>0){var y=0;while(r[y].isEmpty())y++;}for(var b=g;b>=y;b--)r[b].isEmpty()&&r.splice(b,1);}return r};}.call(s.prototype);var d=e("./editor").Editor;(function(){this.updateSelectionMarkers=function(){this.renderer.updateCursor(),this.renderer.updateBackMarkers();},this.addSelectionMarker=function(e){e.cursor||(e.cursor=e.end);var t=this.getSelectionStyle();return e.marker=this.session.addMarker(e,"ace_selection",t),this.session.$selectionMarkers.push(e),this.session.selectionMarkerCount=this.session.$selectionMarkers.length,e},this.removeSelectionMarker=function(e){if(!e.marker)return;this.session.removeMarker(e.marker);var t=this.session.$selectionMarkers.indexOf(e);t!=-1&&this.session.$selectionMarkers.splice(t,1),this.session.selectionMarkerCount=this.session.$selectionMarkers.length;},this.removeSelectionMarkers=function(e){var t=this.session.$selectionMarkers;for(var n=e.length;n--;){var r=e[n];if(!r.marker)continue;this.session.removeMarker(r.marker);var i=t.indexOf(r);i!=-1&&t.splice(i,1);}this.session.selectionMarkerCount=t.length;},this.$onAddRange=function(e){this.addSelectionMarker(e.range),this.renderer.updateCursor(),this.renderer.updateBackMarkers();},this.$onRemoveRange=function(e){this.removeSelectionMarkers(e.ranges),this.renderer.updateCursor(),this.renderer.updateBackMarkers();},this.$onMultiSelect=function(e){if(this.inMultiSelectMode)return;this.inMultiSelectMode=!0,this.setStyle("ace_multiselect"),this.keyBinding.addKeyboardHandler(f.keyboardHandler),this.commands.setDefaultHandler("exec",this.$onMultiSelectExec),this.renderer.updateCursor(),this.renderer.updateBackMarkers();},this.$onSingleSelect=function(e){if(this.session.multiSelect.inVirtualMode)return;this.inMultiSelectMode=!1,this.unsetStyle("ace_multiselect"),this.keyBinding.removeKeyboardHandler(f.keyboardHandler),this.commands.removeDefaultHandler("exec",this.$onMultiSelectExec),this.renderer.updateCursor(),this.renderer.updateBackMarkers(),this._emit("changeSelection");},this.$onMultiSelectExec=function(e){var t=e.command,n=e.editor;if(!n.multiSelect)return;if(!t.multiSelectAction){var r=t.exec(n,e.args||{});n.multiSelect.addRange(n.multiSelect.toOrientedRange()),n.multiSelect.mergeOverlappingRanges();}else t.multiSelectAction=="forEach"?r=n.forEachSelection(t,e.args):t.multiSelectAction=="forEachLine"?r=n.forEachSelection(t,e.args,!0):t.multiSelectAction=="single"?(n.exitMultiSelectMode(),r=t.exec(n,e.args||{})):r=t.multiSelectAction(n,e.args||{});return r},this.forEachSelection=function(e,t,n){if(this.inVirtualSelectionMode)return;var r=n&&n.keepOrder,i=n==1||n&&n.$byLines,o=this.session,u=this.selection,a=u.rangeList,f=(r?u:a).ranges,l;if(!f.length)return e.exec?e.exec(this,t||{}):e(this,t||{});var c=u._eventRegistry;u._eventRegistry={};var h=new s(o);this.inVirtualSelectionMode=!0;for(var p=f.length;p--;){if(i)while(p>0&&f[p].start.row==f[p-1].end.row)p--;h.fromOrientedRange(f[p]),h.index=p,this.selection=o.selection=h;var d=e.exec?e.exec(this,t||{}):e(this,t||{});!l&&d!==undefined&&(l=d),h.toOrientedRange(f[p]);}h.detach(),this.selection=o.selection=u,this.inVirtualSelectionMode=!1,u._eventRegistry=c,u.mergeOverlappingRanges(),u.ranges[0]&&u.fromOrientedRange(u.ranges[0]);var v=this.renderer.$scrollAnimation;return this.onCursorChange(),this.onSelectionChange(),v&&v.from==v.to&&this.renderer.animateScrolling(v.from),l},this.exitMultiSelectMode=function(){if(!this.inMultiSelectMode||this.inVirtualSelectionMode)return;this.multiSelect.toSingleRange();},this.getSelectedText=function(){var e="";if(this.inMultiSelectMode&&!this.inVirtualSelectionMode){var t=this.multiSelect.rangeList.ranges,n=[];for(var r=0;r<t.length;r++)n.push(this.session.getTextRange(t[r]));var i=this.session.getDocument().getNewLineCharacter();e=n.join(i),e.length==(n.length-1)*i.length&&(e="");}else this.selection.isEmpty()||(e=this.session.getTextRange(this.getSelectionRange()));return e},this.$checkMultiselectChange=function(e,t){if(this.inMultiSelectMode&&!this.inVirtualSelectionMode){var n=this.multiSelect.ranges[0];if(this.multiSelect.isEmpty()&&t==this.multiSelect.anchor)return;var r=t==this.multiSelect.anchor?n.cursor==n.start?n.end:n.start:n.cursor;r.row!=t.row||this.session.$clipPositionToDocument(r.row,r.column).column!=t.column?this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange()):this.multiSelect.mergeOverlappingRanges();}},this.findAll=function(e,t,n){t=t||{},t.needle=e||t.needle;if(t.needle==undefined){var r=this.selection.isEmpty()?this.selection.getWordRange():this.selection.getRange();t.needle=this.session.getTextRange(r);}this.$search.set(t);var i=this.$search.findAll(this.session);if(!i.length)return 0;var s=this.multiSelect;n||s.toSingleRange(i[0]);for(var o=i.length;o--;)s.addRange(i[o],!0);return r&&s.rangeList.rangeAtPoint(r.start)&&s.addRange(r,!0),i.length},this.selectMoreLines=function(e,t){var n=this.selection.toOrientedRange(),r=n.cursor==n.end,s=this.session.documentToScreenPosition(n.cursor);this.selection.$desiredColumn&&(s.column=this.selection.$desiredColumn);var o=this.session.screenToDocumentPosition(s.row+e,s.column);if(!n.isEmpty())var u=this.session.documentToScreenPosition(r?n.end:n.start),a=this.session.screenToDocumentPosition(u.row+e,u.column);else var a=o;if(r){var f=i.fromPoints(o,a);f.cursor=f.start;}else{var f=i.fromPoints(a,o);f.cursor=f.end;}f.desiredColumn=s.column;if(!this.selection.inMultiSelectMode)this.selection.addRange(n);else if(t)var l=n.cursor;this.selection.addRange(f),l&&this.selection.substractPoint(l);},this.transposeSelections=function(e){var t=this.session,n=t.multiSelect,r=n.ranges;for(var i=r.length;i--;){var s=r[i];if(s.isEmpty()){var o=t.getWordRange(s.start.row,s.start.column);s.start.row=o.start.row,s.start.column=o.start.column,s.end.row=o.end.row,s.end.column=o.end.column;}}n.mergeOverlappingRanges();var u=[];for(var i=r.length;i--;){var s=r[i];u.unshift(t.getTextRange(s));}e<0?u.unshift(u.pop()):u.push(u.shift());for(var i=r.length;i--;){var s=r[i],o=s.clone();t.replace(s,u[i]),s.start.row=o.start.row,s.start.column=o.start.column;}n.fromOrientedRange(n.ranges[0]);},this.selectMore=function(e,t,n){var r=this.session,i=r.multiSelect,s=i.toOrientedRange();if(s.isEmpty()){s=r.getWordRange(s.start.row,s.start.column),s.cursor=e==-1?s.start:s.end,this.multiSelect.addRange(s);if(n)return}var o=r.getTextRange(s),u=h(r,o,e);u&&(u.cursor=e==-1?u.start:u.end,this.session.unfold(u),this.multiSelect.addRange(u),this.renderer.scrollCursorIntoView(null,.5)),t&&this.multiSelect.substractPoint(s.cursor);},this.alignCursors=function(){var e=this.session,t=e.multiSelect,n=t.ranges,r=-1,s=n.filter(function(e){if(e.cursor.row==r)return !0;r=e.cursor.row;});if(!n.length||s.length==n.length-1){var o=this.selection.getRange(),u=o.start.row,f=o.end.row,l=u==f;if(l){var c=this.session.getLength(),h;do h=this.session.getLine(f);while(/[=:]/.test(h)&&++f<c);do h=this.session.getLine(u);while(/[=:]/.test(h)&&--u>0);u<0&&(u=0),f>=c&&(f=c-1);}var p=this.session.removeFullLines(u,f);p=this.$reAlignText(p,l),this.session.insert({row:u,column:0},p.join("\n")+"\n"),l||(o.start.column=0,o.end.column=p[p.length-1].length),this.selection.setRange(o);}else{s.forEach(function(e){t.substractPoint(e.cursor);});var d=0,v=Infinity,m=n.map(function(t){var n=t.cursor,r=e.getLine(n.row),i=r.substr(n.column).search(/\S/g);return i==-1&&(i=0),n.column>d&&(d=n.column),i<v&&(v=i),i});n.forEach(function(t,n){var r=t.cursor,s=d-r.column,o=m[n]-v;s>o?e.insert(r,a.stringRepeat(" ",s-o)):e.remove(new i(r.row,r.column,r.row,r.column-s+o)),t.start.column=t.end.column=d,t.start.row=t.end.row=r.row,t.cursor=t.end;}),t.fromOrientedRange(n[0]),this.renderer.updateCursor(),this.renderer.updateBackMarkers();}},this.$reAlignText=function(e,t){function u(e){return a.stringRepeat(" ",e)}function f(e){return e[2]?u(i)+e[2]+u(s-e[2].length+o)+e[4].replace(/^([=:])\s+/,"$1 "):e[0]}function l(e){return e[2]?u(i+s-e[2].length)+e[2]+u(o)+e[4].replace(/^([=:])\s+/,"$1 "):e[0]}function c(e){return e[2]?u(i)+e[2]+u(o)+e[4].replace(/^([=:])\s+/,"$1 "):e[0]}var n=!0,r=!0,i,s,o;return e.map(function(e){var t=e.match(/(\s*)(.*?)(\s*)([=:].*)/);return t?i==null?(i=t[1].length,s=t[2].length,o=t[3].length,t):(i+s+o!=t[1].length+t[2].length+t[3].length&&(r=!1),i!=t[1].length&&(n=!1),i>t[1].length&&(i=t[1].length),s<t[2].length&&(s=t[2].length),o>t[3].length&&(o=t[3].length),t):[e]}).map(t?f:n?r?l:f:c)};}).call(d.prototype),t.onSessionChange=function(e){var t=e.session;t&&!t.multiSelect&&(t.$selectionMarkers=[],t.selection.$initRangeList(),t.multiSelect=t.selection),this.multiSelect=t&&t.multiSelect;var n=e.oldSession;n&&(n.multiSelect.off("addRange",this.$onAddRange),n.multiSelect.off("removeRange",this.$onRemoveRange),n.multiSelect.off("multiSelect",this.$onMultiSelect),n.multiSelect.off("singleSelect",this.$onSingleSelect),n.multiSelect.lead.off("change",this.$checkMultiselectChange),n.multiSelect.anchor.off("change",this.$checkMultiselectChange)),t&&(t.multiSelect.on("addRange",this.$onAddRange),t.multiSelect.on("removeRange",this.$onRemoveRange),t.multiSelect.on("multiSelect",this.$onMultiSelect),t.multiSelect.on("singleSelect",this.$onSingleSelect),t.multiSelect.lead.on("change",this.$checkMultiselectChange),t.multiSelect.anchor.on("change",this.$checkMultiselectChange)),t&&this.inMultiSelectMode!=t.selection.inMultiSelectMode&&(t.selection.inMultiSelectMode?this.$onMultiSelect():this.$onSingleSelect());},t.MultiSelect=m,e("./config").defineOptions(d.prototype,"editor",{enableMultiselect:{set:function(e){m(this),e?(this.on("changeSession",this.$multiselectOnSessionChange),this.on("mousedown",o)):(this.off("changeSession",this.$multiselectOnSessionChange),this.off("mousedown",o));},value:!0},enableBlockSelect:{set:function(e){this.$blockSelectEnabled=e;},value:!0}});}),define("ace/mode/folding/fold_mode",["require","exports","module","ace/range"],function(e,t,n){var r=e("../../range").Range,i=t.FoldMode=function(){};(function(){this.foldingStartMarker=null,this.foldingStopMarker=null,this.getFoldWidget=function(e,t,n){var r=e.getLine(n);return this.foldingStartMarker.test(r)?"start":t=="markbeginend"&&this.foldingStopMarker&&this.foldingStopMarker.test(r)?"end":""},this.getFoldWidgetRange=function(e,t,n){return null},this.indentationBlock=function(e,t,n){var i=/\S/,s=e.getLine(t),o=s.search(i);if(o==-1)return;var u=n||s.length,a=e.getLength(),f=t,l=t;while(++t<a){var c=e.getLine(t).search(i);if(c==-1)continue;if(c<=o)break;l=t;}if(l>f){var h=e.getLine(l).length;return new r(f,u,l,h)}},this.openingBracketBlock=function(e,t,n,i,s){var o={row:n,column:i+1},u=e.$findClosingBracket(t,o,s);if(!u)return;var a=e.foldWidgets[u.row];return a==null&&(a=e.getFoldWidget(u.row)),a=="start"&&u.row>o.row&&(u.row--,u.column=e.getLine(u.row).length),r.fromPoints(o,u)},this.closingBracketBlock=function(e,t,n,i,s){var o={row:n,column:i},u=e.$findOpeningBracket(t,o);if(!u)return;return u.column++,o.column--,r.fromPoints(u,o)};}).call(i.prototype);}),define("ace/theme/textmate",["require","exports","module","ace/lib/dom"],function(e,t,n){t.isDark=!1,t.cssClass="ace-tm",t.cssText='.ace-tm .ace_gutter {background: #f0f0f0;color: #333;}.ace-tm .ace_print-margin {width: 1px;background: #e8e8e8;}.ace-tm .ace_fold {background-color: #6B72E6;}.ace-tm {background-color: #FFFFFF;color: black;}.ace-tm .ace_cursor {color: black;}.ace-tm .ace_invisible {color: rgb(191, 191, 191);}.ace-tm .ace_storage,.ace-tm .ace_keyword {color: blue;}.ace-tm .ace_constant {color: rgb(197, 6, 11);}.ace-tm .ace_constant.ace_buildin {color: rgb(88, 72, 246);}.ace-tm .ace_constant.ace_language {color: rgb(88, 92, 246);}.ace-tm .ace_constant.ace_library {color: rgb(6, 150, 14);}.ace-tm .ace_invalid {background-color: rgba(255, 0, 0, 0.1);color: red;}.ace-tm .ace_support.ace_function {color: rgb(60, 76, 114);}.ace-tm .ace_support.ace_constant {color: rgb(6, 150, 14);}.ace-tm .ace_support.ace_type,.ace-tm .ace_support.ace_class {color: rgb(109, 121, 222);}.ace-tm .ace_keyword.ace_operator {color: rgb(104, 118, 135);}.ace-tm .ace_string {color: rgb(3, 106, 7);}.ace-tm .ace_comment {color: rgb(76, 136, 107);}.ace-tm .ace_comment.ace_doc {color: rgb(0, 102, 255);}.ace-tm .ace_comment.ace_doc.ace_tag {color: rgb(128, 159, 191);}.ace-tm .ace_constant.ace_numeric {color: rgb(0, 0, 205);}.ace-tm .ace_variable {color: rgb(49, 132, 149);}.ace-tm .ace_xml-pe {color: rgb(104, 104, 91);}.ace-tm .ace_entity.ace_name.ace_function {color: #0000A2;}.ace-tm .ace_heading {color: rgb(12, 7, 255);}.ace-tm .ace_list {color:rgb(185, 6, 144);}.ace-tm .ace_meta.ace_tag {color:rgb(0, 22, 142);}.ace-tm .ace_string.ace_regex {color: rgb(255, 0, 0)}.ace-tm .ace_marker-layer .ace_selection {background: rgb(181, 213, 255);}.ace-tm.ace_multiselect .ace_selection.ace_start {box-shadow: 0 0 3px 0px white;}.ace-tm .ace_marker-layer .ace_step {background: rgb(252, 255, 0);}.ace-tm .ace_marker-layer .ace_stack {background: rgb(164, 229, 101);}.ace-tm .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid rgb(192, 192, 192);}.ace-tm .ace_marker-layer .ace_active-line {background: rgba(0, 0, 0, 0.07);}.ace-tm .ace_gutter-active-line {background-color : #dcdcdc;}.ace-tm .ace_marker-layer .ace_selected-word {background: rgb(250, 250, 255);border: 1px solid rgb(200, 200, 250);}.ace-tm .ace_indent-guide {background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;}',t.$id="ace/theme/textmate";var r=e("../lib/dom");r.importCssString(t.cssText,t.cssClass);}),define("ace/line_widgets",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/range"],function(e,t,n){function o(e){this.session=e,this.session.widgetManager=this,this.session.getRowLength=this.getRowLength,this.session.$getWidgetScreenLength=this.$getWidgetScreenLength,this.updateOnChange=this.updateOnChange.bind(this),this.renderWidgets=this.renderWidgets.bind(this),this.measureWidgets=this.measureWidgets.bind(this),this.session._changedWidgets=[],this.$onChangeEditor=this.$onChangeEditor.bind(this),this.session.on("change",this.updateOnChange),this.session.on("changeFold",this.updateOnFold),this.session.on("changeEditor",this.$onChangeEditor);}var r=e("./lib/oop"),i=e("./lib/dom"),s=e("./range").Range;(function(){this.getRowLength=function(e){var t;return this.lineWidgets?t=this.lineWidgets[e]&&this.lineWidgets[e].rowCount||0:t=0,!this.$useWrapMode||!this.$wrapData[e]?1+t:this.$wrapData[e].length+1+t},this.$getWidgetScreenLength=function(){var e=0;return this.lineWidgets.forEach(function(t){t&&t.rowCount&&!t.hidden&&(e+=t.rowCount);}),e},this.$onChangeEditor=function(e){this.attach(e.editor);},this.attach=function(e){e&&e.widgetManager&&e.widgetManager!=this&&e.widgetManager.detach();if(this.editor==e)return;this.detach(),this.editor=e,e&&(e.widgetManager=this,e.renderer.on("beforeRender",this.measureWidgets),e.renderer.on("afterRender",this.renderWidgets));},this.detach=function(e){var t=this.editor;if(!t)return;this.editor=null,t.widgetManager=null,t.renderer.off("beforeRender",this.measureWidgets),t.renderer.off("afterRender",this.renderWidgets);var n=this.session.lineWidgets;n&&n.forEach(function(e){e&&e.el&&e.el.parentNode&&(e._inDocument=!1,e.el.parentNode.removeChild(e.el));});},this.updateOnFold=function(e,t){var n=t.lineWidgets;if(!n||!e.action)return;var r=e.data,i=r.start.row,s=r.end.row,o=e.action=="add";for(var u=i+1;u<s;u++)n[u]&&(n[u].hidden=o);n[s]&&(o?n[i]?n[s].hidden=o:n[i]=n[s]:(n[i]==n[s]&&(n[i]=undefined),n[s].hidden=o));},this.updateOnChange=function(e){var t=this.session.lineWidgets;if(!t)return;var n=e.start.row,r=e.end.row-n;if(r!==0)if(e.action=="remove"){var i=t.splice(n+1,r);i.forEach(function(e){e&&this.removeLineWidget(e);},this),this.$updateRows();}else{var s=new Array(r);s.unshift(n,0),t.splice.apply(t,s),this.$updateRows();}},this.$updateRows=function(){var e=this.session.lineWidgets;if(!e)return;var t=!0;e.forEach(function(e,n){if(e){t=!1,e.row=n;while(e.$oldWidget)e.$oldWidget.row=n,e=e.$oldWidget;}}),t&&(this.session.lineWidgets=null);},this.addLineWidget=function(e){this.session.lineWidgets||(this.session.lineWidgets=new Array(this.session.getLength()));var t=this.session.lineWidgets[e.row];t&&(e.$oldWidget=t,t.el&&t.el.parentNode&&(t.el.parentNode.removeChild(t.el),t._inDocument=!1)),this.session.lineWidgets[e.row]=e,e.session=this.session;var n=this.editor.renderer;e.html&&!e.el&&(e.el=i.createElement("div"),e.el.innerHTML=e.html),e.el&&(i.addCssClass(e.el,"ace_lineWidgetContainer"),e.el.style.position="absolute",e.el.style.zIndex=5,n.container.appendChild(e.el),e._inDocument=!0),e.coverGutter||(e.el.style.zIndex=3),e.pixelHeight==null&&(e.pixelHeight=e.el.offsetHeight),e.rowCount==null&&(e.rowCount=e.pixelHeight/n.layerConfig.lineHeight);var r=this.session.getFoldAt(e.row,0);e.$fold=r;if(r){var s=this.session.lineWidgets;e.row==r.end.row&&!s[r.start.row]?s[r.start.row]=e:e.hidden=!0;}return this.session._emit("changeFold",{data:{start:{row:e.row}}}),this.$updateRows(),this.renderWidgets(null,n),this.onWidgetChanged(e),e},this.removeLineWidget=function(e){e._inDocument=!1,e.session=null,e.el&&e.el.parentNode&&e.el.parentNode.removeChild(e.el);if(e.editor&&e.editor.destroy)try{e.editor.destroy();}catch(t){}if(this.session.lineWidgets){var n=this.session.lineWidgets[e.row];if(n==e)this.session.lineWidgets[e.row]=e.$oldWidget,e.$oldWidget&&this.onWidgetChanged(e.$oldWidget);else while(n){if(n.$oldWidget==e){n.$oldWidget=e.$oldWidget;break}n=n.$oldWidget;}}this.session._emit("changeFold",{data:{start:{row:e.row}}}),this.$updateRows();},this.getWidgetsAtRow=function(e){var t=this.session.lineWidgets,n=t&&t[e],r=[];while(n)r.push(n),n=n.$oldWidget;return r},this.onWidgetChanged=function(e){this.session._changedWidgets.push(e),this.editor&&this.editor.renderer.updateFull();},this.measureWidgets=function(e,t){var n=this.session._changedWidgets,r=t.layerConfig;if(!n||!n.length)return;var i=Infinity;for(var s=0;s<n.length;s++){var o=n[s];if(!o||!o.el)continue;if(o.session!=this.session)continue;if(!o._inDocument){if(this.session.lineWidgets[o.row]!=o)continue;o._inDocument=!0,t.container.appendChild(o.el);}o.h=o.el.offsetHeight,o.fixedWidth||(o.w=o.el.offsetWidth,o.screenWidth=Math.ceil(o.w/r.characterWidth));var u=o.h/r.lineHeight;o.coverLine&&(u-=this.session.getRowLineCount(o.row),u<0&&(u=0)),o.rowCount!=u&&(o.rowCount=u,o.row<i&&(i=o.row));}i!=Infinity&&(this.session._emit("changeFold",{data:{start:{row:i}}}),this.session.lineWidgetWidth=null),this.session._changedWidgets=[];},this.renderWidgets=function(e,t){var n=t.layerConfig,r=this.session.lineWidgets;if(!r)return;var i=Math.min(this.firstRow,n.firstRow),s=Math.max(this.lastRow,n.lastRow,r.length);while(i>0&&!r[i])i--;this.firstRow=n.firstRow,this.lastRow=n.lastRow,t.$cursorLayer.config=n;for(var o=i;o<=s;o++){var u=r[o];if(!u||!u.el)continue;if(u.hidden){u.el.style.top=-100-(u.pixelHeight||0)+"px";continue}u._inDocument||(u._inDocument=!0,t.container.appendChild(u.el));var a=t.$cursorLayer.getPixelPosition({row:o,column:0},!0).top;u.coverLine||(a+=n.lineHeight*this.session.getRowLineCount(u.row)),u.el.style.top=a-n.offset+"px";var f=u.coverGutter?0:t.gutterWidth;u.fixedWidth||(f-=t.scrollLeft),u.el.style.left=f+"px",u.fullWidth&&u.screenWidth&&(u.el.style.minWidth=n.width+2*n.padding+"px"),u.fixedWidth?u.el.style.right=t.scrollBar.getWidth()+"px":u.el.style.right="";}};}).call(o.prototype),t.LineWidgets=o;}),define("ace/ext/error_marker",["require","exports","module","ace/line_widgets","ace/lib/dom","ace/range"],function(e,t,n){function o(e,t,n){var r=0,i=e.length-1;while(r<=i){var s=r+i>>1,o=n(t,e[s]);if(o>0)r=s+1;else{if(!(o<0))return s;i=s-1;}}return -(r+1)}function u(e,t,n){var r=e.getAnnotations().sort(s.comparePoints);if(!r.length)return;var i=o(r,{row:t,column:-1},s.comparePoints);i<0&&(i=-i-1),i>=r.length?i=n>0?0:r.length-1:i===0&&n<0&&(i=r.length-1);var u=r[i];if(!u||!n)return;if(u.row===t){do u=r[i+=n];while(u&&u.row===t);if(!u)return r.slice()}var a=[];t=u.row;do a[n<0?"unshift":"push"](u),u=r[i+=n];while(u&&u.row==t);return a.length&&a}var r=e("../line_widgets").LineWidgets,i=e("../lib/dom"),s=e("../range").Range;t.showErrorMarker=function(e,t){var n=e.session;n.widgetManager||(n.widgetManager=new r(n),n.widgetManager.attach(e));var s=e.getCursorPosition(),o=s.row,a=n.widgetManager.getWidgetsAtRow(o).filter(function(e){return e.type=="errorMarker"})[0];a?a.destroy():o-=t;var f=u(n,o,t),l;if(f){var c=f[0];s.column=(c.pos&&typeof c.column!="number"?c.pos.sc:c.column)||0,s.row=c.row,l=e.renderer.$gutterLayer.$annotations[s.row];}else{if(a)return;l={text:["Looks good!"],className:"ace_ok"};}e.session.unfold(s.row),e.selection.moveToPosition(s);var h={row:s.row,fixedWidth:!0,coverGutter:!0,el:i.createElement("div"),type:"errorMarker"},p=h.el.appendChild(i.createElement("div")),d=h.el.appendChild(i.createElement("div"));d.className="error_widget_arrow "+l.className;var v=e.renderer.$cursorLayer.getPixelPosition(s).left;d.style.left=v+e.renderer.gutterWidth-5+"px",h.el.className="error_widget_wrapper",p.className="error_widget "+l.className,p.innerHTML=l.text.join("<br>"),p.appendChild(i.createElement("div"));var m=function(e,t,n){if(t===0&&(n==="esc"||n==="return"))return h.destroy(),{command:"null"}};h.destroy=function(){if(e.$mouseHandler.isMousePressed)return;e.keyBinding.removeKeyboardHandler(m),n.widgetManager.removeLineWidget(h),e.off("changeSelection",h.destroy),e.off("changeSession",h.destroy),e.off("mouseup",h.destroy),e.off("change",h.destroy);},e.keyBinding.addKeyboardHandler(m),e.on("changeSelection",h.destroy),e.on("changeSession",h.destroy),e.on("mouseup",h.destroy),e.on("change",h.destroy),e.session.widgetManager.addLineWidget(h),h.el.onmousedown=e.focus.bind(e),e.renderer.scrollCursorIntoView(null,.5,{bottom:h.el.offsetHeight});},i.importCssString("    .error_widget_wrapper {        background: inherit;        color: inherit;        border:none    }    .error_widget {        border-top: solid 2px;        border-bottom: solid 2px;        margin: 5px 0;        padding: 10px 40px;        white-space: pre-wrap;    }    .error_widget.ace_error, .error_widget_arrow.ace_error{        border-color: #ff5a5a    }    .error_widget.ace_warning, .error_widget_arrow.ace_warning{        border-color: #F1D817    }    .error_widget.ace_info, .error_widget_arrow.ace_info{        border-color: #5a5a5a    }    .error_widget.ace_ok, .error_widget_arrow.ace_ok{        border-color: #5aaa5a    }    .error_widget_arrow {        position: absolute;        border: solid 5px;        border-top-color: transparent!important;        border-right-color: transparent!important;        border-left-color: transparent!important;        top: -5px;    }","");}),define("ace/ace",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/dom","ace/lib/event","ace/range","ace/editor","ace/edit_session","ace/undomanager","ace/virtual_renderer","ace/worker/worker_client","ace/keyboard/hash_handler","ace/placeholder","ace/multi_select","ace/mode/folding/fold_mode","ace/theme/textmate","ace/ext/error_marker","ace/config"],function(e,t,n){e("./lib/fixoldbrowsers");var r=e("./lib/dom"),i=e("./lib/event"),s=e("./range").Range,o=e("./editor").Editor,u=e("./edit_session").EditSession,a=e("./undomanager").UndoManager,f=e("./virtual_renderer").VirtualRenderer;e("./worker/worker_client"),e("./keyboard/hash_handler"),e("./placeholder"),e("./multi_select"),e("./mode/folding/fold_mode"),e("./theme/textmate"),e("./ext/error_marker"),t.config=e("./config"),t.require=e,typeof define=="function"&&(t.define=define),t.edit=function(e,n){if(typeof e=="string"){var s=e;e=document.getElementById(s);if(!e)throw new Error("ace.edit can't find div #"+s)}if(e&&e.env&&e.env.editor instanceof o)return e.env.editor;var u="";if(e&&/input|textarea/i.test(e.tagName)){var a=e;u=a.value,e=r.createElement("pre"),a.parentNode.replaceChild(e,a);}else e&&(u=e.textContent,e.innerHTML="");var l=t.createEditSession(u),c=new o(new f(e),l,n),h={document:l,editor:c,onResize:c.resize.bind(c,null)};return a&&(h.textarea=a),i.addListener(window,"resize",h.onResize),c.on("destroy",function(){i.removeListener(window,"resize",h.onResize),h.editor.container.env=null;}),c.container.env=c.env=h,c},t.createEditSession=function(e,t){var n=new u(e,t);return n.setUndoManager(new a),n},t.Range=s,t.Editor=o,t.EditSession=u,t.UndoManager=a,t.VirtualRenderer=f,t.version="1.4.3";});            (function() {
                window.require(["ace/ace"], function(a) {
                    if (a) {
                        a.config.init(true);
                        a.define = window.define;
                    }
                    if (!window.ace)
                        window.ace = a;
                    for (var key in a) if (a.hasOwnProperty(key))
                        window.ace[key] = a[key];
                    window.ace["default"] = window.ace;
                    if (typeof module$1 == "object" && typeof exports$1 == "object" && module$1) {
                        module$1.exports = window.ace;
                    }
                });
            })();

//=================================
//Additional code to convert to ES6 module
if(exports$1 != module$1.exports) exports$1 = module$1.exports;
//=================================

/** This method shows a configurable dialog. The layout object
 * defines the form content for the dialog. The on submit
 * function is called when submit is pressed. The on submit function should
 * return true or false, indicating whether of not to close the dialog. */
function showConfigurableDialog(layout,onSubmitFunction,optionalOnCancelFunction) {

    var dialog = dialogMgr.createDialog({"movable":true});
    var lineObjects = [];
    
    //this is the action for the form
    var formActions = {};
    //close form, in case actions needed
    formActions.onClose = function() {
        for(var i = 0; i < lineObjects.length; i++) {
            lineObject = lineObjects[i];
            if(lineObject.onClose) {
                lineObject.onClose();
            }
        }
        dialogMgr.closeDialog(dialog);
    };
    //cancel
    formActions.onCancel = function() {
        if(optionalOnCancelFunction) optionalOnCancelFunction();
        formActions.onClose();
    };
    //submit
    formActions.onSubmit = function() {
        //load the form data
        var formData = {};
        var lineObject;
        for(var i = 0; i < lineObjects.length; i++) {
            lineObject = lineObjects[i];
            if(lineObject.addToResult) {
                lineObject.addToResult(formData);
            }
        }
        //submit data
        var closeDialog = onSubmitFunction(formData);
        if(closeDialog) {
            formActions.onClose();
        }
    };
    
    //this will be used if we want to set the initial focus
    var initialFocusElement;

    var content = uiutil.createElement("div",{"className":"dialogBody"});
    for(var i = 0; i < layout.lines.length; i++) {
        var lineDef = layout.lines[i];
        
        //create line
        var lineObject = createLine(lineDef,formActions);
        lineObjects.push(lineObject);
        if(lineObject.element) { //no element for "invisible" entry, which is used to pass values along
            content.appendChild(lineObject.element);
        }
        if((lineDef.focus)&&(lineObject.focusElement)) {
            initialFocusElement = lineObject.focusElement;
        }
    }
    
    //show dialog
    dialog.setContent(content,uiutil.SIZE_WINDOW_TO_CONTENT);
    dialogMgr.showDialog(dialog);
    if(initialFocusElement) {
        initialFocusElement.focus();
    }
    
    //size the dialog to the content
    dialog.fitToContent();
    dialog.centerInParent();
}
    
    
    
function createLine(lineDef,formActions) {
    var lineFunction = lineFunctions[lineDef.type];
    if(lineFunction) {
        return lineFunction(lineDef,formActions);
    }
    else {
        //print an error message
        alert("Error: Unknown for element type: " + lineDef.type);
        return null;
    }
}

let lineFunctions = {
    //linedef.type = "title"
    //linedef.title = title
    "title": function(lineDef,formActions) {
        var lineObject = {};
        //create the element
        var line = uiutil.createElement("div",{"className":"dialogLine"});
        line.appendChild(uiutil.createElement("div",{"className":"dialogTitle","innerHTML":lineDef.title}));
        lineObject.element = line;
        
        //no addToResult or onClose
        
        return lineObject;
    },
    
    //lineDef.type = "dropdown"
    //lineDef.heading = dropdown heading (optional)
    //lineDef.entries = list of strings (or values) in dropdown
    //lineDef.initial = index of initial selection (optional)
    //lineDef.resultKey = name of result in result data
    "dropdown": function(lineDef,formActions) {
        var lineObject = {};
        //create the element
        var line = uiutil.createElement("div",{"className":"dialogLine"});
        if(lineDef.heading) {
            line.appendChild(document.createTextNode(lineDef.heading));
        }
        var select = uiutil.createElement("select");
        lineObject.focusElement = select;
        for(var i = 0; i < lineDef.entries.length; i++) {
            var entry = lineDef.entries[i];
            let label, value;
            if(apogeeutil$1.getObjectType(entry) == "Array") {
                value = entry[0];
                label = entry[1];
            }
            else {
                value = entry;
                label = entry;   
            }
            select.add(uiutil.createElement("option",{"text":label, "value":value}));
        }
        if(lineDef.initial) {
            select.value = lineDef.initial;
        }
        if(lineDef.disabled) {
            select.disabled = true;
        }
        line.appendChild(select);
        lineObject.element = line;
        //get result
        lineObject.addToResult = function(formData) {
            var result = select.value;
            formData[lineDef.resultKey] = result;
        };
        //no on Close
        
        return lineObject;
    },
    
    //lineDef.type = "inputElement"
    //lineDef.heading = element heading (optional)
    //lineDef.resultKey = name of result in result data
    "inputElement": function(lineDef,formActions) {
        var lineObject = {};
        //create the element
        var line = uiutil.createElement("div",{"className":"dialogLine"});
        if(lineDef.heading) {
            line.appendChild(document.createTextNode(lineDef.heading));
        }
        var inputElement = uiutil.createElement("input",{"type":"text"});
        lineObject.focusElement = inputElement;
        if(lineDef.initial) {
            inputElement.value = lineDef.initial;
        }
        if(lineDef.disabled) {
            inputElement.disabled = true;
        }
        line.appendChild(inputElement);
        lineObject.element = line;
        //get result
        lineObject.addToResult = function(formData) {
            var result = inputElement.value.trim();
            formData[lineDef.resultKey] = result;
        };
        //no on Close
        
        return lineObject;
    },
    
    "aceEditor": function(lineDef,formActions) {
        
    },
    
    "radioButton": function(lineDef,formActions) {
        //implement!
    },
    
    "checkbox": function(lineDef,formActions) {
        var lineObject = {};
        //create the element
        var line = uiutil.createElement("div",{"className":"dialogLine"});
        if(lineDef.heading) {
            line.appendChild(document.createTextNode(lineDef.heading));
        }
        var checkbox = uiutil.createElement("input");
        checkbox.type = "checkbox";
        lineObject.focusElement = checkbox;
        if(lineDef.name) {
            checkbox.name = lineDef.name;
        }
        if(lineDef.value) {
            checkbox.value = lineDef.value;
        }
        if(lineDef.initial) {
            checkbox.checked = true;
        }
        line.appendChild(checkbox);
        lineObject.element = line;
        //get result
        lineObject.addToResult = function(formData) {
            var result = checkbox.checked;
            formData[lineDef.resultKey] = result;
        };
        //no on Close
        
        return lineObject;
    },
    
    //lineDef.type = "submit"
    //lineDef.submit = name of submit button (optional)
    //lineDef.cancel = name of cancel button (optional)
    "submit": function(lineDef,formActions) {
        var lineObject = {};
        //create the element
        var line = uiutil.createElement("div",{"className":"dialogLine"});
        if(lineDef.submit) {  
            line.appendChild(uiutil.createElement("button",
            {"className":"dialogButton","innerHTML":lineDef.submit,"onclick":formActions.onSubmit}));
        }
        if(lineDef.cancel) {
            line.appendChild(uiutil.createElement("button",
            {"className":"dialogButton","innerHTML":lineDef.cancel,"onclick":formActions.onCancel}));
        }
        lineObject.element = line;
        //no add to result or on close
        return lineObject;
    },
    
    //This allows the user to input a custom element
    //lineDef.type = "custom"
    //lineDef.createLineObject(formActions) - returns lineObject
    "custom": function(lineDef,formActions) {
        return lineDef.createLineObject(formActions);
    },
    
    //lineDef.type = "invisible"
    //lineDef.intial = value for this element (optional)
    //lineDef.resultKey = name of result in result data
    "invisible": function(lineDef,formActions) {
        var lineObject = {};
        //create the empty element
        lineObject.element = null;
        //get result
        lineObject.addToResult = function(formData) {
            
            formData[lineDef.resultKey] = lineDef.initial;
        };
        //no on Close
        
        return lineObject;
    }
    
    
};

//=====================================
// UI Entry Point
//=====================================

/** This method gets a callback to update the properties of a component. */
function updateComponent(componentView) {

    var modelManager = componentView.getModelView().getModelManager(); 
    var component = componentView.getComponent();
    
    var componentClass = component.constructor;
    var componentViewClass = componentView.constructor;

    var displayName = componentClass.displayName;
    var additionalLines = apogeeutil$1.jsonCopy(componentViewClass.propertyDialogLines); 

    var initialValues = component.getPropertyValues(modelManager.getModel()); 

    // add the folders to which we can move this (it can move to root only if it is a parent)
    let includeRootFolder = componentViewClass.hasTabEntry;
    var parentList = modelManager.getParentList(includeRootFolder);

    //create the dialog layout - do on the fly because folder list changes
    var dialogLayout = getPropertiesDialogLayout(displayName,parentList,additionalLines,false,initialValues);

    //create on submit callback
    var onSubmitFunction = function(submittedValues) {
        
        //get the changed values
        var newValues = {};
        for(var key in initialValues) {
            if(initialValues[key] !== submittedValues[key]) {
                newValues[key] = submittedValues[key];
            }
        }
        
        var commands = [];
        
        //--------------
        // Update Properties
        //--------------
        
        var memberUpdateJson = {};
        if(componentClass.transferMemberProperties) {
            componentClass.transferMemberProperties(newValues,memberUpdateJson);
        }
        var numMemberProps = apogeeutil$1.jsonObjectLength(memberUpdateJson);
        
        var componentUpdateJson = {};
        if(componentClass.transferComponentProperties) {
            componentClass.transferComponentProperties(newValues,componentUpdateJson);
        }
        var numComponentProps = apogeeutil$1.jsonObjectLength(componentUpdateJson);
        
        if((numMemberProps > 0)||(numComponentProps > 0)) {
            let updateCommand = {};
            updateCommand.type = "updateComponent";
            updateCommand.memberId = component.getMemberId();
            if(numMemberProps > 0) updateCommand.updatedMemberProperties = memberUpdateJson;
            if(numComponentProps > 0) updateCommand.updatedComponentProperties = componentUpdateJson;
            commands.push(updateCommand);
        }
        
        //--------------
        // Move
        //--------------
        
        if((newValues.name)||(newValues.parentId)) {
            
            //validate the name
            if(newValues.name) {
                var nameResult = validateTableName(newValues.name);
                if(!nameResult.valid) {
                    alert(nameResult.errorMessage);
                    return false;
                }
            }

            let oldName = component.getName();
            let modelView;

            let renameEditorCommands;

            //do the first stage of editor commands
            if(componentViewClass.hasChildEntry) {
                //load model view, will be used for old parent and new parent
                modelView = componentView.getModelView();

                //look up the old parent component
                let oldParentComponent = component.getParentComponent(modelManager);
                //remove the component from the parent component document.
                //if there is no parent component, we wil assume this was in the root folder
                if(oldParentComponent) {
                    let oldParentComponentView = modelView.getComponentViewByComponentId(oldParentComponent.getId());

                    if(newValues.parentId) {
                        //----------------------------
                        //move case
                        //delete old node
                        //----------------------------
                        let oldParentEditorCommand = oldParentComponentView.getRemoveApogeeNodeFromPageCommand(oldName);
                        commands.push(oldParentEditorCommand);
                    }
                    else if(newValues.name) {
                        //---------------------------
                        //rename case
                        //get the rename editr comamnds, then apply the one to clear the component node name
                        //----------------------------
                        renameEditorCommands = oldParentComponentView.getRenameApogeeNodeCommands(component.getMemberId(),oldName,newValues.name);
                        commands.push(renameEditorCommands.setupCommand);
                    }
                }
            }
            
            //update the component name
            let moveCommand = {};
            moveCommand.type = "moveComponent";
            moveCommand.memberId = component.getMemberId();
            moveCommand.newMemberName = submittedValues.name;
            moveCommand.newParentId = newValues.parentId;
            commands.push(moveCommand);

            //do the second stage of editor commands
            if(componentViewClass.hasChildEntry) {

                //-----------------------------------
                // move case
                // add the compone nodes to the new page after the component has been moved there
                //----------------------------------------------
                if(newValues.parentId) {
                    let newParentComponentId = modelManager.getComponentIdByMemberId(newValues.parentId);
                    //there will be no component id if we are putting this in the root folder
                    if(newParentComponentId) {
                        let newParentComponentView = modelView.getComponentViewByComponentId(newParentComponentId);

                        let newName = newValues.name ? newValues.name : oldName;

                        //insert node add at end of new page
                        let newParentCommands = newParentComponentView.getInsertApogeeNodeOnPageCommands(newName,true);
                        //added the editor setup command
                        if(newParentCommands.editorSetupCommand) commands.push(newParentCommands.editorSetupCommand);
                        //check if we need to add any delete component commands  - we shouldn't have any since we are not overwriting data here
                        if(newParentCommands.deletedComponentCommands) {
                            //make sure the user wants to proceed
                            let deletedComponentNames = newParentCommands.deletedComponentCommands.map(command => command.memberId);
                            let doDelete = confirm("Are you sure you want to delete these apogee nodes: " + deletedComponentNames);
                            
                            //return if user rejects
                            if(!doDelete) return;
                            
                            commands.push(...newParentCommands.deletedComponentCommands);
                        }

                        //add the editor insert command
                        if(newParentCommands.editorAddCommand) commands.push(newParentCommands.editorAddCommand);
                    }
                    else {
                        if(!componentViewClass.hasTabEntry) {
                            //TBR if we want to enforce this condition...
                            throw new Error("This component can not be placed in the root folder.");
                        }
                    }

                }

                //----------------------------
                //rename case
                //set the new node name, after the compnoent rename is done
                //-------------------------------------------
                if(renameEditorCommands) {
                    //update apogee node name
                    commands.push(renameEditorCommands.setNameCommand);
                }
            }

        }
        
        //---------------
        // combine commands (as needed)
        //---------------

        var command;
        
        if(commands.length > 1) {
            //make a compound command
            command = {};
            command.type = "compoundCommand";
            command.childCommands = commands;
        }
        else if(commands.length === 1) {
            command = commands[0];
        }
        
        //execute command
        if(command) {   
            modelManager.getApp().executeCommand(command);
        }

        returnToEditor(componentView,submittedValues.name);

        //return true to close the dialog
        return true;
    };

    //return focus to editor on cancel
    let onCancelFunction = () => returnToEditor(componentView);

    //show dialog
    showConfigurableDialog(dialogLayout,onSubmitFunction,onCancelFunction);
}

function returnToEditor(componentView) {
    let componentViewClass = componentView.constructor;
    if(componentViewClass.hasChildDisplay) {
        let parentComponentView = componentView.getParentComponentView();
        if(parentComponentView) {
            parentComponentView.giveEditorFocusIfShowing();
        }
    }
}

//========================
// dialog setup - this is shared with add component since it is the same basic action
//========================

//this is for a create or update dialog
//omit folder names (null) and folder initial value to omit the parent selection
function getPropertiesDialogLayout(displayName,folderNames,additionalLines,doCreate,initialValues) { 
    
    //create the dialog layout - do on the fly because folder list changes
    var dialogLayout = {};
    var lines = [];
    dialogLayout.lines = lines;

    var titleLine = {};
    titleLine.type = "title";
    if(doCreate) {
        titleLine.title = "New " + displayName;
    }
    else {
        titleLine.title = "Update " + displayName; 
    }
    lines.push(titleLine);

    if(folderNames) {
        var parentLine = {};
        parentLine.type = "dropdown";
        parentLine.heading = "Folder: ";
        parentLine.entries = folderNames;
        parentLine.resultKey = "parentId"; 
        lines.push(parentLine);
    }

    var nameLine = {};
    nameLine.type = "inputElement";
    nameLine.heading = "Name: ";
    nameLine.resultKey = "name";
    nameLine.focus = true;
    lines.push(nameLine);
    
    //add additioanl lines, if applicable
    if(additionalLines) {
        for(var i = 0; i < additionalLines.length; i++) {
            lines.push(additionalLines[i]);
        }
    }

    //submit
    var submitLine = {};
    submitLine.type = "submit";
    if(doCreate) {
        submitLine.submit = "Create";
    }
    else {
        submitLine.submit = "Update";
    }
    submitLine.cancel = "Cancel";
    lines.push(submitLine);
    
    //set the initial values
    if(initialValues) {
        for(var i = 0; i < lines.length; i++) {
            var line = lines[i];
            if(line.resultKey) {
                line.initial = initialValues[line.resultKey];
            }
        }
    }
    
    return dialogLayout;
}

/** This method shows a dialog to select from additional components. */
function showSelectComponentDialog(componentInfoList,onSelectFunction) {

    var dialog = dialogMgr.createDialog({"movable":true});
    
    //add a scroll container
    var contentContainer = uiutil.createElement("div",null,
        {
			"display":"block",
            "position":"relative",
            "top":"0px",
            "height":"100%",
            "overflow": "auto"
        });
	dialog.setContent(contentContainer,uiutil.SIZE_WINDOW_TO_CONTENT);
    
    var line;
    
	var content = uiutil.createElement("div",null,
			{
				"display":"table",
				"overflow":"hidden"
			});
	contentContainer.appendChild(content);
    
    var line;
  
    //title
    line = uiutil.createElement("div",{"className":"dialogLine"});
    line.appendChild(uiutil.createElement("div",{"className":"dialogTitle","innerHTML":"Select Component Type"}));
    content.appendChild(line);
    
    //folder selection
    line = uiutil.createElement("div",{"className":"dialogLine"});
    line.appendChild(document.createTextNode("Component:"));
    var select = uiutil.createElement("select");
    line.appendChild(select);
    componentInfoList.forEach( componentInfo => {
		select.add(uiutil.createElement("option",{"text":componentInfo.displayName,"value":componentInfo.uniqueName}));
    });
    content.appendChild(line);
    
    //buttons
    line = uiutil.createElement("div",{"className":"dialogLine"});
    var onCancel = function() {
        dialogMgr.closeDialog(dialog);
    };
    
    var onCreate = function() {
		var componentClass = select.value;
        onSelectFunction(componentClass);
        dialogMgr.closeDialog(dialog);
    };
    line.appendChild(uiutil.createElement("button",{"className":"dialogButton","innerHTML":"Create","onclick":onCreate}));
    line.appendChild(uiutil.createElement("button",{"className":"dialogButton","innerHTML":"Cancel","onclick":onCancel}));
    content.appendChild(line);
    
    dialog.setContent(content,uiutil.SIZE_WINDOW_TO_CONTENT);  
    
    //show dialog
    dialogMgr.showDialog(dialog);
    
    //size the dialog to the content
    dialog.fitToContent();
    dialog.centerInParent();
}

/** This module initializes the default component view classes. */
let componentViewClassMap = {};

let ERROR_COMPONENT_VIEW_CLASS;

/** This method is used to register a new component view class for the user interface. */
function registerComponentView(viewClass) {
    componentViewClassMap[viewClass.componentName] = viewClass;
}

/** This method retrieves a component view class using the component unique name. */
function getComponentViewClass(componentName) {
    return componentViewClassMap[componentName];
}

function setErrorComponentView(errorComponentViewClass) {
    ERROR_COMPONENT_VIEW_CLASS = errorComponentViewClass;
}

//=====================================
// UI Entry Point
//=====================================

/** This functions initiates the add component action. It will create a dialog for the user to enter the relevent 
 * properties, with the values optionalInitialProperties preset. The created componenent will also use the 
 * property values in optionalBaseComponentValues, overridden by the user input properties where applicable. The member
 * created will be made using the optionalBaseMemberValues, agagin overidden by any user input values.  */   
//piggybackCommand is a temporary test!!!
function addComponent(appView,app,componentClass,optionalInitialProperties,optionalBaseMemberValues,optionalBaseComponentValues) {

        let componentViewClass = getComponentViewClass(componentClass.uniqueName);
        let modelView = appView.getWorkspaceView().getModelView();

        //get the active workspace
        var workspaceManager = app.getWorkspaceManager();
        if(!workspaceManager) {
            alert("There is no open workspace.");
            return;
        }     

        var modelManager = workspaceManager.getModelManager();
        if(!modelManager) {
            alert("The workspace has not been loaded yet.");
            return;
        }    

        //this is not a true test - the workspace and model can be presenet ith out the model loaded.

        
        //get the tyep display name
        var displayName = componentClass.displayName;
        
        //get any additional property content for dialog beyond basic properties
        var additionalLines = apogeeutil$1.jsonCopy(componentViewClass.propertyDialogLines); 
        
        //get the folder list
        let includeRootFolder = componentViewClass.hasTabEntry;
        var parentList = modelManager.getParentList(includeRootFolder);
        
        //create the dialog layout - do on the fly because folder list changes
        var dialogLayout = getPropertiesDialogLayout(displayName,parentList,additionalLines,true,optionalInitialProperties);

        //we will populate the parent if we need to insert thenew component as a child in the parent document. 
        
        
        //create on submit callback
        var onSubmitFunction = function(userInputProperties) {
            
            //validate the name
            var nameResult = validateTableName(userInputProperties.name);
            if(!nameResult.valid) {
                alert(nameResult.errorMessage);
                return false;
            }

            //other validation of inputs?

//we should do this cleaner - by storing parent id in the submit input
            let modelManager = modelView.getModelManager();
            let parentMemberId = userInputProperties.parentId;

            let commands = [];
            
            //create the model command
            let createCommandData = {};
            createCommandData.type = "addComponent";
            createCommandData.parentId = parentMemberId;
            createCommandData.memberJson = Component.createMemberJson(componentClass,userInputProperties,optionalBaseMemberValues);
            createCommandData.componentJson = Component.createComponentJson(componentClass,userInputProperties,optionalBaseComponentValues);

            //editor related commands
            let additionalCommandInfo;
            let parentComponentView;
            if(componentViewClass.hasChildEntry) {
                let parentComponentId = modelManager.getComponentIdByMemberId(parentMemberId);
                if(parentComponentId) {
                    parentComponentView = modelView.getComponentViewByComponentId(parentComponentId);
                    if(!parentComponentView) throw new Error("Parent component not found!");

                    additionalCommandInfo = getAdditionalCommands(parentComponentView,userInputProperties.name);

                    //added the editor setup command
                    if(additionalCommandInfo.editorSetupCommand) commands.push(additionalCommandInfo.editorSetupCommand);

                    //add any delete commands
                    if(additionalCommandInfo.deletedComponentCommands){
                        //make sure the user wants to proceed
                        let doDelete = confirm("Are you sure you want to delete these apogee nodes: " + additionalCommandInfo.deletedComponentShortNames);
                        
                        //return if user rejects
                        if(!doDelete) return;

                        commands.push(...additionalCommandInfo.deletedComponentCommands);
                    } 
                }
            }

            //store create command
            commands.push(createCommandData);

            //add the editor insert command
            if((additionalCommandInfo)&&(additionalCommandInfo.editorAddCommand)) {
                commands.push(additionalCommandInfo.editorAddCommand);
            }
            
            let commandData;
            if(commands.length > 1) {
                commandData = {};
                commandData.type = "compoundCommand";
                commandData.childCommands = commands;
            }
            else if(commands.length === 1) {
                commandData = commands[0];
            }
            else {
                //this shouldn't happen
                return;
            }
            
            //execute command
            app.executeCommand(commandData);

            //give focus back to editor
            if(parentComponentView) {
                parentComponentView.giveEditorFocusIfShowing();
            }

            //return true to close the dialog
            return true;
        };

        //give foxus back to editor
        let onCancelFunction = () => null;        
        //show dialog
        showConfigurableDialog(dialogLayout,onSubmitFunction,onCancelFunction);
}


/** This gets a callback to add an "additional" component, menaing one that is not
 * in the main component menu. */
function addAdditionalComponent(appView,app,optionalInitialProperties,optionalBaseMemberValues,optionalBaseComponentValues) {
        
    var onSelect = function(componentUniqueName) {
        let componentClass = componentInfo.getComponentClass(componentUniqueName);
        if(componentClass) {
            addComponent(appView,app,componentClass,optionalInitialProperties,optionalBaseMemberValues,optionalBaseComponentValues);
        }
        else {
            alert("Unknown component type: " + componentType);
        }
    };
    //get the display names
    let additionalComponents = componentInfo.getAdditionalComponentNames();
    let componentInfoList = additionalComponents.map( componentName => {
        let componentClass = componentInfo.getComponentClass(componentName); 
        return {displayName: componentClass.displayName, uniqueName: componentName};
    });
    //open select component dialog
    showSelectComponentDialog(componentInfoList,onSelect);
}

/** This is to get an commands needed to add the a child node onto a parent page. */
function getAdditionalCommands(parentComponentView,childName) {
    //check selection
    let useParentSelection = getUseParentSelection(parentComponentView);
    
    let insertAtEnd = !useParentSelection;

    return parentComponentView.getInsertApogeeNodeOnPageCommands(childName,insertAtEnd);
}

function getUseParentSelection(parentComponentView) {
    //use the parent selection only if the tab is the active tab
    //otherwise the component should be placed at the end

    let tabDisplay = parentComponentView.getTabDisplay();
    if(!tabDisplay) return false;

    let tab = tabDisplay.getTab();
    if(!tab) return false;
    
    return tabDisplay.getIsShowing();
}

//=====================================
// UI Entry Point
//=====================================

function closeWorkspace(app) {
    
    var activeWorkspaceManager = app.getWorkspaceManager();
    if(activeWorkspaceManager === null) {
        alert("There is no workspace close.");
        return;
    }

    //
    if(activeWorkspaceManager.getIsDirty()) {
        var doClose = confirm("There is unsaved data. Are you sure you want to close the workspace?");
        if(!doClose) {
            return;
        }
    }
    
    var commandData = {};
    commandData.type = "closeWorkspace";

    app.executeCommand(commandData);
}

//=====================================
// UI Entry Point
//=====================================

function createWorkspace(app) {
    //make sure there is not an open workspace
    if(app.getWorkspaceManager()) {
        alert("There is already an open workspace. You must close the workspace first.");
        return;
    }      
    
    var commandData = {};
    commandData.type = "openWorkspace";
    
    app.executeCommand(commandData);
}

//=====================================
// UI Entry Point
//=====================================

/** This is the UI sequence to open a workspace */
function openWorkspace(app,fileAccessObject) {
    
    //make sure there is not an open workspace
    if(app.getWorkspaceManager()) {
        alert("There is an open workspace. You must close the workspace first.");
        return;
    }    

    let onOpen = (err,workspaceData,fileMetadata) => onWorkspaceOpen(err,app,workspaceData,fileMetadata);

    fileAccessObject.openFile(onOpen);
}

//=====================================
// Internal functions
//=====================================

/** This method should be called when workspace data is opened, to create the workspace. */
function onWorkspaceOpen(err,app,workspaceData,fileMetadata) {

    if(err) {
        var errorMessage = "There was an error opening the file";
        if(err.message)errorMessage += ": " + err.message;
        alert(errorMessage);
        return;
    }
    else if(workspaceData) {
        if(app.getWorkspaceManager()) {
            alert("There is already an open workspace");
            return;
        }
        
        var workspaceJson;
        try {
            workspaceJson = JSON.parse(workspaceData);
        }
        catch(error) {
            if(error.stack) console.error(error.stack);
            
            alert("Error parsing workspace content: " + error.message);
            return;
        }
        
        //open workspace
        var commandData = {};
        commandData.type = "openWorkspace";
        commandData.workspaceJson = workspaceJson;
        commandData.fileMetadata = fileMetadata;

        app.executeCommand(commandData);
    }
}

//=====================================
// UI Entry Point
//=====================================

function saveWorkspace(app,fileAccessObject,requestDirectSave) {

    var activeWorkspaceManager = app.getWorkspaceManager();
    var workspaceText;
    var fileMetadata;
    var doDirectSave = false;
    if(activeWorkspaceManager) {
        var workspaceJson = activeWorkspaceManager.toJson();
        workspaceText = JSON.stringify(workspaceJson);
        fileMetadata = activeWorkspaceManager.getFileMetadata();
        //see if we can do a direct save
        if(requestDirectSave) doDirectSave = fileAccessObject.directSaveOk(fileMetadata);
    }
    else {
        alert("There is no workspace open.");
        return;
    }

    //clear workspace dirty flag on completion of save
    var onSave = (err,fileSaved,updatedFileMetadata) => {
        if(err) {
            alert("There was an error saving the file: " + err.toString());
        }
        else if(fileSaved) {
            var workspaceManager = app.getWorkspaceManager();
            workspaceManager.clearIsDirty();
            if(updatedFileMetadata) {
                workspaceManager.setFileMetadata(updatedFileMetadata);
            }
        }
    };

    if(doDirectSave) {
        fileAccessObject.saveFile(fileMetadata,workspaceText,onSave);
    }
    else {
        fileAccessObject.saveFileAs(fileMetadata,workspaceText,onSave);
    }
}

const DIALOG_LAYOUT_TITLE_LINE = {
    "type": "title",
    "title": "Update Workspace"
};
const DIALOG_LAYOUT_NAME_LINE = {
    "type": "inputElement",
    "heading": "Name: ",
    "resultKey": "name",
    "initial": "",
    "focus": true
};
const DIALOG_LAYOUT_SUBMIT_LINE = {
    "type": "submit",
    "submit": "Update",
    "cancel": "Cancel"
};

//=====================================
// UI Entry Point
//=====================================

/** This method gets a callback to update the properties of a workspace. */
function updateWorkspaceProperties(workspaceManager) {
        
    var model = workspaceManager.getModelManager().getModel();

    //load initial values
    var initialValues = {};
    initialValues.name = model.getName();

    //create the dialog layout
    var nameLine = apogeeutil$1.jsonCopy(DIALOG_LAYOUT_NAME_LINE);
    nameLine.initial = initialValues.name;

    var dialogLayout = {};
    dialogLayout.lines = [];
    dialogLayout.lines.push(DIALOG_LAYOUT_TITLE_LINE);
    dialogLayout.lines.push(nameLine);
    //(add any workspace ui lines here)
    dialogLayout.lines.push(DIALOG_LAYOUT_SUBMIT_LINE);

    //create on submit callback
    var onSubmitFunction = function(newValues) {

        var valuesChanged = false;

        //validate the name, if it changed
        if(newValues.name !== initialValues.name) {
            //validate name - for now just make sure it is not zero length
            if(newValues.length === 0) {
                alert("The name must not be empty");
                return false;
            }

            valuesChanged = true;
        }

        //validate any other fields here

        //update
        if(valuesChanged) {
            var commandData = {};
            commandData.type = "updateWorkspace";
            commandData.updatedCoreProperties = {};
            commandData.updatedCoreProperties.name = newValues.name;

            workspaceManager.getApp().executeCommand(commandData);
        }

        //return true to close the dialog
        return true;
    };

    //show dialog
    showConfigurableDialog(dialogLayout,onSubmitFunction);
}

const DIALOG_LAYOUT_URL_LINE = {
    "type": "inputElement",
    "heading": "URL: ",
    "resultKey": "url",
    "initial": "",
    "focus": true
};
const DIALOG_LAYOUT_NICKNAME_LINE = {
    "type": "inputElement",
    "heading": "Nickname (optional): ",
    "resultKey": "nickname",
    "initial": ""
};
const DIALOG_LAYOUT_SUBMIT_LINE$1 = {
    "type": "submit",
    "submit": "Update",
    "cancel": "Cancel"
};

//=====================================
// UI Entry Point
//=====================================

/** This method adds a link to the workspace. */
function addLink(app,displayInfo) {
        
    //create the dialog layout 
    var titleLine = {};
    titleLine.type = "title";
    titleLine.title = displayInfo.ADD_ENTRY_TEXT;

    var dialogLayout = {};
    dialogLayout.lines = [];
    dialogLayout.lines.push(titleLine);
    dialogLayout.lines.push(DIALOG_LAYOUT_URL_LINE);
    dialogLayout.lines.push(DIALOG_LAYOUT_NICKNAME_LINE);
    dialogLayout.lines.push(DIALOG_LAYOUT_SUBMIT_LINE$1);

    //create on submit callback
    var onSubmitFunction = function(newValues) {

        //validate url- for now just make sure it is not zero length
        if((!newValues.url)||(newValues.url.length === 0)) {
            alert("The url must not be empty");
            return false;
        }

        //create command json
        var commandData = {};
        commandData.type = "addLink";
        commandData.entryType = displayInfo.REFERENCE_TYPE;
        commandData.url = newValues.url;
        commandData.nickname = newValues.nickname;

        //run command
        app.executeCommand(commandData);

        //return true to close the dialog
        return true;
    };

    //show dialog
    showConfigurableDialog(dialogLayout,onSubmitFunction);
}

/** This method updates a link in the workspace. */
function updateLink(app,referenceEntry,displayInfo) {
        
    var initialValues = {};
    initialValues.url = referenceEntry.getUrl();
    initialValues.nickname = referenceEntry.getNickname();
    if(initialValues.nickname == initialValues.url) initialValues.nickname = "";

    //create the dialog layout
    var titleLine = {};
    titleLine.type = "title";
    titleLine.title = displayInfo.UPDATE_ENTRY_TEXT;

    var urlLine = apogeeutil$1.jsonCopy(DIALOG_LAYOUT_URL_LINE);
    urlLine.initial = initialValues.url;
    var nicknameLine = apogeeutil$1.jsonCopy(DIALOG_LAYOUT_NICKNAME_LINE);
    nicknameLine.initial = initialValues.nickname;

    var dialogLayout = {};
    dialogLayout.lines = [];
    dialogLayout.lines.push(titleLine);
    dialogLayout.lines.push(urlLine);
    dialogLayout.lines.push(nicknameLine);
    dialogLayout.lines.push(DIALOG_LAYOUT_SUBMIT_LINE$1);

    //create on submit callback
    var onSubmitFunction = function(newValues) {

        //validate url- for now just make sure it is not zero length
        if((!newValues.url)||(newValues.url.length === 0)) {
            alert("The url must not be empty");
            return false;
        }

        //run command
        var commandData = {};
        var dataChanged = false;
        commandData.type = "updateLink";
        commandData.entryType = displayInfo.REFERENCE_TYPE;
        commandData.oldUrl = initialValues.url;
        if(initialValues.url != newValues.url) {
            commandData.newUrl = newValues.url;
            dataChanged = true;
        }
        if(initialValues.nickname != newValues.nickname) {
            commandData.newNickname = newValues.nickname;
            dataChanged = true;
        }

        if(dataChanged) {
            app.executeCommand(commandData);
        }
            
        //return true to close the dialog
        return true;
    };

    //show dialog
    showConfigurableDialog(dialogLayout,onSubmitFunction);
}


/** This method deletes a link in the workspace. */
function removeLink(app,referenceEntry,displayInfo) {

    var doDelete= confirm("Are you sure you want to delete this link?");

    //create on submit callback
    if(doDelete) {
        
        var commandData = {};
        commandData.type = "deleteLink";
        commandData.entryType = displayInfo.REFERENCE_TYPE;
        commandData.url = referenceEntry.getUrl();

        //run command
        app.executeCommand(commandData);
    }
}

class ReferenceEntryView {

    constructor(app, referenceEntry,displayInfo) {
        this.app = app;
        this.referenceEntry = referenceEntry;
        this.displayInfo = displayInfo;
        this.treeEntry = this._createTreeEntry();
    }


/** This method loads the link onto the page. It returns a promise that
     * resolves when the link is loaded. */
    getTreeEntry() {
        return this.treeEntry;
    }

    onLinkUpdated(referenceEntry) {
        //make sure this is the right entry 
        if(referenceEntry.getId() != this.referenceEntry.getId()) return;
        
        this.referenceEntry = referenceEntry;
        if(referenceEntry.getIsLabelUpdated()) {
            this.treeEntry.setLabel(this.referenceEntry.getLabel());
        }

        if(referenceEntry.isFieldUpdated("state")) {
            this.treeEntry.setBannerState(this.referenceEntry.getState());
        }
    }

    //===========================================
    // Private Methods
    //===========================================

    _createTreeEntry() {
        var iconUrl = uiutil.getResourcePath(this.displayInfo.ENTRY_ICON_PATH);
        var label = this.referenceEntry.getLabel();
        var menuItemsCallback = () => this._getMenuItems();

        var treeEntry = new TreeEntry(label, iconUrl, null, menuItemsCallback, false);
        treeEntry.setBannerState(this.referenceEntry.getState());
        return treeEntry;
    }

    _getMenuItems() {
        //menu items
        var menuItemList = [];

        //add the standard entries
        var itemInfo = {};
        itemInfo.title = this.displayInfo.UPDATE_ENTRY_TEXT;
        itemInfo.callback = () => updateLink(this.app,this.referenceEntry,this.displayInfo);
        menuItemList.push(itemInfo);

        //add the standard entries
        var itemInfo = {};
        itemInfo.title = this.displayInfo.REMOVE_ENTRY_TEXT;
        itemInfo.callback = () => removeLink(this.app,this.referenceEntry,this.displayInfo);
        menuItemList.push(itemInfo);

        return menuItemList;
    }



}

class ReferenceListView {

    constructor(app,referenceType,displayInfo,viewState) {
        this.app = app;
        this.referenceType = referenceType;
        this.displayInfo = displayInfo;

        this.childViews = {};

        this._setTreeEntry(viewState);
    }

    getDisplayInfo() {
        return this.displayInfo;
    }

    getTreeEntry() {
        return this.treeEntry;
    }

    onLinkCreated(referenceEntry) {
        let referenceEntryView = new ReferenceEntryView(this.app,referenceEntry,this.displayInfo);
        this.childViews[referenceEntry.getId()] = referenceEntryView;
        this.treeEntry.addChild(referenceEntryView.getTreeEntry());
    }

    onLinkUpdated(referenceEntry) {
        let referenceEntryView = this.childViews[referenceEntry.getId()];
        if(referenceEntryView) {
            referenceEntryView.onLinkUpdated(referenceEntry);
        }
    }

    onLinkDeleted(referenceEntry) {
        let referenceEntryView = this.childViews[referenceEntry.getId()];
        if(referenceEntryView) {
            this.treeEntry.removeChild(referenceEntryView.getTreeEntry());
        }
    }

    getViewState() {
        if(this.treeEntry) {
            return {treeState: this.treeEntry.getState()};
        }
    }

    //===============================================
    // Private Methods
    //===============================================

    _setTreeEntry(viewState) {
        var iconUrl = uiutil.getResourcePath(this.displayInfo.LIST_ICON_PATH);
        var menuItemCallback = () => this._getListMenuItems();
        this.treeEntry = new TreeEntry(this.displayInfo.LIST_NAME, iconUrl, null, menuItemCallback, false);

        if((viewState)&&(viewState.treeState !== undefined)) {
            this.treeEntry.setState(viewState.treeState);
        }
    }

    /** @private */
    _getListMenuItems() {
        //menu items
        var menuItemList = [];

        //add the standard entries
        var itemInfo = {};
        itemInfo.title = this.displayInfo.ADD_ENTRY_TEXT;
        itemInfo.callback = () => addLink(this.app,this.displayInfo);
        menuItemList.push(itemInfo);
        
        return menuItemList;
    }
}

class ReferenceView {

    constructor(app, referenceManager) {
        this.app = app;
        this.referenceManager = referenceManager;

        //get the view state
        let viewState = this.referenceManager.getCachedViewState();
        let listViewStates = ((viewState)&&(viewState.lists)) ? viewState.lists : {};

        //create the tree entry
        this.treeEntry = this._createTreeEntry(viewState);

        //initailize the child list views
        this.referenceListViews = {};
        let referenceClassArray = referenceManager.constructor.getReferenceClassArray();
        referenceClassArray.forEach( referenceClass => {
            let entryType = referenceClass.REFERENCE_TYPE;
            let referenceListView = this._createReferenceListView(entryType,listViewStates[entryType]); 
            this.referenceListViews[entryType] = referenceListView;
            let childTreeEntry = referenceListView.getTreeEntry();
            this.treeEntry.addChild(childTreeEntry);
        });

        app.addListener("referenceEntry_created",referenceEntry => this._onLinkCreated(referenceEntry));
        app.addListener("referenceEntry_updated",referenceEntry => this._onLinkUpdated(referenceEntry));
        app.addListener("referenceEntry_deleted",referenceEntry => this._onLinkDeleted(referenceEntry));
        app.addListener("referenceManager_updated",referenceManager => this._onReferenceManagerUpdated(referenceManager));

        this.referenceManager.setViewStateCallback(() => this.getViewState());
    }

    /** This returns the tree entry to display the reference entry for this reference manager. */
    getTreeEntry() {
        return this.treeEntry;
    }

    closeWorkspace() {
        //no action in ui for references
    }

    //-----------------------------------
    // Save methods
    //-----------------------------------
    
    getViewState() {
        let json = {};
        json.treeState = this.treeEntry.getState();
        json.lists = {};
        for(let entryType in this.referenceListViews) {
            let referenceList = this.referenceListViews[entryType];
            json.lists[entryType] = referenceList.getViewState();
        }
        return json;
    }

    //==================================
    // Private Methods
    //==================================

    _onLinkCreated(referenceEntry) {
        try {
            let referenceList = this.referenceListViews[referenceEntry.getEntryType()];
            if(referenceList) {
                referenceList.onLinkCreated(referenceEntry);
            }
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            alert("Error updating display for created reference entry: " + error.toString());
        }
    }

    _onLinkUpdated(referenceEntry) {
        try {
            let referenceList = this.referenceListViews[referenceEntry.getEntryType()];
            if(referenceList) {
                referenceList.onLinkUpdated(referenceEntry);
            }
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            alert("Error updating display for created reference entry: " + error.toString());
        }
    }

    _onLinkDeleted(referenceEntry) {
        try {
            let referenceList = this.referenceListViews[referenceEntry.getEntryType()];
            referenceList.onLinkDeleted(referenceEntry);
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            alert("Error updating display for reference entry: " + error.toString());
        }
    }

    _onReferenceManagerUpdated(referenceManager) {
        try {
            this.referenceManager = referenceManager;
            this.referenceManager.setViewStateCallback(() => this.getViewState());
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            alert("Error updating display for deleted reference entry: " + error.toString());
        }
    }

    /** @private */
    _createTreeEntry(viewState) {
        var iconUrl = uiutil.getResourcePath(REFERENCES_ICON_PATH);
        let treeEntry = new TreeEntry("References", iconUrl, null, null, false);

        if((viewState)&&(viewState.treeState !== undefined)) {
            treeEntry.setState(viewState.treeState);
        }

        return treeEntry;
    }

    _createReferenceListView(entryType,viewState) {
        let listDisplayInfo = LIST_DISPLAY_INFO[entryType];
        if(!listDisplayInfo) {
            listDisplayInfo = apogeeutil$1.jsonCopy(DEFAULT_LIST_DISPLAY_INFO);
            //set the proper entry type, and use that for the list name too
            listDisplayInfo.REFERENCE_TYPE = entryType;
            listDisplayInfo.LIST_NAME = entryType;
        }
        return new ReferenceListView(this.app,entryType,listDisplayInfo,viewState);
    }

}



let REFERENCES_ICON_PATH = "/componentIcons/references.png";

/** This is the UI definition data for the added reference lists.
 * This should be placed somewhere else to make it easier for people to 
 * add additional reference types.
 */
let LIST_DISPLAY_INFO = {

    "amd module": {
        "REFERENCE_TYPE": "amd module",
        "LIST_NAME": "Web Modules",
        "ADD_ENTRY_TEXT":"Add Web Module",
        "UPDATE_ENTRY_TEXT":"Update Web Module",
        "REMOVE_ENTRY_TEXT":"Remove Web Module",
        "LIST_ICON_PATH":"/componentIcons/folder.png",
        "ENTRY_ICON_PATH":"/componentIcons/webModule.png"
    },

    "css link": {
        "REFERENCE_TYPE": "css link",
        "LIST_NAME": "CSS Links",
        "ADD_ENTRY_TEXT":"Add CSS Link",
        "UPDATE_ENTRY_TEXT":"Update CSS Link",
        "REMOVE_ENTRY_TEXT":"Remove CSS Link",
        "LIST_ICON_PATH":"/componentIcons/folder.png",
        "ENTRY_ICON_PATH": "/componentIcons/cssLink.png"
    },

    "npm module": {
        "REFERENCE_TYPE": "npm module",
        "LIST_NAME": "NPM Modules",
        "ADD_ENTRY_TEXT":"Add NPM Module",
        "UPDATE_ENTRY_TEXT":"Update NPM Module",
        "REMOVE_ENTRY_TEXT":"Remove NPM Module",
        "LIST_ICON_PATH":"/componentIcons/folder.png",
        "ENTRY_ICON_PATH":"/componentIcons/module.png"
    },

    "es module": {
        "REFERENCE_TYPE": "es module",
        "LIST_NAME": "Web Modules",
        "ADD_ENTRY_TEXT":"Add ES Web Module",
        "UPDATE_ENTRY_TEXT":"Update Web Module",
        "REMOVE_ENTRY_TEXT":"Remove Web Module",
        "LIST_ICON_PATH":"/componentIcons/folder.png",
        "ENTRY_ICON_PATH":"/componentIcons/webModule.png"
    },

    "js link": {
        "REFERENCE_TYPE": "js link",
        "LIST_NAME": "JS Scripts",
        "ADD_ENTRY_TEXT":"Add JS Script Link",
        "UPDATE_ENTRY_TEXT":"Update JS Script Link",
        "REMOVE_ENTRY_TEXT":"Remove JS Script Link",
        "LIST_ICON_PATH":"/componentIcons/folder.png",
        "ENTRY_ICON_PATH":"/componentIcons/javascriptLink.png"
    }
};

//if this is used, replace the reference type and list name
let DEFAULT_LIST_DISPLAY_INFO = {
    "REFERENCE_TYPE": "PUT THE ENTRY TYPE HERE!",
    "LIST_NAME": "PUT THE ENTRY TYPE HERE!",
    "ADD_ENTRY_TEXT":"Add Link",
    "UPDATE_ENTRY_TEXT":"Update Link",
    "REMOVE_ENTRY_TEXT":"Remove Link",
    "LIST_ICON_PATH":"/componentIcons/folder.png",
    "ENTRY_ICON_PATH":"/componentIcons/javascriptLink.png"
};

/** This class manages the user interface for a workspace object. */
class ModelView {

    constructor(workspaceView,modelManager) {

        //yes these
        this.modelManager = modelManager;
        this.workspaceView = workspaceView;

        this.treeEntry = null;

        this.componentViewMap = {};

        this.init();

        //subscribe to events
        let app = this.modelManager.getApp();
        app.addListener("component_created",component => this.onComponentCreated(component));
        app.addListener("component_updated",component => this.onComponentUpdated(component));
        app.addListener("component_deleted",component => this.onComponentDeleted(component));
        app.addListener("modelManager_updated",modelManager => this.onModelManagerUpdated(modelManager));

        this.modelManager.setViewStateCallback(() => this.getViewState());
    }

    getTreeEntry() {
        return this.treeEntry;
    }

    getTabFrame() {
        return this.workspaceView.getTabFrame();
    }

    getComponentViewByComponentId(componentId) {
        return this.componentViewMap[componentId];
    }

    getApp() {
        return this.workspaceView.getApp();
    }

    getWorkspaceView() {
        return this.workspaceView;
    }

    getModelManager() {
        return this.modelManager;
    }

    getAppView() {
        return this.workspaceView.getAppView();
    }

    closeWorkspace() {
        for(let viewId in this.componentViewMap) {
            let componentView = this.componentViewMap[viewId];
            componentView.closeWorkspace();
        }
    }

    //================================
    // Event handlers
    //================================


    /** This is called on component created events. We only 
     * want to respond to the root folder event here.
     */
    onComponentCreated(component) {
        try {
            //create the component view
            let componentViewClass = getComponentViewClass(component.constructor.uniqueName);
            let componentView;
            if(componentViewClass) {
                componentView = new componentViewClass(this,component);
            }

            if(!componentView) {
                componentView = new ERROR_COMPONENT_VIEW_CLASS(this,component);
            }

            this.componentViewMap[component.getId()] = componentView;

            //find the parent
            let parentComponent = component.getParentComponent(this.modelManager);
            if(parentComponent) {
                let parentComponentView = this.getComponentViewByComponentId(parentComponent.getId());
                if(parentComponentView) {
                    parentComponentView.addChild(componentView);
                    componentView.setLastAssignedParentComponentView(parentComponentView);
                }
            }
            else { 
                //this is a root component
                this.addChildToRoot(componentView);
            }

            //do view state initialization
            componentView.loadViewStateFromComponent();
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            alert("Error updating display for created component: " + error.toString());
        }
    }

    onComponentUpdated(component) {
        try {
            let componentView = this.getComponentViewByComponentId(component.getId());
            componentView.componentUpdated(component);
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            alert("Error updating display for component: " + error.toString());
        }
    }

    onComponentDeleted(component) {
        try {
            let componentId = component.getId();

            let componentView = this.componentViewMap[componentId];
            if(componentView) {
                componentView.onDelete();
        
                //remove from the parent parent
                let parentComponentView = componentView.getLastAssignedParentComponentView();
                if(parentComponentView) {
                    parentComponentView.removeChild(componentView);
                }
                else {
                    //this is a root component
                    this.removeChildFromRoot(componentView);
                }
            }

            delete this.componentViewMap[componentId];
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            alert("Error updating display for delete component: " + error.toString());
        }
    }

    onModelManagerUpdated(modelManager) {
        try {
            this.modelManager = modelManager;
            let model = this.modelManager.getModel();
            if(model.isFieldUpdated("name")) {
                this.workspaceView.setName(model.getName());
            }
            
            this.modelManager.setViewStateCallback(() => this.getViewState());
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            alert("Error updating display for model update: " + error.toString());
        }
    }

    addChildToRoot(componentView) {
        this.treeEntry.addChild(componentView.getTreeEntry());
    }

    removeChildFromRoot(componentView) {
        this.treeEntry.removeChild(componentView.getTreeEntry());
    }

    //====================================
    // properties and display
    //====================================

    getViewState() {
        if(this.treeEntry) {
            return {treeState: this.treeEntry.getState()};
        }
    }

    init() {
        this.treeEntry = this.createTreeEntry();
        this.treeEntry.setState(TreeEntry.EXPANDED);

        let viewState = this.modelManager.getCachedViewState();
        if((viewState)&&(viewState.treeState !== undefined)) {
            this.treeEntry.setState(viewState.treeState);
        }
    }

    createTreeEntry() {

        //menu item callback
        var menuItemCallback = () => {
            //open menu item
            var menuItemList = [];
            var app = this.getApp();
            var appView = this.getAppView();
            let initialValues = {parentId: this.getModelManager().getModel().getId()};
            let pageComponents = componentInfo.getPageComponentNames();
            pageComponents.forEach(pageComponentName => {
                let childMenuItem = {};
                let pageComponentClass = componentInfo.getComponentClass(pageComponentName);
                childMenuItem.title = "Add Child " + pageComponentClass.displayName;
                childMenuItem.callback = () => addComponent(appView,app,pageComponentClass,initialValues);
                menuItemList.push(childMenuItem);
            });

            return menuItemList;
        };

        var iconUrl = uiutil.getResourcePath(ICON_RES_PATH);
        var isRoot = true;
        return new TreeEntry(MODEL_FOLDER_LABEL, iconUrl, null, menuItemCallback, isRoot);
    }

}

let MODEL_FOLDER_LABEL = "Code";

let ICON_RES_PATH = "/componentIcons/folder.png";

/** This class manages the user interface for a workspace object. */
class WorkspaceView {

    constructor(workspaceManager,appView) {

        //yes these
        this.workspaceManager = workspaceManager;
        this.app = workspaceManager.getApp();
        this.appView = appView;
        this.modelView = null;

        this.treeEntry = null;

        this.init();

        this.app.addListener("workspaceManager_updated",workspaceManager => this.onWorkspaceUpdated(workspaceManager));

        //Thisis used to retieve UI state to save when the app is being saved
        this.workspaceManager.setViewStateCallback(() => this.getViewState());
    }

    getTreeEntry() {
        return this.treeEntry;
    }

    getTabFrame() {
        return this.appView.getTabFrame();
    }

    getModelView() {
        return this.modelView;
    }

    getApp() {
        return this.app;
    }

    getWorkspaceManager() {
        return this.workspaceManager;
    }

    getAppView() {
        return this.appView;
    }

    /** This sets the name label on the workspace. The name comes from the model, however, we will display it on the workspace object. */
    setName(name) {
        this.treeEntry.setLabel(name);
    }

    /** This method takes any actions on workspace close. */
    close() {
        if(this.modelView) {
            this.modelView.closeWorkspace();
        }
        if(this.referenceView) {
            this.referenceView.closeWorkspace();
        }
    }

    onWorkspaceUpdated(workspaceManager) {
        try {
            this.workspaceManager = workspaceManager;
            this.workspaceManager.setViewStateCallback(() => this.getViewState());
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            alert("Error updating display for workspace update: " + error.toString());
        }
    }

    //====================================
    // properties and display
    //====================================

    /** Thie methor retrieves a serialized UI state, to be used during save. */
    getViewState() {
        if(this.treeEntry) {
            return {treeState: this.treeEntry.getState()};
        }
    }

    init() {
        this.treeEntry = this.createTreeEntry();

        //model manager
        this.modelView = new ModelView(this,this.workspaceManager.getModelManager());
        let modelTreeEntry = this.modelView.getTreeEntry();
        this.treeEntry.addChild(modelTreeEntry);

        //reference mamageger
        this.referenceView = new ReferenceView(this.app,this.workspaceManager.getReferenceManager());
        let refTreeEntry = this.referenceView.getTreeEntry();
        this.treeEntry.addChild(refTreeEntry);

        //set the view state
        let viewState = this.workspaceManager.getCachedViewState();
        if((viewState)&&(viewState.treeState !== undefined)) {
            this.treeEntry.setState(viewState.treeState);
        }
        else {
            this.treeEntry.setState(TreeEntry.EXPANDED);
        }
    }

    createTreeEntry() {
        //generally we expct the workspace not to exist yet. We will update this when it opens.
        let modelManager = this.workspaceManager.getModelManager();
        let model = modelManager.getModel();
        var labelText = model ? model.getName() : Workspace_OPENING_NAME; //add the name
        var iconUrl = uiutil.getResourcePath(WorkspaceView.ICON_RES_PATH);
        var menuItemCallback = () => this.getMenuItems();
        var isRoot = true;
        return new TreeEntry(labelText, iconUrl, null, menuItemCallback,isRoot);
    }

    getMenuItems() {
        //menu items
        var menuItemList = [];

        //add the standard entries
        var itemInfo = {};
        itemInfo.title = "Edit Properties";
        itemInfo.callback = () => updateWorkspaceProperties(this.getWorkspaceManager());
        menuItemList.push(itemInfo);

        //DEV ENTRY
        itemInfo = {};
        itemInfo.title = "Print Dependencies";
        itemInfo.callback = () => this.showDependencies();
        menuItemList.push(itemInfo);

        return menuItemList;
    }


}

let Workspace_OPENING_NAME = "opening...";

WorkspaceView.ICON_RES_PATH = "/componentIcons/workspace.png";

class ApogeeView {

    /** This creates the app view, which in turn creates the contained app.
     * - containerId - This is the DOM element ID in which the app view should be created. If this is set
     * to null (or other false value) the UI will not be created.
     * - appConfigManager - This is the app config managerm which defines some needed functionality. 
     */
    constructor(containerId,appConfigManager) {
        this.treePane = null;
        this.tabFrame = null;
        this.workspaceView = null;
        this.containerId = containerId;
        this.app = new Apogee(appConfigManager);
        
        if(containerId) {
            this.loadUI(containerId);
        }

        this.subscribeToAppEvents();
    }

    subscribeToAppEvents() {
        //subscribe to events
        this.app.addListener("workspaceManager_created",workspaceManager => this.onWorkspaceCreated(workspaceManager));
        this.app.addListener("workspaceManager_deleted",workspaceManager => this.onWorkspaceClosed(workspaceManager));
        this.app.addListener("component_updated",component => this.onComponentUpdated(component));
    }

    getTreePane() {
        return this.treePane;
    }

    getTabFrame() {
        return this.tabFrame;
    }

    getWorkspaceView() {
        return this.workspaceView;
    }

    getApp() {
        return this.app;
    }

    //================================
    // TargetEvent handlers
    //================================

    onWorkspaceCreated(workspaceManager) {
        if(this.workspaceView != null) {
            //discard an old view if there is one
            this.onWorkspaceClosed();
        }

        //create the new workspace view
        this.workspaceView = new WorkspaceView(workspaceManager,this);

        //load the tree entry, if needed
        if(this.containerId) {
            let treeEntry = this.workspaceView.getTreeEntry();
            this.tree.setRootEntry(treeEntry);
        }
    }

    onWorkspaceClosed(workspaceManager) {
        //close any old workspace view
        if(this.workspaceView) {
            this.workspaceView.close();
            this.workspaceView = null;
        }

        //clear the tree
        if(this.containerId) {
            this.tree.clearRootEntry();
        }

        //rather than rely on people to clear their own workspace handlers from the app
        //I clear them all here
        //I haven't decided the best way to do this. In the app? Here? I see problems
        //with all of them.
        //The most obvious is that in clearing them here it could clear listeners from within
        //the app layer. (There is one now but it is in the workspace anyway)
        //The only reason I'm doing it here no is that the app doesn't know who all is listening
        //to it so clearing all that is risky.
        this.app.clearListenersAndHandlers();
        this.subscribeToAppEvents();
    }

    //=================================
    // User Interface Creation Methods
    //=================================

    /** This method creates the app ui. 
     * @private */
    loadUI(containerId) {
        
        var windowElements = uiutil.initWindows(containerId);
        var topContainer = windowElements.baseElement;
        
        var mainContainer = new DisplayAndHeader(DisplayAndHeader.FIXED_PANE,
                null,
                DisplayAndHeader.FIXED_PANE,
                null
            );
        topContainer.appendChild(mainContainer.getOuterElement());
        
        //-------------------
        //create menus
        //-------------------
        var menuBar = this.createMenuBar();
        mainContainer.getHeader().appendChild(menuBar);
        
        //----------------------
        //create the split pane
        //----------------------
        this.splitPane = new SplitPane(
                SplitPane.SCROLLING_PANE,
                SplitPane.FIXED_PANE
            );
        mainContainer.getBody().appendChild(this.splitPane.getOuterElement());

        //---------------------
        //load the tree pane
        //---------------------
        this.treePane = this.splitPane.getLeftPaneContainer();

        //tree view
        this.tree = new TreeControl();
        uiutil.removeAllChildren(this.treePane);
        this.treePane.appendChild(this.tree.getElement());
        
        //----------------------
        //create the tab frame
        //----------------------
        this.tabFrame = new TabFrame();
        this.splitPane.getRightPaneContainer().appendChild(this.tabFrame.getElement());
        
        //add listener for displaying the active tab
        this.tabFrame.addListener(uiutil.SHOWN_EVENT,tab => this.onTabShown(tab));
        this.tabFrame.addListener(uiutil.HIDDEN_EVENT,tab => this.onTabHidden(tab));

        //-----------------------
        // Create the width resize listener (for now I am putting it in app - refering to both panes)
        //-----------------------

        this.splitPane.addListener("move",() => this.onSplitPaneResize());
        window.addEventListener("resize",() => this.onWindowResize());

    }

    //------------------------------
    // Active Tab display name handling logic
    // This is not good. I need to clean a few things up.
    // - the id is the component id. If we geet tabs for other things we will need a more general id
    // - by the same token, we should have a way of getting the display name from the tab itself, as part of the tab interface.
    //------------------------------
    onTabHidden(tab) {
        this.activeTabIconDisplay.style.display = "none";
        this.activeTabTitleDisplay.style.display = "none";
    }

    onTabShown(tab) {
        if(!this.workspaceView) return;

        let modelView = this.workspaceView.getModelView();
        let modelManager = modelView.getModelManager();
        
        var componentId = tab.getId();
        let tabComponentView = modelView.getComponentViewByComponentId(componentId);
        if(tabComponentView) {
            this.activeTabIconDisplay.src = tabComponentView.getIconUrl();
            this.activeTabTitleDisplay.innerHTML = tabComponentView.getDisplayName(true,modelManager);
            this.activeTabIconDisplay.style.display = "";
            this.activeTabTitleDisplay.style.display = "";
        }
    }

    /** This is called whenever a component in the model, or the model, changes. If the display name
     * of that component changes, we update the tab display name. This is also not very general. I should
     * clean it up to allow other things besides components to have tabs. I should probably make a tab event that
     * its title changes, or just that it was udpated. */
    onComponentUpdated(component) {
        //tab id for components is the component id
        if((component.getId() == this.tabFrame.getActiveTab())) {
            //this is pretty messy too... 
            let model = this.workspaceView.getModelView().getModelManager().getModel();
            if((component.isDisplayNameUpdated())||(component.getMember().isFullNameUpdated(model))) {
                let tab = this.tabFrame.getTab(component.getId());
                this.onTabShown(tab);
            }
        }
    }

    //---------------------------------
    // Width resize events - for tab frame and tree frame
    //---------------------------------

    onSplitPaneResize() {
        this.triggerResizeWait();
    }

    onWindowResize() {
        this.triggerResizeWait();
    }

    triggerResizeWait() {
        //only do the slow resizde timer if we have listeners
        if(!this.app.hasListeners("frameWidthResize")) return;

        //create a new timer if we don't already have one
        if(!this.resizeWaitTimer) {
            this.resizeWaitTimer =  setTimeout(() => this.resizeTimerExpired(),RESIZE_TIMER_PERIOD_MS$1);
        }
    }

    resizeTimerExpired() {
        this.resizeWaitTimer = null;
        this.app.dispatchEvent("frameWidthResize",null);
    }

    //=================================
    // Menu Functions
    //=================================

    /** This method creates the creates the menu bar, with the attached functionality. 
     * @private */
    createMenuBar() {
        var name;
        var menus = {};
        
        //creat menu  bar with left elements (menus) and right elements (active tab display)
        var menuBar = uiutil.createElementWithClass("div","menu_bar");
        var menuBarLeft = uiutil.createElementWithClass("div","menu_bar_left",menuBar);
        var menuBarRight = uiutil.createElementWithClass("div","menu_bar_right",menuBar);

        //Workspace menu
        name = "Workspace";
        this.workspaceMenu = Menu.createMenu(name);
        menuBarLeft.appendChild(this.workspaceMenu.getElement());
        menus[name] = this.workspaceMenu;
        
        //populate the workspace menu on the fly - depends on workspace state
        var getWorkspaceMenuCallback = () => this.getWorkspaceMenuItems();
        this.workspaceMenu.setAsOnTheFlyMenu(getWorkspaceMenuCallback);
        
        //Edit menu
        name = "Edit";
        this.editMenu = Menu.createMenu(name);
        menuBarLeft.appendChild(this.editMenu.getElement());
        menus[name] = this.editMenu;
        
        //populate the workspace menu on the fly - depends on workspace state
        var getEditMenuCallback = () => this.getEditMenuItems();
        this.editMenu.setAsOnTheFlyMenu(getEditMenuCallback);
        
        //FOR NOW REMOVE GLOBAL COMPONENT AND IMPORT MENUS
        // //Components Menu
        // name = "Components";
        // menu = Menu.createMenu(name);
        // menuBarLeft.appendChild(menu.getElement());
        // menus[name] = menu;
        
        // //add create child elements
        // menu.setMenuItems(this.getAddChildMenuItems());
        
        // //libraries menu
        // name = "Import/Export";
        // menu = Menu.createMenu(name);
        // menuBarLeft.appendChild(menu.getElement());
        // menus[name] = menu;
        
        // var importCallback = () => importWorkspace(this,this.app,this.fileAccessObject,FolderComponent,FolderComponentView);
        // menu.addCallbackMenuItem("Import as Folder",importCallback);
        
        // var import2Callback = () => importWorkspace(this,this.app,this.fileAccessObject,FolderFunctionComponent,FolderFunctionComponentView);
        // menu.addCallbackMenuItem("Import as Folder Function",import2Callback);
        
        // var exportCallback = () => exportWorkspace(this,this.fileAccessObject);
        // menu.addCallbackMenuItem("Export as Workspace",exportCallback);
        
        //allow the implementation to add more menus or menu items
        if(this.addToMenuBar) {
            this.addToMenuBar(menuBar,menus);
        }
        
        //add the active tab display
        this.activeTabIconDisplay = uiutil.createElementWithClass("img","tab-icon-display",menuBarRight);
        this.activeTabIconDisplay.style.display = "none";
        this.activeTabTitleDisplay = uiutil.createElementWithClass("div","tab-title-display",menuBarRight);
        this.activeTabTitleDisplay.style.display = "none";
        return menuBar;
        
    }

    /** This method gets the workspace menu items. This is created on the fly because the
     * items will change depending on the state of the workspace. */
    getWorkspaceMenuItems() {
        
        let menuItems = [];
        let menuItem;

        let fileAccessObject = this.app.getFileAccessObject();
        
        menuItem = {};
        menuItem.title = "New";
        menuItem.callback = () => createWorkspace(this.app);
        menuItems.push(menuItem);
        
        menuItem = {};
        menuItem.title = "Open";
        menuItem.callback = () => openWorkspace(this.app,fileAccessObject);
        menuItems.push(menuItem);

        let workspaceManager = this.app.getWorkspaceManager();
        if(workspaceManager) {
            var fileMetadata = workspaceManager.getFileMetadata();

            if(fileAccessObject.directSaveOk(fileMetadata)) {
                menuItem = {};
                menuItem.title = "Save";
                menuItem.callback = () => saveWorkspace(this.app,fileAccessObject,true);
                menuItems.push(menuItem);
            }

            menuItem = {};
            menuItem.title = "Save as";
            menuItem.callback = () => saveWorkspace(this.app,fileAccessObject,false);
            menuItems.push(menuItem);
        }  

        menuItem = {};
        menuItem.title = "Close";
        menuItem.callback = () => closeWorkspace(this.app);
        menuItems.push(menuItem);
        
        return menuItems;
    }

    /** This method gets the workspace menu items. This is created on the fly because the
     * items will change depending on the state of the workspace. */
    getEditMenuItems() {
        
        var menuItems = [];
        var menuItem;

        let commandManager = this.app.getCommandManager();
        let commandHistory = commandManager.getCommandHistory();
        
        //populate the undo menu item
        var undoLabel;
        var undoCallback;
        var nextUndoDesc = commandHistory.getNextUndoDesc();
        if(nextUndoDesc === null) {
            undoLabel = "-no undo-";
            undoCallback = null;
        }
        else {
            if(nextUndoDesc == "") {
                undoLabel = "Undo";
            }
            else {
                undoLabel = "Undo: " + nextUndoDesc;
            }
            undoCallback = () => commandHistory.undo();
        }
        menuItem = {};
        menuItem.title = undoLabel;
        menuItem.callback = undoCallback;
        menuItems.push(menuItem);
        
        //populate the redo menu item
        var redoLabel;
        var redoCallback;
        var nextRedoDesc = commandHistory.getNextRedoDesc();
        if(nextRedoDesc === null) {
            redoLabel = "-no redo-";
            redoCallback = null;
        }
        else {
            if(nextRedoDesc == "") {
                redoLabel = "Redo";
            }
            else {
                redoLabel = "Redo: " + nextRedoDesc;
            }
            redoCallback = () => commandHistory.redo();
        }
        menuItem = {};
        menuItem.title = redoLabel;
        menuItem.callback = redoCallback;
        menuItems.push(menuItem);
        
        return menuItems;
    }

    ///** This method should be implemented if custom menus or menu items are desired. */
    //addToMenuBar(menuBar,menus);

    getAddChildMenuItems(optionalInitialProperties,optionalBaseMemberValues,optionalBaseComponentValues) {

        let standardComponents = componentConfig.getStandardComponentNames();
        
        var menuItemList = [];
        
        for(var i = 0; i < standardComponents.length; i++) {
            let componentName = standardComponents[i];
            let componentClass = componentInfo.getComponentClass(componentName);
            
            let menuItem = {};
            menuItem.title = "Add " + componentClass.displayName;
            menuItem.callback = () => addComponent(this,this.app,componentClass,optionalInitialProperties,optionalBaseMemberValues,optionalBaseComponentValues);
            menuItemList.push(menuItem);
        }

        //add the additional component item
        let menuItem = {};
        menuItem.title = "Other Components...";
        menuItem.callback = () => addAdditionalComponent(this,this.app,optionalInitialProperties,optionalBaseMemberValues,optionalBaseMemberValues);
        menuItemList.push(menuItem);

        return menuItemList;
    }

    
    //========================================
    // Static Functions
    //========================================

    /** This method is used to register a new component view class for the user interface. */
    static registerComponentView(viewClass) {
        componentClassMap[viewClass.componentName] = viewClass;
    }

    /** This method retrieves a component view class using the component unique name. */
    static getComponentViewClass(componentName) {
        return componentClassMap[componentName];
    }

}


let componentClassMap = {};

const RESIZE_TIMER_PERIOD_MS$1 = 500;

/** This namespace provides methods to create a standard save bar and other toolbars. */

function getSaveBar(onSave,onCancel) {
    var saveDiv = uiutil.createElement("div",null,
        {
            //"display":"block",
            //"position":"relative",
            //"top":"0px",
            "backgroundColor":"white",
            "border":"solid 1px gray",
            "padding":"3px"
        });

    saveDiv.appendChild(document.createTextNode("Edit: "));

    var saveBarSaveButton = document.createElement("button");
    saveBarSaveButton.innerHTML = "Save";
    saveBarSaveButton.onclick = onSave;
    saveDiv.appendChild(saveBarSaveButton);

    saveDiv.appendChild(document.createTextNode(" "));

    var saveBarCancelButton = document.createElement("button");
    saveBarCancelButton.innerHTML = "Cancel";
    saveBarCancelButton.onclick = onCancel;
    saveDiv.appendChild(saveBarCancelButton);
    
    return saveDiv;
}

/** This is a standin for the display conatiner for the literate page
 * 
 * @class 
 */
class WebDisplayContainer {

    constructor(componentView, viewType) {
        
        this.mainElement = null;
        this.headerContainer = null;
        this.viewContainer = null;
        
        this.isShowing = false;
        this.isContentLoaded = false;
        
        this.inEditMode = false;
        
        this.content = null;
        
        this.componentView = componentView;
        this.viewType = viewType;
        this.dataDisplay = null;
        
        //initialize
        this.initUI();
    }

    getComponentView() {
        return this.componentView;
    }

    //-------------------
    // state management
    //-------------------

    /** This method should be called whent the frame parent is loaded or unloaded from the DOM. */
    setIsShowing(isShowing) {
        this.isShowing = isShowing;
        this.updateDataDisplayLoadedState();
    }

    /** This returns the isShowing status of the display. */
    getIsShowing() {
        return this.isShowing;
    }

    /** This method closes the window. If the argument forceClose is not
     * set to true the "request_close" handler is called to check if
     * it is ok to close the window. */
    close(forceClose) {

        if(!forceClose) {
            //make a close request
            var requestResponse = this.callHandler(uiutil.REQUEST_CLOSE,this);
            if(requestResponse == uiutil.DENY_CLOSE) {
                //do not close the window
                return;
            }
        }

        this.dispatchEvent(uiutil.CLOSE_EVENT,this);
    }

    // /** I don't expect this will be used. People currently won't be saving from the web app.
    //  * But if it is, it will pass along the data display state.  */
    // getStateJson() {
    //     //we only read the data display data
    //     if(this.dataDisplay) {
    //         this.dataDisplay.addUiStateData(this.savedUiState);
    //     }
    //     return this.savedUiState;
    // }

    // /** This container only reads the data display state. And saved state for the display container is ignored. */
    // setStateJson(json) {
    //     if(json) {
    //         this.savedUiState = json;
    //     }
    //     else {
    //         this.savedUiState = {};
    //     }

    //     //we only read the data display state
    //     //there is no state used in the container itself.
    //     if(this.dataDisplay) {
    //         this.dataDisplay.readUiStateData(this.savedUiState);
    //     }
    // }

    //---------------------------
    // GUI ELEMENT
    //---------------------------

    /** This method returns the main dom element for the window frame. */
    getDisplayElement() {
        return this.mainElement;
    }

    //====================================
    // Initialization Methods
    //====================================

    /** @private */
    initUI() {
        
        //make the container
        this.mainElement = uiutil.createElementWithClass("div","visiui_displayContainer_mainClass",null);
        
        //add the header elment (for the save bar)
        this.headerContainer = uiutil.createElementWithClass("div","visiui_displayContainer_headerContainerClass",this.mainElement);
        
        //add the view container
        this.viewContainer = uiutil.createElementWithClass("div","visiui_displayContainer_viewContainerClass",this.mainElement);

    }

    /** This method shold be called when the content loaded or frame visible state 
     * changes to manage the data display.
     * private */
    updateDataDisplayLoadedState() {
        
        if(this.isShowing) {
            if(!this.dataDisplayLoaded) {
                if(!this.dataDisplay) {
                    //the display should be created only when it is made visible
                    this.dataDisplay =  this.componentView.getDataDisplay(this,this.viewType);
                    this.setContent(this.dataDisplay.getContent());
                    this.dataDisplay.showData();
                }
            
                if(this.dataDisplay.onLoad) this.dataDisplay.onLoad();
                this.dataDisplayLoaded = true;
            }
        }
        else {
            if(this.dataDisplay) {
                if(this.dataDisplayLoaded) {
                    this.dataDisplayLoaded = false;
                    if(this.dataDisplay.onUnload) this.dataDisplay.onUnload();
                }
            }  
        }
        
            
        //fyi - this is remove code, when we need to add it
        //[]
    }

    //------------------------------
    // standard methods
    //------------------------------

    /** The displayDestroyFlags indicate when the display for this view mode will be destroyed,
     * refering to times it is not visible to the user. See further notes in the constructor
     * description. */
    setDisplayDestroyFlags(displayDestroyFlags) {
        
        //in web view, view is alwasy active
    }   

    /** This method cleasr the data display. It should only be called when the data display is not showing. 
     * maybe allow this when the display is showing - unload and reload it*/
    reloadDisplay() {
        //this destrpys the data display, not the container - bad name
        this.destroy();

        //reload display
        this.updateDataDisplayLoadedState();
    }

    /** This method destroys the data display. */
    destroy() {
        if(this.dataDisplay) {
            if(this.dataDisplay.destroy) {
                this.dataDisplay.destroy();
            }
            this.dataDisplay = null;
            this.dataDisplayLoaded = false;
        }
    }

    /** This method should be called called before the view mode is closed. It should
     * return true or false. NO - IT RETURNS SOMETHING ELSE! FIX THIS! */
    isCloseOk() {
        if(this.dataDisplay) {
            if(this.dataDisplay.isCloseOk) {
                return this.dataDisplay.isCloseOk();
            }
            
            if(this.inEditMode) {
                return DisplayContainer.UNSAVED_DATA;
            }
        }
        
        return DisplayContainer.CLOSE_OK;
    }
        
    /** This method is called when the member is updated, to make sure the 
    * data display is up to date. */
   componentUpdated(component) {
        //update the data display
        if((this.dataDisplay)&&(!this.inEditMode)) {
            let {reloadData,reloadDataDisplay} = this.dataDisplay.doUpdate();
            if(reloadDataDisplay) {
                this.reloadDisplay();
            }
            else if(reloadData) {
                this.dataDisplay.showData();
            }
        }
    }
        
    //------------------------------
    // Accessed by the Editor, if applicable
    //------------------------------

    onCancel() {
        //reload old data
        this.dataDisplay.showData();
        
        return true;
    }

    startEditMode(onSave,onCancel) {
        if(!this.inEditMode) {
            this.inEditMode = true;
            var saveBar = getSaveBar(onSave,onCancel);
            this.setHeaderContent(saveBar);
        }
    }

    endEditMode() {
        //exit edit mode
        if(this.inEditMode) {
            this.inEditMode = false;
            this.setHeaderContent(null);
        }
    }

    isInEditMode() {
        return this.inEditMode;
    }


    //====================================
    // Internal Methods
    //====================================

    /** This sets the content for the window. If null (or otherwise false) is passed
     * the content will be set to empty.*/
    setHeaderContent(contentElement) {
        uiutil.removeAllChildren(this.headerContainer);
        if(contentElement) {
            this.headerContainer.appendChild(contentElement);
        }
    }

    /** This sets the content for the window.  */
    setContent(contentElement) {
        
        uiutil.removeAllChildren(this.viewContainer);
        
        //set the content
        this.viewContainer.appendChild(contentElement);
        this.content = contentElement;
    }

    /** This method removes the given element from the content display. If the element
     * is not in the content display, no action is taken. */
    safeRemoveContent() {
        for(var i = 0; i < this.viewContainer.childNodes.length; i++) {
            var node = this.viewContainer.childNodes[i];
            if(node === this.content) {
                this.viewContainer.removeChild(this.content);
                this.content = null;
            }
        }
    }

}

/** This is the component display for a web page.
 * NOTES:
 * - I currently allow only one view to be displayed. The can be changed to allow multiple display containers and views.
 */
class WebComponentDisplay {

    constructor(componentView, activeView) {
        this.componentView = componentView;

        this.activeView = activeView;
        this.displayContainer = null;
        this.savedActiveViewUiState = null;
        
        //these are the header elements
        this.mainElement = null;
        this.bannerContainer = null;
    
        //this is the window in which the component is displayed
        this.loadComponentDisplay();

        //add a cleanup action to the base component - component must already be initialized
    //    this.addCleanupAction(PageChildComponentDisplay.destroy);
    };

    setIsShowing(isShowing) {
        this.displayContainer.setIsShowing(isShowing);
    }

    getIsShowing() {
        this.displayContainer.getIsShowing();
    }

    getElement() {
        return this.mainElement;
    }

    getComponentView() {
        return this.componentView;
    }

    componentUpdated(component) {
        //update the banner
        // var bannerDiv;
        // if(bannerState == bannerConstants.BANNER_TYPE_NONE) {
        //     bannerDiv = null;
        // }
        // else {
        //     bannerDiv = getBanner(bannerMessage,bannerState);
        // }
        // uiutil.removeAllChildren(this.bannerContainer);
        // if(bannerDiv) {
        //     this.bannerContainer.appendChild(bannerDiv);
        // }

        this.displayContainer.componentUpdated(component);
    }

    /** This gets the current window state, to reconstruct the view. */
    getStateJson() {
        return undefined;
    }

    /** This gets the current window state, to reconstruct the view. */
    setStateJson(json) {
        
    }

    ////////////////////////////////////////////////////////////

    // /** This saves the state only for the single active view. */
    // getStateJson() {
    //     //if the display container is active, update the saved state
    //     if(this.displayContainer) {
    //         this.savedActiveViewUiState = displayContainer.getStateJson();
    //     }

    //     if(this.savedActiveViewUiState) {
    //         let json = {};
    //         json.views = {};
    //         json.views[this.activeView] = this.savedActiveViewUiState
    //         return json;
    //     }
    //     else {
    //         return null;
    //     }
    // }

    // /** This reads the state only for the single active view. */
    // setStateJson(json) {
    //     if((json)&&(json.views)) {
    //         this.savedActiveViewUiState = json.views[this.activeView];
    //         if((this.savedActiveViewUiState)&&(this.displayContainer)) {
    //             this.displayContainer.setStateJson(this.savedActiveViewUiState);
    //         }
    //     }
    // }

   ////////////////////////////////////////////////////

    /** This will reload the given data display. */
    reloadDisplay(viewType) {
        if(viewType == this.activeView) {
            if(this.displayContainer) {
                displayContainer.reloadDisplay();
            }
        }
    }

    /** This should be called by the component when it discards this display. */
    deleteDisplay() {
        //dispose any view elements
        if(this.displayContainer) {
            //refresh the saved UI state
            this.savedActiveViewUiState = displayContainer.getStateJson();

            this.displayContainer.destroy();
            this.displayContainer = null;
        }
    }


    //===============================
    // Private Functions
    //===============================


    /** This is the standard window for the component.  
     * @private */
    loadComponentDisplay() {

        //make the container
        this.mainElement = uiutil.createElementWithClass("div","visiui_pageChild_mainClass",null);
        
        //add banner container
        this.bannerContainer = uiutil.createElementWithClass("div","visiui_pageChild_bannerContainerClass",this.mainElement);
        
        //add the view container
        this.viewContainer = uiutil.createElementWithClass("div","visiui_pageChild_viewContainerClass",this.mainElement);
        
        //create the view element
        this.displayContainer = new WebDisplayContainer(this.componentView, this.activeView);

        //set the saved state, if there is one
        if(this.savedActiveViewUiState) {
            this.displayContainer.setStateJson(this.savedActiveViewUiState);
        }
        
        //add the view display
        this.viewContainer.appendChild(this.displayContainer.getDisplayElement());
    }

}

/** 
 * This is the format of the AppConfigManager. This class does not need
 * to be extended. It has not internal functionality.
 */
class WebAppConfigManager {
    
    constructor() {
    }
    
    /** This method should return a Promise object the loades the
     * app configuration.
     */
    getConfigPromise(app) {
        return Promise.resolve();
    };
    
    /** This method should return a default FileAccessObject. It will be loaded
     * if an alternate is not loaded in configuration.
     */
    getDefaultFileAccessObject(app) {
        return null;
    }
    
    /** This method should return a promise for the initial workspace
     * that should be loaded
     */
    getInitialWorkspaceFilePromise(app) {
        return null;
    }
    
    /** This method should return the file metadata for the intial workspace.
     * This will be used in saving the initail workspace. (For example, if the
     * initial workspace is a locally loaded file in the electron version, this
     * file metadata will allow the user to select "save" to update the file 
     * without having to select a file to save to.
     */
    getInitialWorkspaceFileMetadata(app) {
        return null;
    }
}

/** This replaces ApogeeView when running a client web application. */

class ApogeeWebView {

    /** This creates the app view, which in turn creates the contained app.
     * - containerId - This is the DOM element ID in which the app view should be created. If this is set
     * to null (or other false value) the UI will not be created.
     * - appConfigManager - This is the app config managerm which defines some needed functionality. 
     */
    constructor() {
        this.app = new Apogee(new WebAppConfigManager());

        this.componentByNameMap = {};
        this.componentByIdMap = {};

        this.app.addListener("component_created",component => this._onComponentCreated(component));
        this.app.addListener("component_updated",component => this._onComponentUpdated(component));
        this.app.addListener("component_deleted",component => this._onComponentDeleted(component));

        //resize monitoring
        window.addEventListener("resize",() => this.onWindowResize());
    }

    getApp() {
        return this.app;
    }

    /** This method should be called to open the workspace once the display info has been initialized. */
    openWorkspace(url) {
        var openWorkspace = workspaceText => {
            let workspaceJson = JSON.parse(workspaceText);

            //open workspace
            var commandData = {};
            commandData.type = "openWorkspace";
            commandData.workspaceJson = workspaceJson;

            this.app.executeCommand(commandData);
        };

        apogeeutil.textRequest(url).then(openWorkspace);
    }

    //=======================================
    // View Management
    //=======================================

    
    /** This method attaches the apgee output display to the dom element. See the 
     * documentation for CSS requirements for the host element.
     * 
     * @param {type} memberName - The full name of the member to add to the web page (including the top level folder name)
     * @param {type} parentElementId - This is the DOM element ID into which the display should be added.
     * @param {type} isShowing - If the element is currently showing, this flag should be set to true. Otherwise, it 
     * should be set to false and the isShowing event used when the element becomes visible
     * @param {type} optionalViewType - For this component, the name of the data view can optionally be specified. Otherwise the default is used.
     * @returns {undefined} There is no return value
     */ 
    addDisplay(memberName,parentElementId,parentIsShowing,viewName) {

        let componentInfo = this.componentByNameMap[memberName];
        if(!componentInfo) {
            componentInfo = {};
            componentInfo.memberName = memberName;
            componentInfo.displayViews = [];
            componentInfo.listeners = [];
            //this will be filled in later
            componentInfo.componentView = null;
            componentInfo.id = null;

            this.componentByNameMap[memberName] = componentInfo;
        }
        
        let displayViewInfo = {};
        displayViewInfo.parentElementId = parentElementId;
        displayViewInfo.parentIsShowing = parentIsShowing;
        displayViewInfo.viewName = viewName;

        //this will be filled in later.
        //displayViewInfo.displayContainer = null;
        //displayViewInfo.dataDisplay = null;
        //WE NEED TO FIX THIS - CURRENTLY ONLY ONE DISPLAY SUPPORTED!!
        displayViewInfo.componentDisplay = null;

        componentInfo.displayViews.push(displayViewInfo);
    }

    /** This method allows the user to add a listener for a component. Note that a listener can only be added
     * either before the workspace is loaded or, if after the workspace is loaded, for a component that had
     * a display or listener set before the workspace was loaded. 
     * The callback will be a called when the component is created or updated. It will pass a component
     * abject as the single argument. */
    addComponentListener(memberName,callback) {
        let componentInfo = this.componentByNameMap[memberName];
        if(!componentInfo) {
            componentInfo = {};
            componentInfo.memberName = memberName;
            componentInfo.displayViews = [];
            componentInfo.listeners = [];
            //this will be filled in later
            componentInfo.componentView = null;
            componentInfo.id = null;

            this.componentByNameMap[memberName] = componentInfo;
        }

        componentInfo.listeners.push(callback);
    }

    /** This method removes a listener that had been added for a component. */
    removeComponentListener(memberName,callback) {
        let componentInfo = this.componentByNameMap[memberName];
        if(componentInfo) {
            componentInfo.listeners = componentInfo.listeners.filter(activeCallback => activeCallback != callback);
        }
    }

    /** If the DOM element is loaded or unloaded, this method should be called to update
     * the state. This state is available to all component displays and is used by some of them.
     */
    setIsShowing(memberName,viewName,parentIsShowing) {
        let displayViewInfo = this._lookupDisplayView(memberName,viewName);
        if(displayViewInfo) {
            displayViewInfo.parentIsShowing = parentIsShowing;
            if(displayViewInfo.componentDisplay) {
                displayViewInfo.componentDisplay.setIsShowing(parentIsShowing);
            }
        }
    }

    //This method is obsolete. However, we should have some way to tell a specific display that its width
    //has changed, if they care. Currently I think only the HandsonGridEditor cares(?). And now the only
    //way to notify it is to say all widths (the frame width) has changed.
    // /** If the DOM element is resized this method should be called. This information is available
    //  * to all component display and is used by some of them.
    //  */
    // onResize(memberName,viewName) {
    //     let displayViewInfo = this._lookupDisplayViewInfo(memberName,viewName);
    //     if((displayViewInfo)&&(displayViewInfo.componentDisplay)) {
    //         displayViewInfo.componentDisplay.onResize();
    //     }
    // }

    //---------------------------------
    // Width resize events - for tab frame and tree frame
    //---------------------------------

    onWindowResize() {
        this.triggerResizeWait();
    }

    triggerResizeWait() {
        //only do the slow resizde timer if we have listeners
        if(!this.app.hasListeners("frameWidthResize")) return;

        //create a new timer if we don't already have one
        if(!this.resizeWaitTimer) {
            this.resizeWaitTimer =  setTimeout(() => this.resizeTimerExpired(),RESIZE_TIMER_PERIOD_MS);
        }
    }

    resizeTimerExpired() {
        this.resizeWaitTimer = null;
        this.app.dispatchEvent("frameWidthResize",null);
    }


    //========================================
    // Private Functions
    //========================================
    
    //--------------------------------
    // Event handlers
    //--------------------------------


    /** This is called on component created events. We only 
     * want to respond to the root folder event here.
     */
    _onComponentCreated(component) {
        try {
            //lookup the component info
            let modelManager = this.app.getWorkspaceManager().getModelManager();
            let memberName = component.getFullName(modelManager);
            let componentInfo = this.componentByNameMap[memberName];
            if(!componentInfo) return;

            //register the id
            let id = component.getId();
            componentInfo.id = id;
            //add this to the map indexed by id
            this.componentByIdMap[id] = componentInfo;

            //create the component view
            let componentViewClass = getComponentViewClass(component.constructor.uniqueName);
            let componentView;
            if(componentViewClass) {
                componentView = new componentViewClass(this,component);
            }

            if(!componentView) {
                componentView = new ERROR_COMPONENT_VIEW_CLASS(this,component);
            }

            componentInfo.componentView = componentView;

            //initialize the display views
            componentInfo.displayViews.forEach( displayViewInfo => {
                this._createComponentDisplay(componentInfo,displayViewInfo);
            });

            //--------------------------------------------
            //leave out? TBD
            //do view state initialization
            //componentView.loadViewStateFromComponent();

            //callback any listeners from the user
            if(componentInfo.listeners.length > 0) {
                try {
                    componentInfo.listeners.forEach(callback => callback(component));
                }
                catch(error) {
                    console.error("Error calling users listener " + error.toString());
                    if(error.stack) console.error(error.stack);
                }
            }
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            alert("Error updating display for created component: " + error.toString());
        }
    }

    _onComponentUpdated(component) {
        try {
            let componentInfo = this.componentByIdMap[component.getId()];
            if(componentInfo) { 

                //update the component views, if applicable
                if(componentInfo.componentView) componentInfo.componentView.componentUpdated(component);

                //callback any listeners from the user
                if(componentInfo.listeners.length > 0) {
                    try {
                        componentInfo.listeners.forEach(callback => callback(component));
                    }
                    catch(error) {
                        console.error("Error calling users listener " + error.toString());
                        if(error.stack) console.error(error.stack);
                    }
                }
            }
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            alert("Error updating display for component: " + error.toString());
        }
    }

    _onComponentDeleted(component) {
        try {
            let componentInfo = this.componentByIdMap[component.getId()];
            if(componentInfo) {
                if(componentInfo.componentView) componentInfo.componentView.onDelete();

                delete this.componentByIdMap[componentInfo.id];
                delete this.componentByNameMap[componentInfo.memberName];
            }
        }
        catch(error) {
            if(error.stack) console.error(error.stack);

            alert("Error updating display for delete component: " + error.toString());
        }
    }

    //--------------------------------
    // Other functions
    //--------------------------------

    /** This method returns a WebComponentDisplay object which contains the component display object. 
    * If the optionalViewType is not set, the default view (which is typically the desired one) will be used.*/
    _createComponentDisplay(componentInfo,displayViewInfo) {
        let componentDisplay = new WebComponentDisplay(componentInfo.componentView, displayViewInfo.viewName);
        componentInfo.componentView.setComponentDisplay(componentDisplay);

        //look up the parent element 
        let parentElement = document.getElementById(displayViewInfo.parentElementId);
        if(!parentElement) {
            console.error("DOM Element not found:" + displayViewInfo.parentElementId);
            return;
        }
        displayViewInfo.parentElement = parentElement;

        //add to the page
        var displayElement = componentDisplay.getElement();
        parentElement.appendChild(displayElement);

        if(displayViewInfo.parentIsShowing) {
            componentDisplay.setIsShowing(true);
        }
    }

    _lookupDisplayView(memberName,viewName) {
        var componentInfo = this.componentByNameMap[memberName];
        if(!componentInfo) {
            console.error("Workspace member not found not found:" + memberName);
            return null;
        }

        let displayViewInfo = componentInfo.displayViews.find( displayViewInfo => (displayViewInfo.viewName == viewName));
        
        if(displayViewInfo) {
            return displayViewInfo;
        }
        else {
            console.error("Display view not registered: " + memberName + " - " + viewName);
        }
    }

}

function deleteComponent(componentView) {

    var doDelete = confirm("Are you sure you want to delete this object?");
    if(!doDelete) {
        return;
    }

    var modelManager = componentView.getModelView().getModelManager(); 
    var component = componentView.getComponent();

    var member = component.getMember();
    var commands = [];

    if(componentView.constructor.hasChildEntry) {
        let parentComponentView = componentView.getParentComponentView();

        let editorCommand = parentComponentView.getRemoveApogeeNodeFromPageCommand(component.getName());
        commands.push(editorCommand);
    }

    //model command
    var modelCommand = {};
    modelCommand.type = "deleteComponent";
    modelCommand.memberId = member.getId();
    commands.push(modelCommand);
    
    //combined command
    let commandData;
    if(commands.length > 1) {
        commandData = {};
        commandData.type = "compoundCommand";
        commandData.childCommands = commands;
    }
    else if(commands.length === 1) {
        commandData = commands[0];
    }
    else {
        return;
    }

    modelManager.getApp().executeCommand(commandData);
}

/** This component represents a json table object. */
class TreeComponentDisplay {

    constructor(componentView) {
        this.componentView = componentView;
        
        this.treeEntry = this._createTreeEntry();
        this._setBannerState();

        //opnly needed for parents...
        this.treeEntry.setSortFunction(TreeComponentDisplay.treeSortFunction);
        //this should be overwritten in component
        this.treeEntry.setExtraSortParam(0);
    };

    getTreeEntry() {
        return this.treeEntry;
    }

    getState() {
        return this.treeEntry.getState();
    }

    setState(state) {
        this.treeEntry.setState(state);
    }

    setComponentTypeSortOrder(typeSortOrder) {
        this.treeEntry.setExtraSortParam(typeSortOrder);
    }

    // changeParent(newParentComponent,oldParentComponent) {
    //     var oldParentTreeEntry = oldParentComponent.getTreeEntry();
    //     oldParentTreeEntry.removeChild(this.treeEntry);
        
    //     var newParentTreeEntry = newParentComponent.getTreeEntry();
    //     newParentTreeEntry.addChild(this.treeEntry);
    // }

    deleteDisplay() {
        alert("Delete tree component display not implemneted");
    }

    componentUpdated(component) {

        if(component.isMemberFieldUpdated("member","name")) {
            this._setLabel();
        }

        if(component.isMemberFieldUpdated("member","state")) {
            this._setBannerState();
        }
    }
    //===============================
    // Private Functions
    //===============================

    /** @private */
    _createTreeEntry() {
        //TREE_ENTRY
        //FIX THIS CODE!!!
        //open doesn't work and the context menu is duplicated code (that shouldn't be)
        
        //menu item callback
        var menuItemCallback = () => {
            //open menu item
            var menuItemList = [];
            var openMenuItem = this.componentView.getOpenMenuItem();
            if(openMenuItem) {
                menuItemList.push(openMenuItem);
            }

            var component = this.componentView.getComponent();
            var modelView = this.componentView.getModelView();

            //add child folder menu item
            if(this.componentView.usesTabDisplay()) {
                let app = modelView.getApp();
                let appView = modelView.getAppView();
                let initialValues = {parentId: component.getMemberId()};
                let pageComponents = componentInfo.getPageComponentNames();
                pageComponents.forEach(pageComponentName => {
                    let childMenuItem = {};
                    let pageComponentClass = componentInfo.getComponentClass(pageComponentName);
                    childMenuItem.title = "Add Child " + pageComponentClass.displayName;
                    childMenuItem.callback = () => addComponent(appView,app,pageComponentClass,initialValues);
                    menuItemList.push(childMenuItem);
                });
            }

            return this.componentView.getMenuItems(menuItemList);
        };
        
        //double click callback
        var openCallback = this.componentView.createOpenCallback();
        
        var component = this.componentView.getComponent();
        var modelView = this.componentView.getModelView();
        var labelText = this.componentView.getName();
        var iconUrl = this.componentView.getIconUrl();
        var isRoot = component.getParentComponent(modelView.getModelManager()) ? true : false;
        return new TreeEntry(labelText, iconUrl, openCallback, menuItemCallback,isRoot);
    }

    _setLabel() {
        let displayName = this.componentView.getName();
        this.treeEntry.setLabel(displayName);
    }

    _setBannerState() {
        let bannerState = this.componentView.getBannerState();
        //let bannerMessage = this.componentView.getBannerMessage();

        var iconOverlay = getIconOverlay(bannerState);
        if(iconOverlay) {
            this.treeEntry.setIconOverlay(iconOverlay);
        }
        else {
            this.treeEntry.clearIconOverlay();
        }
    }

    /** This is used to sort the child tree entries. 
     * We allow for a different ordering for different types by using the extrar sort parameter.
     * (for now, we put folers first. Other component type parameters can be set too) */
    static treeSortFunction(entry1,entry2) {
        var typeOrderDiff = (entry1.getExtraSortParam() - entry2.getExtraSortParam());
        if(typeOrderDiff) {
            return typeOrderDiff;
        }
        else {
            return entry1.getLabel().localeCompare(entry2.getLabel());
        }
    }
}

/** This is the base functionality for a component. */
class ComponentView {

    constructor(modelView,component) {
        
        this.modelView = modelView;
        this.component = component;
        //this is to record the latest parent view to which this was added
        this.lastAssignedParentComponentView = null;
        
        //ui elements
        this.childComponentDisplay = null; //this is the main display, inside the parent tab
        this.childDisplayState = null;
        
        this.tabDisplay = null; //only valid on parents, which open into a tab
        
        this.treeDisplay = null; //this is shown in the tree view
        this.treeState = null;

        this.component.setViewStateCallback(() => this.getViewState());
    }

    //==============================
    // Public Instance Methods
    //==============================

    /** This method returns the base member for this component. */
    getComponent() {
        return this.component;
    }

    getName() {
        return this.component.getName();
    }

    getFullName(model) {
        return this.component.getFullName(model);
    }

    /** This method returns a display name for the member object. */
    getDisplayName(useFullPath,modelForFullPathOnly) {
        return this.component.getDisplayName(useFullPath,modelForFullPathOnly);
    }

    /** This method returns true if the display name field is updated. It is only applicable if 
     * the full path is NOT used. */
    isDisplayNameUpdated() {
        return this.component.isDisplayNameUpdated();
    }

    getBannerState() {
        let member = this.component.getMember();
        return member.getState();
    }

    getBannerMessage() {
        let member = this.component.getMember();
        let state =  member.getState();
        switch(state) {
            case apogeeutil$1.STATE_NORMAL:
                return "";

            case apogeeutil$1.STATE_PENDING:
                return bannerConstants.PENDING_MESSAGE;

            case apogeeutil$1.STATE_INVALID:
                return bannerConstants.INVALID_MESSAGE;

            case apogeeutil$1.STATE_ERROR:
                return member.getErrorMsg();

            default:
                return "Unknown state: " + state; 
        }
    }

    /** This method gets the parent component view of the current component view. 
     * This method does not depends only on the relation between the components, 
     * rather than any relationship established between the component views. This should give the
     * same result getLastAssignedParentComponentView except during a delete or move operation. */
    getParentComponentView() {

        let parentComponent = this.component.getParentComponent(this.modelView.getModelManager());
        if((parentComponent)&&(this.modelView)) {
            return this.modelView.getComponentViewByComponentId(parentComponent.getId());
        }
        else {
            return null;
        }

    }

    /** This sets the assigned parent component view. This should be done for
     * bookkeeping so it can be removed suring a move or delete operation. */
    setLastAssignedParentComponentView(parentComponentView) {
        this.lastAssignedParentComponentView = parentComponentView;

    }

    /** This method gets the assigned parent component view, which may not
     * be the view corresponding to the current parent component. This should differ 
     * only during move or delete operations. */
    getLastAssignedParentComponentView() {
        return this.lastAssignedParentComponentView;

    }

    /** This method returns the icon url for the component. */
    getIconUrl() {
        if(this.constructor.ICON_URL) {
            return this.constructor.ICON_URL;
        }
        else {
            var resPath = this.constructor.ICON_RES_PATH;
            if(!resPath) resPath = ComponentView.DEFAULT_ICON_RES_PATH;
            return uiutil.getResourcePath(resPath);
        }
    }

    /** This method returns the model manager for this component. */
    getModelView() {
        return this.modelView;
    }

    /** This method is called when the workspace is closing */
    closeWorkspace() {
        this.onDelete();
    }

    //-----------------------------------
    // Save methods
    //-----------------------------------

    
    /** This method reads the current UI state and saves it to the component. */
    getViewState() {
        let json = {};
        let statePresent = false;

        //get the child display state
        let activeChildDisplayState;
        if(this.childComponentDisplay) {
            activeChildDisplayState = this.childComponentDisplay.getStateJson();
        }
        else {
            activeChildDisplayState = this.childDisplayState;
        }

        if(activeChildDisplayState !== undefined) {
            json.childDisplayState = activeChildDisplayState;
            statePresent = true;
        }
    
        //get the tree display state
        let activeTreeState;
        if(this.treeDisplay) {
            activeTreeState = this.treeDisplay.getState();
        }
        else {
            activeTreeState = this.treeState; 
        }

        if((activeTreeState !== undefined)&&(activeTreeState != TreeEntry.NO_CONTROL)) {
            json.treeState = activeTreeState;
            statePresent = true;
        }

        //allow the specific component implementation to write to the json
        if(this.writeToJson) {
            statePresent = this.writeToJson(json);
        }

        if(this.tabDisplay) {
            json.tabOpened = true;
            var tab = this.tabDisplay.getTab();
            if(tab.getIsShowing()) {
                json.tabShowing = true;
            }
            statePresent = true;
        }

        //return the state
        if(statePresent) {
            return json;
        }
        else {
            return undefined;
        }
    }

    /** This method reads the UI state from the component. */
    loadViewStateFromComponent() {
        let json = this.component.getCachedViewState();
        if(!json) return;

        //set the tree state
        if((json.treeState !== undefined)&&(json.treeState !== null)) {
            if(this.treeDisplay) {
                this.treeDisplay.setState(json.treeState);
                this.treeState = null;
            }
            else {
                this.treeState = json.treeState;
            }
        }
        
        //set window options
        if((json.childDisplayState !== undefined)||(json.childDisplayState !== null)) {
            if(this.childComponentDisplay) {
                this.childComponentDisplay.setStateJson(json.childDisplayState);
                this.childDisplayState = null;
            }
            else {
                this.childDisplayState = json.childDisplayState;
            }
        }
        
        //allow the component implemnetation ro read from the json
        if(this.readFromJson) {
            this.readFromJson(json);
        }

        //check the tab display state (where tabs are used)
        if(json.tabOpened) {
            let setShowing = json.tabShowing;
            this.createTabDisplay(setShowing);
        }
    }

    /** This method can be implemented if the component view has additional state to save.
     * It should return true if state was added, and false otherwise. */
    //writeToJson(json) { return false;}

    /** This method can be implemented if the component view has additional state saved. */
    //readFromJson(json) {}

    //-------------------
    // tree entry methods - this is the element in the tree view
    //-------------------
    getTreeEntry() {
        if(!this.treeDisplay) {
            this.treeDisplay = this.createTreeDisplay();
        }
        return this.treeDisplay.getTreeEntry();
    }

    /** @protected */
    createTreeDisplay() {
        var treeDisplay = new TreeComponentDisplay(this);

        if((this.treeState !== undefined)&&(this.treeState !== null)) {
            treeDisplay.setState(this.treeState);
        }
        
        //default sort order within parent
        var treeEntrySortOrder = (this.constructor.TREE_ENTRY_SORT_ORDER !== undefined) ? this.constructor.TREE_ENTRY_SORT_ORDER : ComponentView.DEFAULT_COMPONENT_TYPE_SORT_ORDER;
        treeDisplay.setComponentTypeSortOrder(treeEntrySortOrder);
        
        return treeDisplay;
    }

    //-------------------
    // component display methods - this is the element in the parent tab (main display)
    //-------------------

    setComponentDisplay(childComponentDisplay) {
        this.childComponentDisplay = childComponentDisplay; 
        if(this.childDisplayState) {
            this.childComponentDisplay.setStateJson(this.childDisplayState);
            this.childDisplayState = null;
        }
    }

    getComponentDisplay() {
        return this.childComponentDisplay;
    }

    closeComponentDisplay() {
        if(this.childComponentDisplay) {
            //first store the window state
            this.childDisplayState = this.childComponentDisplay.getStateJson();
            
            //delete the window
            this.childComponentDisplay.deleteDisplay();
            
            this.childComponentDisplay = null;
        }
    }

    //-------------------
    // tab display methods - this is the tab element, only used for parent members
    //-------------------

    /** This indicates if the component has a tab display. */
    usesTabDisplay() {
        return this.constructor.hasTabEntry;
    }
    //Implement in extending class:
    ///** This creates the tab display for the component. */
    //instantiateTabDisplay();

    createTabDisplay(makeActive) {
        if((this.usesTabDisplay())&&(!this.tabDisplay)) {
            if(this.modelView) { 
                var tabFrame = this.modelView.getTabFrame();
                if(tabFrame) {

                    this.tabDisplay = this.instantiateTabDisplay();

                    //add the tab display to the tab frame
                    let tab = this.tabDisplay.getTab();
                    tabFrame.addTab(tab,makeActive);
                }
            }
        }
    }

    getTabDisplay() {
        return this.tabDisplay;
    }

    /** This closes the tab display for the component. */
    closeTabDisplay() {
        if(this.tabDisplay) {
            var tabDisplay = this.tabDisplay;
            this.tabDisplay = null;
            tabDisplay.closeTab();
            tabDisplay.destroy();    
        }
    }

    //-------------------
    // Menu methods
    //-------------------

    getMenuItems(optionalMenuItemList) {
        //menu items
        var menuItemList = optionalMenuItemList ? optionalMenuItemList : [];
            
        //add the standard entries
        var itemInfo = {};
        itemInfo.title = "Edit Properties";
        itemInfo.callback = () => updateComponent(this);
        menuItemList.push(itemInfo);

        var itemInfo = {};
        itemInfo.title = "Delete";
        itemInfo.callback = () => deleteComponent(this);
        menuItemList.push(itemInfo);
        
        return menuItemList;
    }

    getOpenMenuItem () {
        var openCallback = this.createOpenCallback();
        if(openCallback) {
            var itemInfo = {};
            itemInfo.title = "Open";
            itemInfo.callback = openCallback;
            return itemInfo;
        }
        else {
            return null;
        }
    }

    //==============================
    // Protected Instance Methods
    //==============================

    /** This method cleans up after a delete. Any extending object that has delete
     * actions should pass a callback function to the method "addClenaupAction" */
    onDelete() {
        if(this.tabDisplay) {
            this.closeTabDisplay();
        }
    }

    /** This method extends the member udpated function from the base.
     * @protected */    
    componentUpdated(component) {
        //set the new component
        this.component = component;
        this.component.setViewStateCallback(() => this.getViewState());

        //check for parent change
        if(component.isFieldUpdated("member")) {
            let member = component.getMember();
            if(member.isFieldUpdated("parentId")) {
                var oldParentComponentView = this.getLastAssignedParentComponentView();
                var newParentComponentView = this.getParentComponentView();

                if(oldParentComponentView != newParentComponentView) {
                    //remove from old parent component
                    if(oldParentComponentView) {
                        oldParentComponentView.removeChild(this);
                        //delete all the window display
                        if(this.childComponentDisplay) {
                            this.childComponentDisplay.deleteDisplay();
                            this.childComponentDisplay = null;
                        }
                    }
                    else if(this.modelView) {
                        //this was in the root folder
                        this.modelView.removeChildFromRoot(this);
                    }

                    //add to the new parent component
                    if(newParentComponentView) {
                        newParentComponentView.addChild(this);
                        this.setLastAssignedParentComponentView(newParentComponentView);
                    }
                    else if(this.modelView) {
                        //this is placed in the root folder
                        this.modelView.addChildToRoot(this);
                        this.setLastAssignedParentComponentView(null);
                    }
                }
            }  
        }
        
        //update for new data
        if(this.treeDisplay) {
            this.treeDisplay.componentUpdated(component);
        }
        if(this.childComponentDisplay != null) {
            this.childComponentDisplay.componentUpdated(component);
        }
        if(this.tabDisplay != null) {
            this.tabDisplay.componentUpdated(component);
        }
    }

    //=============================
    // Action UI Entry Points
    //=============================

    /** This method creates a callback for deleting the component. 
     *  @private */
    createOpenCallback() {
        var openCallback;
        
        var makeTabActive = function(tabComponent) {
            var tabDisplay = tabComponent.getTabDisplay();
            if(tabDisplay) {
                var tab = tabDisplay.getTab();
                tab.makeActive();
            }
            else {
                //create the tab display - this automaticaly puts it in the tab frame
                tabComponent.createTabDisplay(true);
            }
        };
        
        if(this.usesTabDisplay()) {
            openCallback = () => {
                makeTabActive(this);

                //allow time for UI to be created and then select start fo doc
                //this will also give the doc focus
                setTimeout(() => {
                    let tabDisplay = this.getTabDisplay();
                    if(tabDisplay.selectStartOfDocument) {
                        tabDisplay.selectStartOfDocument();
                    }
                },0);
            };
        }
        else {
            //remove the tree from the parent
            openCallback = () => {
                var parentComponentView = this.getParentComponentView();
                if((parentComponentView)&&(parentComponentView.constructor.hasTabEntry)) {

                    //open the parent and bring this child to the front
                    makeTabActive(parentComponentView);

                    parentComponentView.showChild(this);

                }
            };
        }
        
        return openCallback;
    }
}

//These parameters are used to order the components in the tree entry.
ComponentView.DEFAULT_COMPONENT_TYPE_SORT_ORDER = 5;
ComponentView.FOLDER_COMPONENT_TYPE_SORT_ORDER = 0;

ComponentView.DEFAULT_ICON_RES_PATH = "/genericIcon.png";

ComponentView.MENU_ITEM_OPEN = 0x01;

/** This is the base class for data displays, which show individual edit/display fields for a component. For example, a standard JSON
 * data component has three data displays, for the component value, the function body and the supplemental code.
 * 
 * @param {type} displayContainer - this is the ui container that will show the display
 * @param {type} dataSource - the dataSource for the editor. It is an object with the following functions:
 *  - {reloadDataDisplay, reloadData} = doUpdate() - Required - This function updates the component instance
 *      held by the data source and it returns to boolean values, "reloadDataDisplay", which indicates is the data display should 
 *      be reloaded (such as if it is replaced with a new data display or if the UI elements for it have been updated) and
 *      "reloadData" which indicates the data value displayed in the data display should be reloaded.  
 *  - data = getData() - Requiried - This returns the data that should be displayed. The format of the data depends on the 
 *      data display. If the data is not valid, then the value apogeeutil.INVALID_VALUE should be returned.
 *  - editOk = getEditOk() - Optional - If present, this indicates if the data display edit mode should be used. If it is not present
 *      it is assumed to be false.
 *  - closeDialog = saveData(data) - Optional This is used if the data display edit mode is used. It should save the data. The return value
 *      should be true if the edit operation should be concluded. It shoudl return false if there is a save failure such that you want to 
 *      stay in edit mode.
 *  - (other) - Optional - Data displays may define additional functions as needed for their implmentations. Examples where this is done in in the custom
 *      components to pass non-model data (like the HTML or the UI generator code) into the data display.
 */ 
class DataDisplay {
    constructor(displayContainer,dataSource) {
        this.displayContainer = displayContainer;
        this.dataSource = dataSource;
        this.editOk = false;

        //defaults for container sizing logic
        this.supressContainerHorizontalScroll = false;
        this.useContainerHeightUi = false;
    }

    /** This method updates the internal component instance and also returns
     * true if the data display needs to be refreshed. */
    doUpdate() {
        if(this.dataSource) {
            return this.dataSource.doUpdate();
        }
        else {
            return false;
        }
    }
    
    save() {
        var data = this.getData();
        var saveComplete;
        
        //figure out if there is a problem with this - we hav to end edit mode before
        //we save because in edit mode it will not overwrite the data in the display
        //if we fail, we restart edit mode below
        this.endEditMode();

        if((this.dataSource)&&(this.dataSource.saveData)) {
            saveComplete = this.dataSource.saveData(data);
        }
        else {
            alert("Error: Data not saved: save callback not set!");
            saveComplete = true;
        }

        //end edit mode if we entered it
        if(!saveComplete) {
            this.startEditMode();
        }
    }

    cancel() {
        //reset the original data
        var cancelComplete = this.displayContainer.onCancel();

        if(cancelComplete) {
            this.endEditMode();
        }
    }
    
    //=============================
    // Implemement in extending class
    //=============================
    
    //This method gets the data from the editor. OPTIONAL. Required id editing is enabled.
    //getData() {}
    
    //this sets the data into the editor display. REQUIRED if edit mode or save is used
    //setData(data) {}
    
    //this method is called on loading the display. OPTIONAL
    //onLoad() {}
    
    //this method is called on unloading the display. OPTIONAL
    //onUnLoad() {}

    //this method is called when the display will be destroyed. OPTIONAL
    //destroy() {}
    
    //This method returns the content element for the data display REQUIRED
    //getContent() {}

    //---------------------------
    // UI State Management
    //---------------------------
    
    /** This method adds any data display state info to the view state json. 
     * By default there is none. Note that this modifies the json state of the view,
     * rather than providing a data object that will by added to it.. */
    addUiStateData(json) {

    }

    /** This method reads an data display state info from the view state json. */
    readUiStateData(json) {

    }

    //----------------------------
    // This is the View resize API
    // The display has controls for the user to resize the display. These use the 
    // following API to interact with the display
    //----------------------------

    /** This function is called to see if the container should provide horizontal scroll bars for the display view content. */
    getSupressContainerHorizontalScroll() {
        return this.supressContainerHorizontalScroll;
    }

    /** This sets the variable that determines if the container will provide a horizontal scroll bars for the display view
     * content. The default value is false. */
    setSupressContainerHorizontalScroll(supressContainerHorizontalScroll) {
        this.supressContainerHorizontalScroll = supressContainerHorizontalScroll;
    }

    /** This function is called to see if the container should provide a view height UI, if the container supports it. */
    getUseContainerHeightUi() {
        return this.useContainerHeightUi;
    }

    /** This sets the variable that determines if the container will provide a height adjustment UI. The default value is false. */
    setUseContainerHeightUi(useContainerHeightUi) {
        this.useContainerHeightUi = useContainerHeightUi;
    }

    /** This method gets the resize mode. Options:
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
     */
    //getResizeHeightMode();

    /** This method sets the resize mode. Options:
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
     */
    //setResizeHeightMode(resizeMode);

    /** This method adjusts the size when the resize mode is DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME. Options:
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MORE;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_LESS;
    */
    //adjustHeight(adjustment);

    /** This method returns the possible resize options, for use in the mode DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME. Flags:
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_LESS = 1;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MORE = 2;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_NONE = 0;
     * These flags should be or'ed togethder to give the allowed options.
    */
    //getHeightAdjustFlags();

    //=============================
    // protected, package and private Methods
    //=============================
	
    showData() {
        var data;
        var editOk;
        if(this.dataSource) {
            if(this.dataSource.getData) {
                data = this.dataSource.getData();
            }
            if(this.dataSource.getEditOk) {
                editOk = this.dataSource.getEditOk();
            }
        }
        if(data === undefined) {
            data = "DATA UNAVAILABLE";
            this.editOK = false;
        }
        else if(editOk === undefined) {
            this.editOk = false;
        }
        else {
            this.editOk = editOk;
        }
        
        this.setData(data);
    }

    /** @protected */
    endEditMode() {
        this.displayContainer.endEditMode();

    }
    
    /** @protected */
    startEditMode() {
        var onSave = () => this.save();
        var onCancel = () => this.cancel();

        this.displayContainer.startEditMode(onSave,onCancel);
    }

    /** @protected */
    onTriggerEditMode() {
        if(this.editOk) {
            this.startEditMode();
        }
    }

    /** This method retrieves the data source for the data display */
    getDataSource() {
        return this.dataSource;
    }

    getDisplayContainer() {
        return this.displayContainer;
    }
}

/** 
 * This namespace includes some data display constants.
 * @namespace
 */
let DATA_DISPLAY_CONSTANTS = {};

//these are responses to hide request and close request
DATA_DISPLAY_CONSTANTS.UNSAVED_DATA = -1;
DATA_DISPLAY_CONSTANTS.CLOSE_OK = 1;

DATA_DISPLAY_CONSTANTS.VIEW_STATE_INACTIVE = 1;
DATA_DISPLAY_CONSTANTS.VIEW_STATE_MINIMIZED = 2;

//this should probably go somewhere else
DATA_DISPLAY_CONSTANTS.NO_EDIT_BACKGROUND_COLOR = "#f4f4f4";

//display view size constants
DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME = "resize_height_mode_some";
DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX = "resize_height_mode_max";

DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_LESS = 1;
DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MORE = 2;
DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_NONE = 0;

/** Editor that uses the Ace text editor.
 * 
 * @param {type} displayContainer - the display container
 * @param {type} dataSource - {updateComponent,getData,getEditOk,setData}; format for data is text
 * @param {type} aceMode - the display format, such as "ace/mode/json"
 */
class AceTextEditor extends DataDisplay {
    
    constructor(displayContainer,dataSource,aceMode,options) {
        super(displayContainer,dataSource);

        this.editorDiv = uiutil.createElement("div");

        //========================
        //this is for consistency of lines to pixels
        this.editorDiv.style.fontSize = "12px";
        this.editorDiv.style.lineHeight = "1.2";
        this.pixelsPerLine = 14;
        //=========================

        this.aceMode = aceMode;

        this.storedData = null;

        //configure the options
        if(!options) options = {};

        this.editorOptions = {};
        this.showSomeMaxLines = DEFAULT_MAX_LINES;
        if(options.displayMax) {
            this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
            this.editorOptions.maxLines = MAX_MAX_LINES;
        }
        else {
            this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
            this.editorOptions.maxLines = this.showSomeMaxLines;
        }

        this.editorOptions.minLines = DEFAULT_MIN_LINES;

        //set variables for internal display view sizing
        this.setSupressContainerHorizontalScroll(true);
        this.setUseContainerHeightUi(true);
    }
    
    createEditor() {
        var editor = exports$1.edit(this.editorDiv);
        editor.setOptions(this.editorOptions);
        editor.renderer.setShowGutter(false);
        editor.setHighlightActiveLine(false);
        editor.setTheme("ace/theme/eclipse"); //good
        editor.getSession().setMode(this.aceMode); 
        
        editor.$blockScrolling = Infinity;
        editor.renderer.attachToShadowRoot();        
        
        this.editor = editor;
        
        if(this.storedData) {
            this.setData(this.storedData);
        }
        
        //enter edit mode on change to the data
        this.editor.addEventListener("input",() => this.checkStartEditMode());
    }
    
    getContent() {
        return this.editorDiv;
    }

    getData() {
        if(this.editor) {
            this.storedData = this.editor.getSession().getValue();
        }
        return this.storedData; 
    }
    
    setData(text) {
        //The data source should give a text value "" if the data in invalid rather than sending
        //in a json, but we will do this check anyway.
        if(text == apogeeutil$1.INVALID_VALUE) {
            var errorMsg = "ERROR: Data value is not valid";
            text = "";
        }

        //check data is valid
        if(apogeeutil$1.getObjectType(text) != "String") {
            var errorMsg = "ERROR: Data value is not text";
            //this.setError(errorMsg);
            text = errorMsg;
        }
            
        //store the data
        this.storedData = text;
        
        //place ineditor, if it is present
        if(this.editor) {
            this.editor.getSession().setValue(text);

            //set the edit mode and background color
            if(this.editOk) {
                this.editorDiv.style.backgroundColor = "";
                this.editor.setReadOnly(false);
            }
            else {
                this.editorDiv.style.backgroundColor = DATA_DISPLAY_CONSTANTS.NO_EDIT_BACKGROUND_COLOR;
                this.editor.setReadOnly(true);
            }
        }
    }
    
    onLoad() {
        if(!this.editor) {
            this.createEditor();
        }
        this.editor.resize();
    }

    destroy() {
        if(this.editor) {
            this.editor.destroy();
            this.editor = null;
        }
    }
    
    checkStartEditMode() {
        if((!this.displayContainer.isInEditMode())&&(this.editor)) {
            var activeData = this.editor.getSession().getValue();
            if(activeData != this.storedData) {
                this.onTriggerEditMode();
            }
        }
    }

    //---------------------------
    // UI State Management
    //---------------------------
    
    /** This method adds any data display state info to the view state json. 
     * By default there is none. Note that this modifies the json state of the view,
     * rather than providing a data object that will by added to it.. */
    addUiStateData(json) {
        if(this.editorOptions.maxLines) {
            json.height = this.editorOptions.maxLines * this.pixelsPerLine;
        }
    }

    /** This method reads an data display state info from the view state json. */
    readUiStateData(json) {
        if(json.height) {
            let maxLines = Math.round(json.height / this.pixelsPerLine);
            if(maxLines >= MAX_MAX_LINES) {
                this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
                maxLines = MAX_MAX_LINES;
            }
            else {
                this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
                if(maxLines < DEFAULT_MIN_LINES) {
                    maxLines = DEFAULT_MIN_LINES;
                }
                this.showSomeMaxLines = maxLines;
            }

            this.editorOptions.maxLines = maxLines;

            if(this.editor) {
                this.editor.setOptions(this.editorOptions);
            }
        }
    }

    //----------------------------
    // This is the View resize API
    // The display has controls for the user to resize the display. These use the 
    // following API to interact with the display
    //----------------------------

    /** This method gets the resize mode. Options:
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
     */
    getResizeHeightMode() {
        return this.resizeHeightMode;
    }

    /** This method sets the resize mode. Options:
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
     */
    setResizeHeightMode(resizeHeightMode) {
        if(resizeHeightMode == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME) {
            this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
            this.editorOptions.maxLines = this.showSomeMaxLines;
        }
        else if(resizeHeightMode == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX) {
            this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
            this.editorOptions.maxLines = MAX_MAX_LINES;
        }
        else {
            //ignore unknown value
            return;
        }

        if(this.editor) {
            this.editor.setOptions(this.editorOptions);
        }
    }

    /** This method adjusts the size when the resize mode is DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME. Options:
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MORE;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_LESS;
    */
    adjustHeight(adjustment) {
        if(this.resizeHeightMode == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME) {
            if(this.editor) {
                let newMaxLines;
                if(adjustment == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_LESS) {
                    //decrease size by 1 line - except if our size is 
                    //larger than the current doc, then shrink it to 
                    //one line smaller than current doc.
                    let docLines = this.editor.getSession().getLength();
                    if(docLines < this.showSomeMaxLines) {
                        this.showSomeMaxLines = docLines;
                    }
                    newMaxLines = this.showSomeMaxLines - 1;
                    if(newMaxLines <  DEFAULT_MIN_LINES) {
                        newMaxLines = DEFAULT_MIN_LINES;
                    }
                }
                else if(adjustment == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MORE) {
                    //just grow size by 1 line
                    newMaxLines = this.showSomeMaxLines + 1;
                    if(newMaxLines >  MAX_MAX_LINES) {
                        newMaxLines = MAX_MAX_LINES;
                    }
                }
                else {
                    //ignore an unknown command
                    return;
                }

                //update the lines options
                this.showSomeMaxLines = newMaxLines;
                this.editorOptions.maxLines = this.showSomeMaxLines;
                this.editor.setOptions(this.editorOptions);
            }
        }
    }

    /** This method returns the possible resize options, for use in the mode DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME. Flags:
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_LESS = 1;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MORE = 2;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_NONE = 0;
     * These flags should be or'ed togethder to give the allowed options.
    */
    getHeightAdjustFlags() {
        //We won't dynamically figufre out if we can add or remove lines based on current content. If
        //we add this we will have to track if it changes. 
        //So they user may push these buttons and nothing will happen.
        //We will set the flags based on our absolute limits.
        let flags = 0;
        if(this.showSomeMaxLines < MAX_MAX_LINES) {
            flags = flags | DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MORE;
        }
        if(this.showSomeMaxLines > DEFAULT_MIN_LINES) {
            flags = flags | DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_LESS;
        }
        return flags;
    }
}

//options for displaying all or some lines
AceTextEditor.OPTION_SET_DISPLAY_MAX = { "displayMax":true};
AceTextEditor.OPTION_SET_DISPLAY_SOME = { "displayMax":false};

//configuration constants
let MAX_MAX_LINES = 500;
let DEFAULT_MAX_LINES = 20;
let DEFAULT_MIN_LINES = 2;

/** This is an editor that displays a customized form for data input. */
class ConfigurableFormEditor extends DataDisplay {
    
    /** This allows for a static or dynamic layout setting
     * @param {type} displayContainer - the displayContainer
     * @param {type} dataSource - {
     *  - doUpdate - this should return reloadDataDisplay = true if the form should be reconfigured. 
     *          otherwise it should return reloadData if the form data should be reloaded.
     *  - getData - returns the desired form value,
     *  - getEditOk - gets if form is editable (optional)
     *  - setData - called when data is saved, with the form value (optional)
     *  - getLayout - This returns the layour for the configurable form.
     *  }
     */
    constructor(displayContainer,dataSource) {
        super(displayContainer,dataSource);
        
        //construct the display
        this.panel = new ConfigurablePanel();
        if(dataSource.getDisplayData) {
            this.panel.configureForm(dataSource.getDisplayData());
        }
    }

    /** This method will return undefined until showData is called. */
    getContent() {
        return this.panel.getElement();
    }
    
    /** This returns the form value (not the layout too) */
    getData() {
        //get the form value, and set it to the refernece for changes to the form 
        this.changeReferenceValue = this.panel.getValue();
        return this.changeReferenceValue;
    }
    
    /** This is passed the data form the data callback, which should be the extended data  - including layout + value */
    setData(data) {
        //we need a better error case
        if(data == apogeeutil$1.INVALID_VALUE) {
            data = {};
        }

        this.changeReferenceValue = data;

        //input data is the layout and the value
        this.panel.setValue(data);
        
        //set change to enable save bar is form value differs from initial data
        let dataSource = this.getDataSource();
        if((dataSource.getEditOk)&&(dataSource.getEditOk())) {
            var onChange = (currentFormValue,form) => {
                if(apogeeutil$1.jsonEquals(currentFormValue,this.changeReferenceValue)) {
                    this.endEditMode();
                }
                else {
                    this.startEditMode();
                }
            };
            this.panel.addOnChange(onChange);
        }     
    }
}

let dataDisplayHelper = {};

const FORMAT_STRING = "\t";

/** This function creates the data display data source  for the data of the given member. The
 * member field should be the field name used to access the data source from the associated component. */
dataDisplayHelper.getMemberDataJsonDataSource = function(app,componentView,memberFieldName) {

    //this is used internally to lookup the data member used here
    let _getDataMember = function() {
        let component = componentView.getComponent();
        let member = component.getField(memberFieldName);
        return member;
    };
    
    return {

        doUpdate: function() {
            //return value is whether or not the data display needs to be udpated
            let component = componentView.getComponent();
            let reloadData = component.isMemberDataUpdated(memberFieldName);
            let reloadDataDisplay = false;
            return {reloadData,reloadDataDisplay};
        },

        getData: function() {
            return _getDataMember().getData();
        },

        getEditOk: function () {
            return !_getDataMember().hasCode();
        },

        saveData: function(data) {
            var commandData = {};
            commandData.type = "saveMemberData";
            commandData.memberId = _getDataMember().getId();
            commandData.data = data;
            
            app.executeCommand(commandData);
            return true;
        }
    }
};

/** This function creates editor callbacks or member data where the editor takes text format. */
dataDisplayHelper.getMemberDataTextDataSource = function(app,componentView,memberFieldName) {

    let baseSource = dataDisplayHelper.getMemberDataJsonDataSource(app,componentView,memberFieldName);

    return {
        doUpdate: baseSource.doUpdate,

        getData: function() {
            let json = baseSource.getData();

            var textData;
            if(json == apogeeutil.INVALID_VALUE) {
                //for invalid input, convert to display an empty string
                textData = "";
            }
            else if(json === null) {
                textData = "null";
            }
            else if(json === undefined) {
                textData = "undefined";
            }
            else {
                textData = JSON.stringify(json,null,FORMAT_STRING);
            }

            return textData;
        },

        getEditOk: baseSource.getEditOk,

        saveData: function(text) {
            var data;
            if(text.length > 0) {
                try {
                    data = JSON.parse(text);
                }
                catch(error) {
                    if(error.stack) console.error(error.stack);
                    
                    //parsing error
                    alert("There was an error parsing the JSON input: " +  error.message);
                    return false;
                }
            }
            else {
                data = "";
            }

            return baseSource.saveData(data);
        }
    }
};


/** This function creates editor callbacks or the member function body. 
 * The argument optionalClearCodeValue can optionally be set. If so, the member data will be 
 * set with this value if the function body and supplemental code are empty. 
 * The optionalDefaultDataValue will be used to clear the function and save the data value if the formula and
 * private code are empty strings. */
dataDisplayHelper.getMemberFunctionBodyDataSource = function(app,componentView,memberFieldName,optionalDefaultDataValue) {

    //this is used internally to lookup the data member used here
    let _getFunctionMember = function() {
        let component = componentView.getComponent();
        let member = component.getField(memberFieldName);
        return member;
    };

    return {

        doUpdate: function() {
            //return value is whether or not the data display needs to be udpated
            let component = componentView.getComponent();
            let reloadData = component.isMemberFieldUpdated(memberFieldName,"functionBody");
            let reloadDataDisplay = false;
            return {reloadData,reloadDataDisplay};
        },

        getData: function() {
            return _getFunctionMember().getFunctionBody();
        },

        getEditOk: function() {
            return true;
        },

        saveData: function(text) {
            let functionMember = _getFunctionMember();

            var commandData = {};
            commandData.type = "saveMemberCode";
            commandData.memberId = functionMember.getId();
            commandData.argList = functionMember.getArgList();
            commandData.functionBody = text;
            commandData.supplementalCode = functionMember.getSupplementalCode();
            if(optionalDefaultDataValue !== undefined) commandData.clearCodeDataValue = optionalDefaultDataValue;
            
            app.executeCommand(commandData);
            return true;
        }
    }
};

/** This function creates editor callbacks or the member supplemental code. 
 * The optionalDefaultDataValue will be used to clear the function and save the data value if the formula and
 * private code are empty strings. 
*/
dataDisplayHelper.getMemberSupplementalDataSource = function(app,componentView,memberFieldName,optionalDefaultDataValue) {

    //this is used internally to lookup the data member used here
    let _getFunctionMember = function() {
        let component = componentView.getComponent();
        let member = component.getField(memberFieldName);
        return member;
    };

    return {

        doUpdate: function() {
            //return value is whether or not the data display needs to be udpated
            let component = componentView.getComponent();
            let reloadData = component.isMemberFieldUpdated(memberFieldName,"supplementalCode");
            let reloadDataDisplay = false;
            return {reloadData,reloadDataDisplay};
        },

        getData: function() {
            return _getFunctionMember().getSupplementalCode();
        },

        getEditOk: function() {
            return true;
        },

        saveData: function(text) {
            let functionMember = _getFunctionMember();

            var commandData = {};
            commandData.type = "saveMemberCode";
            commandData.memberId = functionMember.getId();
            commandData.argList = functionMember.getArgList();
            commandData.functionBody = functionMember.getFunctionBody();
            commandData.supplementalCode = text;
            if(optionalDefaultDataValue !== undefined) commandData.clearCodeDataValue = optionalDefaultDataValue;
            
            app.executeCommand(commandData);
            return true;
        }
    }
};

/** JsDataDisplay
 * This is the data display for a custom control where the control is generated
 * from javascript code. Is should be passed a 
 * resource (javascript object) which has the following methods optionally defined: 
 * 
 * init(outputElement,outputMode);
 * setData(data,outputElement,outputMode);
 * requestInactive(outputElement,outputMode);
 * onHide(outputElement,outputMode);
 * destroy(outputElement,outputMode);
 */

/** This is the display/editor for the custom control output. */
class ErrorDisplay extends DataDisplay {
    constructor(displayContainer) {
        var dataSource = {
            doUpdate: () => false,
            getData: () => null
        };
        super(displayContainer,dataSource);
        
        var msg = "ERROR - Component not loaded!";
        var msgDiv = uiutil.createElement("div");
        msgDiv.style = "color:red; font-weight:bold";
        msgDiv.innerHTML = msg;
        
        this.displayElement = msgDiv;
    }
    
    /** This method will return undefined until showData is called. */
    getContent() {
        return this.displayElement;
    }

    setData(data) {
        //no action
    }
}

/*!
 * (The MIT License)
 * 
 * Copyright (c) 2012-2014 Marcin Warpechowski
 * Copyright (c) 2015 Handsoncode sp. z o.o. <hello@handsoncode.net>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 * Version: 6.2.0
 * Release date: 14/11/2018 (built at 07/11/2018 13:05:16)
 */

//-----------------------------------------
// ES6 Module Conversion - Added to execute this UMD module as CommonJS and use "exports" as the export.
// Additional code appears at the bottom of the file.
let module$2 = {};
module$2.exports = {};
let exports$2 = module$2.exports;
//------------------------------------------

!function(e,t){"object"==typeof exports$2&&"object"==typeof module$2?module$2.exports=t():"function"==typeof define&&define.amd?define("Handsontable",[],t):"object"==typeof exports$2?exports$2.Handsontable=t():e.Handsontable=t();}("undefined"!=typeof self?self:undefined,function(){return function(e){function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:o});},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=453)}([function(e,t,n){function o(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);e.length>t;t++)n[t]=e[t];return n}return Array.from(e)}function r(e){for(var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=-1,o=null,r=e;null!==r;){if(n===t){o=r;break}r.host&&r.nodeType===Node.DOCUMENT_FRAGMENT_NODE?r=r.host:(n+=1,r=r.parentNode);}return o}function i(e,t,n){for(var o=e;null!==o&&o!==n;){if(o.nodeType===Node.ELEMENT_NODE&&(t.indexOf(o.nodeName)>-1||t.indexOf(o)>-1))return o;o=o.host&&o.nodeType===Node.DOCUMENT_FRAGMENT_NODE?o.host:o.parentNode;}return null}function a(e,t,n){for(var o=[],r=e;r&&(r=i(r,t,n))&&(!n||n.contains(r));)o.push(r),r=r.host&&r.nodeType===Node.DOCUMENT_FRAGMENT_NODE?r.host:r.parentNode;var a=o.length;return a?o[a-1]:null}function s(e,t){var n=e.parentNode,o=[];for("string"==typeof t?o=Array.prototype.slice.call(document.querySelectorAll(t),0):o.push(t);null!==n;){if(o.indexOf(n)>-1)return !0;n=n.parentNode;}return !1}function l(e){function t(e){return e.nodeType===Node.ELEMENT_NODE&&e.nodeName===n.toUpperCase()}for(var n="hot-table",o=!1,r=u(e);null!==r;){if(t(r)){o=!0;break}if(r.host&&r.nodeType===Node.DOCUMENT_FRAGMENT_NODE){if(o=t(r.host))break;r=r.host;}r=r.parentNode;}return o}function u(e){return "undefined"!=typeof Polymer&&"function"==typeof wrap?wrap(e):e}function c(e){return "undefined"!=typeof Polymer&&"function"==typeof unwrap?unwrap(e):e}function h(e){var t=0,n=e;if(n.previousSibling)for(;n=n.previousSibling;)t+=1;return t}function f(e,t){var n=document.querySelector(".ht_clone_"+e);return n?n.contains(t):null}function d(e){var t=[];if(!e||!e.length)return t;for(var n=0;e[n];)t.push(e[n]),n+=1;return t}function p(e,t){return Q(e,t)}function g(e,t){return ee(e,t)}function v(e,t){return te(e,t)}function m(e,t){if(3===e.nodeType)t.removeChild(e);else if(["TABLE","THEAD","TBODY","TFOOT","TR"].indexOf(e.nodeName)>-1)for(var n=e.childNodes,o=n.length-1;o>=0;o--)m(n[o],e);}function y(e){for(var t=void 0;t=e.lastChild;)e.removeChild(t);}function w(e,t){ie.test(t)?e.innerHTML=t:C(e,t);}function C(e,t){var n=e.firstChild;n&&3===n.nodeType&&null===n.nextSibling?ae?n.textContent=t:n.data=t:(y(e),e.appendChild(document.createTextNode(t)));}function b(e){for(var t=e;c(t)!==document.documentElement;){if(null===t)return !1;if(t.nodeType===Node.DOCUMENT_FRAGMENT_NODE){if(t.host){if(t.host.impl)return b(t.host.impl);if(t.host)return b(t.host);throw Error("Lost in Web Components world")}return !1}if("none"===t.style.display)return !1;t=t.parentNode;}return !0}function _(e){var t=document.documentElement,n=e,o=void 0,r=void 0,i=void 0,a=void 0;if((0, $.hasCaptionProblem)()&&n.firstChild&&"CAPTION"===n.firstChild.nodeName)return a=n.getBoundingClientRect(),{top:a.top+(window.pageYOffset||t.scrollTop)-(t.clientTop||0),left:a.left+(window.pageXOffset||t.scrollLeft)-(t.clientLeft||0)};for(o=n.offsetLeft,r=n.offsetTop,i=n;(n=n.offsetParent)&&n!==document.body;)o+=n.offsetLeft,r+=n.offsetTop,i=n;return i&&"fixed"===i.style.position&&(o+=window.pageXOffset||t.scrollLeft,r+=window.pageYOffset||t.scrollTop),{left:o,top:r}}function S(){var e=window.scrollY;return void 0===e&&(e=document.documentElement.scrollTop),e}function E(){var e=window.scrollX;return void 0===e&&(e=document.documentElement.scrollLeft),e}function O(e){return e===window?S():e.scrollTop}function T(e){return e===window?E():e.scrollLeft}function k(e){for(var t=["auto","scroll"],n=e.parentNode,o=void 0,r=void 0,i=void 0,a="",s="",l="",u="";n&&n.style&&document.body!==n;){if(o=n.style.overflow,r=n.style.overflowX,i=n.style.overflowY,"scroll"===o||"scroll"===r||"scroll"===i)return n;if(window.getComputedStyle&&(a=window.getComputedStyle(n),s=a.getPropertyValue("overflow"),l=a.getPropertyValue("overflow-y"),u=a.getPropertyValue("overflow-x"),"scroll"===s||"scroll"===u||"scroll"===l))return n;if(n.scrollHeight+1>=n.clientHeight&&(-1!==t.indexOf(i)||-1!==t.indexOf(o)||-1!==t.indexOf(s)||-1!==t.indexOf(l)))return n;if(n.scrollWidth+1>=n.clientWidth&&(-1!==t.indexOf(r)||-1!==t.indexOf(o)||-1!==t.indexOf(s)||-1!==t.indexOf(u)))return n;n=n.parentNode;}return window}function R(e){for(var t=e.parentNode;t&&t.style&&document.body!==t;){if("visible"!==t.style.overflow&&""!==t.style.overflow)return t;var n=D(t),o=["scroll","hidden","auto"],r=n.getPropertyValue("overflow"),i=n.getPropertyValue("overflow-y"),a=n.getPropertyValue("overflow-x");if(o.includes(r)||o.includes(i)||o.includes(a))return t;t=t.parentNode;}return window}function M(e,t){if(e){if(e!==window){var n,o=e.style[t];return ""!==o&&void 0!==o?o:(n=D(e),""!==n[t]&&void 0!==n[t]?n[t]:void 0)}if("width"===t)return window.innerWidth+"px";if("height"===t)return window.innerHeight+"px"}}function D(e){return e.currentStyle||document.defaultView.getComputedStyle(e)}function A(e){return e.offsetWidth}function N(e){return (0, $.hasCaptionProblem)()&&e.firstChild&&"CAPTION"===e.firstChild.nodeName?e.offsetHeight+e.firstChild.offsetHeight:e.offsetHeight}function P(e){return e.clientHeight||e.innerHeight}function H(e){return e.clientWidth||e.innerWidth}function L(e,t,n){window.addEventListener?e.addEventListener(t,n,!1):e.attachEvent("on"+t,n);}function x(e,t,n){window.removeEventListener?e.removeEventListener(t,n,!1):e.detachEvent("on"+t,n);}function I(e){if(e.selectionStart)return e.selectionStart;if(document.selection){e.focus();var t=document.selection.createRange();if(null==t)return 0;var n=e.createTextRange(),o=n.duplicate();return n.moveToBookmark(t.getBookmark()),o.setEndPoint("EndToStart",n),o.text.length}return 0}function j(e){if(e.selectionEnd)return e.selectionEnd;if(document.selection){var t=document.selection.createRange();if(null==t)return 0;return e.createTextRange().text.indexOf(t.text)+t.text.length}return 0}function F(){var e="";return window.getSelection?e=""+window.getSelection():document.selection&&"Control"!==document.selection.type&&(e=document.selection.createRange().text),e}function W(e,t,n){if(void 0===n&&(n=t),e.setSelectionRange){e.focus();try{e.setSelectionRange(t,n);}catch(i){var o=e.parentNode,r=o.style.display;o.style.display="block",e.setSelectionRange(t,n),o.style.display=r;}}else if(e.createTextRange){var i=e.createTextRange();i.collapse(!0),i.moveEnd("character",n),i.moveStart("character",t),i.select();}}function B(){var e=document.createElement("div");e.style.height="200px",e.style.width="100%";var t=document.createElement("div");t.style.boxSizing="content-box",t.style.height="150px",t.style.left="0px",t.style.overflow="hidden",t.style.position="absolute",t.style.top="0px",t.style.width="200px",t.style.visibility="hidden",t.appendChild(e),(document.body||document.documentElement).appendChild(t);var n=e.offsetWidth;t.style.overflow="scroll";var o=e.offsetWidth;return n==o&&(o=t.clientWidth),(document.body||document.documentElement).removeChild(t),n-o}function Y(){return void 0===re&&(re=B()),re}function V(e){return e.offsetWidth!==e.clientWidth}function U(e){return e.offsetHeight!==e.clientHeight}function z(e,t,n){(0, Z.isIE8)()||(0, Z.isIE9)()?(e.style.top=n,e.style.left=t):(0, Z.isSafari)()?e.style["-webkit-transform"]="translate3d("+t+","+n+",0)":e.style.transform="translate3d("+t+","+n+",0)";}function G(e){var t=void 0;return e.style.transform&&""!==(t=e.style.transform)?["transform",t]:e.style["-webkit-transform"]&&""!==(t=e.style["-webkit-transform"])?["-webkit-transform",t]:-1}function K(e){e.style.transform&&""!==e.style.transform?e.style.transform="":e.style["-webkit-transform"]&&""!==e.style["-webkit-transform"]&&(e.style["-webkit-transform"]="");}function X(e){var t=["INPUT","SELECT","TEXTAREA"];return e&&(t.indexOf(e.nodeName)>-1||"true"===e.contentEditable)}function q(e){return X(e)&&-1==e.className.indexOf("handsontableInput")&&-1==e.className.indexOf("copyPaste")}t.__esModule=!0,t.HTML_CHARACTERS=void 0,t.getParent=r,t.closest=i,t.closestDown=a,t.isChildOf=s,t.isChildOfWebComponentTable=l,t.polymerWrap=u,t.polymerUnwrap=c,t.index=h,t.overlayContainsElement=f,t.hasClass=p,t.addClass=g,t.removeClass=v,t.removeTextNodes=m,t.empty=y,t.fastInnerHTML=w,t.fastInnerText=C,t.isVisible=b,t.offset=_,t.getWindowScrollTop=S,t.getWindowScrollLeft=E,t.getScrollTop=O,t.getScrollLeft=T,t.getScrollableElement=k,t.getTrimmingContainer=R,t.getStyle=M,t.getComputedStyle=D,t.outerWidth=A,t.outerHeight=N,t.innerHeight=P,t.innerWidth=H,t.addEvent=L,t.removeEvent=x,t.getCaretPosition=I,t.getSelectionEndPosition=j,t.getSelectionText=F,t.setCaretPosition=W,t.getScrollbarWidth=Y,t.hasVerticalScrollbar=V,t.hasHorizontalScrollbar=U,t.setOverlayPosition=z,t.getCssTransform=G,t.resetCssTransform=K,t.isInput=X,t.isOutsideInput=q;var Z=n(35),$=n(41),J=!!document.documentElement.classList,Q=void 0,ee=void 0,te=void 0;if(J){var ne=function(){var e=document.createElement("div");return e.classList.add("test","test2"),e.classList.contains("test2")}();Q=function(e,t){return void 0!==e.classList&&"string"==typeof t&&""!==t&&e.classList.contains(t)},ee=function(e,t){var n=t;if("string"==typeof n&&(n=n.split(" ")),n=d(n),n.length>0)if(ne){var r;(r=e.classList).add.apply(r,o(n));}else for(var i=0;n&&n[i];)e.classList.add(n[i]),i+=1;},te=function(e,t){var n=t;if("string"==typeof n&&(n=n.split(" ")),n=d(n),n.length>0)if(ne){var r;(r=e.classList).remove.apply(r,o(n));}else for(var i=0;n&&n[i];)e.classList.remove(n[i]),i+=1;};}else{var oe=function(e){return RegExp("(\\s|^)"+e+"(\\s|$)")};Q=function(e,t){return void 0!==e.className&&oe(t).test(e.className)},ee=function(e,t){var n=0,o=e.className,r=t;if("string"==typeof r&&(r=r.split(" ")),""===o)o=r.join(" ");else for(;r&&r[n];)oe(r[n]).test(o)||(o+=" "+r[n]),n+=1;e.className=o;},te=function(e,t){var n=0,o=e.className,r=t;for("string"==typeof r&&(r=r.split(" "));r&&r[n];)o=o.replace(oe(r[n])," ").trim(),n+=1;e.className!==o&&(e.className=o);};}var re,ie=t.HTML_CHARACTERS=/(<(.*)>|&(.*);)/,ae=!!document.createTextNode("test").textContent;},function(e,t,n){function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e){var t=void 0;return Array.isArray(e)?t=[]:(t={},p(e,function(e,n){"__children"!==n&&(t[n]=e&&"object"===(void 0===e?"undefined":w(e))&&!Array.isArray(e)?r(e):Array.isArray(e)?e.length&&"object"===w(e[0])&&!Array.isArray(e[0])?[r(e[0])]:[]:null);})),t}function i(e,t){return t.prototype.constructor=t,e.prototype=new t,e.prototype.constructor=e,e}function a(e,t){return p(t,function(t,n){e[n]=t;}),e}function s(e,t){p(t,function(n,o){t[o]&&"object"===w(t[o])?(e[o]||(e[o]=Array.isArray(t[o])?[]:"[object Date]"===Object.prototype.toString.call(t[o])?t[o]:{}),s(e[o],t[o])):e[o]=t[o];});}function l(e){return "object"===(void 0===e?"undefined":w(e))?JSON.parse(JSON.stringify(e)):e}function u(e){var t={};return p(e,function(e,n){t[n]=e;}),t}function c(e){e.MIXINS||(e.MIXINS=[]);for(var t=arguments.length,n=Array(t>1?t-1:0),o=1;t>o;o++)n[o-1]=arguments[o];return (0, C.arrayEach)(n,function(t){e.MIXINS.push(t.MIXIN_NAME),p(t,function(t,n){if(void 0!==e.prototype[n])throw Error("Mixin conflict. Property '"+n+"' already exist and cannot be overwritten.");if("function"==typeof t)e.prototype[n]=t;else{Object.defineProperty(e.prototype,n,{get:function(e,t){var n="_"+e,o=function(e){var t=e;return (Array.isArray(t)||f(t))&&(t=l(t)),t};return function(){return void 0===this[n]&&(this[n]=o(t)),this[n]}}(n,t),set:function(e){var t="_"+e;return function(e){this[t]=e;}}(n),configurable:!0});}});}),e}function h(e,t){return JSON.stringify(e)===JSON.stringify(t)}function f(e){return "[object Object]"===Object.prototype.toString.call(e)}function d(e,t,n,o){o.value=n,o.writable=!1!==o.writable,o.enumerable=!1!==o.enumerable,o.configurable=!1!==o.configurable,Object.defineProperty(e,t,o);}function p(e,t){for(var n in e)if((!e.hasOwnProperty||e.hasOwnProperty&&Object.prototype.hasOwnProperty.call(e,n))&&!1===t(e[n],n,e))break;return e}function g(e,t){var n=t.split("."),o=e;return p(n,function(e){if(void 0===(o=o[e]))return o=void 0,!1}),o}function v(e){if(!f(e))return 0;return function e(t){var n=0;return f(t)?p(t,function(t){n+=e(t);}):n+=1,n}(e)}function m(e){var t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"value",r="_"+n,i=(t={_touched:!1},o(t,r,e),o(t,"isTouched",function(){return this._touched}),t);return Object.defineProperty(i,n,{get:function(){return this[r]},set:function(e){this._touched=!0,this[r]=e;},enumerable:!0,configurable:!0}),i}function y(e,t){return Object.prototype.hasOwnProperty.call(e,t)}t.__esModule=!0;var w="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};t.duckSchema=r,t.inherit=i,t.extend=a,t.deepExtend=s,t.deepClone=l,t.clone=u,t.mixin=c,t.isObjectEqual=h,t.isObject=f,t.defineGetter=d,t.objectEach=p,t.getProperty=g,t.deepObjectSize=v,t.createObjectPropListener=m,t.hasOwnProperty=y;var C=n(2);},function(e,t,n){function o(e){for(var t=e.length,n=0;t>n;)e[n]=[e[n]],n+=1;}function r(e,t){for(var n=t.length,o=0;n>o;)e.push(t[o]),o+=1;}function i(e){var t=[];if(!e||0===e.length||!e[0]||0===e[0].length)return t;for(var n=e.length,o=e[0].length,r=0;n>r;r++)for(var i=0;o>i;i++)t[i]||(t[i]=[]),t[i][r]=e[r][i];return t}function a(e,t,n,o){var r=-1,i=e,a=n;Array.isArray(e)||(i=Array.from(e));var s=i.length;for(o&&s&&(r+=1,a=i[r]),r+=1;s>r;)a=t(a,i[r],r,i),r+=1;return a}function s(e,t){var n=0,o=e;Array.isArray(e)||(o=Array.from(e));for(var r=o.length,i=[],a=-1;r>n;){var s=o[n];t(s,n,o)&&(a+=1,i[a]=s),n+=1;}return i}function l(e,t){var n=0,o=e;Array.isArray(e)||(o=Array.from(e));for(var r=o.length,i=[],a=-1;r>n;){var s=o[n];a+=1,i[a]=t(s,n,o),n+=1;}return i}function u(e,t){var n=0,o=e;Array.isArray(e)||(o=Array.from(e));for(var r=o.length;r>n&&!1!==t(o[n],n,o);)n+=1;return e}function c(e){return a(e,function(e,t){return e+t},0)}function h(e){return a(e,function(e,t){return e>t?e:t},Array.isArray(e)?e[0]:void 0)}function f(e){return a(e,function(e,t){return t>e?e:t},Array.isArray(e)?e[0]:void 0)}function d(e){return e.length?c(e)/e.length:0}function p(e){return a(e,function(e,t){return e.concat(Array.isArray(t)?p(t):t)},[])}function g(e){var t=[];return u(e,function(e){-1===t.indexOf(e)&&t.push(e);}),t}t.__esModule=!0,t.to2dArray=o,t.extendArray=r,t.pivot=i,t.arrayReduce=a,t.arrayFilter=s,t.arrayMap=l,t.arrayEach=u,t.arraySum=c,t.arrayMax=h,t.arrayMin=f,t.arrayAvg=d,t.arrayFlatten=p,t.arrayUnique=g;},function(e,t,n){var o=n(15),r=n(40),i=n(30),a=n(29),s=n(31),l=function(e,t,n){var u,c,h,f,d=e&l.F,p=e&l.G,g=e&l.S,v=e&l.P,m=e&l.B,y=p?o:g?o[t]||(o[t]={}):(o[t]||{}).prototype,w=p?r:r[t]||(r[t]={}),C=w.prototype||(w.prototype={});p&&(n=t);for(u in n)c=!d&&y&&void 0!==y[u],h=(c?y:n)[u],f=m&&c?s(h,o):v&&"function"==typeof h?s(Function.call,h):h,y&&a(y,u,h,e&l.U),w[u]!=h&&i(w,u,f),v&&C[u]!=h&&(C[u]=h);};o.core=r,l.F=1,l.G=2,l.S=4,l.P=8,l.B=16,l.W=32,l.U=64,l.R=128,e.exports=l;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0,t.Viewport=t.TableRenderer=t.Table=t.Settings=t.Selection=t.Scroll=t.Overlays=t.Event=t.Core=t.default=t.Border=t.BottomLeftCornerOverlay=t.BottomOverlay=t.TopLeftCornerOverlay=t.TopOverlay=t.LeftOverlay=t.DebugOverlay=t.RowFilter=t.ColumnFilter=t.CellRange=t.CellCoords=t.ViewportRowsCalculator=t.ViewportColumnsCalculator=void 0,n(99),n(114),n(115),n(119),n(120),n(122),n(125),n(126),n(127),n(128),n(129),n(130),n(131),n(132),n(133),n(134),n(135),n(136),n(137),n(138),n(139),n(140),n(141),n(142),n(144),n(146),n(147),n(148),n(149),n(150),n(151),n(152),n(153),n(154),n(155),n(156),n(157),n(158),n(88),n(159),n(160),n(162),n(163),n(164),n(165),n(166),n(167),n(168),n(170),n(171),n(172),n(174),n(175),n(176);var r=n(177),i=o(r),a=n(178),s=o(a),l=n(57),u=o(l),c=n(179),h=o(c),f=n(180),d=o(f),p=n(181),g=o(p),v=n(475),m=o(v),y=n(477),w=o(y),C=n(478),b=o(C),_=n(479),S=o(_),E=n(480),O=o(E),T=n(481),k=o(T),R=n(310),M=o(R),D=n(182),A=o(D),N=n(303),P=o(N),H=n(304),L=o(H),x=n(305),I=o(x),j=n(482),F=o(j),W=n(306),B=o(W),Y=n(307),V=o(Y),U=n(308),z=o(U),G=n(309),K=o(G);t.ViewportColumnsCalculator=i.default,t.ViewportRowsCalculator=s.default,t.CellCoords=u.default,t.CellRange=h.default,t.ColumnFilter=d.default,t.RowFilter=g.default,t.DebugOverlay=m.default,t.LeftOverlay=w.default,t.TopOverlay=b.default,t.TopLeftCornerOverlay=S.default,t.BottomOverlay=O.default,t.BottomLeftCornerOverlay=k.default,t.Border=M.default,t.default=A.default,t.Core=A.default,t.Event=P.default,t.Overlays=L.default,t.Scroll=I.default,t.Selection=F.default,t.Settings=B.default,t.Table=V.default,t.TableRenderer=z.default,t.Viewport=K.default;},function(e,t,n){function o(e){var t=void 0===e?"undefined":s(e);return "number"==t?!isNaN(e)&&isFinite(e):"string"==t?!!e.length&&(1==e.length?/\d/.test(e):/^\s*[+-]?\s*(?:(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?)|(?:0x[a-f\d]+))\s*$/i.test(e)):"object"==t&&!(!e||"number"!=typeof e.valueOf()||e instanceof Date)}function r(e,t,n){var o=-1;for("function"==typeof t?(n=t,t=e):o=e-1;++o<=t&&!1!==n(o););}function i(e,t,n){var o=e+1;for("function"==typeof t&&(n=t,t=0);--o>=t&&!1!==n(o););}function a(e,t){return t=parseInt((""+t).replace("%",""),10),t=parseInt(e*t/100,10)}t.__esModule=!0;var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};t.isNumeric=o,t.rangeEach=r,t.rangeEachReverse=i,t.valueAccordingPercent=a;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){var n=void 0,o=void 0,r=void 0,i=void 0,a=void 0;t.isTargetWebComponent=!1,t.realTarget=t.target;var h=t.stopImmediatePropagation;if(t.stopImmediatePropagation=function(){h.apply(this),(0, c.stopImmediatePropagation)(this);},!f.isHotTableEnv)return t;for(t=(0, s.polymerWrap)(t),a=t.path?t.path.length:0;a;){if(a-=1,"HOT-TABLE"===t.path[a].nodeName)n=!0;else if(n&&t.path[a].shadowRoot){i=t.path[a];break}0!==a||i||(i=t.path[a]);}return i||(i=t.target),t.isTargetWebComponent=!0,(0, u.isWebComponentSupportedNatively)()?t.realTarget=t.srcElement||t.toElement:((0, l.hasOwnProperty)(e,"hot")||e.isHotTableEnv||e.wtTable)&&((0, l.hasOwnProperty)(e,"hot")?o=e.hot?e.hot.view.wt.wtTable.TABLE:null:e.isHotTableEnv?o=e.view.activeWt.wtTable.TABLE.parentNode.parentNode:e.wtTable&&(o=e.wtTable.TABLE.parentNode.parentNode),r=(0, s.closest)(t.target,["HOT-TABLE"],o),t.realTarget=r?o.querySelector("HOT-TABLE")||t.target:t.target),Object.defineProperty(t,"target",{get:function(){return (0, s.polymerWrap)(i)},enumerable:!0,configurable:!0}),t}function i(){return h}t.__esModule=!0;var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}();t.getListenersCounter=i;var s=n(0),l=n(1),u=n(41),c=n(12),h=0,f=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;o(this,e),this.context=t||this,this.context.eventListeners||(this.context.eventListeners=[]);}return a(e,[{key:"addEventListener",value:function(e,t,n){function o(e){n.call(this,r(a,e));}var i=this,a=this.context;return this.context.eventListeners.push({element:e,event:t,callback:n,callbackProxy:o}),window.addEventListener?e.addEventListener(t,o,!1):e.attachEvent("on"+t,o),h+=1,function(){i.removeEventListener(e,t,n);}}},{key:"removeEventListener",value:function(e,t,n){for(var o=this.context.eventListeners.length,r=void 0;o;)if(o-=1,r=this.context.eventListeners[o],r.event===t&&r.element===e){if(n&&n!==r.callback)continue;this.context.eventListeners.splice(o,1),r.element.removeEventListener?r.element.removeEventListener(r.event,r.callbackProxy,!1):r.element.detachEvent("on"+r.event,r.callbackProxy),h-=1;}}},{key:"clearEvents",value:function(){if(this.context)for(var e=this.context.eventListeners.length;e;){e-=1;var t=this.context.eventListeners[e];t&&this.removeEventListener(t.element,t.event,t.callback);}}},{key:"clear",value:function(){this.clearEvents();}},{key:"destroy",value:function(){this.clearEvents(),this.context=null;}},{key:"fireEvent",value:function(e,t){var n={bubbles:!0,cancelable:"mousemove"!==t,view:window,detail:0,screenX:0,screenY:0,clientX:1,clientY:1,ctrlKey:!1,altKey:!1,shiftKey:!1,metaKey:!1,button:0,relatedTarget:void 0},o=void 0;document.createEvent?(o=document.createEvent("MouseEvents"),o.initMouseEvent(t,n.bubbles,n.cancelable,n.view,n.detail,n.screenX,n.screenY,n.clientX,n.clientY,n.ctrlKey,n.altKey,n.shiftKey,n.metaKey,n.button,document.body.parentNode)):o=document.createEventObject(),e.dispatchEvent?e.dispatchEvent(o):e.fireEvent("on"+t,o);}}]),e}();t.default=f;},function(e,t,n){t.__esModule=!0;var o=t.CONTEXT_MENU_ITEMS_NAMESPACE="ContextMenu:items",r=(t.CONTEXTMENU_ITEMS_ROW_ABOVE=o+".insertRowAbove",t.CONTEXTMENU_ITEMS_ROW_BELOW=o+".insertRowBelow",t.CONTEXTMENU_ITEMS_INSERT_LEFT=o+".insertColumnOnTheLeft",t.CONTEXTMENU_ITEMS_INSERT_RIGHT=o+".insertColumnOnTheRight",t.CONTEXTMENU_ITEMS_REMOVE_ROW=o+".removeRow",t.CONTEXTMENU_ITEMS_REMOVE_COLUMN=o+".removeColumn",t.CONTEXTMENU_ITEMS_UNDO=o+".undo",t.CONTEXTMENU_ITEMS_REDO=o+".redo",t.CONTEXTMENU_ITEMS_READ_ONLY=o+".readOnly",t.CONTEXTMENU_ITEMS_CLEAR_COLUMN=o+".clearColumn",t.CONTEXTMENU_ITEMS_COPY=o+".copy",t.CONTEXTMENU_ITEMS_CUT=o+".cut",t.CONTEXTMENU_ITEMS_FREEZE_COLUMN=o+".freezeColumn",t.CONTEXTMENU_ITEMS_UNFREEZE_COLUMN=o+".unfreezeColumn",t.CONTEXTMENU_ITEMS_MERGE_CELLS=o+".mergeCells",t.CONTEXTMENU_ITEMS_UNMERGE_CELLS=o+".unmergeCells",t.CONTEXTMENU_ITEMS_ADD_COMMENT=o+".addComment",t.CONTEXTMENU_ITEMS_EDIT_COMMENT=o+".editComment",t.CONTEXTMENU_ITEMS_REMOVE_COMMENT=o+".removeComment",t.CONTEXTMENU_ITEMS_READ_ONLY_COMMENT=o+".readOnlyComment",t.CONTEXTMENU_ITEMS_ALIGNMENT=o+".align",t.CONTEXTMENU_ITEMS_ALIGNMENT_LEFT=o+".align.left",t.CONTEXTMENU_ITEMS_ALIGNMENT_CENTER=o+".align.center",t.CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT=o+".align.right",t.CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY=o+".align.justify",t.CONTEXTMENU_ITEMS_ALIGNMENT_TOP=o+".align.top",t.CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE=o+".align.middle",t.CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM=o+".align.bottom",t.CONTEXTMENU_ITEMS_BORDERS=o+".borders",t.CONTEXTMENU_ITEMS_BORDERS_TOP=o+".borders.top",t.CONTEXTMENU_ITEMS_BORDERS_RIGHT=o+".borders.right",t.CONTEXTMENU_ITEMS_BORDERS_BOTTOM=o+".borders.bottom",t.CONTEXTMENU_ITEMS_BORDERS_LEFT=o+".borders.left",t.CONTEXTMENU_ITEMS_REMOVE_BORDERS=o+".borders.remove",t.CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD=o+".nestedHeaders.insertChildRow",t.CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD=o+".nestedHeaders.detachFromParent",t.CONTEXTMENU_ITEMS_HIDE_COLUMN=o+".hideColumn",t.CONTEXTMENU_ITEMS_SHOW_COLUMN=o+".showColumn",t.CONTEXTMENU_ITEMS_HIDE_ROW=o+".hideRow",t.CONTEXTMENU_ITEMS_SHOW_ROW=o+".showRow",t.FILTERS_NAMESPACE="Filters:"),i=t.FILTERS_CONDITIONS_NAMESPACE=r+"conditions";t.FILTERS_CONDITIONS_NONE=i+".none",t.FILTERS_CONDITIONS_EMPTY=i+".isEmpty",t.FILTERS_CONDITIONS_NOT_EMPTY=i+".isNotEmpty",t.FILTERS_CONDITIONS_EQUAL=i+".isEqualTo",t.FILTERS_CONDITIONS_NOT_EQUAL=i+".isNotEqualTo",t.FILTERS_CONDITIONS_BEGINS_WITH=i+".beginsWith",t.FILTERS_CONDITIONS_ENDS_WITH=i+".endsWith",t.FILTERS_CONDITIONS_CONTAINS=i+".contains",t.FILTERS_CONDITIONS_NOT_CONTAIN=i+".doesNotContain",t.FILTERS_CONDITIONS_BY_VALUE=i+".byValue",t.FILTERS_CONDITIONS_GREATER_THAN=i+".greaterThan",t.FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL=i+".greaterThanOrEqualTo",t.FILTERS_CONDITIONS_LESS_THAN=i+".lessThan",t.FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL=i+".lessThanOrEqualTo",t.FILTERS_CONDITIONS_BETWEEN=i+".isBetween",t.FILTERS_CONDITIONS_NOT_BETWEEN=i+".isNotBetween",t.FILTERS_CONDITIONS_AFTER=i+".after",t.FILTERS_CONDITIONS_BEFORE=i+".before",t.FILTERS_CONDITIONS_TODAY=i+".today",t.FILTERS_CONDITIONS_TOMORROW=i+".tomorrow",t.FILTERS_CONDITIONS_YESTERDAY=i+".yesterday",t.FILTERS_DIVS_FILTER_BY_CONDITION=r+"labels.filterByCondition",t.FILTERS_DIVS_FILTER_BY_VALUE=r+"labels.filterByValue",t.FILTERS_LABELS_CONJUNCTION=r+"labels.conjunction",t.FILTERS_LABELS_DISJUNCTION=r+"labels.disjunction",t.FILTERS_VALUES_BLANK_CELLS=r+"values.blankCells",t.FILTERS_BUTTONS_SELECT_ALL=r+"buttons.selectAll",t.FILTERS_BUTTONS_CLEAR=r+"buttons.clear",t.FILTERS_BUTTONS_OK=r+"buttons.ok",t.FILTERS_BUTTONS_CANCEL=r+"buttons.cancel",t.FILTERS_BUTTONS_PLACEHOLDER_SEARCH=r+"buttons.placeholder.search",t.FILTERS_BUTTONS_PLACEHOLDER_VALUE=r+"buttons.placeholder.value",t.FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE=r+"buttons.placeholder.secondValue";},function(e,t,n){function o(e,t){var n=(0, c.toUpperCaseFirst)(e);l.default.getSingleton().add("construct",function(){h.has(this)||h.set(this,{});var e=h.get(this);e[n]||(e[n]=new t(this));}),l.default.getSingleton().add("afterDestroy",function(){if(h.has(this)){var e=h.get(this);(0, u.objectEach)(e,function(e){return e.destroy()}),h.delete(this);}});}function r(e,t){if("string"!=typeof t)throw Error('Only strings can be passed as "plugin" parameter');var n=(0, c.toUpperCaseFirst)(t);if(h.has(e)&&h.get(e)[n])return h.get(e)[n]}function i(e){return h.has(e)?Object.keys(h.get(e)):[]}function a(e,t){var n=null;return h.has(e)&&(0, u.objectEach)(h.get(e),function(e,o){e===t&&(n=o);}),n}t.__esModule=!0,t.getPluginName=t.getRegistredPluginNames=t.getPlugin=t.registerPlugin=void 0;var s=n(16),l=function(e){return e&&e.__esModule?e:{default:e}}(s),u=n(1),c=n(36),h=new WeakMap;t.registerPlugin=o,t.getPlugin=r,t.getRegistredPluginNames=i,t.getPluginName=a;},function(e,t){e.exports=function(e){return "object"==typeof e?null!==e:"function"==typeof e};},function(e,t,n){function o(e){var t=void 0;switch(void 0===e?"undefined":c(e)){case"string":case"number":t=""+e;break;case"object":t=null===e?"":""+e;break;case"undefined":t="";break;default:t=""+e;}return t}function r(e){return void 0!==e}function i(e){return void 0===e}function a(e){return null===e||""===e||i(e)}function s(e){return "[object RegExp]"===Object.prototype.toString.call(e)}function l(e,t){e=C(e||"");var n="",o=!0,r=u(e),i=_(),s=a(e)||"trial"===e;if(s||r)if(r){var l=Math.floor((0, d.default)("14/11/2018","DD/MM/YYYY").toDate().getTime()/864e5),c=b(e);(c>45e3||c!==parseInt(c,10))&&(n="The license key provided to Handsontable Pro is invalid. Make sure you pass it correctly."),n||(l>c+1&&(n=(0, p.toSingleLine)(h)),o=l>c+15);}else n="Evaluation version of Handsontable Pro. Not licensed for use in a production environment.";else n="The license key provided to Handsontable Pro is invalid. Make sure you pass it correctly.";if(i&&(n=!1,o=!1),n&&!S&&(console[s?"info":"warn"](n),S=!0),o&&t.parentNode){var f=document.createElement("div");f.id="hot-display-license-info",f.appendChild(document.createTextNode("Evaluation version of Handsontable Pro.")),f.appendChild(document.createElement("br")),f.appendChild(document.createTextNode("Not licensed for production use.")),t.parentNode.insertBefore(f,t.nextSibling);}}function u(e){var t=[][g],n=t;if(e[g]!==w("Z"))return !1;for(var o="",r="B<H4P+".split(""),i=w(r.shift());i;i=w(r.shift()||"A"))--i<""[g]?n|=(m(""+m(v(o)+(v(y(e,Math.abs(i),2))+[]).padStart(2,"0")))%97||2)>>1:o=y(e,i,i?1===r[g]?9:8:6);return n===t}t.__esModule=!0;var c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},h=function(e,t){return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}(["\n          Your license key of Handsontable Pro has expired. \n          Renew your maintenance plan at https://handsontable.com or downgrade to the previous version of the software.\n          "],["\n          Your license key of Handsontable Pro has expired. \n          Renew your maintenance plan at https://handsontable.com or downgrade to the previous version of the software.\n          "]);t.stringify=o,t.isDefined=r,t.isUndefined=i,t.isEmpty=a,t.isRegExp=s,t._injectProductInfo=l;var f=n(47),d=function(e){return e&&e.__esModule?e:{default:e}}(f),p=n(42),g="length",v=function(e){return parseInt(e,16)},m=function(e){return parseInt(e,10)},y=function(e,t,n){return e.substr(t,n)},w=function(e){return e.codePointAt(0)-65},C=function(e){return (""+e).replace(/\-/g,"")},b=function(e){return v(y(C(e),v("12"),w("F")))/(v(y(C(e),w("B"),~~![][g]))||9)},_=function(){return "undefined"!=typeof location&&/^([a-z0-9\-]+\.)?\x68\x61\x6E\x64\x73\x6F\x6E\x74\x61\x62\x6C\x65\x2E\x63\x6F\x6D$/i.test(location.host)},S=!1;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(1),a=n(2),s=n(440),l=n(8),u=new WeakMap,c=null;t.default=function(){function e(t){var n=this;o(this,e),(0, i.defineGetter)(this,"hot",t,{writable:!1}),(0, i.defineGetter)(this,"t",(0, s.getTranslator)(t),{writable:!1}),u.set(this,{hooks:{}}),c=null,this.pluginName=null,this.pluginsInitializedCallbacks=[],this.isPluginsReady=!1,this.enabled=!1,this.initialized=!1,this.hot.addHook("afterPluginsInitialized",function(){return n.onAfterPluginsInitialized()}),this.hot.addHook("afterUpdateSettings",function(e){return n.onUpdateSettings(e)}),this.hot.addHook("beforeInit",function(){return n.init()});}return r(e,[{key:"init",value:function(){this.pluginName=(0, l.getPluginName)(this.hot,this),this.isEnabled&&this.isEnabled()&&this.enablePlugin(),c||(c=(0, l.getRegistredPluginNames)(this.hot)),0>c.indexOf(this.pluginName)||c.splice(c.indexOf(this.pluginName),1),c.length||this.hot.runHooks("afterPluginsInitialized"),this.initialized=!0;}},{key:"enablePlugin",value:function(){this.enabled=!0;}},{key:"disablePlugin",value:function(){this.eventManager&&this.eventManager.clear(),this.clearHooks(),this.enabled=!1;}},{key:"addHook",value:function(e,t){u.get(this).hooks[e]=u.get(this).hooks[e]||[];var n=u.get(this).hooks[e];this.hot.addHook(e,t),n.push(t),u.get(this).hooks[e]=n;}},{key:"removeHooks",value:function(e){var t=this;(0, a.arrayEach)(u.get(this).hooks[e]||[],function(n){t.hot.removeHook(e,n);});}},{key:"clearHooks",value:function(){var e=this,t=u.get(this).hooks;(0, i.objectEach)(t,function(t,n){return e.removeHooks(n)}),t.length=0;}},{key:"callOnPluginsReady",value:function(e){this.isPluginsReady?e():this.pluginsInitializedCallbacks.push(e);}},{key:"onAfterPluginsInitialized",value:function(){(0, a.arrayEach)(this.pluginsInitializedCallbacks,function(e){return e()}),this.pluginsInitializedCallbacks.length=0,this.isPluginsReady=!0;}},{key:"onUpdateSettings",value:function(){this.isEnabled&&(this.enabled&&!this.isEnabled()&&this.disablePlugin(),!this.enabled&&this.isEnabled()&&this.enablePlugin(),this.enabled&&this.isEnabled()&&this.updatePlugin());}},{key:"updatePlugin",value:function(){}},{key:"destroy",value:function(){var e=this;this.eventManager&&this.eventManager.destroy(),this.clearHooks(),(0, i.objectEach)(this,function(t,n){"hot"!==n&&"t"!==n&&(e[n]=null);}),delete this.t,delete this.hot;}}]),e}();},function(e,t,n){function o(e){e.isImmediatePropagationEnabled=!1,e.cancelBubble=!0;}function r(e){return !1===e.isImmediatePropagationEnabled}function i(e){"function"==typeof e.stopPropagation?e.stopPropagation():e.cancelBubble=!0;}function a(e){return e.pageX?e.pageX:e.clientX+(0, c.getWindowScrollLeft)()}function s(e){return e.pageY?e.pageY:e.clientY+(0, c.getWindowScrollTop)()}function l(e){return 2===e.button}function u(e){return 0===e.button}t.__esModule=!0,t.stopImmediatePropagation=o,t.isImmediatePropagationStopped=r,t.stopPropagation=i,t.pageX=a,t.pageY=s,t.isRightClick=l,t.isLeftClick=u;var c=n(0);},function(e,t,n){var o=n(79)("wks"),r=n(51),i=n(15).Symbol,a="function"==typeof i;(e.exports=function(e){return o[e]||(o[e]=a&&i[e]||(a?i:r)("Symbol."+e))}).store=o;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e){if("function"==typeof e)return e;if(!E(e))throw Error('No registered renderer found under "'+e+'" name');return S(e)}t.__esModule=!0,t.getRegisteredRenderers=t.getRegisteredRendererNames=t.hasRenderer=t.getRenderer=t.registerRenderer=void 0;var i=n(34),a=o(i),s=n(494),l=o(s),u=n(495),c=o(u),h=n(496),f=o(h),d=n(497),p=o(d),g=n(498),v=o(g),m=n(499),y=o(m),w=n(500),C=o(w),b=(0, a.default)("renderers"),_=b.register,S=b.getItem,E=b.hasItem,O=b.getNames,T=b.getValues;_("base",l.default),_("autocomplete",c.default),_("checkbox",f.default),_("html",p.default),_("numeric",v.default),_("password",y.default),_("text",C.default),t.registerRenderer=_,t.getRenderer=r,t.hasRenderer=E,t.getRegisteredRendererNames=O,t.getRegisteredRenderers=T;},function(e,t){var n=e.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=n);},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(){return c}t.__esModule=!0;var i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(2),s=n(1),l=["afterCellMetaReset","afterChange","afterChangesObserved","afterContextMenuDefaultOptions","beforeContextMenuSetItems","afterDropdownMenuDefaultOptions","beforeDropdownMenuSetItems","afterContextMenuHide","beforeContextMenuShow","afterContextMenuShow","afterCopyLimit","beforeCreateCol","afterCreateCol","beforeCreateRow","afterCreateRow","afterDeselect","afterDestroy","afterDocumentKeyDown","afterDrawSelection","beforeRemoveCellClassNames","afterGetCellMeta","afterGetColHeader","afterGetRowHeader","afterInit","afterLoadData","afterMomentumScroll","afterOnCellCornerMouseDown","afterOnCellCornerDblClick","afterOnCellMouseDown","afterOnCellMouseUp","afterOnCellContextMenu","afterOnCellMouseOver","afterOnCellMouseOut","afterRemoveCol","afterRemoveRow","afterRender","beforeRenderer","afterRenderer","afterScrollHorizontally","afterScrollVertically","afterSelection","afterSelectionByProp","afterSelectionEnd","afterSelectionEndByProp","afterSetCellMeta","afterRemoveCellMeta","afterSetDataAtCell","afterSetDataAtRowProp","afterUpdateSettings","afterValidate","beforeLanguageChange","afterLanguageChange","beforeAutofill","beforeCellAlignment","beforeChange","beforeChangeRender","beforeDrawBorders","beforeGetCellMeta","beforeRemoveCellMeta","beforeInit","beforeInitWalkontable","beforeKeyDown","beforeOnCellMouseDown","beforeOnCellMouseUp","beforeOnCellContextMenu","beforeOnCellMouseOver","beforeOnCellMouseOut","beforeRemoveCol","beforeRemoveRow","beforeRender","beforeSetRangeStartOnly","beforeSetRangeStart","beforeSetRangeEnd","beforeTouchScroll","beforeValidate","beforeValueRender","construct","init","modifyCol","unmodifyCol","unmodifyRow","modifyColHeader","modifyColWidth","modifyRow","modifyRowHeader","modifyRowHeight","modifyData","modifyRowData","modifyGetCellCoords","persistentStateLoad","persistentStateReset","persistentStateSave","beforeColumnSort","afterColumnSort","modifyAutofillRange","modifyCopyableRange","beforeCut","afterCut","beforeCopy","afterCopy","beforePaste","afterPaste","beforeColumnMove","afterColumnMove","beforeRowMove","afterRowMove","beforeColumnResize","afterColumnResize","beforeRowResize","afterRowResize","afterGetColumnHeaderRenderers","afterGetRowHeaderRenderers","beforeStretchingColumnWidth","beforeFilter","afterFilter","modifyColumnHeaderHeight","beforeUndo","afterUndo","beforeRedo","afterRedo","modifyRowHeaderWidth","beforeAutofillInsidePopulate","modifyTransformStart","modifyTransformEnd","afterModifyTransformStart","afterModifyTransformEnd","afterViewportRowCalculatorOverride","afterViewportColumnCalculatorOverride","afterPluginsInitialized","skipLengthCache","afterTrimRow","afterUntrimRow","beforeDropdownMenuShow","afterDropdownMenuShow","afterDropdownMenuHide","hiddenRow","hiddenColumn","beforeAddChild","afterAddChild","beforeDetachChild","afterDetachChild","afterBeginEditing","beforeMergeCells","afterMergeCells","beforeUnmergeCells","afterUnmergeCells","afterListen","afterUnlisten"],u=function(){function e(){o(this,e),this.globalBucket=this.createEmptyBucket();}return i(e,null,[{key:"getSingleton",value:function(){return r()}}]),i(e,[{key:"createEmptyBucket",value:function(){var e=Object.create(null);return (0, a.arrayEach)(l,function(t){return e[t]=[]}),e}},{key:"getBucket",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return e?(e.pluginHookBucket||(e.pluginHookBucket=this.createEmptyBucket()),e.pluginHookBucket):this.globalBucket}},{key:"add",value:function(e,t){var n=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(Array.isArray(t))(0, a.arrayEach)(t,function(t){return n.add(e,t,o)});else{var r=this.getBucket(o);if(void 0===r[e]&&(this.register(e),r[e]=[]),t.skip=!1,-1===r[e].indexOf(t)){var i=!1;t.initialHook&&(0, a.arrayEach)(r[e],function(n,o){if(n.initialHook)return r[e][o]=t,i=!0,!1}),i||r[e].push(t);}}return this}},{key:"once",value:function(e,t){var n=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;Array.isArray(t)?(0, a.arrayEach)(t,function(t){return n.once(e,t,o)}):(t.runOnce=!0,this.add(e,t,o));}},{key:"remove",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=this.getBucket(n);return void 0!==o[e]&&o[e].indexOf(t)>=0&&(t.skip=!0,!0)}},{key:"has",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=this.getBucket(t);return !(void 0===n[e]||!n[e].length)}},{key:"run",value:function(e,t,n,o,r,i,a,s){var l=this.globalBucket[t],u=l?l.length:0,c=0;if(u)for(;u>c;)if(l[c]&&!l[c].skip){var h=l[c].call(e,n,o,r,i,a,s);void 0!==h&&(n=h),l[c]&&l[c].runOnce&&this.remove(t,l[c]),c+=1;}else c+=1;var f=this.getBucket(e)[t],d=f?f.length:0,p=0;if(d)for(;d>p;)if(f[p]&&!f[p].skip){var g=f[p].call(e,n,o,r,i,a,s);void 0!==g&&(n=g),f[p]&&f[p].runOnce&&this.remove(t,f[p],e),p+=1;}else p+=1;return n}},{key:"destroy",value:function(){(0, s.objectEach)(this.getBucket(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null),function(e,t,n){return n[t].length=0});}},{key:"register",value:function(e){this.isRegistered(e)||l.push(e);}},{key:"deregister",value:function(e){this.isRegistered(e)&&l.splice(l.indexOf(e),1);}},{key:"isRegistered",value:function(e){return l.indexOf(e)>=0}},{key:"getRegistered",value:function(){return l}}]),e}(),c=new u;t.default=u;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e){var t={},n=e;this.getConstructor=function(){return e},this.getInstance=function(e){return e.guid in t||(t[e.guid]=new n(e)),t[e.guid]},h.default.getSingleton().add("afterDestroy",function(){t[this.guid]=null;});}function i(e,t){var n=void 0;if("function"==typeof e)N.get(e)||s(null,e),n=N.get(e);else{if("string"!=typeof e)throw Error('Only strings and functions can be passed as "editor" parameter');n=L(e);}if(!n)throw Error('No editor registered under name "'+e+'"');return n.getInstance(t)}function a(e){if(!x(e))throw Error('No registered editor found under "'+e+'" name');return L(e).getConstructor()}function s(e,t){var n=new r(t);"string"==typeof e&&H(e,n),N.set(t,n);}t.__esModule=!0,t.getRegisteredEditors=t.getRegisteredEditorNames=t.hasEditor=t.getEditorInstance=t.getEditor=t.registerEditor=void 0,t.RegisteredEditor=r,t._getEditorInstance=i;var l=n(34),u=o(l),c=n(16),h=o(c),f=n(56),d=o(f),p=n(311),g=o(p),v=n(484),m=o(v),y=n(485),w=o(y),C=n(490),b=o(C),_=n(312),S=o(_),E=n(491),O=o(E),T=n(492),k=o(T),R=n(493),M=o(R),D=n(59),A=o(D),N=new WeakMap,P=(0, u.default)("editors"),H=P.register,L=P.getItem,x=P.hasItem,I=P.getNames,j=P.getValues;s("base",d.default),s("autocomplete",g.default),s("checkbox",m.default),s("date",w.default),s("dropdown",b.default),s("handsontable",S.default),s("numeric",O.default),s("password",k.default),s("select",M.default),s("text",A.default),t.registerEditor=s,t.getEditor=a,t.getEditorInstance=i,t.hasEditor=x,t.getRegisteredEditorNames=I,t.getRegisteredEditors=j;},function(e,t,n){var o=n(9);e.exports=function(e){if(!o(e))throw TypeError(e+" is not an object!");return e};},function(e,t,n){function o(e){return (0, b.arrayMap)(e,function(e){return {start:e.getTopLeftCorner(),end:e.getBottomRightCorner()}})}function r(e){return (0, _.hasClass)(e,"htSeparator")}function i(e){return (0, _.hasClass)(e,"htSubmenu")}function a(e){return (0, _.hasClass)(e,"htDisabled")}function s(e){return (0, _.hasClass)(e,"htSelectionDisabled")}function l(e){var t=e.getSelected();return t?0>t[0]?null:t:null}function u(e,t){return -1!==e.indexOf(t)?e:e.replace("htTop","").replace("htMiddle","").replace("htBottom","").replace("  ","")+" "+t}function c(e,t){return -1!==e.indexOf(t)?e:e.replace("htLeft","").replace("htCenter","").replace("htRight","").replace("htJustify","").replace("  ","")+" "+t}function h(e,t){var n={};return (0, b.arrayEach)(e,function(e){for(var o=e.from,r=e.to,i=o.row;r.row>=i;i++)for(var a=o.col;r.col>=a;a++)n[i]||(n[i]=[]),n[i][a]=t(i,a);}),n}function f(e,t,n,o,r){(0, b.arrayEach)(e,function(e){var i=e.from,a=e.to;if(i.row===a.row&&i.col===a.col)d(i.row,i.col,t,n,o,r);else for(var s=i.row;a.row>=s;s++)for(var l=i.col;a.col>=l;l++)d(s,l,t,n,o,r);});}function d(e,t,n,o,r,i){var a=r(e,t),s=o;a.className&&(s="vertical"===n?u(a.className,o):c(a.className,o)),i(e,t,"className",s);}function p(e,t){var n=!1;return Array.isArray(e)&&(0, b.arrayEach)(e,function(e){return e.forAll(function(e,o){if(t(e,o))return n=!0,!1}),n}),n}function g(e){return '<span class="selected">'+String.fromCharCode(10003)+"</span>"+e}function v(e,t){return !e.hidden||!("function"==typeof e.hidden&&e.hidden.call(t))}function m(e,t){for(var n=e.slice(0);n.length>0&&n[0].name===t;)n.shift();return n}function y(e,t){var n=e.slice(0);return n.reverse(),n=m(n,t),n.reverse(),n}function w(e){var t=[];return (0, b.arrayEach)(e,function(e,n){n>0?t[t.length-1].name!==e.name&&t.push(e):t.push(e);}),t}function C(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:S.KEY,n=e.slice(0);return n=m(n,t),n=y(n,t),n=w(n)}t.__esModule=!0,t.normalizeSelection=o,t.isSeparator=r,t.hasSubMenu=i,t.isDisabled=a,t.isSelectionDisabled=s,t.getValidSelection=l,t.prepareVerticalAlignClass=u,t.prepareHorizontalAlignClass=c,t.getAlignmentClasses=h,t.align=f,t.checkSelectionConsistency=p,t.markLabelAsSelected=g,t.isItemHidden=v,t.filterSeparators=C;var b=n(2),_=n(0),S=n(96);},function(e,t,n){var o=n(18),r=n(101),i=n(75),a=Object.defineProperty;t.f=n(22)?Object.defineProperty:function(e,t,n){if(o(e),t=i(t,!0),o(n),r)try{return a(e,t,n)}catch(e){}if("get"in n||"set"in n)throw TypeError("Accessors not supported!");return "value"in n&&(e[t]=n.value),e};},function(e,t,n){function o(e){return 32===e||e>=48&&57>=e||e>=96&&111>=e||e>=186&&192>=e||e>=219&&222>=e||e>=226||e>=65&&90>=e}function r(e){return -1!==[u.ARROW_DOWN,u.ARROW_UP,u.ARROW_LEFT,u.ARROW_RIGHT,u.HOME,u.END,u.DELETE,u.BACKSPACE,u.F1,u.F2,u.F3,u.F4,u.F5,u.F6,u.F7,u.F8,u.F9,u.F10,u.F11,u.F12,u.TAB,u.PAGE_DOWN,u.PAGE_UP,u.ENTER,u.ESCAPE,u.SHIFT,u.CAPS_LOCK,u.ALT].indexOf(e)}function i(e){var t=[];return window.navigator.platform.includes("Mac")?t.push(u.COMMAND_LEFT,u.COMMAND_RIGHT,u.COMMAND_FIREFOX):t.push(u.CONTROL),t.includes(e)}function a(e){return [u.CONTROL,u.COMMAND_LEFT,u.COMMAND_RIGHT,u.COMMAND_FIREFOX].includes(e)}function s(e,t){var n=t.split("|"),o=!1;return (0, l.arrayEach)(n,function(t){if(e===u[t])return o=!0,!1}),o}t.__esModule=!0,t.KEY_CODES=void 0,t.isPrintableChar=o,t.isMetaKey=r,t.isCtrlKey=i,t.isCtrlMetaKey=a,t.isKey=s;var l=n(2),u=t.KEY_CODES={MOUSE_LEFT:1,MOUSE_RIGHT:3,MOUSE_MIDDLE:2,BACKSPACE:8,COMMA:188,INSERT:45,DELETE:46,END:35,ENTER:13,ESCAPE:27,CONTROL:17,COMMAND_LEFT:91,COMMAND_RIGHT:93,COMMAND_FIREFOX:224,ALT:18,HOME:36,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,SPACE:32,SHIFT:16,CAPS_LOCK:20,TAB:9,ARROW_RIGHT:39,ARROW_LEFT:37,ARROW_UP:38,ARROW_DOWN:40,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,A:65,C:67,D:68,F:70,L:76,O:79,P:80,S:83,V:86,X:88};},function(e,t,n){e.exports=!n(23)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a});},function(e,t){e.exports=function(e){try{return !!e()}catch(e){return !0}};},function(e,t,n){var o=n(77),r=n(39);e.exports=function(e){return o(r(e))};},function(e,t,n){var o=n(61),r=Math.min;e.exports=function(e){return e>0?r(o(e),9007199254740991):0};},function(e,t,n){var o=n(3),r=n(40),i=n(23);e.exports=function(e,t){var n=(r.Object||{})[e]||Object[e],a={};a[e]=t(n),o(o.S+o.F*i(function(){n(1);}),"Object",a);};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(0),s=n(1),l=n(2),u=n(6),c=o(u),h=n(182),f=o(h),d={};t.default=function(){function e(t){r(this,e),(0, s.defineGetter)(this,"wot",t,{writable:!1}),this.instance=this.wot,this.type="",this.mainTableScrollableElement=null,this.TABLE=this.wot.wtTable.TABLE,this.hider=this.wot.wtTable.hider,this.spreader=this.wot.wtTable.spreader,this.holder=this.wot.wtTable.holder,this.wtRootElement=this.wot.wtTable.wtRootElement,this.trimmingContainer=(0, a.getTrimmingContainer)(this.hider.parentNode.parentNode),this.areElementSizesAdjusted=!1,this.updateStateOfRendering();}return i(e,null,[{key:"registerOverlay",value:function(t,n){if(-1===e.CLONE_TYPES.indexOf(t))throw Error("Unsupported overlay ("+t+").");d[t]=n;}},{key:"createOverlay",value:function(e,t){return new d[e](t)}},{key:"hasOverlay",value:function(e){return void 0!==d[e]}},{key:"isOverlayTypeOf",value:function(e,t){return !(!e||!d[t])&&e instanceof d[t]}},{key:"CLONE_TOP",get:function(){return "top"}},{key:"CLONE_BOTTOM",get:function(){return "bottom"}},{key:"CLONE_LEFT",get:function(){return "left"}},{key:"CLONE_TOP_LEFT_CORNER",get:function(){return "top_left_corner"}},{key:"CLONE_BOTTOM_LEFT_CORNER",get:function(){return "bottom_left_corner"}},{key:"CLONE_DEBUG",get:function(){return "debug"}},{key:"CLONE_TYPES",get:function(){return [e.CLONE_TOP,e.CLONE_BOTTOM,e.CLONE_LEFT,e.CLONE_TOP_LEFT_CORNER,e.CLONE_BOTTOM_LEFT_CORNER,e.CLONE_DEBUG]}}]),i(e,[{key:"updateStateOfRendering",value:function(){var e=this.needFullRender;this.needFullRender=this.shouldBeRendered();var t=e!==this.needFullRender;return t&&!this.needFullRender&&this.reset(),t}},{key:"shouldBeRendered",value:function(){return !0}},{key:"updateTrimmingContainer",value:function(){this.trimmingContainer=(0, a.getTrimmingContainer)(this.hider.parentNode.parentNode);}},{key:"updateMainScrollableElement",value:function(){this.mainTableScrollableElement=(0, a.getScrollableElement)(this.wot.wtTable.TABLE);}},{key:"makeClone",value:function(t){if(-1===e.CLONE_TYPES.indexOf(t))throw Error('Clone type "'+t+'" is not supported.');var n=document.createElement("DIV"),o=document.createElement("TABLE");n.className="ht_clone_"+t+" handsontable",n.style.position="absolute",n.style.top=0,n.style.left=0,n.style.overflow="hidden",o.className=this.wot.wtTable.TABLE.className,n.appendChild(o),this.type=t,this.wot.wtTable.wtRootElement.parentNode.appendChild(n);var r=this.wot.getSetting("preventOverflow");return this.mainTableScrollableElement=!0===r||"horizontal"===r&&this.type===e.CLONE_TOP||"vertical"===r&&this.type===e.CLONE_LEFT?window:(0, a.getScrollableElement)(this.wot.wtTable.TABLE),new f.default({cloneSource:this.wot,cloneOverlay:this,table:o})}},{key:"refresh",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=this.shouldBeRendered();this.clone&&(this.needFullRender||t)&&this.clone.draw(e),this.needFullRender=t;}},{key:"reset",value:function(){if(this.clone){var e=this.clone.wtTable.holder;(0, l.arrayEach)([e.style,this.clone.wtTable.hider.style,e.parentNode.style],function(e){e.width="",e.height="";});}}},{key:"destroy",value:function(){new c.default(this.clone).destroy();}}]),e}();},function(e,t){var n={}.hasOwnProperty;e.exports=function(e,t){return n.call(e,t)};},function(e,t,n){var o=n(15),r=n(30),i=n(28),a=n(51)("src"),s=Function.toString,l=(""+s).split("toString");n(40).inspectSource=function(e){return s.call(e)},(e.exports=function(e,t,n,s){var u="function"==typeof n;u&&(i(n,"name")||r(n,"name",t)),e[t]!==n&&(u&&(i(n,a)||r(n,a,e[t]?""+e[t]:l.join(t+""))),e===o?e[t]=n:s?e[t]?e[t]=n:r(e,t,n):(delete e[t],r(e,t,n)));})(Function.prototype,"toString",function(){return "function"==typeof this&&this[a]||s.call(this)});},function(e,t,n){var o=n(20),r=n(52);e.exports=n(22)?function(e,t,n){return o.f(e,t,r(1,n))}:function(e,t,n){return e[t]=n,e};},function(e,t,n){var o=n(64);e.exports=function(e,t,n){if(o(e),void 0===t)return e;switch(n){case 1:return function(n){return e.call(t,n)};case 2:return function(n,o){return e.call(t,n,o)};case 3:return function(n,o,r){return e.call(t,n,o,r)}}return function(){return e.apply(t,arguments)}};},function(e,t,n){var o=n(39);e.exports=function(e){return Object(o(e))};},function(e,t,n){var o=n(51)("meta"),r=n(9),i=n(28),a=n(20).f,s=0,l=Object.isExtensible||function(){return !0},u=!n(23)(function(){return l(Object.preventExtensions({}))}),c=function(e){a(e,o,{value:{i:"O"+ ++s,w:{}}});},h=function(e,t){if(!r(e))return "symbol"==typeof e?e:("string"==typeof e?"S":"P")+e;if(!i(e,o)){if(!l(e))return "F";if(!t)return "E";c(e);}return e[o].i},f=function(e,t){if(!i(e,o)){if(!l(e))return !0;if(!t)return !1;c(e);}return e[o].w},d=function(e){return u&&p.NEED&&l(e)&&!i(e,o)&&c(e),e},p=e.exports={KEY:o,NEED:!1,fastKey:h,getWeak:f,onFreeze:d};},function(e,t,n){function o(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);e.length>t;t++)n[t]=e[t];return n}return Array.from(e)}function r(){function e(e,t){l.set(e,t);}function t(e){return l.get(e)}function n(e){return l.has(e)}function r(){return [].concat(o(l.keys()))}function a(){return [].concat(o(l.values()))}var s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"common";i.has(s)||i.set(s,new Map);var l=i.get(s);return {register:e,getItem:t,hasItem:n,getNames:r,getValues:a}}t.__esModule=!0,t.default=r;var i=t.collection=new Map;},function(e,t,n){function o(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.userAgent,n=void 0===t?navigator.userAgent:t,o=e.vendor,r=void 0===o?navigator.vendor:o;(0, f.objectEach)(p,function(e){return void(0, e.test)(n,r)});}function r(){return p.chrome.value}function i(){return p.edge.value}function a(){return p.ie.value}function s(){return p.ie8.value}function l(){return p.ie9.value}function u(){return p.ie.value||p.edge.value}function c(){return p.mobile.value}function h(){return p.safari.value}t.__esModule=!0,t.setBrowserMeta=o,t.isChrome=r,t.isEdge=i,t.isIE=a,t.isIE8=s,t.isIE9=l,t.isMSBrowser=u,t.isMobileBrowser=c,t.isSafari=h;var f=n(1),d=function(e){var t={value:!1};return t.test=function(n,o){t.value=e(n,o);},t},p={chrome:d(function(e,t){return /Chrome/.test(e)&&/Google/.test(t)}),edge:d(function(e){return /Edge/.test(e)}),ie:d(function(e){return /Trident/.test(e)}),ie8:d(function(){return !document.createTextNode("test").textContent}),ie9:d(function(){return !!document.documentMode}),mobile:d(function(e){return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(e)}),safari:d(function(e,t){return /Safari/.test(e)&&/Apple Computer/.test(t)})};o();},function(e,t,n){function o(e){return e[0].toUpperCase()+e.substr(1)}function r(){for(var e=[],t=arguments.length,n=Array(t),o=0;t>o;o++)n[o]=arguments[o];for(var r=n.length;r;){r-=1;var i=(0, u.stringify)(n[r]).toLowerCase();-1===e.indexOf(i)&&e.push(i);}return 1===e.length}function i(){function e(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}return e()+e()+e()+e()}function a(e){return /^([0-9][0-9]?%$)|(^100%$)/.test(e)}function s(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return (""+e).replace(/(?:\\)?\[([^[\]]+)]/g,function(e,n){return "\\"===e.charAt(0)?e.substr(1,e.length-1):void 0===t[n]?"":t[n]})}function l(e){return (""+e).replace(c,"")}t.__esModule=!0,t.toUpperCaseFirst=o,t.equalsIgnoreCase=r,t.randomString=i,t.isPercentValue=a,t.substitute=s,t.stripTags=l;var u=n(10),c=/<\/?\w+\/?>|<\w+[\s|\/][^>]*>/gi;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e){if("function"==typeof e)return e;if(!y(e))throw Error('No registered validator found under "'+e+'" name');return m(e)}t.__esModule=!0,t.getRegisteredValidators=t.getRegisteredValidatorNames=t.hasValidator=t.getValidator=t.registerValidator=void 0;var i=n(34),a=o(i),s=n(501),l=o(s),u=n(502),c=o(u),h=n(503),f=o(h),d=n(504),p=o(d),g=(0, a.default)("validators"),v=g.register,m=g.getItem,y=g.hasItem,w=g.getNames,C=g.getValues;v("autocomplete",l.default),v("date",c.default),v("numeric",f.default),v("time",p.default),t.registerValidator=v,t.getValidator=r,t.hasValidator=y,t.getRegisteredValidatorNames=w,t.getRegisteredValidators=C;},function(e,t,n){var o=n(102),r=n(80);e.exports=Object.keys||function(e){return o(e,r)};},function(e,t){e.exports=function(e){if(void 0==e)throw TypeError("Can't call method on  "+e);return e};},function(e,t){var n=e.exports={version:"2.5.7"};"number"==typeof __e&&(__e=n);},function(e,t,n){function o(e){return d.call(window,e)}function r(e){p.call(window,e);}function i(){return "ontouchstart"in window}function a(){var e=document.createElement("div");return !(!e.createShadowRoot||!(""+e.createShadowRoot).match(/\[native code\]/))}function s(){var e=document.createElement("TABLE");e.style.borderSpacing=0,e.style.borderWidth=0,e.style.padding=0;var t=document.createElement("TBODY");e.appendChild(t),t.appendChild(document.createElement("TR")),t.firstChild.appendChild(document.createElement("TD")),t.firstChild.firstChild.innerHTML="<tr><td>t<br>t</td></tr>";var n=document.createElement("CAPTION");n.innerHTML="c<br>c<br>c<br>c",n.style.padding=0,n.style.margin=0,e.insertBefore(n,t),document.body.appendChild(e),v=2*e.lastChild.offsetHeight>e.offsetHeight,document.body.removeChild(e);}function l(){return void 0===v&&s(),v}function u(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return m||(m="object"===("undefined"==typeof Intl?"undefined":c(Intl))?new Intl.Collator(e,t).compare:"function"==typeof String.prototype.localeCompare?function(e,t){return (""+e).localeCompare(t)}:function(e,t){return e===t?0:e>t?-1:1})}t.__esModule=!0;var c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};t.requestAnimationFrame=o,t.cancelAnimationFrame=r,t.isTouchSupported=i,t.isWebComponentSupportedNatively=a,t.hasCaptionProblem=l,t.getComparisonFunction=u;for(var h=0,f=["ms","moz","webkit","o"],d=window.requestAnimationFrame,p=window.cancelAnimationFrame,g=0;4>g&&!d;++g)d=window[f[g]+"RequestAnimationFrame"],p=window[f[g]+"CancelAnimationFrame"]||window[f[g]+"CancelRequestAnimationFrame"];d||(d=function(e){var t=(new Date).getTime(),n=Math.max(0,16-(t-h)),o=window.setTimeout(function(){e(t+n);},n);return h=t+n,o}),p||(p=function(e){clearTimeout(e);});var v=void 0,m=void 0;},function(e,t,n){function o(e){for(var t=arguments.length,n=Array(t>1?t-1:0),o=1;t>o;o++)n[o-1]=arguments[o];return (0, r.arrayReduce)(e,function(e,t,o){return e+t.replace(/(?:\r?\n\s+)/g,"")+(n[o]?n[o]:"")},"").trim()}t.__esModule=!0,t.toSingleLine=o;var r=n(2);},function(e,t,n){function o(e){return "function"==typeof e}function r(e){function t(){for(var t=this,a=arguments.length,s=Array(a),l=0;a>l;l++)s[l]=arguments[l];var u=Date.now(),c=!1;r.lastCallThrottled=!0,o||(o=u,c=!0);var h=n-(u-o);return c?(r.lastCallThrottled=!1,e.apply(this,s)):(i&&clearTimeout(i),i=setTimeout(function(){r.lastCallThrottled=!1,e.apply(t,s),o=0,i=void 0;},h)),r}var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:200,o=0,r={lastCallThrottled:!0},i=null;return t}function i(e){function t(){s=i;}function n(){for(var t=arguments.length,n=Array(t),o=0;t>o;o++)n[o]=arguments[o];return s?(s-=1,e.apply(this,n)):a.apply(this,n)}var o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:200,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:10,a=r(e,o),s=i;return n.clearHits=t,n}function a(e){function t(){for(var t=this,i=arguments.length,a=Array(i),s=0;i>s;s++)a[s]=arguments[s];return o&&clearTimeout(o),o=setTimeout(function(){r=e.apply(t,a);},n),r}var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:200,o=null,r=void 0;return t}function s(){for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];var o=t[0],r=t.slice(1);return function(){for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];return (0, h.arrayReduce)(r,function(e,t){return t(e)},o.apply(this,t))}}function l(e){for(var t=arguments.length,n=Array(t>1?t-1:0),o=1;t>o;o++)n[o-1]=arguments[o];return function(){for(var t=arguments.length,o=Array(t),r=0;t>r;r++)o[r]=arguments[r];return e.apply(this,n.concat(o))}}function u(e){function t(o){return function(){for(var r=arguments.length,i=Array(r),a=0;r>a;a++)i[a]=arguments[a];var s=o.concat(i);return n>s.length?t(s):e.apply(this,s)}}var n=e.length;return t([])}function c(e){function t(o){return function(){for(var r=arguments.length,i=Array(r),a=0;r>a;a++)i[a]=arguments[a];var s=o.concat(i.reverse());return n>s.length?t(s):e.apply(this,s)}}var n=e.length;return t([])}t.__esModule=!0,t.isFunction=o,t.throttle=r,t.throttleAfterHits=i,t.debounce=a,t.pipe=s,t.partial=l,t.curry=u,t.curryRight=c;var h=n(2);},function(e,t){var n={}.toString;e.exports=function(e){return n.call(e).slice(8,-1)};},function(e,t,n){var o=n(9);e.exports=function(e,t){if(!o(e)||e._t!==t)throw TypeError("Incompatible receiver, "+t+" required!");return e};},function(e,t,n){var o=n(13)("unscopables"),r=Array.prototype;void 0==r[o]&&n(30)(r,o,{}),e.exports=function(e){r[o][e]=!0;};},function(e,t,n){(function(e){!function(t,n){e.exports=n();}(0,function(){function t(){return Mo.apply(null,arguments)}function o(e){return e instanceof Array||"[object Array]"===Object.prototype.toString.call(e)}function r(e){return null!=e&&"[object Object]"===Object.prototype.toString.call(e)}function i(e){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(e).length;var t;for(t in e)if(e.hasOwnProperty(t))return !1;return !0}function a(e){return void 0===e}function s(e){return "number"==typeof e||"[object Number]"===Object.prototype.toString.call(e)}function l(e){return e instanceof Date||"[object Date]"===Object.prototype.toString.call(e)}function u(e,t){var n,o=[];for(n=0;e.length>n;++n)o.push(t(e[n],n));return o}function c(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function h(e,t){for(var n in t)c(t,n)&&(e[n]=t[n]);return c(t,"toString")&&(e.toString=t.toString),c(t,"valueOf")&&(e.valueOf=t.valueOf),e}function f(e,t,n,o){return Ot(e,t,n,o,!0).utc()}function d(){return {empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}}function p(e){return null==e._pf&&(e._pf=d()),e._pf}function g(e){if(null==e._isValid){var t=p(e),n=Do.call(t.parsedDateParts,function(e){return null!=e}),o=!isNaN(e._d.getTime())&&0>t.overflow&&!t.empty&&!t.invalidMonth&&!t.invalidWeekday&&!t.weekdayMismatch&&!t.nullInput&&!t.invalidFormat&&!t.userInvalidated&&(!t.meridiem||t.meridiem&&n);if(e._strict&&(o=o&&0===t.charsLeftOver&&0===t.unusedTokens.length&&void 0===t.bigHour),null!=Object.isFrozen&&Object.isFrozen(e))return o;e._isValid=o;}return e._isValid}function v(e){var t=f(NaN);return null!=e?h(p(t),e):p(t).userInvalidated=!0,t}function m(e,t){var n,o,r;if(a(t._isAMomentObject)||(e._isAMomentObject=t._isAMomentObject),a(t._i)||(e._i=t._i),a(t._f)||(e._f=t._f),a(t._l)||(e._l=t._l),a(t._strict)||(e._strict=t._strict),a(t._tzm)||(e._tzm=t._tzm),a(t._isUTC)||(e._isUTC=t._isUTC),a(t._offset)||(e._offset=t._offset),a(t._pf)||(e._pf=p(t)),a(t._locale)||(e._locale=t._locale),Ao.length>0)for(n=0;Ao.length>n;n++)o=Ao[n],r=t[o],a(r)||(e[o]=r);return e}function y(e){m(this,e),this._d=new Date(null!=e._d?e._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===No&&(No=!0,t.updateOffset(this),No=!1);}function w(e){return e instanceof y||null!=e&&null!=e._isAMomentObject}function C(e){return 0>e?Math.ceil(e)||0:Math.floor(e)}function b(e){var t=+e,n=0;return 0!==t&&isFinite(t)&&(n=C(t)),n}function _(e,t,n){var o,r=Math.min(e.length,t.length),i=Math.abs(e.length-t.length),a=0;for(o=0;r>o;o++)(n&&e[o]!==t[o]||!n&&b(e[o])!==b(t[o]))&&a++;return a+i}function S(e){!1===t.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+e);}function E(e,n){var o=!0;return h(function(){if(null!=t.deprecationHandler&&t.deprecationHandler(null,e),o){for(var r,i=[],a=0;arguments.length>a;a++){if(r="","object"==typeof arguments[a]){r+="\n["+a+"] ";for(var s in arguments[0])r+=s+": "+arguments[0][s]+", ";r=r.slice(0,-2);}else r=arguments[a];i.push(r);}S(e+"\nArguments: "+Array.prototype.slice.call(i).join("")+"\n"+Error().stack),o=!1;}return n.apply(this,arguments)},n)}function O(e,n){null!=t.deprecationHandler&&t.deprecationHandler(e,n),Po[e]||(S(n),Po[e]=!0);}function T(e){return e instanceof Function||"[object Function]"===Object.prototype.toString.call(e)}function k(e){var t,n;for(n in e)t=e[n],T(t)?this[n]=t:this["_"+n]=t;this._config=e,this._dayOfMonthOrdinalParseLenient=RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source);}function R(e,t){var n,o=h({},e);for(n in t)c(t,n)&&(r(e[n])&&r(t[n])?(o[n]={},h(o[n],e[n]),h(o[n],t[n])):null!=t[n]?o[n]=t[n]:delete o[n]);for(n in e)c(e,n)&&!c(t,n)&&r(e[n])&&(o[n]=h({},o[n]));return o}function M(e){null!=e&&this.set(e);}function D(e,t,n){var o=this._calendar[e]||this._calendar.sameElse;return T(o)?o.call(t,n):o}function A(e){var t=this._longDateFormat[e],n=this._longDateFormat[e.toUpperCase()];return t||!n?t:this._longDateFormat[e]=n.replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)})}function N(){return this._invalidDate}function P(e){return this._ordinal.replace("%d",e)}function H(e,t,n,o){var r=this._relativeTime[n];return T(r)?r(e,t,n,o):r.replace(/%d/i,e)}function L(e,t){var n=this._relativeTime[e>0?"future":"past"];return T(n)?n(t):n.replace(/%s/i,t)}function x(e,t){var n=e.toLowerCase();Fo[n]=Fo[n+"s"]=Fo[t]=e;}function I(e){return "string"==typeof e?Fo[e]||Fo[e.toLowerCase()]:void 0}function j(e){var t,n,o={};for(n in e)c(e,n)&&(t=I(n))&&(o[t]=e[n]);return o}function F(e,t){Wo[e]=t;}function W(e){var t=[];for(var n in e)t.push({unit:n,priority:Wo[n]});return t.sort(function(e,t){return e.priority-t.priority}),t}function B(e,t,n){var o=""+Math.abs(e),r=t-o.length;return (0>e?"-":n?"+":"")+(""+Math.pow(10,Math.max(0,r))).substr(1)+o}function Y(e,t,n,o){var r=o;"string"==typeof o&&(r=function(){return this[o]()}),e&&(Uo[e]=r),t&&(Uo[t[0]]=function(){return B(r.apply(this,arguments),t[1],t[2])}),n&&(Uo[n]=function(){return this.localeData().ordinal(r.apply(this,arguments),e)});}function V(e){return e.match(/\[[\s\S]/)?e.replace(/^\[|\]$/g,""):e.replace(/\\/g,"")}function U(e){var t,n,o=e.match(Bo);for(t=0,n=o.length;n>t;t++)o[t]=Uo[o[t]]?Uo[o[t]]:V(o[t]);return function(t){var r,i="";for(r=0;n>r;r++)i+=T(o[r])?o[r].call(t,e):o[r];return i}}function z(e,t){return e.isValid()?(t=G(t,e.localeData()),(Vo[t]=Vo[t]||U(t))(e)):e.localeData().invalidDate()}function G(e,t){function n(e){return t.longDateFormat(e)||e}var o=5;for(Yo.lastIndex=0;o>=0&&Yo.test(e);)e=e.replace(Yo,n),Yo.lastIndex=0,o-=1;return e}function K(e,t,n){lr[e]=T(t)?t:function(e,o){return e&&n?n:t};}function X(e,t){return c(lr,e)?lr[e](t._strict,t._locale):RegExp(q(e))}function q(e){return Z(e.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(e,t,n,o,r){return t||n||o||r}))}function Z(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function $(e,t){var n,o=t;for("string"==typeof e&&(e=[e]),s(t)&&(o=function(e,n){n[t]=b(e);}),n=0;e.length>n;n++)ur[e[n]]=o;}function J(e,t){$(e,function(e,n,o,r){o._w=o._w||{},t(e,o._w,o,r);});}function Q(e,t,n){null!=t&&c(ur,e)&&ur[e](t,n._a,n,e);}function ee(e){return te(e)?366:365}function te(e){return e%4==0&&e%100!=0||e%400==0}function ne(){return te(this.year())}function oe(e,n){return function(o){return null!=o?(ie(this,e,o),t.updateOffset(this,n),this):re(this,e)}}function re(e,t){return e.isValid()?e._d["get"+(e._isUTC?"UTC":"")+t]():NaN}function ie(e,t,n){e.isValid()&&!isNaN(n)&&("FullYear"===t&&te(e.year())&&1===e.month()&&29===e.date()?e._d["set"+(e._isUTC?"UTC":"")+t](n,e.month(),ue(n,e.month())):e._d["set"+(e._isUTC?"UTC":"")+t](n));}function ae(e){return e=I(e),T(this[e])?this[e]():this}function se(e,t){if("object"==typeof e){e=j(e);for(var n=W(e),o=0;n.length>o;o++)this[n[o].unit](e[n[o].unit]);}else if(e=I(e),T(this[e]))return this[e](t);return this}function le(e,t){return (e%t+t)%t}function ue(e,t){if(isNaN(e)||isNaN(t))return NaN;var n=le(t,12);return e+=(t-n)/12,1===n?te(e)?29:28:31-n%7%2}function ce(e,t){return e?o(this._months)?this._months[e.month()]:this._months[(this._months.isFormat||br).test(t)?"format":"standalone"][e.month()]:o(this._months)?this._months:this._months.standalone}function he(e,t){return e?o(this._monthsShort)?this._monthsShort[e.month()]:this._monthsShort[br.test(t)?"format":"standalone"][e.month()]:o(this._monthsShort)?this._monthsShort:this._monthsShort.standalone}function fe(e,t,n){var o,r,i,a=e.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],o=0;12>o;++o)i=f([2e3,o]),this._shortMonthsParse[o]=this.monthsShort(i,"").toLocaleLowerCase(),this._longMonthsParse[o]=this.months(i,"").toLocaleLowerCase();return n?"MMM"===t?(r=wr.call(this._shortMonthsParse,a),-1!==r?r:null):(r=wr.call(this._longMonthsParse,a),-1!==r?r:null):"MMM"===t?-1!==(r=wr.call(this._shortMonthsParse,a))?r:(r=wr.call(this._longMonthsParse,a),-1!==r?r:null):-1!==(r=wr.call(this._longMonthsParse,a))?r:(r=wr.call(this._shortMonthsParse,a),-1!==r?r:null)}function de(e,t,n){var o,r,i;if(this._monthsParseExact)return fe.call(this,e,t,n);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),o=0;12>o;o++){if(r=f([2e3,o]),n&&!this._longMonthsParse[o]&&(this._longMonthsParse[o]=RegExp("^"+this.months(r,"").replace(".","")+"$","i"),this._shortMonthsParse[o]=RegExp("^"+this.monthsShort(r,"").replace(".","")+"$","i")),n||this._monthsParse[o]||(i="^"+this.months(r,"")+"|^"+this.monthsShort(r,""),this._monthsParse[o]=RegExp(i.replace(".",""),"i")),n&&"MMMM"===t&&this._longMonthsParse[o].test(e))return o;if(n&&"MMM"===t&&this._shortMonthsParse[o].test(e))return o;if(!n&&this._monthsParse[o].test(e))return o}}function pe(e,t){var n;if(!e.isValid())return e;if("string"==typeof t)if(/^\d+$/.test(t))t=b(t);else if(t=e.localeData().monthsParse(t),!s(t))return e;return n=Math.min(e.date(),ue(e.year(),t)),e._d["set"+(e._isUTC?"UTC":"")+"Month"](t,n),e}function ge(e){return null!=e?(pe(this,e),t.updateOffset(this,!0),this):re(this,"Month")}function ve(){return ue(this.year(),this.month())}function me(e){return this._monthsParseExact?(c(this,"_monthsRegex")||we.call(this),e?this._monthsShortStrictRegex:this._monthsShortRegex):(c(this,"_monthsShortRegex")||(this._monthsShortRegex=Er),this._monthsShortStrictRegex&&e?this._monthsShortStrictRegex:this._monthsShortRegex)}function ye(e){return this._monthsParseExact?(c(this,"_monthsRegex")||we.call(this),e?this._monthsStrictRegex:this._monthsRegex):(c(this,"_monthsRegex")||(this._monthsRegex=Or),this._monthsStrictRegex&&e?this._monthsStrictRegex:this._monthsRegex)}function we(){function e(e,t){return t.length-e.length}var t,n,o=[],r=[],i=[];for(t=0;12>t;t++)n=f([2e3,t]),o.push(this.monthsShort(n,"")),r.push(this.months(n,"")),i.push(this.months(n,"")),i.push(this.monthsShort(n,""));for(o.sort(e),r.sort(e),i.sort(e),t=0;12>t;t++)o[t]=Z(o[t]),r[t]=Z(r[t]);for(t=0;24>t;t++)i[t]=Z(i[t]);this._monthsRegex=RegExp("^("+i.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=RegExp("^("+r.join("|")+")","i"),this._monthsShortStrictRegex=RegExp("^("+o.join("|")+")","i");}function Ce(e,t,n,o,r,i,a){var s=new Date(e,t,n,o,r,i,a);return 100>e&&e>=0&&isFinite(s.getFullYear())&&s.setFullYear(e),s}function be(e){var t=new Date(Date.UTC.apply(null,arguments));return 100>e&&e>=0&&isFinite(t.getUTCFullYear())&&t.setUTCFullYear(e),t}function _e(e,t,n){var o=7+t-n;return -(7+be(e,0,o).getUTCDay()-t)%7+o-1}function Se(e,t,n,o,r){var i,a,s=(7+n-o)%7,l=_e(e,o,r),u=1+7*(t-1)+s+l;return u>0?u>ee(e)?(i=e+1,a=u-ee(e)):(i=e,a=u):(i=e-1,a=ee(i)+u),{year:i,dayOfYear:a}}function Ee(e,t,n){var o,r,i=_e(e.year(),t,n),a=Math.floor((e.dayOfYear()-i-1)/7)+1;return 1>a?(r=e.year()-1,o=a+Oe(r,t,n)):a>Oe(e.year(),t,n)?(o=a-Oe(e.year(),t,n),r=e.year()+1):(r=e.year(),o=a),{week:o,year:r}}function Oe(e,t,n){var o=_e(e,t,n),r=_e(e+1,t,n);return (ee(e)-o+r)/7}function Te(e){return Ee(e,this._week.dow,this._week.doy).week}function ke(){return this._week.dow}function Re(){return this._week.doy}function Me(e){var t=this.localeData().week(this);return null==e?t:this.add(7*(e-t),"d")}function De(e){var t=Ee(this,1,4).week;return null==e?t:this.add(7*(e-t),"d")}function Ae(e,t){return "string"!=typeof e?e:isNaN(e)?(e=t.weekdaysParse(e),"number"==typeof e?e:null):parseInt(e,10)}function Ne(e,t){return "string"==typeof e?t.weekdaysParse(e)%7||7:isNaN(e)?null:e}function Pe(e,t){return e?o(this._weekdays)?this._weekdays[e.day()]:this._weekdays[this._weekdays.isFormat.test(t)?"format":"standalone"][e.day()]:o(this._weekdays)?this._weekdays:this._weekdays.standalone}function He(e){return e?this._weekdaysShort[e.day()]:this._weekdaysShort}function Le(e){return e?this._weekdaysMin[e.day()]:this._weekdaysMin}function xe(e,t,n){var o,r,i,a=e.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],o=0;7>o;++o)i=f([2e3,1]).day(o),this._minWeekdaysParse[o]=this.weekdaysMin(i,"").toLocaleLowerCase(),this._shortWeekdaysParse[o]=this.weekdaysShort(i,"").toLocaleLowerCase(),this._weekdaysParse[o]=this.weekdays(i,"").toLocaleLowerCase();return n?"dddd"===t?(r=wr.call(this._weekdaysParse,a),-1!==r?r:null):"ddd"===t?(r=wr.call(this._shortWeekdaysParse,a),-1!==r?r:null):(r=wr.call(this._minWeekdaysParse,a),-1!==r?r:null):"dddd"===t?-1!==(r=wr.call(this._weekdaysParse,a))?r:-1!==(r=wr.call(this._shortWeekdaysParse,a))?r:(r=wr.call(this._minWeekdaysParse,a),-1!==r?r:null):"ddd"===t?-1!==(r=wr.call(this._shortWeekdaysParse,a))?r:-1!==(r=wr.call(this._weekdaysParse,a))?r:(r=wr.call(this._minWeekdaysParse,a),-1!==r?r:null):-1!==(r=wr.call(this._minWeekdaysParse,a))?r:-1!==(r=wr.call(this._weekdaysParse,a))?r:(r=wr.call(this._shortWeekdaysParse,a),-1!==r?r:null)}function Ie(e,t,n){var o,r,i;if(this._weekdaysParseExact)return xe.call(this,e,t,n);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),o=0;7>o;o++){if(r=f([2e3,1]).day(o),n&&!this._fullWeekdaysParse[o]&&(this._fullWeekdaysParse[o]=RegExp("^"+this.weekdays(r,"").replace(".",".?")+"$","i"),this._shortWeekdaysParse[o]=RegExp("^"+this.weekdaysShort(r,"").replace(".",".?")+"$","i"),this._minWeekdaysParse[o]=RegExp("^"+this.weekdaysMin(r,"").replace(".",".?")+"$","i")),this._weekdaysParse[o]||(i="^"+this.weekdays(r,"")+"|^"+this.weekdaysShort(r,"")+"|^"+this.weekdaysMin(r,""),this._weekdaysParse[o]=RegExp(i.replace(".",""),"i")),n&&"dddd"===t&&this._fullWeekdaysParse[o].test(e))return o;if(n&&"ddd"===t&&this._shortWeekdaysParse[o].test(e))return o;if(n&&"dd"===t&&this._minWeekdaysParse[o].test(e))return o;if(!n&&this._weekdaysParse[o].test(e))return o}}function je(e){if(!this.isValid())return null!=e?this:NaN;var t=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=e?(e=Ae(e,this.localeData()),this.add(e-t,"d")):t}function Fe(e){if(!this.isValid())return null!=e?this:NaN;var t=(this.day()+7-this.localeData()._week.dow)%7;return null==e?t:this.add(e-t,"d")}function We(e){if(!this.isValid())return null!=e?this:NaN;if(null!=e){var t=Ne(e,this.localeData());return this.day(this.day()%7?t:t-7)}return this.day()||7}function Be(e){return this._weekdaysParseExact?(c(this,"_weekdaysRegex")||Ue.call(this),e?this._weekdaysStrictRegex:this._weekdaysRegex):(c(this,"_weekdaysRegex")||(this._weekdaysRegex=Dr),this._weekdaysStrictRegex&&e?this._weekdaysStrictRegex:this._weekdaysRegex)}function Ye(e){return this._weekdaysParseExact?(c(this,"_weekdaysRegex")||Ue.call(this),e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(c(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=Ar),this._weekdaysShortStrictRegex&&e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)}function Ve(e){return this._weekdaysParseExact?(c(this,"_weekdaysRegex")||Ue.call(this),e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(c(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=Nr),this._weekdaysMinStrictRegex&&e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)}function Ue(){function e(e,t){return t.length-e.length}var t,n,o,r,i,a=[],s=[],l=[],u=[];for(t=0;7>t;t++)n=f([2e3,1]).day(t),o=this.weekdaysMin(n,""),r=this.weekdaysShort(n,""),i=this.weekdays(n,""),a.push(o),s.push(r),l.push(i),u.push(o),u.push(r),u.push(i);for(a.sort(e),s.sort(e),l.sort(e),u.sort(e),t=0;7>t;t++)s[t]=Z(s[t]),l[t]=Z(l[t]),u[t]=Z(u[t]);this._weekdaysRegex=RegExp("^("+u.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=RegExp("^("+l.join("|")+")","i"),this._weekdaysShortStrictRegex=RegExp("^("+s.join("|")+")","i"),this._weekdaysMinStrictRegex=RegExp("^("+a.join("|")+")","i");}function ze(){return this.hours()%12||12}function Ge(){return this.hours()||24}function Ke(e,t){Y(e,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),t)});}function Xe(e,t){return t._meridiemParse}function qe(e){return "p"===(e+"").toLowerCase().charAt(0)}function Ze(e,t,n){return e>11?n?"pm":"PM":n?"am":"AM"}function $e(e){return e?e.toLowerCase().replace("_","-"):e}function Je(e){for(var t,n,o,r,i=0;e.length>i;){for(r=$e(e[i]).split("-"),t=r.length,n=$e(e[i+1]),n=n?n.split("-"):null;t>0;){if(o=Qe(r.slice(0,t).join("-")))return o;if(n&&n.length>=t&&_(r,n,!0)>=t-1)break;t--;}i++;}return null}function Qe(t){var o=null;if(!Ir[t]&&void 0!==e&&e&&e.exports)try{o=Pr._abbr;n(476)("./"+t),et(o);}catch(e){}return Ir[t]}function et(e,t){var n;return e&&(n=a(t)?ot(e):tt(e,t))&&(Pr=n),Pr._abbr}function tt(e,t){if(null!==t){var n=xr;if(t.abbr=e,null!=Ir[e])O("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),n=Ir[e]._config;else if(null!=t.parentLocale){if(null==Ir[t.parentLocale])return jr[t.parentLocale]||(jr[t.parentLocale]=[]),jr[t.parentLocale].push({name:e,config:t}),null;n=Ir[t.parentLocale]._config;}return Ir[e]=new M(R(n,t)),jr[e]&&jr[e].forEach(function(e){tt(e.name,e.config);}),et(e),Ir[e]}return delete Ir[e],null}function nt(e,t){if(null!=t){var n,o,r=xr;o=Qe(e),null!=o&&(r=o._config),t=R(r,t),n=new M(t),n.parentLocale=Ir[e],Ir[e]=n,et(e);}else null!=Ir[e]&&(null!=Ir[e].parentLocale?Ir[e]=Ir[e].parentLocale:null!=Ir[e]&&delete Ir[e]);return Ir[e]}function ot(e){var t;if(e&&e._locale&&e._locale._abbr&&(e=e._locale._abbr),!e)return Pr;if(!o(e)){if(t=Qe(e))return t;e=[e];}return Je(e)}function rt(){return Ho(Ir)}function it(e){var t,n=e._a;return n&&-2===p(e).overflow&&(t=0>n[hr]||n[hr]>11?hr:1>n[fr]||n[fr]>ue(n[cr],n[hr])?fr:0>n[dr]||n[dr]>24||24===n[dr]&&(0!==n[pr]||0!==n[gr]||0!==n[vr])?dr:0>n[pr]||n[pr]>59?pr:0>n[gr]||n[gr]>59?gr:0>n[vr]||n[vr]>999?vr:-1,p(e)._overflowDayOfYear&&(cr>t||t>fr)&&(t=fr),p(e)._overflowWeeks&&-1===t&&(t=mr),p(e)._overflowWeekday&&-1===t&&(t=yr),p(e).overflow=t),e}function at(e,t,n){return null!=e?e:null!=t?t:n}function st(e){var n=new Date(t.now());return e._useUTC?[n.getUTCFullYear(),n.getUTCMonth(),n.getUTCDate()]:[n.getFullYear(),n.getMonth(),n.getDate()]}function lt(e){var t,n,o,r,i,a=[];if(!e._d){for(o=st(e),e._w&&null==e._a[fr]&&null==e._a[hr]&&ut(e),null!=e._dayOfYear&&(i=at(e._a[cr],o[cr]),(e._dayOfYear>ee(i)||0===e._dayOfYear)&&(p(e)._overflowDayOfYear=!0),n=be(i,0,e._dayOfYear),e._a[hr]=n.getUTCMonth(),e._a[fr]=n.getUTCDate()),t=0;3>t&&null==e._a[t];++t)e._a[t]=a[t]=o[t];for(;7>t;t++)e._a[t]=a[t]=null==e._a[t]?2===t?1:0:e._a[t];24===e._a[dr]&&0===e._a[pr]&&0===e._a[gr]&&0===e._a[vr]&&(e._nextDay=!0,e._a[dr]=0),e._d=(e._useUTC?be:Ce).apply(null,a),r=e._useUTC?e._d.getUTCDay():e._d.getDay(),null!=e._tzm&&e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),e._nextDay&&(e._a[dr]=24),e._w&&void 0!==e._w.d&&e._w.d!==r&&(p(e).weekdayMismatch=!0);}}function ut(e){var t,n,o,r,i,a,s,l;if(t=e._w,null!=t.GG||null!=t.W||null!=t.E)i=1,a=4,n=at(t.GG,e._a[cr],Ee(Tt(),1,4).year),o=at(t.W,1),(1>(r=at(t.E,1))||r>7)&&(l=!0);else{i=e._locale._week.dow,a=e._locale._week.doy;var u=Ee(Tt(),i,a);n=at(t.gg,e._a[cr],u.year),o=at(t.w,u.week),null!=t.d?(0>(r=t.d)||r>6)&&(l=!0):null!=t.e?(r=t.e+i,(0>t.e||t.e>6)&&(l=!0)):r=i;}1>o||o>Oe(n,i,a)?p(e)._overflowWeeks=!0:null!=l?p(e)._overflowWeekday=!0:(s=Se(n,o,r,i,a),e._a[cr]=s.year,e._dayOfYear=s.dayOfYear);}function ct(e){var t,n,o,r,i,a,s=e._i,l=Fr.exec(s)||Wr.exec(s);if(l){for(p(e).iso=!0,t=0,n=Yr.length;n>t;t++)if(Yr[t][1].exec(l[1])){r=Yr[t][0],o=!1!==Yr[t][2];break}if(null==r)return void(e._isValid=!1);if(l[3]){for(t=0,n=Vr.length;n>t;t++)if(Vr[t][1].exec(l[3])){i=(l[2]||" ")+Vr[t][0];break}if(null==i)return void(e._isValid=!1)}if(!o&&null!=i)return void(e._isValid=!1);if(l[4]){if(!Br.exec(l[4]))return void(e._isValid=!1);a="Z";}e._f=r+(i||"")+(a||""),yt(e);}else e._isValid=!1;}function ht(e,t,n,o,r,i){var a=[ft(e),Sr.indexOf(t),parseInt(n,10),parseInt(o,10),parseInt(r,10)];return i&&a.push(parseInt(i,10)),a}function ft(e){var t=parseInt(e,10);return t>49?t>999?t:1900+t:2e3+t}function dt(e){return e.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").trim()}function pt(e,t,n){if(e){if(Rr.indexOf(e)!==new Date(t[0],t[1],t[2]).getDay())return p(n).weekdayMismatch=!0,n._isValid=!1,!1}return !0}function gt(e,t,n){if(e)return Gr[e];if(t)return 0;var o=parseInt(n,10),r=o%100;return (o-r)/100*60+r}function vt(e){var t=zr.exec(dt(e._i));if(t){var n=ht(t[4],t[3],t[2],t[5],t[6],t[7]);if(!pt(t[1],n,e))return;e._a=n,e._tzm=gt(t[8],t[9],t[10]),e._d=be.apply(null,e._a),e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),p(e).rfc2822=!0;}else e._isValid=!1;}function mt(e){var n=Ur.exec(e._i);if(null!==n)return void(e._d=new Date(+n[1]));ct(e),!1===e._isValid&&(delete e._isValid,vt(e),!1===e._isValid&&(delete e._isValid,t.createFromInputFallback(e)));}function yt(e){if(e._f===t.ISO_8601)return void ct(e);if(e._f===t.RFC_2822)return void vt(e);e._a=[],p(e).empty=!0;var n,o,r,i,a,s=""+e._i,l=s.length,u=0;for(r=G(e._f,e._locale).match(Bo)||[],n=0;r.length>n;n++)i=r[n],o=(s.match(X(i,e))||[])[0],o&&(a=s.substr(0,s.indexOf(o)),a.length>0&&p(e).unusedInput.push(a),s=s.slice(s.indexOf(o)+o.length),u+=o.length),Uo[i]?(o?p(e).empty=!1:p(e).unusedTokens.push(i),Q(i,o,e)):e._strict&&!o&&p(e).unusedTokens.push(i);p(e).charsLeftOver=l-u,s.length>0&&p(e).unusedInput.push(s),12>=e._a[dr]&&!0===p(e).bigHour&&e._a[dr]>0&&(p(e).bigHour=void 0),p(e).parsedDateParts=e._a.slice(0),p(e).meridiem=e._meridiem,e._a[dr]=wt(e._locale,e._a[dr],e._meridiem),lt(e),it(e);}function wt(e,t,n){var o;return null==n?t:null!=e.meridiemHour?e.meridiemHour(t,n):null!=e.isPM?(o=e.isPM(n),o&&12>t&&(t+=12),o||12!==t||(t=0),t):t}function Ct(e){var t,n,o,r,i;if(0===e._f.length)return p(e).invalidFormat=!0,void(e._d=new Date(NaN));for(r=0;e._f.length>r;r++)i=0,t=m({},e),null!=e._useUTC&&(t._useUTC=e._useUTC),t._f=e._f[r],yt(t),g(t)&&(i+=p(t).charsLeftOver,i+=10*p(t).unusedTokens.length,p(t).score=i,(null==o||o>i)&&(o=i,n=t));h(e,n||t);}function bt(e){if(!e._d){var t=j(e._i);e._a=u([t.year,t.month,t.day||t.date,t.hour,t.minute,t.second,t.millisecond],function(e){return e&&parseInt(e,10)}),lt(e);}}function _t(e){var t=new y(it(St(e)));return t._nextDay&&(t.add(1,"d"),t._nextDay=void 0),t}function St(e){var t=e._i,n=e._f;return e._locale=e._locale||ot(e._l),null===t||void 0===n&&""===t?v({nullInput:!0}):("string"==typeof t&&(e._i=t=e._locale.preparse(t)),w(t)?new y(it(t)):(l(t)?e._d=t:o(n)?Ct(e):n?yt(e):Et(e),g(e)||(e._d=null),e))}function Et(e){var n=e._i;a(n)?e._d=new Date(t.now()):l(n)?e._d=new Date(n.valueOf()):"string"==typeof n?mt(e):o(n)?(e._a=u(n.slice(0),function(e){return parseInt(e,10)}),lt(e)):r(n)?bt(e):s(n)?e._d=new Date(n):t.createFromInputFallback(e);}function Ot(e,t,n,a,s){var l={};return !0!==n&&!1!==n||(a=n,n=void 0),(r(e)&&i(e)||o(e)&&0===e.length)&&(e=void 0),l._isAMomentObject=!0,l._useUTC=l._isUTC=s,l._l=n,l._i=e,l._f=t,l._strict=a,_t(l)}function Tt(e,t,n,o){return Ot(e,t,n,o,!1)}function kt(e,t){var n,r;if(1===t.length&&o(t[0])&&(t=t[0]),!t.length)return Tt();for(n=t[0],r=1;t.length>r;++r)t[r].isValid()&&!t[r][e](n)||(n=t[r]);return n}function Rt(){return kt("isBefore",[].slice.call(arguments,0))}function Mt(){return kt("isAfter",[].slice.call(arguments,0))}function Dt(e){for(var t in e)if(-1===wr.call(Zr,t)||null!=e[t]&&isNaN(e[t]))return !1;for(var n=!1,o=0;Zr.length>o;++o)if(e[Zr[o]]){if(n)return !1;parseFloat(e[Zr[o]])!==b(e[Zr[o]])&&(n=!0);}return !0}function At(){return this._isValid}function Nt(){return $t(NaN)}function Pt(e){var t=j(e),n=t.year||0,o=t.quarter||0,r=t.month||0,i=t.week||0,a=t.day||0,s=t.hour||0,l=t.minute||0,u=t.second||0,c=t.millisecond||0;this._isValid=Dt(t),this._milliseconds=+c+1e3*u+6e4*l+1e3*s*60*60,this._days=+a+7*i,this._months=+r+3*o+12*n,this._data={},this._locale=ot(),this._bubble();}function Ht(e){return e instanceof Pt}function Lt(e){return 0>e?-1*Math.round(-1*e):Math.round(e)}function xt(e,t){Y(e,0,0,function(){var e=this.utcOffset(),n="+";return 0>e&&(e=-e,n="-"),n+B(~~(e/60),2)+t+B(~~e%60,2)});}function It(e,t){var n=(t||"").match(e);if(null===n)return null;var o=n[n.length-1]||[],r=(o+"").match($r)||["-",0,0],i=60*r[1]+b(r[2]);return 0===i?0:"+"===r[0]?i:-i}function jt(e,n){var o,r;return n._isUTC?(o=n.clone(),r=(w(e)||l(e)?e.valueOf():Tt(e).valueOf())-o.valueOf(),o._d.setTime(o._d.valueOf()+r),t.updateOffset(o,!1),o):Tt(e).local()}function Ft(e){return 15*-Math.round(e._d.getTimezoneOffset()/15)}function Wt(e,n,o){var r,i=this._offset||0;if(!this.isValid())return null!=e?this:NaN;if(null!=e){if("string"==typeof e){if(null===(e=It(ir,e)))return this}else 16>Math.abs(e)&&!o&&(e*=60);return !this._isUTC&&n&&(r=Ft(this)),this._offset=e,this._isUTC=!0,null!=r&&this.add(r,"m"),i!==e&&(!n||this._changeInProgress?nn(this,$t(e-i,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,t.updateOffset(this,!0),this._changeInProgress=null)),this}return this._isUTC?i:Ft(this)}function Bt(e,t){return null!=e?("string"!=typeof e&&(e=-e),this.utcOffset(e,t),this):-this.utcOffset()}function Yt(e){return this.utcOffset(0,e)}function Vt(e){return this._isUTC&&(this.utcOffset(0,e),this._isUTC=!1,e&&this.subtract(Ft(this),"m")),this}function Ut(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var e=It(rr,this._i);null!=e?this.utcOffset(e):this.utcOffset(0,!0);}return this}function zt(e){return !!this.isValid()&&(e=e?Tt(e).utcOffset():0,(this.utcOffset()-e)%60==0)}function Gt(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()}function Kt(){if(!a(this._isDSTShifted))return this._isDSTShifted;var e={};if(m(e,this),e=St(e),e._a){var t=e._isUTC?f(e._a):Tt(e._a);this._isDSTShifted=this.isValid()&&_(e._a,t.toArray())>0;}else this._isDSTShifted=!1;return this._isDSTShifted}function Xt(){return !!this.isValid()&&!this._isUTC}function qt(){return !!this.isValid()&&this._isUTC}function Zt(){return !!this.isValid()&&(this._isUTC&&0===this._offset)}function $t(e,t){var n,o,r,i=e,a=null;return Ht(e)?i={ms:e._milliseconds,d:e._days,M:e._months}:s(e)?(i={},t?i[t]=e:i.milliseconds=e):(a=Jr.exec(e))?(n="-"===a[1]?-1:1,i={y:0,d:b(a[fr])*n,h:b(a[dr])*n,m:b(a[pr])*n,s:b(a[gr])*n,ms:b(Lt(1e3*a[vr]))*n}):(a=Qr.exec(e))?(n="-"===a[1]?-1:1,i={y:Jt(a[2],n),M:Jt(a[3],n),w:Jt(a[4],n),d:Jt(a[5],n),h:Jt(a[6],n),m:Jt(a[7],n),s:Jt(a[8],n)}):null==i?i={}:"object"==typeof i&&("from"in i||"to"in i)&&(r=en(Tt(i.from),Tt(i.to)),i={},i.ms=r.milliseconds,i.M=r.months),o=new Pt(i),Ht(e)&&c(e,"_locale")&&(o._locale=e._locale),o}function Jt(e,t){var n=e&&parseFloat(e.replace(",","."));return (isNaN(n)?0:n)*t}function Qt(e,t){var n={milliseconds:0,months:0};return n.months=t.month()-e.month()+12*(t.year()-e.year()),e.clone().add(n.months,"M").isAfter(t)&&--n.months,n.milliseconds=+t-+e.clone().add(n.months,"M"),n}function en(e,t){var n;return e.isValid()&&t.isValid()?(t=jt(t,e),e.isBefore(t)?n=Qt(e,t):(n=Qt(t,e),n.milliseconds=-n.milliseconds,n.months=-n.months),n):{milliseconds:0,months:0}}function tn(e,t){return function(n,o){var r,i;return null===o||isNaN(+o)||(O(t,"moment()."+t+"(period, number) is deprecated. Please use moment()."+t+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),i=n,n=o,o=i),n="string"==typeof n?+n:n,r=$t(n,o),nn(this,r,e),this}}function nn(e,n,o,r){var i=n._milliseconds,a=Lt(n._days),s=Lt(n._months);e.isValid()&&(r=null==r||r,s&&pe(e,re(e,"Month")+s*o),a&&ie(e,"Date",re(e,"Date")+a*o),i&&e._d.setTime(e._d.valueOf()+i*o),r&&t.updateOffset(e,a||s));}function on(e,t){var n=e.diff(t,"days",!0);return -6>n?"sameElse":-1>n?"lastWeek":0>n?"lastDay":1>n?"sameDay":2>n?"nextDay":7>n?"nextWeek":"sameElse"}function rn(e,n){var o=e||Tt(),r=jt(o,this).startOf("day"),i=t.calendarFormat(this,r)||"sameElse";return this.format(n&&(T(n[i])?n[i].call(this,o):n[i])||this.localeData().calendar(i,this,Tt(o)))}function an(){return new y(this)}function sn(e,t){var n=w(e)?e:Tt(e);return !(!this.isValid()||!n.isValid())&&(t=I(a(t)?"millisecond":t),"millisecond"===t?this.valueOf()>n.valueOf():n.valueOf()<this.clone().startOf(t).valueOf())}function ln(e,t){var n=w(e)?e:Tt(e);return !(!this.isValid()||!n.isValid())&&(t=I(a(t)?"millisecond":t),"millisecond"===t?this.valueOf()<n.valueOf():this.clone().endOf(t).valueOf()<n.valueOf())}function un(e,t,n,o){return o=o||"()",("("===o[0]?this.isAfter(e,n):!this.isBefore(e,n))&&(")"===o[1]?this.isBefore(t,n):!this.isAfter(t,n))}function cn(e,t){var n,o=w(e)?e:Tt(e);return !(!this.isValid()||!o.isValid())&&(t=I(t||"millisecond"),"millisecond"===t?this.valueOf()===o.valueOf():(n=o.valueOf(),this.clone().startOf(t).valueOf()<=n&&n<=this.clone().endOf(t).valueOf()))}function hn(e,t){return this.isSame(e,t)||this.isAfter(e,t)}function fn(e,t){return this.isSame(e,t)||this.isBefore(e,t)}function dn(e,t,n){var o,r,i;if(!this.isValid())return NaN;if(o=jt(e,this),!o.isValid())return NaN;switch(r=6e4*(o.utcOffset()-this.utcOffset()),t=I(t)){case"year":i=pn(this,o)/12;break;case"month":i=pn(this,o);break;case"quarter":i=pn(this,o)/3;break;case"second":i=(this-o)/1e3;break;case"minute":i=(this-o)/6e4;break;case"hour":i=(this-o)/36e5;break;case"day":i=(this-o-r)/864e5;break;case"week":i=(this-o-r)/6048e5;break;default:i=this-o;}return n?i:C(i)}function pn(e,t){var n,o,r=12*(t.year()-e.year())+(t.month()-e.month()),i=e.clone().add(r,"months");return 0>t-i?(n=e.clone().add(r-1,"months"),o=(t-i)/(i-n)):(n=e.clone().add(r+1,"months"),o=(t-i)/(n-i)),-(r+o)||0}function gn(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")}function vn(e){if(!this.isValid())return null;var t=!0!==e,n=t?this.clone().utc():this;return 0>n.year()||n.year()>9999?z(n,t?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):T(Date.prototype.toISOString)?t?this.toDate().toISOString():new Date(this._d.valueOf()).toISOString().replace("Z",z(n,"Z")):z(n,t?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")}function mn(){if(!this.isValid())return "moment.invalid(/* "+this._i+" */)";var e="moment",t="";this.isLocal()||(e=0===this.utcOffset()?"moment.utc":"moment.parseZone",t="Z");return this.format("["+e+'("]'+(0>this.year()||this.year()>9999?"YYYYYY":"YYYY")+"-MM-DD[T]HH:mm:ss.SSS"+t+'[")]')}function yn(e){e||(e=this.isUtc()?t.defaultFormatUtc:t.defaultFormat);var n=z(this,e);return this.localeData().postformat(n)}function wn(e,t){return this.isValid()&&(w(e)&&e.isValid()||Tt(e).isValid())?$t({to:this,from:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()}function Cn(e){return this.from(Tt(),e)}function bn(e,t){return this.isValid()&&(w(e)&&e.isValid()||Tt(e).isValid())?$t({from:this,to:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()}function _n(e){return this.to(Tt(),e)}function Sn(e){var t;return void 0===e?this._locale._abbr:(t=ot(e),null!=t&&(this._locale=t),this)}function En(){return this._locale}function On(e){switch(e=I(e)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":case"date":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0);}return "week"===e&&this.weekday(0),"isoWeek"===e&&this.isoWeekday(1),"quarter"===e&&this.month(3*Math.floor(this.month()/3)),this}function Tn(e){return void 0===(e=I(e))||"millisecond"===e?this:("date"===e&&(e="day"),this.startOf(e).add(1,"isoWeek"===e?"week":e).subtract(1,"ms"))}function kn(){return this._d.valueOf()-6e4*(this._offset||0)}function Rn(){return Math.floor(this.valueOf()/1e3)}function Mn(){return new Date(this.valueOf())}function Dn(){var e=this;return [e.year(),e.month(),e.date(),e.hour(),e.minute(),e.second(),e.millisecond()]}function An(){var e=this;return {years:e.year(),months:e.month(),date:e.date(),hours:e.hours(),minutes:e.minutes(),seconds:e.seconds(),milliseconds:e.milliseconds()}}function Nn(){return this.isValid()?this.toISOString():null}function Pn(){return g(this)}function Hn(){return h({},p(this))}function Ln(){return p(this).overflow}function xn(){return {input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}}function In(e,t){Y(0,[e,e.length],0,t);}function jn(e){return Yn.call(this,e,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)}function Fn(e){return Yn.call(this,e,this.isoWeek(),this.isoWeekday(),1,4)}function Wn(){return Oe(this.year(),1,4)}function Bn(){var e=this.localeData()._week;return Oe(this.year(),e.dow,e.doy)}function Yn(e,t,n,o,r){var i;return null==e?Ee(this,o,r).year:(i=Oe(e,o,r),t>i&&(t=i),Vn.call(this,e,t,n,o,r))}function Vn(e,t,n,o,r){var i=Se(e,t,n,o,r),a=be(i.year,0,i.dayOfYear);return this.year(a.getUTCFullYear()),this.month(a.getUTCMonth()),this.date(a.getUTCDate()),this}function Un(e){return null==e?Math.ceil((this.month()+1)/3):this.month(3*(e-1)+this.month()%3)}function zn(e){var t=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==e?t:this.add(e-t,"d")}function Gn(e,t){t[vr]=b(1e3*("0."+e));}function Kn(){return this._isUTC?"UTC":""}function Xn(){return this._isUTC?"Coordinated Universal Time":""}function qn(e){return Tt(1e3*e)}function Zn(){return Tt.apply(null,arguments).parseZone()}function $n(e){return e}function Jn(e,t,n,o){return ot()[n](f().set(o,t),e)}function Qn(e,t,n){if(s(e)&&(t=e,e=void 0),e=e||"",null!=t)return Jn(e,t,n,"month");var o,r=[];for(o=0;12>o;o++)r[o]=Jn(e,o,n,"month");return r}function eo(e,t,n,o){"boolean"==typeof e?(s(t)&&(n=t,t=void 0),t=t||""):(t=e,n=t,e=!1,s(t)&&(n=t,t=void 0),t=t||"");var r=ot(),i=e?r._week.dow:0;if(null!=n)return Jn(t,(n+i)%7,o,"day");var a,l=[];for(a=0;7>a;a++)l[a]=Jn(t,(a+i)%7,o,"day");return l}function to(e,t){return Qn(e,t,"months")}function no(e,t){return Qn(e,t,"monthsShort")}function oo(e,t,n){return eo(e,t,n,"weekdays")}function ro(e,t,n){return eo(e,t,n,"weekdaysShort")}function io(e,t,n){return eo(e,t,n,"weekdaysMin")}function ao(){var e=this._data;return this._milliseconds=ci(this._milliseconds),this._days=ci(this._days),this._months=ci(this._months),e.milliseconds=ci(e.milliseconds),e.seconds=ci(e.seconds),e.minutes=ci(e.minutes),e.hours=ci(e.hours),e.months=ci(e.months),e.years=ci(e.years),this}function so(e,t,n,o){var r=$t(t,n);return e._milliseconds+=o*r._milliseconds,e._days+=o*r._days,e._months+=o*r._months,e._bubble()}function lo(e,t){return so(this,e,t,1)}function uo(e,t){return so(this,e,t,-1)}function co(e){return 0>e?Math.floor(e):Math.ceil(e)}function ho(){var e,t,n,o,r,i=this._milliseconds,a=this._days,s=this._months,l=this._data;return (0>i||0>a||0>s)&&(i>0||a>0||s>0)&&(i+=864e5*co(po(s)+a),a=0,s=0),l.milliseconds=i%1e3,e=C(i/1e3),l.seconds=e%60,t=C(e/60),l.minutes=t%60,n=C(t/60),l.hours=n%24,a+=C(n/24),r=C(fo(a)),s+=r,a-=co(po(r)),o=C(s/12),s%=12,l.days=a,l.months=s,l.years=o,this}function fo(e){return 4800*e/146097}function po(e){return 146097*e/4800}function go(e){if(!this.isValid())return NaN;var t,n,o=this._milliseconds;if("month"===(e=I(e))||"year"===e)return t=this._days+o/864e5,n=this._months+fo(t),"month"===e?n:n/12;switch(t=this._days+Math.round(po(this._months)),e){case"week":return t/7+o/6048e5;case"day":return t+o/864e5;case"hour":return 24*t+o/36e5;case"minute":return 1440*t+o/6e4;case"second":return 86400*t+o/1e3;case"millisecond":return Math.floor(864e5*t)+o;default:throw Error("Unknown unit "+e)}}function vo(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*b(this._months/12):NaN}function mo(e){return function(){return this.as(e)}}function yo(){return $t(this)}function wo(e){return e=I(e),this.isValid()?this[e+"s"]():NaN}function Co(e){return function(){return this.isValid()?this._data[e]:NaN}}function bo(){return C(this.days()/7)}function _o(e,t,n,o,r){return r.relativeTime(t||1,!!n,e,o)}function So(e,t,n){var o=$t(e).abs(),r=Ti(o.as("s")),i=Ti(o.as("m")),a=Ti(o.as("h")),s=Ti(o.as("d")),l=Ti(o.as("M")),u=Ti(o.as("y")),c=ki.ss>=r&&["s",r]||ki.s>r&&["ss",r]||1>=i&&["m"]||ki.m>i&&["mm",i]||1>=a&&["h"]||ki.h>a&&["hh",a]||1>=s&&["d"]||ki.d>s&&["dd",s]||1>=l&&["M"]||ki.M>l&&["MM",l]||1>=u&&["y"]||["yy",u];return c[2]=t,c[3]=+e>0,c[4]=n,_o.apply(null,c)}function Eo(e){return void 0===e?Ti:"function"==typeof e&&(Ti=e,!0)}function Oo(e,t){return void 0!==ki[e]&&(void 0===t?ki[e]:(ki[e]=t,"s"===e&&(ki.ss=t-1),!0))}function To(e){if(!this.isValid())return this.localeData().invalidDate();var t=this.localeData(),n=So(this,!e,t);return e&&(n=t.pastFuture(+this,n)),t.postformat(n)}function ko(e){return (e>0)-(0>e)||+e}function Ro(){if(!this.isValid())return this.localeData().invalidDate();var e,t,n,o=Ri(this._milliseconds)/1e3,r=Ri(this._days),i=Ri(this._months);e=C(o/60),t=C(e/60),o%=60,e%=60,n=C(i/12),i%=12;var a=n,s=i,l=r,u=t,c=e,h=o?o.toFixed(3).replace(/\.?0+$/,""):"",f=this.asSeconds();if(!f)return "P0D";var d=0>f?"-":"",p=ko(this._months)!==ko(f)?"-":"",g=ko(this._days)!==ko(f)?"-":"",v=ko(this._milliseconds)!==ko(f)?"-":"";return d+"P"+(a?p+a+"Y":"")+(s?p+s+"M":"")+(l?g+l+"D":"")+(u||c||h?"T":"")+(u?v+u+"H":"")+(c?v+c+"M":"")+(h?v+h+"S":"")}var Mo,Do;Do=Array.prototype.some?Array.prototype.some:function(e){for(var t=Object(this),n=t.length>>>0,o=0;n>o;o++)if(o in t&&e.call(this,t[o],o,t))return !0;return !1};var Ao=t.momentProperties=[],No=!1,Po={};t.suppressDeprecationWarnings=!1,t.deprecationHandler=null;var Ho;Ho=Object.keys?Object.keys:function(e){var t,n=[];for(t in e)c(e,t)&&n.push(t);return n};var Lo={sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},xo={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},Io=/\d{1,2}/,jo={future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},Fo={},Wo={},Bo=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,Yo=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,Vo={},Uo={},zo=/\d/,Go=/\d\d/,Ko=/\d{3}/,Xo=/\d{4}/,qo=/[+-]?\d{6}/,Zo=/\d\d?/,$o=/\d\d\d\d?/,Jo=/\d\d\d\d\d\d?/,Qo=/\d{1,3}/,er=/\d{1,4}/,tr=/[+-]?\d{1,6}/,nr=/\d+/,or=/[+-]?\d+/,rr=/Z|[+-]\d\d:?\d\d/gi,ir=/Z|[+-]\d\d(?::?\d\d)?/gi,ar=/[+-]?\d+(\.\d{1,3})?/,sr=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,lr={},ur={},cr=0,hr=1,fr=2,dr=3,pr=4,gr=5,vr=6,mr=7,yr=8;Y("Y",0,0,function(){var e=this.year();return e>9999?"+"+e:""+e}),Y(0,["YY",2],0,function(){return this.year()%100}),Y(0,["YYYY",4],0,"year"),Y(0,["YYYYY",5],0,"year"),Y(0,["YYYYYY",6,!0],0,"year"),x("year","y"),F("year",1),K("Y",or),K("YY",Zo,Go),K("YYYY",er,Xo),K("YYYYY",tr,qo),K("YYYYYY",tr,qo),$(["YYYYY","YYYYYY"],cr),$("YYYY",function(e,n){n[cr]=2===e.length?t.parseTwoDigitYear(e):b(e);}),$("YY",function(e,n){n[cr]=t.parseTwoDigitYear(e);}),$("Y",function(e,t){t[cr]=parseInt(e,10);}),t.parseTwoDigitYear=function(e){return b(e)+(b(e)>68?1900:2e3)};var wr,Cr=oe("FullYear",!0);wr=Array.prototype.indexOf?Array.prototype.indexOf:function(e){var t;for(t=0;this.length>t;++t)if(this[t]===e)return t;return -1},Y("M",["MM",2],"Mo",function(){return this.month()+1}),Y("MMM",0,0,function(e){return this.localeData().monthsShort(this,e)}),Y("MMMM",0,0,function(e){return this.localeData().months(this,e)}),x("month","M"),F("month",8),K("M",Zo),K("MM",Zo,Go),K("MMM",function(e,t){return t.monthsShortRegex(e)}),K("MMMM",function(e,t){return t.monthsRegex(e)}),$(["M","MM"],function(e,t){t[hr]=b(e)-1;}),$(["MMM","MMMM"],function(e,t,n,o){var r=n._locale.monthsParse(e,o,n._strict);null!=r?t[hr]=r:p(n).invalidMonth=e;});var br=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,_r="January_February_March_April_May_June_July_August_September_October_November_December".split("_"),Sr="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),Er=sr,Or=sr;Y("w",["ww",2],"wo","week"),Y("W",["WW",2],"Wo","isoWeek"),x("week","w"),x("isoWeek","W"),F("week",5),F("isoWeek",5),K("w",Zo),K("ww",Zo,Go),K("W",Zo),K("WW",Zo,Go),J(["w","ww","W","WW"],function(e,t,n,o){t[o.substr(0,1)]=b(e);});var Tr={dow:0,doy:6};Y("d",0,"do","day"),Y("dd",0,0,function(e){return this.localeData().weekdaysMin(this,e)}),Y("ddd",0,0,function(e){return this.localeData().weekdaysShort(this,e)}),Y("dddd",0,0,function(e){return this.localeData().weekdays(this,e)}),Y("e",0,0,"weekday"),Y("E",0,0,"isoWeekday"),x("day","d"),x("weekday","e"),x("isoWeekday","E"),F("day",11),F("weekday",11),F("isoWeekday",11),K("d",Zo),K("e",Zo),K("E",Zo),K("dd",function(e,t){return t.weekdaysMinRegex(e)}),K("ddd",function(e,t){return t.weekdaysShortRegex(e)}),K("dddd",function(e,t){return t.weekdaysRegex(e)}),J(["dd","ddd","dddd"],function(e,t,n,o){var r=n._locale.weekdaysParse(e,o,n._strict);null!=r?t.d=r:p(n).invalidWeekday=e;}),J(["d","e","E"],function(e,t,n,o){t[o]=b(e);});var kr="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),Rr="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),Mr="Su_Mo_Tu_We_Th_Fr_Sa".split("_"),Dr=sr,Ar=sr,Nr=sr;Y("H",["HH",2],0,"hour"),Y("h",["hh",2],0,ze),Y("k",["kk",2],0,Ge),Y("hmm",0,0,function(){return ""+ze.apply(this)+B(this.minutes(),2)}),Y("hmmss",0,0,function(){return ""+ze.apply(this)+B(this.minutes(),2)+B(this.seconds(),2)}),Y("Hmm",0,0,function(){return ""+this.hours()+B(this.minutes(),2)}),Y("Hmmss",0,0,function(){return ""+this.hours()+B(this.minutes(),2)+B(this.seconds(),2)}),Ke("a",!0),Ke("A",!1),x("hour","h"),F("hour",13),K("a",Xe),K("A",Xe),K("H",Zo),K("h",Zo),K("k",Zo),K("HH",Zo,Go),K("hh",Zo,Go),K("kk",Zo,Go),K("hmm",$o),K("hmmss",Jo),K("Hmm",$o),K("Hmmss",Jo),$(["H","HH"],dr),$(["k","kk"],function(e,t,n){var o=b(e);t[dr]=24===o?0:o;}),$(["a","A"],function(e,t,n){n._isPm=n._locale.isPM(e),n._meridiem=e;}),$(["h","hh"],function(e,t,n){t[dr]=b(e),p(n).bigHour=!0;}),$("hmm",function(e,t,n){var o=e.length-2;t[dr]=b(e.substr(0,o)),t[pr]=b(e.substr(o)),p(n).bigHour=!0;}),$("hmmss",function(e,t,n){var o=e.length-4,r=e.length-2;t[dr]=b(e.substr(0,o)),t[pr]=b(e.substr(o,2)),t[gr]=b(e.substr(r)),p(n).bigHour=!0;}),$("Hmm",function(e,t,n){var o=e.length-2;t[dr]=b(e.substr(0,o)),t[pr]=b(e.substr(o));}),$("Hmmss",function(e,t,n){var o=e.length-4,r=e.length-2;t[dr]=b(e.substr(0,o)),t[pr]=b(e.substr(o,2)),t[gr]=b(e.substr(r));});var Pr,Hr=/[ap]\.?m?\.?/i,Lr=oe("Hours",!0),xr={calendar:Lo,longDateFormat:xo,invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:Io,relativeTime:jo,months:_r,monthsShort:Sr,week:Tr,weekdays:kr,weekdaysMin:Mr,weekdaysShort:Rr,meridiemParse:Hr},Ir={},jr={},Fr=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,Wr=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,Br=/Z|[+-]\d\d(?::?\d\d)?/,Yr=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],Vr=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],Ur=/^\/?Date\((\-?\d+)/i,zr=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,Gr={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};t.createFromInputFallback=E("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(e){e._d=new Date(e._i+(e._useUTC?" UTC":""));}),t.ISO_8601=function(){},t.RFC_2822=function(){};var Kr=E("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=Tt.apply(null,arguments);return this.isValid()&&e.isValid()?this>e?this:e:v()}),Xr=E("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=Tt.apply(null,arguments);return this.isValid()&&e.isValid()?e>this?this:e:v()}),qr=function(){return Date.now?Date.now():+new Date},Zr=["year","quarter","month","week","day","hour","minute","second","millisecond"];xt("Z",":"),xt("ZZ",""),K("Z",ir),K("ZZ",ir),$(["Z","ZZ"],function(e,t,n){n._useUTC=!0,n._tzm=It(ir,e);});var $r=/([\+\-]|\d\d)/gi;t.updateOffset=function(){};var Jr=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,Qr=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;$t.fn=Pt.prototype,$t.invalid=Nt;var ei=tn(1,"add"),ti=tn(-1,"subtract");t.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",t.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var ni=E("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(e){return void 0===e?this.localeData():this.locale(e)});Y(0,["gg",2],0,function(){return this.weekYear()%100}),Y(0,["GG",2],0,function(){return this.isoWeekYear()%100}),In("gggg","weekYear"),In("ggggg","weekYear"),In("GGGG","isoWeekYear"),In("GGGGG","isoWeekYear"),x("weekYear","gg"),x("isoWeekYear","GG"),F("weekYear",1),F("isoWeekYear",1),K("G",or),K("g",or),K("GG",Zo,Go),K("gg",Zo,Go),K("GGGG",er,Xo),K("gggg",er,Xo),K("GGGGG",tr,qo),K("ggggg",tr,qo),J(["gggg","ggggg","GGGG","GGGGG"],function(e,t,n,o){t[o.substr(0,2)]=b(e);}),J(["gg","GG"],function(e,n,o,r){n[r]=t.parseTwoDigitYear(e);}),Y("Q",0,"Qo","quarter"),x("quarter","Q"),F("quarter",7),K("Q",zo),$("Q",function(e,t){t[hr]=3*(b(e)-1);}),Y("D",["DD",2],"Do","date"),x("date","D"),F("date",9),K("D",Zo),K("DD",Zo,Go),K("Do",function(e,t){return e?t._dayOfMonthOrdinalParse||t._ordinalParse:t._dayOfMonthOrdinalParseLenient}),$(["D","DD"],fr),$("Do",function(e,t){t[fr]=b(e.match(Zo)[0]);});var oi=oe("Date",!0);Y("DDD",["DDDD",3],"DDDo","dayOfYear"),x("dayOfYear","DDD"),F("dayOfYear",4),K("DDD",Qo),K("DDDD",Ko),$(["DDD","DDDD"],function(e,t,n){n._dayOfYear=b(e);}),Y("m",["mm",2],0,"minute"),x("minute","m"),F("minute",14),K("m",Zo),K("mm",Zo,Go),$(["m","mm"],pr);var ri=oe("Minutes",!1);Y("s",["ss",2],0,"second"),x("second","s"),F("second",15),K("s",Zo),K("ss",Zo,Go),$(["s","ss"],gr);var ii=oe("Seconds",!1);Y("S",0,0,function(){return ~~(this.millisecond()/100)}),Y(0,["SS",2],0,function(){return ~~(this.millisecond()/10)}),Y(0,["SSS",3],0,"millisecond"),Y(0,["SSSS",4],0,function(){return 10*this.millisecond()}),Y(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),Y(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),Y(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),Y(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),Y(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),x("millisecond","ms"),F("millisecond",16),K("S",Qo,zo),K("SS",Qo,Go),K("SSS",Qo,Ko);var ai;for(ai="SSSS";9>=ai.length;ai+="S")K(ai,nr);for(ai="S";9>=ai.length;ai+="S")$(ai,Gn);var si=oe("Milliseconds",!1);Y("z",0,0,"zoneAbbr"),Y("zz",0,0,"zoneName");var li=y.prototype;li.add=ei,li.calendar=rn,li.clone=an,li.diff=dn,li.endOf=Tn,li.format=yn,li.from=wn,li.fromNow=Cn,li.to=bn,li.toNow=_n,li.get=ae,li.invalidAt=Ln,li.isAfter=sn,li.isBefore=ln,li.isBetween=un,li.isSame=cn,li.isSameOrAfter=hn,li.isSameOrBefore=fn,li.isValid=Pn,li.lang=ni,li.locale=Sn,li.localeData=En,li.max=Xr,li.min=Kr,li.parsingFlags=Hn,li.set=se,li.startOf=On,li.subtract=ti,li.toArray=Dn,li.toObject=An,li.toDate=Mn,li.toISOString=vn,li.inspect=mn,li.toJSON=Nn,li.toString=gn,li.unix=Rn,li.valueOf=kn,li.creationData=xn,li.year=Cr,li.isLeapYear=ne,li.weekYear=jn,li.isoWeekYear=Fn,li.quarter=li.quarters=Un,li.month=ge,li.daysInMonth=ve,li.week=li.weeks=Me,li.isoWeek=li.isoWeeks=De,li.weeksInYear=Bn,li.isoWeeksInYear=Wn,li.date=oi,li.day=li.days=je,li.weekday=Fe,li.isoWeekday=We,li.dayOfYear=zn,li.hour=li.hours=Lr,li.minute=li.minutes=ri,li.second=li.seconds=ii,li.millisecond=li.milliseconds=si,li.utcOffset=Wt,li.utc=Yt,li.local=Vt,li.parseZone=Ut,li.hasAlignedHourOffset=zt,li.isDST=Gt,li.isLocal=Xt,li.isUtcOffset=qt,li.isUtc=Zt,li.isUTC=Zt,li.zoneAbbr=Kn,li.zoneName=Xn,li.dates=E("dates accessor is deprecated. Use date instead.",oi),li.months=E("months accessor is deprecated. Use month instead",ge),li.years=E("years accessor is deprecated. Use year instead",Cr),li.zone=E("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",Bt),li.isDSTShifted=E("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",Kt);var ui=M.prototype;ui.calendar=D,ui.longDateFormat=A,ui.invalidDate=N,ui.ordinal=P,ui.preparse=$n,ui.postformat=$n,ui.relativeTime=H,ui.pastFuture=L,ui.set=k,ui.months=ce,ui.monthsShort=he,ui.monthsParse=de,ui.monthsRegex=ye,ui.monthsShortRegex=me,ui.week=Te,ui.firstDayOfYear=Re,ui.firstDayOfWeek=ke,ui.weekdays=Pe,ui.weekdaysMin=Le,ui.weekdaysShort=He,ui.weekdaysParse=Ie,ui.weekdaysRegex=Be,ui.weekdaysShortRegex=Ye,ui.weekdaysMinRegex=Ve,ui.isPM=qe,ui.meridiem=Ze,et("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var t=e%10;return e+(1===b(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th")}}),t.lang=E("moment.lang is deprecated. Use moment.locale instead.",et),t.langData=E("moment.langData is deprecated. Use moment.localeData instead.",ot);var ci=Math.abs,hi=mo("ms"),fi=mo("s"),di=mo("m"),pi=mo("h"),gi=mo("d"),vi=mo("w"),mi=mo("M"),yi=mo("y"),wi=Co("milliseconds"),Ci=Co("seconds"),bi=Co("minutes"),_i=Co("hours"),Si=Co("days"),Ei=Co("months"),Oi=Co("years"),Ti=Math.round,ki={ss:44,s:45,m:45,h:22,d:26,M:11},Ri=Math.abs,Mi=Pt.prototype;return Mi.isValid=At,Mi.abs=ao,Mi.add=lo,Mi.subtract=uo,Mi.as=go,Mi.asMilliseconds=hi,Mi.asSeconds=fi,Mi.asMinutes=di,Mi.asHours=pi,Mi.asDays=gi,Mi.asWeeks=vi,Mi.asMonths=mi,Mi.asYears=yi,Mi.valueOf=vo,Mi._bubble=ho,Mi.clone=yo,Mi.get=wo,Mi.milliseconds=wi,Mi.seconds=Ci,Mi.minutes=bi,Mi.hours=_i,Mi.days=Si,Mi.weeks=bo,Mi.months=Ei,Mi.years=Oi,Mi.humanize=To,Mi.toISOString=Ro,Mi.toString=Ro,Mi.toJSON=Ro,Mi.locale=Sn,Mi.localeData=En,Mi.toIsoString=E("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",Ro),Mi.lang=ni,Y("X",0,0,"unix"),Y("x",0,0,"valueOf"),K("x",or),K("X",ar),$("X",function(e,t,n){n._d=new Date(1e3*parseFloat(e,10));}),$("x",function(e,t,n){n._d=new Date(b(e));}),t.version="2.20.1",function(e){Mo=e;}(Tt),t.fn=li,t.min=Rt,t.max=Mt,t.now=qr,t.utc=f,t.unix=qn,t.months=to,t.isDate=l,t.locale=et,t.invalid=v,t.duration=$t,t.isMoment=w,t.weekdays=oo,t.parseZone=Zn,t.localeData=ot,t.isDuration=Ht,t.monthsShort=no,t.weekdaysMin=io,t.defineLocale=tt,t.updateLocale=nt,t.locales=rt,t.weekdaysShort=ro,t.normalizeUnits=I,t.relativeTimeRounding=Eo,t.relativeTimeThreshold=Oo,t.calendarFormat=on,t.prototype=li,t.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"YYYY-[W]WW",MONTH:"YYYY-MM"},t}),window.moment=n(47);}).call(t,n(183)(e));},function(e,t,n){t.__esModule=!0;var o=n(2),r=n(1),i={_localHooks:Object.create(null),addLocalHook:function(e,t){return this._localHooks[e]||(this._localHooks[e]=[]),this._localHooks[e].push(t),this},runLocalHooks:function(e){for(var t=this,n=arguments.length,r=Array(n>1?n-1:0),i=1;n>i;i++)r[i-1]=arguments[i];this._localHooks[e]&&(0, o.arrayEach)(this._localHooks[e],function(e){return e.apply(t,r)});},clearLocalHooks:function(){return this._localHooks={},this}};(0, r.defineGetter)(i,"MIXIN_NAME","localHooks",{writable:!1,enumerable:!1}),t.default=i;},function(e,t,n){function o(e,t){return "border_row"+e+"col"+t}function r(){return {width:1,color:"#000"}}function i(){return {hide:!0}}function a(){return {width:1,color:"#000",cornerVisible:!1}}function s(e,t){return {id:o(e,t),border:a(),row:e,col:t,top:i(),right:i(),bottom:i(),left:i()}}function l(e,t){return (0, h.hasOwnProperty)(t,"border")&&(e.border=t.border),(0, h.hasOwnProperty)(t,"top")&&(t.top?((0, h.isObject)(t.top)||(t.top=r()),e.top=t.top):(t.top=i(),e.top=t.top)),(0, h.hasOwnProperty)(t,"right")&&(t.right?((0, h.isObject)(t.right)||(t.right=r()),e.right=t.right):(t.right=i(),e.right=t.right)),(0, h.hasOwnProperty)(t,"bottom")&&(t.bottom?((0, h.isObject)(t.bottom)||(t.bottom=r()),e.bottom=t.bottom):(t.bottom=i(),e.bottom=t.bottom)),(0, h.hasOwnProperty)(t,"left")&&(t.left?((0, h.isObject)(t.left)||(t.left=r()),e.left=t.left):(t.left=i(),e.left=t.left)),e}function u(e,t){var n=!1;return (0, f.arrayEach)(e.getSelectedRange(),function(o){o.forAll(function(o,r){var i=e.getCellMeta(o,r).borders;if(i){if(!t)return n=!0,!1;if(!(0, h.hasOwnProperty)(i[t],"hide")||!1===i[t].hide)return n=!0,!1}});}),n}function c(e){return '<span class="selected">'+String.fromCharCode(10003)+"</span>"+e}t.__esModule=!0,t.createId=o,t.createDefaultCustomBorder=r,t.createSingleEmptyBorder=i,t.createDefaultHtBorder=a,t.createEmptyBorders=s,t.extendDefaultBorder=l,t.checkSelectionBorders=u,t.markSelected=c;var h=n(1),f=n(2);},function(e,t){e.exports=!1;},function(e,t){var n=0,o=Math.random();e.exports=function(e){return "Symbol(".concat(void 0===e?"":e,")_",(++n+o).toString(36))};},function(e,t){e.exports=function(e,t){return {enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}};},function(e,t){e.exports={};},function(e,t,n){var o=n(20).f,r=n(28),i=n(13)("toStringTag");e.exports=function(e,t,n){e&&!r(e=n?e:e.prototype,i)&&o(e,i,{configurable:!0,value:t});};},function(e,t){t.f={}.propertyIsEnumerable;},function(e,t,n){function o(e){this.instance=e,this.state=a.VIRGIN,this._opened=!1,this._fullEditMode=!1,this._closeCallback=null,this.init();}t.__esModule=!0,t.EditorState=void 0;var r=n(4),i=n(10),a=t.EditorState={VIRGIN:"STATE_VIRGIN",EDITING:"STATE_EDITING",WAITING:"STATE_WAITING",FINISHED:"STATE_FINISHED"};o.prototype._fireCallbacks=function(e){this._closeCallback&&(this._closeCallback(e),this._closeCallback=null);},o.prototype.init=function(){},o.prototype.getValue=function(){throw Error("Editor getValue() method unimplemented")},o.prototype.setValue=function(){throw Error("Editor setValue() method unimplemented")},o.prototype.open=function(){throw Error("Editor open() method unimplemented")},o.prototype.close=function(){throw Error("Editor close() method unimplemented")},o.prototype.prepare=function(e,t,n,o,r,i){this.TD=o,this.row=e,this.col=t,this.prop=n,this.originalValue=r,this.cellProperties=i,this.state=a.VIRGIN;},o.prototype.extend=function(){function e(){for(var e=arguments.length,n=Array(e),o=0;e>o;o++)n[o]=arguments[o];t.apply(this,n);}var t=this.constructor;return function(e,t){function n(){}return n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e,e}(e,t)},o.prototype.saveValue=function(e,t){var n=void 0,o=void 0;t?(n=this.instance.getSelectedLast(),n[0]>n[2]&&(o=n[0],n[0]=n[2],n[2]=o),n[1]>n[3]&&(o=n[1],n[1]=n[3],n[3]=o)):n=[this.row,this.col,null,null],this.instance.populateFromArray(n[0],n[1],e,n[2],n[3],"edit");},o.prototype.beginEditing=function(e,t){if(this.state===a.VIRGIN){if(this.instance.view.scrollViewport(new r.CellCoords(this.row,this.col)),this.state=a.EDITING,this.isInFullEditMode()){this.setValue("string"==typeof e?e:(0, i.stringify)(this.originalValue));}this.open(t),this._opened=!0,this.focus(),this.instance.view.render(),this.instance.runHooks("afterBeginEditing",this.row,this.col);}},o.prototype.finishEditing=function(e,t,n){var o=this,r=void 0;if(n){var i=this._closeCallback;this._closeCallback=function(e){i&&i(e),n(e),o.instance.view.render();};}if(!this.isWaiting()){if(this.state===a.VIRGIN)return void this.instance._registerTimeout(function(){o._fireCallbacks(!0);});if(this.state===a.EDITING){if(e)return this.cancelChanges(),void this.instance.view.render();var s=this.getValue();r=this.instance.getSettings().trimWhitespace?[["string"==typeof s?String.prototype.trim.call(s||""):s]]:[[s]],this.state=a.WAITING,this.saveValue(r,t),this.instance.getCellValidator(this.cellProperties)?this.instance.addHookOnce("postAfterValidate",function(e){o.state=a.FINISHED,o.discardEditor(e);}):(this.state=a.FINISHED,this.discardEditor(!0));}}},o.prototype.cancelChanges=function(){this.state=a.FINISHED,this.discardEditor();},o.prototype.discardEditor=function(e){this.state===a.FINISHED&&(!1===e&&!0!==this.cellProperties.allowInvalid?(this.instance.selectCell(this.row,this.col),this.focus(),this.state=a.EDITING,this._fireCallbacks(!1)):(this.close(),this._opened=!1,this._fullEditMode=!1,this.state=a.VIRGIN,this._fireCallbacks(!0)));},o.prototype.enableFullEditMode=function(){this._fullEditMode=!0;},o.prototype.isInFullEditMode=function(){return this._fullEditMode},o.prototype.isOpened=function(){return this._opened},o.prototype.isWaiting=function(){return this.state===a.WAITING},o.prototype.checkEditorSection=function(){var e=this.instance.countRows(),t="";return this.row<this.instance.getSettings().fixedRowsTop?t=this.col<this.instance.getSettings().fixedColumnsLeft?"top-left-corner":"top":this.instance.getSettings().fixedRowsBottom&&this.row>=e-this.instance.getSettings().fixedRowsBottom?t=this.col<this.instance.getSettings().fixedColumnsLeft?"bottom-left-corner":"bottom":this.col<this.instance.getSettings().fixedColumnsLeft&&(t="left"),t},t.default=o;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}();t.default=function(){function e(t,n){o(this,e),this.row=null,this.col=null,void 0!==t&&void 0!==n&&(this.row=t,this.col=n);}return r(e,[{key:"isValid",value:function(e){return this.row>=0&&this.col>=0&&(this.row<e.getSetting("totalRows")&&this.col<e.getSetting("totalColumns"))}},{key:"isEqual",value:function(e){return e===this||this.row===e.row&&this.col===e.col}},{key:"isSouthEastOf",value:function(e){return this.row>=e.row&&this.col>=e.col}},{key:"isNorthWestOf",value:function(e){return e.row>=this.row&&e.col>=this.col}},{key:"isSouthWestOf",value:function(e){return this.row>=e.row&&e.col>=this.col}},{key:"isNorthEastOf",value:function(e){return e.row>=this.row&&this.col>=e.col}},{key:"toObject",value:function(){return {row:this.row,col:this.col}}}]),e}();},function(e,t,n){function o(){if((0, s.isDefined)(console)){var e;(e=console).log.apply(e,arguments);}}function r(){if((0, s.isDefined)(console)){var e;(e=console).warn.apply(e,arguments);}}function i(){if((0, s.isDefined)(console)){var e;(e=console).info.apply(e,arguments);}}function a(){if((0, s.isDefined)(console)){var e;(e=console).error.apply(e,arguments);}}t.__esModule=!0,t.log=o,t.warn=r,t.info=i,t.error=a;var s=n(10);},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var r=n(0),i=n(483),a=o(i),s=n(56),l=o(s),u=n(6),c=o(u),h=n(21),f=n(12),d=l.default.prototype.extend();d.prototype.init=function(){var e=this;this.createElements(),this.eventManager=new c.default(this),this.bindEvents(),this.autoResize=(0, a.default)(),this.holderZIndex=-1,this.instance.addHook("afterDestroy",function(){e.destroy();});},d.prototype.prepare=function(e,t,n,o,r,i){for(var a=this,u=this.state,c=arguments.length,h=Array(c>6?c-6:0),f=6;c>f;f++)h[f-6]=arguments[f];if(l.default.prototype.prepare.apply(this,[e,t,n,o,r,i].concat(h)),!i.readOnly){this.refreshDimensions(!0);var d=i.allowInvalid,p=i.fragmentSelection;d&&(this.TEXTAREA.value=""),u!==s.EditorState.FINISHED&&this.hideEditableElement();!p&&this.instance._registerImmediate(function(){return a.focus()});}},d.prototype.hideEditableElement=function(){this.textareaParentStyle.top="-9999px",this.textareaParentStyle.left="-9999px",this.textareaParentStyle.zIndex="-1",this.textareaParentStyle.position="fixed";},d.prototype.showEditableElement=function(){this.textareaParentStyle.zIndex=0>this.holderZIndex?"":this.holderZIndex,this.textareaParentStyle.position="";},d.prototype.getValue=function(){return this.TEXTAREA.value},d.prototype.setValue=function(e){this.TEXTAREA.value=e;},d.prototype.beginEditing=function(){if(this.state===s.EditorState.VIRGIN){this.TEXTAREA.value="";for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];l.default.prototype.beginEditing.apply(this,t);}};var p=function(e){var t=this,n=t.getActiveEditor(),o=(e.ctrlKey||e.metaKey)&&!e.altKey;if(e.target===n.TEXTAREA&&!(0, f.isImmediatePropagationStopped)(e)){switch(e.keyCode){case h.KEY_CODES.ARROW_RIGHT:case h.KEY_CODES.ARROW_LEFT:n.isInFullEditMode()&&(!n.isWaiting()&&!n.allowKeyEventPropagation||!n.isWaiting()&&n.allowKeyEventPropagation&&!n.allowKeyEventPropagation(e.keyCode))&&(0, f.stopImmediatePropagation)(e);break;case h.KEY_CODES.ARROW_UP:case h.KEY_CODES.ARROW_DOWN:n.isInFullEditMode()&&(!n.isWaiting()&&!n.allowKeyEventPropagation||!n.isWaiting()&&n.allowKeyEventPropagation&&!n.allowKeyEventPropagation(e.keyCode))&&(0, f.stopImmediatePropagation)(e);break;case h.KEY_CODES.ENTER:var i=this.selection.isMultiple();if(o&&!i||e.altKey){if(n.isOpened()){var a=(0, r.getCaretPosition)(n.TEXTAREA),s=n.getValue();n.setValue(s.slice(0,a)+"\n"+s.slice(a)),(0, r.setCaretPosition)(n.TEXTAREA,a+1);}else n.beginEditing(n.originalValue+"\n");(0, f.stopImmediatePropagation)(e);}e.preventDefault();break;case h.KEY_CODES.BACKSPACE:case h.KEY_CODES.DELETE:case h.KEY_CODES.HOME:case h.KEY_CODES.END:(0, f.stopImmediatePropagation)(e);}-1===[h.KEY_CODES.ARROW_UP,h.KEY_CODES.ARROW_RIGHT,h.KEY_CODES.ARROW_DOWN,h.KEY_CODES.ARROW_LEFT].indexOf(e.keyCode)&&n.autoResize.resize(String.fromCharCode(e.keyCode));}};d.prototype.open=function(){this.refreshDimensions(),this.showEditableElement(),this.instance.addHook("beforeKeyDown",p);},d.prototype.close=function(){this.autoResize.unObserve(),document.activeElement===this.TEXTAREA&&this.instance.listen(),this.hideEditableElement(),this.instance.removeHook("beforeKeyDown",p);},d.prototype.focus=function(){this.TEXTAREA.select(),(0, r.setCaretPosition)(this.TEXTAREA,this.TEXTAREA.value.length);},d.prototype.createElements=function(){this.TEXTAREA=document.createElement("TEXTAREA"),this.TEXTAREA.tabIndex=-1,(0, r.addClass)(this.TEXTAREA,"handsontableInput"),this.textareaStyle=this.TEXTAREA.style,this.textareaStyle.width=0,this.textareaStyle.height=0,this.TEXTAREA_PARENT=document.createElement("DIV"),(0, r.addClass)(this.TEXTAREA_PARENT,"handsontableInputHolder"),this.textareaParentStyle=this.TEXTAREA_PARENT.style,this.textareaParentStyle.zIndex="-1",this.TEXTAREA_PARENT.appendChild(this.TEXTAREA),this.instance.rootElement.appendChild(this.TEXTAREA_PARENT);},d.prototype.getEditedCell=function(){var e=this.checkEditorSection(),t=void 0;switch(e){case"top":t=this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.getCell({row:this.row,col:this.col}),this.holderZIndex=101;break;case"top-left-corner":t=this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell({row:this.row,col:this.col}),this.holderZIndex=103;break;case"bottom-left-corner":t=this.instance.view.wt.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.getCell({row:this.row,col:this.col}),this.holderZIndex=103;break;case"left":t=this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.getCell({row:this.row,col:this.col}),this.holderZIndex=102;break;case"bottom":t=this.instance.view.wt.wtOverlays.bottomOverlay.clone.wtTable.getCell({row:this.row,col:this.col}),this.holderZIndex=102;break;default:t=this.instance.getCell(this.row,this.col),this.holderZIndex=-1;}return -1!==t&&-2!==t?t:void 0},d.prototype.refreshValue=function(){var e=this.instance.toPhysicalRow(this.row),t=this.instance.getSourceDataAtCell(e,this.col);this.originalValue=t,this.setValue(t),this.refreshDimensions();},d.prototype.refreshDimensions=function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.state===s.EditorState.EDITING||e){if(!(this.TD=this.getEditedCell()))return void(e||this.close(!0));var t=(0, r.offset)(this.TD),n=(0, r.offset)(this.instance.rootElement),o=this.instance.view.wt.wtOverlays.topOverlay.mainTableScrollableElement,i=this.instance.view.wt.wtOverlays.leftOverlay.mainTableScrollableElement,a=this.instance.countRows(),l=o!==window?o.scrollTop:0,u=i!==window?i.scrollLeft:0,c=this.checkEditorSection(),h=["","left"].includes(c)?l:0,f=["","top","bottom"].includes(c)?u:0,d=t.top===n.top?0:1,p=this.instance.getSettings(),g=this.instance.hasColHeaders(),v=this.TD.style.backgroundColor,m=t.top-n.top-d-h,y=t.left-n.left-1-f,w=void 0;switch(c){case"top":w=(0, r.getCssTransform)(this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.holder.parentNode);break;case"left":w=(0, r.getCssTransform)(this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.holder.parentNode);break;case"top-left-corner":w=(0, r.getCssTransform)(this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.holder.parentNode);break;case"bottom-left-corner":w=(0, r.getCssTransform)(this.instance.view.wt.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.holder.parentNode);break;case"bottom":w=(0, r.getCssTransform)(this.instance.view.wt.wtOverlays.bottomOverlay.clone.wtTable.holder.parentNode);}(g&&0===this.instance.getSelectedLast()[0]||p.fixedRowsBottom&&this.instance.getSelectedLast()[0]===a-p.fixedRowsBottom)&&(m+=1),0===this.instance.getSelectedLast()[1]&&(y+=1),w&&-1!==w?this.textareaParentStyle[w[0]]=w[1]:(0, r.resetCssTransform)(this.TEXTAREA_PARENT),this.textareaParentStyle.top=m+"px",this.textareaParentStyle.left=y+"px",this.showEditableElement();var C=this.instance.view.wt.wtViewport.rowsRenderCalculator.startPosition,b=this.instance.view.wt.wtViewport.columnsRenderCalculator.startPosition,_=this.instance.view.wt.wtOverlays.leftOverlay.getScrollPosition(),S=this.instance.view.wt.wtOverlays.topOverlay.getScrollPosition(),E=(0, r.getScrollbarWidth)(),O=this.TD.offsetTop+C-S,T=this.TD.offsetLeft+b-_,k=(0, r.innerWidth)(this.TD)-8,R=(0, r.hasVerticalScrollbar)(o)?E:0,M=(0, r.hasHorizontalScrollbar)(i)?E:0,D=this.instance.view.maximumVisibleElementWidth(T)-9-R,A=this.TD.scrollHeight+1,N=Math.max(this.instance.view.maximumVisibleElementHeight(O)-M,23),P=(0, r.getComputedStyle)(this.TD);this.TEXTAREA.style.fontSize=P.fontSize,this.TEXTAREA.style.fontFamily=P.fontFamily,this.TEXTAREA.style.backgroundColor=v,this.autoResize.init(this.TEXTAREA,{minHeight:Math.min(A,N),maxHeight:N,minWidth:Math.min(k,D),maxWidth:D},!0);}},d.prototype.bindEvents=function(){var e=this;this.eventManager.addEventListener(this.TEXTAREA,"cut",function(e){(0, f.stopPropagation)(e);}),this.eventManager.addEventListener(this.TEXTAREA,"paste",function(e){(0, f.stopPropagation)(e);}),this.instance.addHook("afterScrollHorizontally",function(){e.refreshDimensions();}),this.instance.addHook("afterScrollVertically",function(){e.refreshDimensions();}),this.instance.addHook("afterColumnResize",function(){e.refreshDimensions(),e.focus();}),this.instance.addHook("afterRowResize",function(){e.refreshDimensions(),e.focus();}),this.instance.addHook("afterDestroy",function(){e.eventManager.destroy();});},d.prototype.destroy=function(){this.eventManager.destroy();},t.default=d;},function(e,t,n){t.__esModule=!0,t.sort=t.DO_NOT_SWAP=t.FIRST_BEFORE_SECOND=t.FIRST_AFTER_SECOND=t.getCompareFunctionFactory=t.getRootComparator=t.registerRootComparator=void 0;var o=n(449),r=n(549);t.registerRootComparator=o.registerRootComparator,t.getRootComparator=o.getRootComparator,t.getCompareFunctionFactory=o.getCompareFunctionFactory,t.FIRST_AFTER_SECOND=r.FIRST_AFTER_SECOND,t.FIRST_BEFORE_SECOND=r.FIRST_BEFORE_SECOND,t.DO_NOT_SWAP=r.DO_NOT_SWAP,t.sort=r.sort;},function(e,t){var n=Math.ceil,o=Math.floor;e.exports=function(e){return isNaN(e=+e)?0:(e>0?o:n)(e)};},function(e,t,n){var o=n(61),r=Math.max,i=Math.min;e.exports=function(e,t){return e=o(e),0>e?r(e+t,0):i(e,t)};},function(e,t,n){var o=n(29);e.exports=function(e,t,n){for(var r in t)o(e,r,t[r],n);return e};},function(e,t){e.exports=function(e){if("function"!=typeof e)throw TypeError(e+" is not a function!");return e};},function(e,t){e.exports=function(e,t,n,o){if(!(e instanceof t)||void 0!==o&&o in e)throw TypeError(n+": incorrect invocation!");return e};},function(e,t,n){var o=n(31),r=n(105),i=n(106),a=n(18),s=n(25),l=n(107),u={},c={},t=e.exports=function(e,t,n,h,f){var d,p,g,v,m=f?function(){return e}:l(e),y=o(n,h,t?2:1),w=0;if("function"!=typeof m)throw TypeError(e+" is not iterable!");if(i(m)){for(d=s(e.length);d>w;w++)if((v=t?y(a(p=e[w])[0],p[1]):y(e[w]))===u||v===c)return v}else for(g=m.call(e);!(p=g.next()).done;)if((v=r(g,y,p.value,t))===u||v===c)return v};t.BREAK=u,t.RETURN=c;},function(e,t,n){var o=n(15),r=n(3),i=n(29),a=n(63),s=n(33),l=n(66),u=n(65),c=n(9),h=n(23),f=n(81),d=n(54),p=n(456);e.exports=function(e,t,n,g,v,m){var y=o[e],w=y,C=v?"set":"add",b=w&&w.prototype,_={},S=function(e){var t=b[e];i(b,e,"delete"==e?function(e){return !(m&&!c(e))&&t.call(this,0===e?0:e)}:"has"==e?function(e){return !(m&&!c(e))&&t.call(this,0===e?0:e)}:"get"==e?function(e){return m&&!c(e)?void 0:t.call(this,0===e?0:e)}:"add"==e?function(e){return t.call(this,0===e?0:e),this}:function(e,n){return t.call(this,0===e?0:e,n),this});};if("function"==typeof w&&(m||b.forEach&&!h(function(){(new w).entries().next();}))){var E=new w,O=E[C](m?{}:-0,1)!=E,T=h(function(){E.has(1);}),k=f(function(e){new w(e);}),R=!m&&h(function(){for(var e=new w,t=5;t--;)e[C](t,t);return !e.has(-0)});k||(w=t(function(t,n){u(t,w,e);var o=p(new y,t,w);return void 0!=n&&l(n,v,o[C],o),o}),w.prototype=b,b.constructor=w),(T||R)&&(S("delete"),S("has"),v&&S("get")),(R||O)&&S(C),m&&b.clear&&delete b.clear;}else w=g.getConstructor(t,e,v,C),a(w.prototype,n),s.NEED=!0;return d(w,e),_[e]=w,r(r.G+r.W+r.F*(w!=y),_),m||g.setStrong(w,e,v),w};},function(e,t,n){var o=n(55),r=n(52),i=n(24),a=n(75),s=n(28),l=n(101),u=Object.getOwnPropertyDescriptor;t.f=n(22)?u:function(e,t){if(e=i(e),t=a(t,!0),l)try{return u(e,t)}catch(e){}if(s(e,t))return r(!o.f.call(e,t),e[t])};},function(e,t,n){var o=n(31),r=n(77),i=n(32),a=n(25),s=n(457);e.exports=function(e,t){var n=1==e,l=2==e,u=3==e,c=4==e,h=6==e,f=5==e||h,d=t||s;return function(t,s,p){for(var g,v,m=i(t),y=r(m),w=o(s,p,3),C=a(y.length),b=0,_=n?d(t,C):l?d(t,0):void 0;C>b;b++)if((f||b in y)&&(g=y[b],v=w(g,b,m),e))if(n)_[b]=v;else if(v)switch(e){case 3:return !0;case 5:return g;case 6:return b;case 2:_.push(g);}else if(c)return !1;return h?-1:u||c?c:_}};},function(e,t){t.f=Object.getOwnPropertySymbols;},function(e,t,n){var o=n(30),r=n(29),i=n(23),a=n(39),s=n(13);e.exports=function(e,t,n){var l=s(e),u=n(a,l,""[e]),c=u[0],h=u[1];i(function(){var t={};return t[l]=function(){return 7},7!=""[e](t)})&&(r(String.prototype,e,c),o(RegExp.prototype,l,2==t?function(e,t){return h.call(e,this,t)}:function(e){return h.call(e,this)}));};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){var n=e,o=t;return (0, c.isObject)(e)&&(o=e,n=o.languageCode),l(n,o),y(n,(0, c.deepClone)(o)),(0, c.deepClone)(o)}function i(e){return a(e)?(0, c.deepClone)(w(e)):null}function a(e){return C(e)}function s(){return g.default}function l(e,t){e!==v&&(0, h.extendNotExistingKeys)(t,w(v));}function u(){return b()}t.__esModule=!0,t.DEFAULT_LANGUAGE_CODE=t.getLanguagesDictionaries=t.getDefaultLanguageDictionary=t.hasLanguageDictionary=t.getLanguageDictionary=t.registerLanguageDictionary=void 0;var c=n(1),h=n(444),f=n(34),d=o(f),p=n(520),g=o(p),v=g.default.languageCode,m=(0, d.default)("languagesDictionaries"),y=m.register,w=m.getItem,C=m.hasItem,b=m.getValues;t.registerLanguageDictionary=r,t.getLanguageDictionary=i,t.hasLanguageDictionary=a,t.getDefaultLanguageDictionary=s,t.getLanguagesDictionaries=u,t.DEFAULT_LANGUAGE_CODE=v,r(g.default);},function(e,t,n){function o(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:w;if(t!==w&&t!==C)throw Error("The second argument is used internally only and cannot be overwritten.");var n=Array.isArray(e),r=t===w,i=d;if(n){var a=e[0];if(0===e.length)i=p;else if(r&&a instanceof c.CellRange)i=v;else if(r&&Array.isArray(a))i=o(a,C);else if(e.length>=2&&4>=e.length){var s=!e.some(function(e,t){return !y[t].includes(void 0===e?"undefined":u(e))});s&&(i=g);}}return i}function r(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=t.keepDirection,o=void 0!==n&&n,r=t.propToCol;if(!m.includes(e))throw Error("Unsupported selection ranges schema type was provided.");return function(t){var n=e===v,i=n?t.from.row:t[0],a=n?t.from.col:t[1],s=n?t.to.row:t[2],l=n?t.to.col:t[3];if("function"==typeof r&&("string"==typeof a&&(a=r(a)),"string"==typeof l&&(l=r(l))),(0, f.isUndefined)(s)&&(s=i),(0, f.isUndefined)(l)&&(l=a),!o){var u=i,c=a,h=s,d=l;i=Math.min(u,h),a=Math.min(c,d),s=Math.max(u,h),l=Math.max(c,d);}return [i,a,s,l]}}function i(e){var t=o(e);if(t===d||t===p)return [];var n=r(t),i=new Set;(0, h.arrayEach)(e,function(e){var t=n(e),o=l(t,4),r=o[1],a=o[3],s=a-r+1;(0, h.arrayEach)(Array.from(Array(s),function(e,t){return r+t}),function(e){i.has(e)||i.add(e);});});var a=Array.from(i).sort(function(e,t){return e-t});return (0, h.arrayReduce)(a,function(e,t,n,o){return 0!==n&&t===o[n-1]+1?e[e.length-1][1]+=1:e.push([t,1]),e},[])}function a(e){var t=o(e);if(t===d||t===p)return [];var n=r(t),i=new Set;(0, h.arrayEach)(e,function(e){var t=n(e),o=l(t,3),r=o[0],a=o[2],s=a-r+1;(0, h.arrayEach)(Array.from(Array(s),function(e,t){return r+t}),function(e){i.has(e)||i.add(e);});});var a=Array.from(i).sort(function(e,t){return e-t});return (0, h.arrayReduce)(a,function(e,t,n,o){return 0!==n&&t===o[n-1]+1?e[e.length-1][1]+=1:e.push([t,1]),e},[])}function s(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1/0;return "number"==typeof e&&e>=0&&t>e}t.__esModule=!0,t.SELECTION_TYPES=t.SELECTION_TYPE_OBJECT=t.SELECTION_TYPE_ARRAY=t.SELECTION_TYPE_EMPTY=t.SELECTION_TYPE_UNRECOGNIZED=void 0;var l=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),u="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};t.detectSelectionType=o,t.normalizeSelectionFactory=r,t.transformSelectionToColumnDistance=i,t.transformSelectionToRowDistance=a,t.isValidCoord=s;var c=n(4),h=n(2),f=n(10),d=t.SELECTION_TYPE_UNRECOGNIZED=0,p=t.SELECTION_TYPE_EMPTY=1,g=t.SELECTION_TYPE_ARRAY=2,v=t.SELECTION_TYPE_OBJECT=3,m=t.SELECTION_TYPES=[v,g],y=[["number"],["number","string"],["number","undefined"],["number","string","undefined"]],w=Symbol("root"),C=Symbol("child");},function(e,t,n){var o=n(9),r=n(15).document,i=o(r)&&o(r.createElement);e.exports=function(e){return i?r.createElement(e):{}};},function(e,t,n){var o=n(9);e.exports=function(e,t){if(!o(e))return e;var n,r;if(t&&"function"==typeof(n=e.toString)&&!o(r=n.call(e)))return r;if("function"==typeof(n=e.valueOf)&&!o(r=n.call(e)))return r;if(!t&&"function"==typeof(n=e.toString)&&!o(r=n.call(e)))return r;throw TypeError("Can't convert object to primitive value")};},function(e,t,n){var o=n(18),r=n(454),i=n(80),a=n(78)("IE_PROTO"),s=function(){},l=function(){var e,t=n(74)("iframe"),o=i.length;for(t.style.display="none",n(104).appendChild(t),t.src="javascript:",e=t.contentWindow.document,e.open(),e.write("<script>document.F=Object<\/script>"),e.close(),l=e.F;o--;)delete l.prototype[i[o]];return l()};e.exports=Object.create||function(e,t){var n;return null!==e?(s.prototype=o(e),n=new s,s.prototype=null,n[a]=e):n=l(),void 0===t?n:r(n,t)};},function(e,t,n){var o=n(44);e.exports=Object("z").propertyIsEnumerable(0)?Object:function(e){return "String"==o(e)?e.split(""):Object(e)};},function(e,t,n){var o=n(79)("keys"),r=n(51);e.exports=function(e){return o[e]||(o[e]=r(e))};},function(e,t,n){var o=n(40),r=n(15),i=r["__core-js_shared__"]||(r["__core-js_shared__"]={});(e.exports=function(e,t){return i[e]||(i[e]=void 0!==t?t:{})})("versions",[]).push({version:o.version,mode:n(50)?"pure":"global",copyright:" 2018 Denis Pushkarev (zloirock.ru)"});},function(e,t){e.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");},function(e,t,n){var o=n(13)("iterator"),r=!1;try{var i=[7][o]();i.return=function(){r=!0;},Array.from(i,function(){throw 2});}catch(e){}e.exports=function(e,t){if(!t&&!r)return !1;var n=!1;try{var i=[7],a=i[o]();a.next=function(){return {done:n=!0}},i[o]=function(){return a},e(i);}catch(e){}return n};},function(e,t,n){var o,r,i,a=n(31),s=n(460),l=n(104),u=n(74),c=n(15),h=c.process,f=c.setImmediate,d=c.clearImmediate,p=c.MessageChannel,g=c.Dispatch,v=0,m={},y=function(){var e=+this;if(m.hasOwnProperty(e)){var t=m[e];delete m[e],t();}},w=function(e){y.call(e.data);};f&&d||(f=function(e){for(var t=[],n=1;arguments.length>n;)t.push(arguments[n++]);return m[++v]=function(){s("function"==typeof e?e:Function(e),t);},o(v),v},d=function(e){delete m[e];},"process"==n(44)(h)?o=function(e){h.nextTick(a(y,e,1));}:g&&g.now?o=function(e){g.now(a(y,e,1));}:p?(r=new p,i=r.port2,r.port1.onmessage=w,o=a(i.postMessage,i,1)):c.addEventListener&&"function"==typeof postMessage&&!c.importScripts?(o=function(e){c.postMessage(e+"","*");},c.addEventListener("message",w,!1)):o="onreadystatechange"in u("script")?function(e){l.appendChild(u("script")).onreadystatechange=function(){l.removeChild(this),y.call(e);};}:function(e){setTimeout(a(y,e,1),0);}),e.exports={set:f,clear:d};},function(e,t,n){var o=n(15),r=o.navigator;e.exports=r&&r.userAgent||"";},function(e,t,n){var o=n(102),r=n(80).concat("length","prototype");t.f=Object.getOwnPropertyNames||function(e){return o(e,r)};},function(e,t,n){var o=n(145),r=n(39);e.exports=function(e,t,n){if(o(t))throw TypeError("String#"+n+" doesn't accept regex!");return r(e)+""};},function(e,t,n){var o=n(13)("match");e.exports=function(e){var t=/./;try{"/./"[e](t);}catch(n){try{return t[o]=!1,!"/./"[e](t)}catch(e){}}return !0};},function(e,t,n){var o=n(20),r=n(52);e.exports=function(e,t,n){t in e?o.f(e,t,r(0,n)):e[t]=n;};},function(e,t,n){var o=n(46),r=n(111),i=n(53),a=n(24);e.exports=n(109)(Array,"Array",function(e,t){this._t=a(e),this._i=0,this._k=t;},function(){var e=this._t,t=this._k,n=this._i++;return e&&e.length>n?"keys"==t?r(0,n):"values"==t?r(0,e[n]):r(0,[n,e[n]]):(this._t=void 0,r(1))},"values"),i.Arguments=i.Array,o("keys"),o("values"),o("entries");},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e){if(!N(e))throw Error('You declared cell type "'+e+'" as a string that is not mapped to a known object.\n                 Cell type must be an object or a string mapped to an object registered by "Handsontable.cellTypes.registerCellType" method');return A(e)}function i(e,t){var n=t.editor,o=t.renderer,r=t.validator;n&&(0, l.registerEditor)(e,n),o&&(0, u.registerRenderer)(e,o),r&&(0, c.registerValidator)(e,r),D(e,t);}t.__esModule=!0,t.getRegisteredCellTypes=t.getRegisteredCellTypeNames=t.hasCellType=t.getCellType=t.registerCellType=void 0;var a=n(34),s=o(a),l=n(17),u=n(14),c=n(37),h=n(505),f=o(h),d=n(506),p=o(d),g=n(507),v=o(g),m=n(508),y=o(m),w=n(509),C=o(w),b=n(510),_=o(b),S=n(511),E=o(S),O=n(512),T=o(O),k=n(513),R=o(k),M=(0, s.default)("cellTypes"),D=M.register,A=M.getItem,N=M.hasItem,P=M.getNames,H=M.getValues;i("autocomplete",f.default),i("checkbox",p.default),i("date",v.default),i("dropdown",y.default),i("handsontable",C.default),i("numeric",_.default),i("password",E.default),i("text",T.default),i("time",R.default),t.registerCellType=i,t.getCellType=r,t.hasCellType=N,t.getRegisteredCellTypeNames=P,t.getRegisteredCellTypes=H;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);e.length>t;t++)n[t]=e[t];return n}return Array.from(e)}function i(e,t){function n(e){var t=(0, U.normalizeLanguageCode)(e);(0, V.hasLanguageDictionary)(t)?(q.runHooks("beforeLanguageChange",t),Z.prototype.language=t,q.runHooks("afterLanguageChange",t)):(0, U.warnUserAboutLanguageRegistration)(e);}function o(){var e=!1;return {validatorsInQueue:0,valid:!0,addValidatorToQueue:function(){this.validatorsInQueue+=1,e=!1;},removeValidatorFormQueue:function(){this.validatorsInQueue=0>this.validatorsInQueue-1?0:this.validatorsInQueue-1,this.checkIfQueueIsEmpty();},onQueueEmpty:function(){},checkIfQueueIsEmpty:function(){0===this.validatorsInQueue&&!1===e&&(e=!0,this.onQueueEmpty(this.valid));}}}function i(e){var t=e.replace(",",".");return !1===isNaN(parseFloat(t))?parseFloat(t):e}function g(e,t,n){function r(){var o=void 0;e.length&&(o=q.runHooks("beforeChange",e,t||"edit"),(0, h.isFunction)(o)?(0, f.warn)("Your beforeChange callback returns a function. It's not supported since Handsontable 0.12.1 (and the returned function will not be executed)."):!1===o&&e.splice(0,e.length)),n();}var a=new o;a.onQueueEmpty=r;for(var l=e.length-1;l>=0;l--)if(null===e[l])e.splice(l,1);else{var c=s(e[l],4),d=c[0],p=c[1],g=c[3],v=Q.propToCol(p),m=q.getCellMeta(d,v);"numeric"===m.type&&"string"==typeof g&&function(e){return e.length>0&&/^-?[\d\s]*(\.|,)?\d*$/.test(e)}(g)&&(e[l][3]=i(g)),q.getCellValidator(m)&&(a.addValidatorToQueue(),q.validateCell(e[l][3],m,function(t,n){return function(o){if("boolean"!=typeof o)throw Error("Validation error: result is not boolean");if(!1===o&&!1===n.allowInvalid){e.splice(t,1),n.valid=!0;var r=q.getCell(n.visualRow,n.visualCol);null!==r&&(0, u.removeClass)(r,q.getSettings().invalidCellClassName);}a.removeValidatorFormQueue();}}(l,m),t));}a.checkIfQueueIsEmpty();}function m(e,t){var n=e.length-1;if(n>=0){for(;n>=0;n--){var o=!1;if(null!==e[n]){if(null!==e[n][2]&&void 0!==e[n][2]||null!==e[n][3]&&void 0!==e[n][3]){if(J.settings.allowInsertRow)for(;e[n][0]>q.countRows()-1;){var r=Q.createRow(void 0,void 0,t);if(0===r){o=!0;break}}if(!o){if("array"===q.dataType&&(!J.settings.columns||0===J.settings.columns.length)&&J.settings.allowInsertColumn)for(;Q.propToCol(e[n][1])>q.countCols()-1;)Q.createCol(void 0,void 0,t);Q.set(e[n][0],e[n][1],e[n][3]);}}}else e.splice(n,1);}q.forceFullRender=!0,te.adjustRowsAndCols(),q.runHooks("beforeChangeRender",e,t),ne.lockEditor(),q._refreshBorders(null),ne.unlockEditor(),q.view.wt.wtOverlays.adjustElementsSize(),q.runHooks("afterChange",e,t||"edit");var i=q.getActiveEditor();i&&(0, d.isDefined)(i.refreshValue)&&i.refreshValue();}}function w(e,t,n){return "object"===(void 0===e?"undefined":a(e))?e:[[e,t,n]]}function M(e){if((0, b.hasOwnProperty)(e,"type")){var t={},n=void 0;"object"===a(e.type)?n=e.type:"string"==typeof e.type&&(n=(0, B.getCellType)(e.type));for(var o in n)(0, b.hasOwnProperty)(n,o)&&!(0, b.hasOwnProperty)(e,o)&&(t[o]=n[o]);return t}}function A(e){return function(){throw Error('The "'+e+'" method cannot be called because this Handsontable instance has been destroyed')}}var I=this,F=arguments.length>2&&void 0!==arguments[2]&&arguments[2],X=!1,q=this,Z=function(){},$=new C.default(q),J=void 0,Q=void 0,ee=void 0,te=void 0,ne=void 0;(0, b.extend)(Z.prototype,W.default.prototype),(0, b.extend)(Z.prototype,t),(0, b.extend)(Z.prototype,M(t)),(0, U.applyLanguageSetting)(Z.prototype,t.language),(0, L.hasValidParameter)(F)&&(0, L.registerAsRootInstance)(this),(0, z.startObserving)(),this.isDestroyed=!1,this.rootElement=e,this.isHotTableEnv=(0, u.isChildOfWebComponentTable)(this.rootElement),C.default.isHotTableEnv=this.isHotTableEnv,this.container=document.createElement("div"),this.renderCall=!1,e.insertBefore(this.container,e.firstChild),this.guid="ht_"+(0, k.randomString)();var oe=(0, H.getTranslator)(q);ee=new N.default(q),this.rootElement.id&&"ht_"!==this.rootElement.id.substring(0,3)||(this.rootElement.id=this.guid),J={cellSettings:[],columnSettings:[],columnsSettingConflicts:["data","width","language"],settings:new Z,selRange:null,isPopulated:null,scrollable:null,firstRun:!0};var re=new G.Selection(J.settings,{countCols:function(){return q.countCols()},countRows:function(){return q.countRows()},propToCol:function(e){return Q.propToCol(e)},isEditorOpened:function(){return !!q.getActiveEditor()&&q.getActiveEditor().isOpened()}});this.selection=re,this.selection.addLocalHook("beforeSetRangeStart",function(e){I.runHooks("beforeSetRangeStart",e);}),this.selection.addLocalHook("beforeSetRangeStartOnly",function(e){I.runHooks("beforeSetRangeStartOnly",e);}),this.selection.addLocalHook("beforeSetRangeEnd",function(e){I.runHooks("beforeSetRangeEnd",e),0>e.row&&(e.row=I.view.wt.wtTable.getFirstVisibleRow()),0>e.col&&(e.col=I.view.wt.wtTable.getFirstVisibleColumn());}),this.selection.addLocalHook("afterSetRangeEnd",function(e){var t=(0, b.createObjectPropListener)(!1),n=I.selection.getSelectedRange(),o=n.current(),r=o.from,i=o.to,a=n.size()-1;I.runHooks("afterSelection",r.row,r.col,i.row,i.col,t,a),I.runHooks("afterSelectionByProp",r.row,q.colToProp(r.col),i.row,q.colToProp(i.col),t,a);var s=I.selection.isSelectedByAnyHeader(),l=I.selection.selectedRange.current(),c=!0;X&&(c=!1),t.isTouched()&&(c=!t.value);var h=I.selection.isSelectedByRowHeader(),f=I.selection.isSelectedByColumnHeader();!1!==c&&(s?h?I.view.scrollViewportVertically(e.row):f&&I.view.scrollViewportHorizontally(e.col):I.view.scrollViewport(l&&!I.selection.isMultiple()?l.from:e)),h&&f?(0, u.addClass)(I.rootElement,["ht__selection--rows","ht__selection--columns"]):h?((0, u.removeClass)(I.rootElement,"ht__selection--columns"),(0, u.addClass)(I.rootElement,"ht__selection--rows")):f?((0, u.removeClass)(I.rootElement,"ht__selection--rows"),(0, u.addClass)(I.rootElement,"ht__selection--columns")):(0, u.removeClass)(I.rootElement,["ht__selection--rows","ht__selection--columns"]),I._refreshBorders(null);}),this.selection.addLocalHook("afterSelectionFinished",function(e){var t=e.length-1,n=e[t],o=n.from,r=n.to;I.runHooks("afterSelectionEnd",o.row,o.col,r.row,r.col,t),I.runHooks("afterSelectionEndByProp",o.row,q.colToProp(o.col),r.row,q.colToProp(r.col),t);}),this.selection.addLocalHook("afterIsMultipleSelection",function(e){var t=I.runHooks("afterIsMultipleSelection",e.value);e.value&&(e.value=t);}),this.selection.addLocalHook("beforeModifyTransformStart",function(e){I.runHooks("modifyTransformStart",e);}),this.selection.addLocalHook("afterModifyTransformStart",function(e,t,n){I.runHooks("afterModifyTransformStart",e,t,n);}),this.selection.addLocalHook("beforeModifyTransformEnd",function(e){I.runHooks("modifyTransformEnd",e);}),this.selection.addLocalHook("afterModifyTransformEnd",function(e,t,n){I.runHooks("afterModifyTransformEnd",e,t,n);}),this.selection.addLocalHook("afterDeselect",function(){ne.destroyEditor(),I._refreshBorders(),(0, u.removeClass)(I.rootElement,["ht__selection--rows","ht__selection--columns"]),I.runHooks("afterDeselect");}),this.selection.addLocalHook("insertRowRequire",function(e){I.alter("insert_row",e,1,"auto");}),this.selection.addLocalHook("insertColRequire",function(e){I.alter("insert_col",e,1,"auto");}),te={alter:function(e,t){function n(e,t,n,o){var i=function(){var e=void 0;return "array"===o?e=[]:"object"===o&&(e={}),e},a=(0, _.arrayMap)(Array(n),function(){return i()});a.unshift(t,0),e.splice.apply(e,r(a));}var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments[3],a=arguments[4],l=void 0,u=function(e){if(0===e.length)return [];var t=[].concat(r(e));return t.sort(function(e,t){var n=s(e,1),o=n[0],r=s(t,1),i=r[0];return o===i?0:o>i?1:-1}),(0, _.arrayReduce)(t,function(e,t){var n=s(t,2),o=n[0],r=n[1],i=e[e.length-1],a=s(i,2),l=a[0],u=a[1],c=l+u;if(c<o)e.push([o,r]);else{i[1]+=Math.max(r-(c-o),0);}return e},[t[0]])};switch(e){case"insert_row":var c=q.countSourceRows();if(q.getSettings().maxRows===c)return;t=(0, d.isDefined)(t)?t:c,l=Q.createRow(t,o,i),n(J.cellSettings,t,o,"array"),l&&(re.isSelected()&&re.selectedRange.current().from.row>=t?(re.selectedRange.current().from.row+=l,re.transformEnd(l,0)):q._refreshBorders());break;case"insert_col":l=Q.createCol(t,o,i);for(var h=0,f=q.countSourceRows();f>h;h++)J.cellSettings[h]&&n(J.cellSettings[h],t,o);if(l){if(Array.isArray(q.getSettings().colHeaders)){var p=[t,0];p.length+=l,Array.prototype.splice.apply(q.getSettings().colHeaders,p);}re.isSelected()&&re.selectedRange.current().from.col>=t?(re.selectedRange.current().from.col+=l,re.transformEnd(0,l)):q._refreshBorders();}break;case"remove_row":var g=function(e){var t=0;(0, _.arrayEach)(e,function(e){var n=s(e,2),r=n[0],a=n[1],l=(0, d.isEmpty)(r)?q.countRows()-1:Math.max(r-t,0);Number.isInteger(r)&&(r=Math.max(r-t,0)),Q.removeRow(r,a,i),J.cellSettings.splice(l,o);var u=q.countRows(),c=q.getSettings().fixedRowsTop;l+1>c||(q.getSettings().fixedRowsTop-=Math.min(a,c-l));var h=q.getSettings().fixedRowsBottom;h&&l>=u-h&&(q.getSettings().fixedRowsBottom-=Math.min(a,h)),t+=a;});};g(Array.isArray(t)?u(t):[[t,o]]),te.adjustRowsAndCols(),q._refreshBorders();break;case"remove_col":var v=function(e){var t=0;(0, _.arrayEach)(e,function(e){var n=s(e,2),o=n[0],r=n[1],a=(0, d.isEmpty)(o)?q.countCols()-1:Math.max(o-t,0),l=oe.toPhysicalColumn(a);Number.isInteger(o)&&(o=Math.max(o-t,0)),Q.removeCol(o,r,i);for(var u=0,c=q.countSourceRows();c>u;u++)J.cellSettings[u]&&J.cellSettings[u].splice(l,r);var h=q.getSettings().fixedColumnsLeft;a+1>h||(q.getSettings().fixedColumnsLeft-=Math.min(r,h-a)),Array.isArray(q.getSettings().colHeaders)&&(void 0===l&&(l=-1),q.getSettings().colHeaders.splice(l,r)),t+=r;});};v(Array.isArray(t)?u(t):[[t,o]]),te.adjustRowsAndCols(),q._refreshBorders();break;default:throw Error('There is no such action "'+e+'"')}a||te.adjustRowsAndCols();},adjustRowsAndCols:function(){if(J.settings.minRows){var e=q.countRows();if(J.settings.minRows>e)for(var t=0,n=J.settings.minRows;n-e>t;t++)Q.createRow(q.countRows(),1,"auto");}if(J.settings.minSpareRows){var o=q.countEmptyRows(!0);if(J.settings.minSpareRows>o)for(;J.settings.minSpareRows>o&&q.countSourceRows()<J.settings.maxRows;o++)Q.createRow(q.countRows(),1,"auto");}var r=void 0;if((J.settings.minCols||J.settings.minSpareCols)&&(r=q.countEmptyCols(!0)),J.settings.minCols&&!J.settings.columns&&q.countCols()<J.settings.minCols)for(;q.countCols()<J.settings.minCols;r++)Q.createCol(q.countCols(),1,"auto");if(J.settings.minSpareCols&&!J.settings.columns&&"array"===q.dataType&&J.settings.minSpareCols>r)for(;J.settings.minSpareCols>r&&q.countCols()<J.settings.maxCols;r++)Q.createCol(q.countCols(),1,"auto");var i=q.countRows(),a=q.countCols();0!==i&&0!==a||re.deselect(),re.isSelected()&&(0, _.arrayEach)(re.selectedRange,function(e){var t=!1,n=e.from.row,o=e.from.col,r=e.to.row,s=e.to.col;n>i-1?(n=i-1,t=!0,r>n&&(r=n)):r>i-1&&(r=i-1,t=!0,n>r&&(n=r)),o>a-1?(o=a-1,t=!0,s>o&&(s=o)):s>a-1&&(s=a-1,t=!0,o>s&&(o=s)),t&&q.selectCell(n,o,r,s);}),q.view&&q.view.wt.wtOverlays.adjustElementsSize();},populateFromArray:function(e,t,n,o,i,s,l){var u=void 0,c=void 0,h=void 0,f=void 0,p=[],g={};if(0===(c=t.length))return !1;var v=void 0,m=void 0,y=void 0,w=void 0;switch(i){case"shift_down":for(v=n?n.col-e.col+1:0,m=n?n.row-e.row+1:0,t=(0, P.translateRowsToColumns)(t),h=0,f=t.length,y=Math.max(f,v);y>h;h++)if(f>h){var C;for(u=0,c=t[h].length;m-c>u;u++)t[h].push(t[h][u%c]);t[h].unshift(e.col+h,e.row,0),(C=q).spliceCol.apply(C,r(t[h]));}else{var _;t[h%f][0]=e.col+h,(_=q).spliceCol.apply(_,r(t[h%f]));}break;case"shift_right":for(v=n?n.col-e.col+1:0,m=n?n.row-e.row+1:0,u=0,c=t.length,w=Math.max(c,m);w>u;u++)if(c>u){var S;for(h=0,f=t[u].length;v-f>h;h++)t[u].push(t[u][h%f]);t[u].unshift(e.row+u,e.col,0),(S=q).spliceRow.apply(S,r(t[u]));}else{var E;t[u%c][0]=e.row+u,(E=q).spliceRow.apply(E,r(t[u%c]));}break;case"overwrite":default:g.row=e.row,g.col=e.col;var O={row:n&&e?n.row-e.row+1:1,col:n&&e?n.col-e.col+1:1},T=0,k=0,R=!0,M=void 0,D=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=t[e%t.length];return null!==n?o[n%o.length]:o},A=t.length,N=n?n.row-e.row+1:0;for(c=n?N:Math.max(A,N),u=0;c>u&&(!(n&&g.row>n.row&&N>A||!J.settings.allowInsertRow&&g.row>q.countRows()-1)&&g.row<J.settings.maxRows);u++){var H=u-T,L=D(H).length,x=n?n.col-e.col+1:0;if(f=n?x:Math.max(L,x),g.col=e.col,M=q.getCellMeta(g.row,g.col),"CopyPaste.paste"!==o&&"Autofill.autofill"!==o||!M.skipRowOnPaste){for(k=0,h=0;f>h&&(!(n&&g.col>n.col&&x>L||!J.settings.allowInsertColumn&&g.col>q.countCols()-1)&&g.col<J.settings.maxCols);h++)if(M=q.getCellMeta(g.row,g.col),"CopyPaste.paste"!==o&&"Autofill.fill"!==o||!M.skipColumnOnPaste)if(M.readOnly)g.col+=1;else{var I=h-k,j=D(H,I),F=q.getDataAtCell(g.row,g.col),W={row:H,col:I};if("Autofill.fill"===o){var B=q.runHooks("beforeAutofillInsidePopulate",W,s,t,l,{},O);B&&(j=(0, d.isUndefined)(B.value)?j:B.value);}if(null!==j&&"object"===(void 0===j?"undefined":a(j)))if(null===F||"object"!==(void 0===F?"undefined":a(F)))R=!1;else{var Y=(0, b.duckSchema)(F[0]||F),V=(0, b.duckSchema)(j[0]||j);(0, b.isObjectEqual)(Y,V)?j=(0, b.deepClone)(j):R=!1;}else null!==F&&"object"===(void 0===F?"undefined":a(F))&&(R=!1);R&&p.push([g.row,g.col,j]),R=!0,g.col+=1;}else k+=1,g.col+=1,f+=1;g.row+=1;}else T+=1,g.row+=1,c+=1;}q.setDataAtCell(p,null,null,o||"populateFromArray");}}},this.init=function(){ee.setData(J.settings.data),q.runHooks("beforeInit"),(0, p.isMobileBrowser)()&&(0, u.addClass)(q.rootElement,"mobile"),this.updateSettings(J.settings,!0),this.view=new D.default(this),ne=y.default.getInstance(q,J,re,Q),this.forceFullRender=!0,q.runHooks("init"),this.view.render(),"object"===a(J.firstRun)&&(q.runHooks("afterChange",J.firstRun[0],J.firstRun[1]),J.firstRun=!1),q.runHooks("afterInit");},this.validateCell=function(e,t,n,o){function r(e){if(arguments.length>1&&void 0!==arguments[1]&&!arguments[1]||!0===t.hidden)return void n(e);var o=t.visualCol,r=t.visualRow,i=q.getCell(r,o,!0);i&&"TH"!==i.nodeName&&q.view.wt.wtSettings.settings.cellRenderer(r,o,i),n(e);}var i=q.getCellValidator(t);(0, d.isRegExp)(i)&&(i=function(e){return function(t,n){n(e.test(t));}}(i)),(0, h.isFunction)(i)?(e=q.runHooks("beforeValidate",e,t.visualRow,t.prop,o),q._registerTimeout(setTimeout(function(){i.call(t,e,function(n){n=q.runHooks("afterValidate",n,e,t.visualRow,t.prop,o),t.valid=n,r(n),q.runHooks("postAfterValidate",n,e,t.visualRow,t.prop,o);});},0))):q._registerTimeout(setTimeout(function(){t.valid=!0,r(t.valid,!1);},0));},this.setDataAtCell=function(e,t,n,o){var r=w(e,t,n),i=[],s=o,l=void 0,u=void 0,c=void 0;for(l=0,u=r.length;u>l;l++){if("object"!==a(r[l]))throw Error("Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter");if("number"!=typeof r[l][1])throw Error("Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`");c=Q.colToProp(r[l][1]),i.push([r[l][0],c,ee.getAtCell(oe.toPhysicalRow(r[l][0]),r[l][1]),r[l][2]]);}s||"object"!==(void 0===e?"undefined":a(e))||(s=t),q.runHooks("afterSetDataAtCell",i,s),g(i,s,function(){m(i,s);});},this.setDataAtRowProp=function(e,t,n,o){var r=w(e,t,n),i=[],s=o,l=void 0,u=void 0;for(l=0,u=r.length;u>l;l++)i.push([r[l][0],r[l][1],ee.getAtCell(oe.toPhysicalRow(r[l][0]),r[l][1]),r[l][2]]);s||"object"!==(void 0===e?"undefined":a(e))||(s=t),q.runHooks("afterSetDataAtRowProp",i,s),g(i,s,function(){m(i,s);});},this.listen=function(){if(0>=arguments.length||void 0===arguments[0]||arguments[0]){var e=!document.activeElement||document.activeElement&&void 0===document.activeElement.nodeName;document.activeElement&&document.activeElement!==document.body&&!e?document.activeElement.blur():e&&document.body.focus();}q&&!q.isListening()&&(K=q.guid,q.runHooks("afterListen"));},this.unlisten=function(){this.isListening()&&(K=null,q.runHooks("afterUnlisten"));},this.isListening=function(){return K===q.guid},this.destroyEditor=function(){q._refreshBorders(arguments.length>0&&void 0!==arguments[0]&&arguments[0],1>=arguments.length||void 0===arguments[1]||arguments[1]);},this.populateFromArray=function(e,t,n,o,r,i,s,l,u){if("object"!==(void 0===n?"undefined":a(n))||"object"!==a(n[0]))throw Error("populateFromArray parameter `input` must be an array of arrays");var c="number"==typeof o?new x.CellCoords(o,r):null;return te.populateFromArray(new x.CellCoords(e,t),n,c,i,s,l,u)},this.spliceCol=function(e,t,n){for(var o,r=arguments.length,i=Array(r>3?r-3:0),a=3;r>a;a++)i[a-3]=arguments[a];return (o=Q).spliceCol.apply(o,[e,t,n].concat(i))},this.spliceRow=function(e,t,n){for(var o,r=arguments.length,i=Array(r>3?r-3:0),a=3;r>a;a++)i[a-3]=arguments[a];return (o=Q).spliceRow.apply(o,[e,t,n].concat(i))},this.getSelected=function(){if(re.isSelected())return (0, _.arrayMap)(re.getSelectedRange(),function(e){var t=e.from,n=e.to;return [t.row,t.col,n.row,n.col]})},this.getSelectedLast=function(){var e=this.getSelected(),t=void 0;return e&&e.length>0&&(t=e[e.length-1]),t},this.getSelectedRange=function(){if(re.isSelected())return Array.from(re.getSelectedRange())},this.getSelectedRangeLast=function(){var e=this.getSelectedRange(),t=void 0;return e&&e.length>0&&(t=e[e.length-1]),t},this.emptySelectedCells=function(){var e=this;if(re.isSelected()){var t=[];(0, _.arrayEach)(re.getSelectedRange(),function(n){var o=n.getTopLeftCorner(),r=n.getBottomRightCorner();(0, R.rangeEach)(o.row,r.row,function(n){(0, R.rangeEach)(o.col,r.col,function(o){e.getCellMeta(n,o).readOnly||t.push([n,o,""]);});});}),t.length>0&&this.setDataAtCell(t);}},this.render=function(){q.view&&(q.renderCall=!0,q.forceFullRender=!0,ne.lockEditor(),q._refreshBorders(null),ne.unlockEditor());},this.loadData=function(e){if(q.dataType=Array.isArray(J.settings.dataSchema)?"array":(0, h.isFunction)(J.settings.dataSchema)?"function":"object",Q&&Q.destroy(),Q=new v.default(q,J,Z),"object"===(void 0===e?"undefined":a(e))&&null!==e)e.push&&e.splice||(e=[e]);else{if(null!==e)throw Error("loadData only accepts array of objects or array of arrays ("+(void 0===e?"undefined":a(e))+" given)");var t=Q.getSchema();e=[];var n=void 0,o=0,r=0;for(o=0,r=J.settings.startRows;r>o;o++)if("object"!==q.dataType&&"function"!==q.dataType||!J.settings.dataSchema)if("array"===q.dataType)n=(0, b.deepClone)(t[0]),e.push(n);else{n=[];for(var i=0,s=J.settings.startCols;s>i;i++)n.push(null);e.push(n);}else n=(0, b.deepClone)(t),e.push(n);}J.isPopulated=!1,Z.prototype.data=e,Array.isArray(e[0])&&(q.dataType="array"),Q.dataSource=e,ee.data=e,ee.dataType=q.dataType,ee.colToProp=Q.colToProp.bind(Q),ee.propToCol=Q.propToCol.bind(Q),function(){J.cellSettings.length=0;}(),te.adjustRowsAndCols(),q.runHooks("afterLoadData",J.firstRun),J.firstRun?J.firstRun=[null,"loadData"]:(q.runHooks("afterChange",null,"loadData"),q.render()),J.isPopulated=!0;},this.getData=function(e,t,n,o){return (0, d.isUndefined)(e)?Q.getAll():Q.getRange(new x.CellCoords(e,t),new x.CellCoords(n,o),Q.DESTINATION_RENDERER)},this.getCopyableText=function(e,t,n,o){return Q.getCopyableText(new x.CellCoords(e,t),new x.CellCoords(n,o))},this.getCopyableData=function(e,t){return Q.getCopyable(e,Q.colToProp(t))},this.getSchema=function(){return Q.getSchema()},this.updateSettings=function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=!1,r=void 0,i=void 0,a=void 0;if((0, d.isDefined)(e.rows))throw Error('"rows" setting is no longer supported. do you mean startRows, minRows or maxRows?');if((0, d.isDefined)(e.cols))throw Error('"cols" setting is no longer supported. do you mean startCols, minCols or maxCols?');for(r in e)"data"!==r&&("language"!==r?j.default.getSingleton().getRegistered().indexOf(r)>-1?((0, h.isFunction)(e[r])||Array.isArray(e[r]))&&(e[r].initialHook=!0,q.addHook(r,e[r])):!t&&(0, b.hasOwnProperty)(e,r)&&(Z.prototype[r]=e[r]):n(e.language));void 0===e.data&&void 0===J.settings.data?q.loadData(null):void 0!==e.data?q.loadData(e.data):void 0!==e.columns&&Q.createMap(),a=q.countCols();var s=e.columns||Z.prototype.columns;if(s&&(0, h.isFunction)(s)&&(a=q.countSourceCols(),o=!0),void 0===e.cell&&void 0===e.cells&&void 0===e.columns||(J.cellSettings.length=0),a>0){var l=void 0,f=void 0;for(r=0,i=0;a>r;r++)o&&!s(r)||(J.columnSettings[i]=(0, c.columnFactory)(Z,J.columnsSettingConflicts),l=J.columnSettings[i].prototype,s&&(f=o?s(r):s[i])&&((0, b.extend)(l,f),(0, b.extend)(l,M(f))),i+=1);}(0, d.isDefined)(e.cell)&&(0, b.objectEach)(e.cell,function(e){q.setCellMetaObject(e.row,e.col,e);}),q.runHooks("afterCellMetaReset"),(0, d.isDefined)(e.className)&&(Z.prototype.className&&(0, u.removeClass)(q.rootElement,Z.prototype.className),e.className&&(0, u.addClass)(q.rootElement,e.className));var p=q.rootElement.style.height;""!==p&&(p=parseInt(q.rootElement.style.height,10));var g=e.height;if((0, h.isFunction)(g)&&(g=g()),t){q.rootElement.getAttribute("style")&&q.rootElement.setAttribute("data-initialstyle",q.rootElement.getAttribute("style"));}if(null===g){var v=q.rootElement.getAttribute("data-initialstyle");v&&(v.indexOf("height")>-1||v.indexOf("overflow")>-1)?q.rootElement.setAttribute("style",v):(q.rootElement.style.height="",q.rootElement.style.overflow="");}else void 0!==g&&(q.rootElement.style.height=g+"px",q.rootElement.style.overflow="hidden");if(void 0!==e.width){var m=e.width;(0, h.isFunction)(m)&&(m=m()),q.rootElement.style.width=m+"px";}t||(Q.clearLengthCache(),q.view&&q.view.wt.wtViewport.resetHasOversizedColumnHeadersMarked(),q.runHooks("afterUpdateSettings",e)),te.adjustRowsAndCols(),q.view&&!J.firstRun&&(q.forceFullRender=!0,ne.lockEditor(),q._refreshBorders(null),ne.unlockEditor()),t||!q.view||""!==p&&""!==g&&void 0!==g||p===g||q.view.wt.wtOverlays.updateMainScrollableElements();},this.getValue=function(){var e=q.getSelectedLast();if(Z.prototype.getValue){if((0, h.isFunction)(Z.prototype.getValue))return Z.prototype.getValue.call(q);if(e)return q.getData()[e[0][0]][Z.prototype.getValue]}else if(e)return q.getDataAtCell(e[0],e[1])},this.getSettings=function(){return J.settings},this.clear=function(){this.selectAll(),this.emptySelectedCells();},this.alter=function(e,t,n,o,r){te.alter(e,t,n,o,r);},this.getCell=function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return q.view.getCellAtCoords(new x.CellCoords(e,t),n)},this.getCoords=function(e){return this.view.wt.wtTable.getCoords.call(this.view.wt.wtTable,e)},this.colToProp=function(e){return Q.colToProp(e)},this.propToCol=function(e){return Q.propToCol(e)},this.toVisualRow=function(e){return oe.toVisualRow(e)},this.toVisualColumn=function(e){return oe.toVisualColumn(e)},this.toPhysicalRow=function(e){return oe.toPhysicalRow(e)},this.toPhysicalColumn=function(e){return oe.toPhysicalColumn(e)},this.getDataAtCell=function(e,t){return Q.get(e,Q.colToProp(t))},this.getDataAtRowProp=function(e,t){return Q.get(e,t)},this.getDataAtCol=function(e){var t;return (t=[]).concat.apply(t,r(Q.getRange(new x.CellCoords(0,e),new x.CellCoords(J.settings.data.length-1,e),Q.DESTINATION_RENDERER)))},this.getDataAtProp=function(e){var t,n=Q.getRange(new x.CellCoords(0,Q.propToCol(e)),new x.CellCoords(J.settings.data.length-1,Q.propToCol(e)),Q.DESTINATION_RENDERER);return (t=[]).concat.apply(t,r(n))},this.getSourceData=function(e,t,n,o){return void 0===e?ee.getData():ee.getByRange(new x.CellCoords(e,t),new x.CellCoords(n,o))},this.getSourceDataArray=function(e,t,n,o){return void 0===e?ee.getData(!0):ee.getByRange(new x.CellCoords(e,t),new x.CellCoords(n,o),!0)},this.getSourceDataAtCol=function(e){return ee.getAtColumn(e)},this.getSourceDataAtRow=function(e){return ee.getAtRow(e)},this.getSourceDataAtCell=function(e,t){return ee.getAtCell(e,t)},this.getDataAtRow=function(e){return Q.getRange(new x.CellCoords(e,0),new x.CellCoords(e,this.countCols()-1),Q.DESTINATION_RENDERER)[0]||[]},this.getDataType=function(e,t,n,o){var r=this,i=void 0===e?[0,0,this.countRows(),this.countCols()]:[e,t,n,o],a=i[0],s=i[1],l=i[2],u=i[3],c=null,h=null;void 0===l&&(l=a),void 0===u&&(u=s);var f="mixed";return (0, R.rangeEach)(Math.min(a,l),Math.max(a,l),function(e){var t=!0;return (0, R.rangeEach)(Math.min(s,u),Math.max(s,u),function(n){var o=r.getCellMeta(e,n);return h=o.type,c?t=c===h:c=h,t}),f=t?h:"mixed",t}),f},this.removeCellMeta=function(e,t,n){var o=oe.toPhysical(e,t),r=s(o,2),i=r[0],a=r[1],l=J.cellSettings[i][a][n];!1!==q.runHooks("beforeRemoveCellMeta",e,t,n,l)&&(delete J.cellSettings[i][a][n],q.runHooks("afterRemoveCellMeta",e,t,n,l)),l=null;},this.spliceCellsMeta=function(e,t){for(var n,o=arguments.length,r=Array(o>2?o-2:0),i=2;o>i;i++)r[i-2]=arguments[i];(n=J.cellSettings).splice.apply(n,[e,t].concat(r));},this.setCellMetaObject=function(e,t,n){var o=this;"object"===(void 0===n?"undefined":a(n))&&(0, b.objectEach)(n,function(n,r){o.setCellMeta(e,t,r,n);});},this.setCellMeta=function(e,t,n,o){var r=oe.toPhysical(e,t),i=s(r,2),a=i[0],l=i[1];J.columnSettings[l]||(J.columnSettings[l]=(0, c.columnFactory)(Z,J.columnsSettingConflicts)),J.cellSettings[a]||(J.cellSettings[a]=[]),J.cellSettings[a][l]||(J.cellSettings[a][l]=new J.columnSettings[l]),J.cellSettings[a][l][n]=o,q.runHooks("afterSetCellMeta",e,t,n,o);},this.getCellsMeta=function(){return (0, _.arrayFlatten)(J.cellSettings)},this.getCellMeta=function(e,t){var n=Q.colToProp(t),o=oe.toPhysical(e,t),r=s(o,2),i=r[0],a=r[1],l=i;null===l&&(l=e),J.columnSettings[a]||(J.columnSettings[a]=(0, c.columnFactory)(Z,J.columnsSettingConflicts)),J.cellSettings[l]||(J.cellSettings[l]=[]),J.cellSettings[l][a]||(J.cellSettings[l][a]=new J.columnSettings[a]);var u=J.cellSettings[l][a];if(u.row=l,u.col=a,u.visualRow=e,u.visualCol=t,u.prop=n,u.instance=q,q.runHooks("beforeGetCellMeta",e,t,u),(0, b.extend)(u,M(u)),u.cells){var h=u.cells.call(u,l,a,n);h&&((0, b.extend)(u,h),(0, b.extend)(u,M(h)));}return q.runHooks("afterGetCellMeta",e,t,u),u},this.getCellMetaAtRow=function(e){return J.cellSettings[e]},this.isColumnModificationAllowed=function(){return !("object"===q.dataType||q.getSettings().columns)};var ie=(0, P.cellMethodLookupFactory)("renderer");this.getCellRenderer=function(e,t){return (0, O.getRenderer)(ie.call(this,e,t))},this.getCellEditor=(0, P.cellMethodLookupFactory)("editor");var ae=(0, P.cellMethodLookupFactory)("validator");this.getCellValidator=function(e,t){var n=ae.call(this,e,t);return "string"==typeof n&&(n=(0, T.getValidator)(n)),n},this.validateCells=function(e){this._validateCells(e);},this.validateRows=function(e,t){if(!Array.isArray(e))throw Error("validateRows parameter `rows` must be an array");this._validateCells(t,e);},this.validateColumns=function(e,t){if(!Array.isArray(e))throw Error("validateColumns parameter `columns` must be an array");this._validateCells(t,void 0,e);},this._validateCells=function(e,t,n){var r=new o;e&&(r.onQueueEmpty=e);for(var i=q.countRows()-1;i>=0;)if(void 0===t||-1!==t.indexOf(i)){for(var a=q.countCols()-1;a>=0;)void 0===n||-1!==n.indexOf(a)?(r.addValidatorToQueue(),q.validateCell(q.getDataAtCell(i,a),q.getCellMeta(i,a),function(e){if("boolean"!=typeof e)throw Error("Validation error: result is not boolean");!1===e&&(r.valid=!1),r.removeValidatorFormQueue();},"validateCells"),a-=1):a-=1;i-=1;}else i-=1;r.checkIfQueueIsEmpty();},this.getRowHeader=function(e){var t=J.settings.rowHeaders,n=e;return void 0!==n&&(n=q.runHooks("modifyRowHeader",n)),void 0===n?(t=[],(0, R.rangeEach)(q.countRows()-1,function(e){t.push(q.getRowHeader(e));})):Array.isArray(t)&&void 0!==t[n]?t=t[n]:(0, h.isFunction)(t)?t=t(n):t&&"string"!=typeof t&&"number"!=typeof t&&(t=n+1),t},this.hasRowHeaders=function(){return !!J.settings.rowHeaders},this.hasColHeaders=function(){if(void 0!==J.settings.colHeaders&&null!==J.settings.colHeaders)return !!J.settings.colHeaders;for(var e=0,t=q.countCols();t>e;e++)if(q.getColHeader(e))return !0;return !1},this.getColHeader=function(e){var t=J.settings.columns&&(0, h.isFunction)(J.settings.columns),n=q.runHooks("modifyColHeader",e),o=J.settings.colHeaders;if(void 0===n){for(var r=[],i=t?q.countSourceCols():q.countCols(),a=0;i>a;a++)r.push(q.getColHeader(a));o=r;}else{var s=n,l=q.runHooks("modifyCol",s),u=function(e){for(var t=[],n=q.countSourceCols(),o=0;n>o;o++)(0, h.isFunction)(q.getSettings().columns)&&q.getSettings().columns(o)&&t.push(o);return t[e]}(l);!1===J.settings.colHeaders?o=null:J.settings.columns&&(0, h.isFunction)(J.settings.columns)&&J.settings.columns(u)&&J.settings.columns(u).title?o=J.settings.columns(u).title:J.settings.columns&&J.settings.columns[l]&&J.settings.columns[l].title?o=J.settings.columns[l].title:Array.isArray(J.settings.colHeaders)&&void 0!==J.settings.colHeaders[l]?o=J.settings.colHeaders[l]:(0, h.isFunction)(J.settings.colHeaders)?o=J.settings.colHeaders(l):J.settings.colHeaders&&"string"!=typeof J.settings.colHeaders&&"number"!=typeof J.settings.colHeaders&&(o=(0, P.spreadsheetColumnLabel)(s));}return o},this._getColWidthFromSettings=function(e){var t=q.getCellMeta(0,e),n=t.width;if(void 0!==n&&n!==J.settings.width||(n=t.colWidths),void 0!==n&&null!==n){switch(void 0===n?"undefined":a(n)){case"object":n=n[e];break;case"function":n=n(e);}"string"==typeof n&&(n=parseInt(n,10));}return n},this.getColWidth=function(e){var t=q._getColWidthFromSettings(e);return t=q.runHooks("modifyColWidth",t,e),void 0===t&&(t=x.ViewportColumnsCalculator.DEFAULT_WIDTH),t},this._getRowHeightFromSettings=function(e){var t=J.settings.rowHeights;if(void 0!==t&&null!==t){switch(void 0===t?"undefined":a(t)){case"object":t=t[e];break;case"function":t=t(e);}"string"==typeof t&&(t=parseInt(t,10));}return t},this.getRowHeight=function(e){var t=q._getRowHeightFromSettings(e);return t=q.runHooks("modifyRowHeight",t,e)},this.countSourceRows=function(){return q.runHooks("modifySourceLength")||(q.getSourceData()?q.getSourceData().length:0)},this.countSourceCols=function(){var e=q.getSourceData()&&q.getSourceData()[0]?q.getSourceData()[0]:[];return (0, b.isObject)(e)?(0, b.deepObjectSize)(e):e.length||0},this.countRows=function(){return Q.getLength()},this.countCols=function(){var e=this.getSettings().maxCols,t=!1,n=0;if("array"===q.dataType&&(t=J.settings.data&&J.settings.data[0]&&J.settings.data[0].length),t&&(n=J.settings.data[0].length),J.settings.columns){if((0, h.isFunction)(J.settings.columns))if("array"===q.dataType){for(var o=0,r=0;n>r;r++)J.settings.columns(r)&&(o+=1);n=o;}else"object"!==q.dataType&&"function"!==q.dataType||(n=Q.colToPropCache.length);else n=J.settings.columns.length;}else"object"!==q.dataType&&"function"!==q.dataType||(n=Q.colToPropCache.length);return Math.min(e,n)},this.rowOffset=function(){return q.view.wt.wtTable.getFirstRenderedRow()},this.colOffset=function(){return q.view.wt.wtTable.getFirstRenderedColumn()},this.countRenderedRows=function(){return q.view.wt.drawn?q.view.wt.wtTable.getRenderedRowsCount():-1},this.countVisibleRows=function(){return q.view.wt.drawn?q.view.wt.wtTable.getVisibleRowsCount():-1},this.countRenderedCols=function(){return q.view.wt.drawn?q.view.wt.wtTable.getRenderedColumnsCount():-1},this.countVisibleCols=function(){return q.view.wt.drawn?q.view.wt.wtTable.getVisibleColumnsCount():-1},this.countEmptyRows=function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=0;return (0, R.rangeEachReverse)(q.countRows()-1,function(n){if(q.isEmptyRow(n))t+=1;else if(!0===e)return !1}),t},this.countEmptyCols=function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(1>q.countRows())return 0;var t=0;return (0, R.rangeEachReverse)(q.countCols()-1,function(n){if(q.isEmptyCol(n))t+=1;else if(!0===e)return !1}),t},this.isEmptyRow=function(e){return J.settings.isEmptyRow.call(q,e)},this.isEmptyCol=function(e){return J.settings.isEmptyCol.call(q,e)},this.selectCell=function(e,t,n,o){var r=4>=arguments.length||void 0===arguments[4]||arguments[4],i=5>=arguments.length||void 0===arguments[5]||arguments[5];return !(0, d.isUndefined)(e)&&!(0, d.isUndefined)(t)&&this.selectCells([[e,t,n,o]],r,i)},this.selectCells=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[[]],t=1>=arguments.length||void 0===arguments[1]||arguments[1],n=2>=arguments.length||void 0===arguments[2]||arguments[2];!1===t&&(X=!0);var o=re.selectCells(e);return o&&n&&q.listen(),X=!1,o},this.selectCellByProp=function(e,t,n,o){var r=4>=arguments.length||void 0===arguments[4]||arguments[4],i=5>=arguments.length||void 0===arguments[5]||arguments[5];return (0, f.warn)((0, S.toSingleLine)(l)),this.selectCells([[e,t,n,o]],r,i)},this.selectColumns=function(e){return re.selectColumns(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:e)},this.selectRows=function(e){return re.selectRows(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:e)},this.deselectCell=function(){re.deselect();},this.selectAll=function(){X=!0,re.selectAll(),X=!1;},this.scrollViewportTo=function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=!n,i=!o,a=!1;return void 0!==e&&void 0!==t&&(a=q.view.scrollViewport(new x.CellCoords(e,t),r,o,n,i)),"number"==typeof e&&"number"!=typeof t&&(a=q.view.scrollViewportVertically(e,r,n)),"number"==typeof t&&"number"!=typeof e&&(a=q.view.scrollViewportHorizontally(t,o,i)),a},this.destroy=function(){q._clearTimeouts(),q._clearImmediates(),q.view&&q.view.destroy(),ee&&ee.destroy(),ee=null,(0, z.stopObserving)();(0, u.empty)(q.rootElement),$.destroy(),ne&&ne.destroy(),q.runHooks("afterDestroy"),j.default.getSingleton().destroy(q),(0, b.objectEach)(q,function(e,t,n){(0, h.isFunction)(e)?n[t]=A(t):"guid"!==t&&(n[t]=null);}),q.isDestroyed=!0,Q&&Q.destroy(),Q=null,J=null,te=null,re=null,ne=null,q=null,Z=null;},this.getActiveEditor=function(){return ne.getActiveEditor()},this.getPlugin=function(e){return (0, E.getPlugin)(this,e)},this.getInstance=function(){return q},this.addHook=function(e,t){j.default.getSingleton().add(e,t,q);},this.hasHook=function(e){return j.default.getSingleton().has(e,q)},this.addHookOnce=function(e,t){j.default.getSingleton().once(e,t,q);},this.removeHook=function(e,t){j.default.getSingleton().remove(e,t,q);},this.runHooks=function(e,t,n,o,r,i,a){return j.default.getSingleton().run(q,e,t,n,o,r,i,a)},this.getTranslatedPhrase=function(e,t){return (0, Y.getTranslatedPhrase)(J.settings.language,e,t)},this.timeouts=[],this._registerTimeout=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=e;"function"==typeof n&&(n=setTimeout(n,t)),this.timeouts.push(n);},this._clearTimeouts=function(){(0, _.arrayEach)(this.timeouts,function(e){clearTimeout(e);});},this.immediates=[],this._registerImmediate=function(e){this.immediates.push(setImmediate(e));},this._clearImmediates=function(){(0, _.arrayEach)(this.immediates,function(e){clearImmediate(e);});},this._refreshBorders=function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=1>=arguments.length||void 0===arguments[1]||arguments[1];ne.destroyEditor(e),q.view.render(),t&&re.isSelected()&&ne.prepareEditor();},j.default.getSingleton().run(q,"construct");}t.__esModule=!0;var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},s=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),l=function(e,t){return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}(["Deprecation warning: This method is going to be removed in the next release.\n      If you want to select a cell using props, please use the `selectCell` method."],["Deprecation warning: This method is going to be removed in the next release.\n      If you want to select a cell using props, please use the \\`selectCell\\` method."]);t.default=i;var u=n(0),c=n(91),h=n(43),f=n(58),d=n(10),p=n(35),g=n(514),v=o(g),m=n(517),y=o(m),w=n(6),C=o(w),b=n(1),_=n(2),S=n(42),E=n(8),O=n(14),T=n(37),k=n(36),R=n(5),M=n(518),D=o(M),A=n(519),N=o(A),P=n(92),H=n(440),L=n(441),x=n(4),I=n(16),j=o(I),F=n(442),W=o(F),B=n(89),Y=n(443),V=n(72),U=n(444),z=n(93),G=n(445),K=null;},function(e,t,n){function o(e,t){function n(){}(0, r.inherit)(n,e);for(var o=0,i=t.length;i>o;o++)n.prototype[t[o]]=void 0;return n}t.__esModule=!0,t.columnFactory=o;var r=n(1);},function(e,t,n){function o(e){for(var t=e+1,n="",o=void 0;t>0;)o=(t-1)%d,n=String.fromCharCode(65+o)+n,t=parseInt((t-o)/d,10);return n}function r(e){var t=0;if(e)for(var n=0,o=e.length-1;e.length>n;n+=1,o-=1)t+=Math.pow(d,o)*(f.indexOf(e[n])+1);return t-=1}function i(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:100,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:4,n=[],r=void 0,i=void 0;for(r=0;e>r;r++){var a=[];for(i=0;t>i;i++)a.push(o(i)+(r+1));n.push(a);}return n}function a(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:100,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:4,n=[],r=void 0,i=void 0;for(r=0;e>r;r++){var a={};for(i=0;t>i;i++)a["prop"+i]=o(i)+(r+1);n.push(a);}return n}function s(e,t){for(var n=[],o=void 0,r=0;e>r;r++){o=[];for(var i=0;t>i;i++)o.push("");n.push(o);}return n}function l(e){var t=[],n=void 0,o=void 0,r=void 0,i=void 0,a=0;for(n=0,o=e.length;o>n;n++)for(r=0,i=e[n].length;i>r;r++)r===a&&(t.push([]),a+=1),t[r].push(e[n][r]);return t}function u(e,t){var n=void 0===t||t;return function(t,o){return function t(o){if(o){if((0, h.hasOwnProperty)(o,e)&&void 0!==o[e])return o[e];if((0, h.hasOwnProperty)(o,"type")&&o.type){if("string"!=typeof o.type)throw Error("Cell type must be a string ");var r=(0, c.getCellType)(o.type);if((0, h.hasOwnProperty)(r,e))return r[e];if(n)return}return t(Object.getPrototypeOf(o))}}("number"==typeof t?this.getCellMeta(t,o):t)}}t.__esModule=!0,t.spreadsheetColumnLabel=o,t.spreadsheetColumnIndex=r,t.createSpreadsheetData=i,t.createSpreadsheetObjectData=a,t.createEmptySpreadsheetData=s,t.translateRowsToColumns=l,t.cellMethodLookupFactory=u;var c=n(89),h=n(1),f="ABCDEFGHIJKLMNOPQRSTUVWXYZ",d=f.length;},function(e,t,n){function o(){0===p&&(f.addEventListener(document,"keydown",function(e){d.has(e.keyCode)||d.add(e.keyCode);}),f.addEventListener(document,"keyup",function(e){d.has(e.keyCode)&&d.delete(e.keyCode);}),f.addEventListener(document,"visibilitychange",function(){document.hidden&&d.clear();}),f.addEventListener(window,"blur",function(){d.clear();})),p+=1;}function r(){p>0&&(p-=1),0===p&&i();}function i(){f.clearEvents(),d.clear(),p=0;}function a(e){return Array.from(d.values()).some(function(t){return (0, h.isKey)(t,e)})}function s(){return Array.from(d.values()).some(function(e){return (0, h.isCtrlMetaKey)(e)})}function l(){return p}t.__esModule=!0,t.stopObserving=t.startObserving=t.isPressedCtrlKey=t.isPressed=t._resetState=t._getRefCount=void 0;var u=n(6),c=function(e){return e&&e.__esModule?e:{default:e}}(u),h=n(21),f=new c.default,d=new Set,p=0;t._getRefCount=l,t._resetState=i,t.isPressed=a,t.isPressedCtrlKey=s,t.startObserving=o,t.stopObserving=r;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(0),a=n(2);t.default=function(){function e(t){o(this,e),this.hot=t,this.container=null,this.injected=!1,this.rows=[],this.columns=[],this.samples=null,this.settings={useHeaders:!0};}return r(e,[{key:"addRow",value:function(e,t){if(this.columns.length)throw Error("Doesn't support multi-dimensional table");this.rows.length||(this.container=this.createContainer(this.hot.rootElement.className));var n={row:e};this.rows.push(n),this.samples=t,this.table=this.createTable(this.hot.table.className),this.table.colGroup.appendChild(this.createColGroupsCol()),this.table.tr.appendChild(this.createRow(e)),this.container.container.appendChild(this.table.fragment),n.table=this.table.table;}},{key:"addColumnHeadersRow",value:function(e){var t=this.hot.getColHeader(0);if(null!==t&&void 0!==t){var n={row:-1};this.rows.push(n),this.container=this.createContainer(this.hot.rootElement.className),this.samples=e,this.table=this.createTable(this.hot.table.className),this.table.colGroup.appendChild(this.createColGroupsCol()),this.table.tHead.appendChild(this.createColumnHeadersRow()),this.container.container.appendChild(this.table.fragment),n.table=this.table.table;}}},{key:"addColumn",value:function(e,t){if(this.rows.length)throw Error("Doesn't support multi-dimensional table");this.columns.length||(this.container=this.createContainer(this.hot.rootElement.className));var n={col:e};this.columns.push(n),this.samples=t,this.table=this.createTable(this.hot.table.className),this.getSetting("useHeaders")&&null!==this.hot.getColHeader(e)&&this.hot.view.appendColHeader(e,this.table.th),this.table.tBody.appendChild(this.createCol(e)),this.container.container.appendChild(this.table.fragment),n.table=this.table.table;}},{key:"getHeights",value:function(e){this.injected||this.injectTable(),(0, a.arrayEach)(this.rows,function(t){e(t.row,(0, i.outerHeight)(t.table)-1);});}},{key:"getWidths",value:function(e){this.injected||this.injectTable(),(0, a.arrayEach)(this.columns,function(t){e(t.col,(0, i.outerWidth)(t.table));});}},{key:"setSettings",value:function(e){this.settings=e;}},{key:"setSetting",value:function(e,t){this.settings||(this.settings={}),this.settings[e]=t;}},{key:"getSettings",value:function(){return this.settings}},{key:"getSetting",value:function(e){return this.settings?this.settings[e]:null}},{key:"createColGroupsCol",value:function(){var e=this,t=document,n=t.createDocumentFragment();return this.hot.hasRowHeaders()&&n.appendChild(this.createColElement(-1)),this.samples.forEach(function(t){(0, a.arrayEach)(t.strings,function(t){n.appendChild(e.createColElement(t.col));});}),n}},{key:"createRow",value:function(e){var t=this,n=document,o=n.createDocumentFragment(),r=n.createElement("th");return this.hot.hasRowHeaders()&&(this.hot.view.appendRowHeader(e,r),o.appendChild(r)),this.samples.forEach(function(r){(0, a.arrayEach)(r.strings,function(r){var i=r.col,a=t.hot.getCellMeta(e,i);a.col=i,a.row=e;var s=t.hot.getCellRenderer(a),l=n.createElement("td");s(t.hot,l,e,i,t.hot.colToProp(i),r.value,a),o.appendChild(l);});}),o}},{key:"createColumnHeadersRow",value:function(){var e=this,t=document,n=t.createDocumentFragment();if(this.hot.hasRowHeaders()){var o=t.createElement("th");this.hot.view.appendColHeader(-1,o),n.appendChild(o);}return this.samples.forEach(function(o){(0, a.arrayEach)(o.strings,function(o){var r=o.col,i=t.createElement("th");e.hot.view.appendColHeader(r,i),n.appendChild(i);});}),n}},{key:"createCol",value:function(e){var t=this,n=document,o=n.createDocumentFragment();return this.samples.forEach(function(r){(0, a.arrayEach)(r.strings,function(r){var i=r.row,a=t.hot.getCellMeta(i,e);a.col=e,a.row=i;var s=t.hot.getCellRenderer(a),l=n.createElement("td"),u=n.createElement("tr");l.setAttribute("ghost-table",1),s(t.hot,l,i,e,t.hot.colToProp(e),r.value,a),u.appendChild(l),o.appendChild(u);});}),o}},{key:"clean",value:function(){this.rows.length=0,this.rows[-1]=void 0,this.columns.length=0,this.samples&&this.samples.clear(),this.samples=null,this.removeTable();}},{key:"injectTable",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;this.injected||((e||this.hot.rootElement).appendChild(this.container.fragment),this.injected=!0);}},{key:"removeTable",value:function(){this.injected&&this.container.container.parentNode&&(this.container.container.parentNode.removeChild(this.container.container),this.container=null,this.injected=!1);}},{key:"createColElement",value:function(e){var t=document,n=t.createElement("col");return n.style.width=this.hot.view.wt.wtTable.getStretchedColumnWidth(e)+"px",n}},{key:"createTable",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=document,n=t.createDocumentFragment(),o=t.createElement("table"),r=t.createElement("thead"),a=t.createElement("tbody"),s=t.createElement("colgroup"),l=t.createElement("tr"),u=t.createElement("th");return this.isVertical()&&o.appendChild(s),this.isHorizontal()&&(l.appendChild(u),r.appendChild(l),o.style.tableLayout="auto",o.style.width="auto"),o.appendChild(r),this.isVertical()&&a.appendChild(l),o.appendChild(a),(0, i.addClass)(o,e),n.appendChild(o),{fragment:n,table:o,tHead:r,tBody:a,colGroup:s,tr:l,th:u}}},{key:"createContainer",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=document,n=t.createDocumentFragment(),o=t.createElement("div"),r="htGhostTable htAutoSize "+e.trim();return (0, i.addClass)(o,r),n.appendChild(o),{fragment:n,container:o}}},{key:"isVertical",value:function(){return !(!this.rows.length||this.columns.length)}},{key:"isHorizontal",value:function(){return !(!this.columns.length||this.rows.length)}}]),e}();},function(e,t,n){function o(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);e.length>t;t++)n[t]=e[t];return n}return Array.from(e)}t.__esModule=!0;var r=n(2),i=n(1),a=n(5),s={_arrayMap:[],getValueByIndex:function(e){var t=this._arrayMap.length,n=null;return t>e&&(n=this._arrayMap[e]),n},getIndexByValue:function(e){var t=void 0;return -1===(t=this._arrayMap.indexOf(e))?null:t},insertItems:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,o=(0, r.arrayMax)(this._arrayMap)+1,i=[];return (0, a.rangeEach)(n-1,function(n){i.push(t._arrayMap.splice(e+n,0,o+n));}),i},removeItems:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,o=[];if(Array.isArray(e)){var i=[].concat(this._arrayMap);e.sort(function(e,t){return t-e}),o=(0, r.arrayReduce)(e,function(e,n){return t._arrayMap.splice(n,1),e.concat(i.slice(n,n+1))},[]);}else o=this._arrayMap.splice(e,n);return o},unshiftItems:function(e){function t(e){return (0, r.arrayReduce)(o,function(t,n){var o=t;return e>n&&(o+=1),o},0)}var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,o=this.removeItems(e,n);this._arrayMap=(0, r.arrayMap)(this._arrayMap,function(e){var n=e,o=t(n);return o&&(n-=o),n});},shiftItems:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;this._arrayMap=(0, r.arrayMap)(this._arrayMap,function(t){var o=t;return e>o||(o+=n),o}),(0, a.rangeEach)(n-1,function(n){t._arrayMap.splice(e+n,0,e+n);});},swapIndexes:function(e,t){var n;(n=this._arrayMap).splice.apply(n,[t,0].concat(o(this._arrayMap.splice(e,1))));},clearMap:function(){this._arrayMap.length=0;}};(0, i.defineGetter)(s,"MIXIN_NAME","arrayMapper",{writable:!1,enumerable:!1}),t.default=s;},function(e,t,n){function o(){return {name:r}}t.__esModule=!0,t.default=o;var r=t.KEY="---------";},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){var e={};return (0, C.objectEach)(H,function(t,n){e[n]=t();}),e}function a(e,t){-1===P.indexOf(e)&&(H[e]=t);}t.__esModule=!0,t.ITEMS=t.UNDO=t.SEPARATOR=t.ROW_BELOW=t.ROW_ABOVE=t.REMOVE_ROW=t.REMOVE_COLUMN=t.REDO=t.READ_ONLY=t.COLUMN_RIGHT=t.COLUMN_LEFT=t.CLEAR_COLUMN=t.ALIGNMENT=void 0;var s,l=n(559);Object.defineProperty(t,"ALIGNMENT",{enumerable:!0,get:function(){return l.KEY}});var u=n(560);Object.defineProperty(t,"CLEAR_COLUMN",{enumerable:!0,get:function(){return u.KEY}});var c=n(561);Object.defineProperty(t,"COLUMN_LEFT",{enumerable:!0,get:function(){return c.KEY}});var h=n(562);Object.defineProperty(t,"COLUMN_RIGHT",{enumerable:!0,get:function(){return h.KEY}});var f=n(563);Object.defineProperty(t,"READ_ONLY",{enumerable:!0,get:function(){return f.KEY}});var d=n(564);Object.defineProperty(t,"REDO",{enumerable:!0,get:function(){return d.KEY}});var p=n(565);Object.defineProperty(t,"REMOVE_COLUMN",{enumerable:!0,get:function(){return p.KEY}});var g=n(566);Object.defineProperty(t,"REMOVE_ROW",{enumerable:!0,get:function(){return g.KEY}});var v=n(567);Object.defineProperty(t,"ROW_ABOVE",{enumerable:!0,get:function(){return v.KEY}});var m=n(568);Object.defineProperty(t,"ROW_BELOW",{enumerable:!0,get:function(){return m.KEY}});var y=n(96);Object.defineProperty(t,"SEPARATOR",{enumerable:!0,get:function(){return y.KEY}});var w=n(569);Object.defineProperty(t,"UNDO",{enumerable:!0,get:function(){return w.KEY}}),t.predefinedItems=i,t.addItem=a;var C=n(1),b=o(l),_=o(u),S=o(c),E=o(h),O=o(f),T=o(d),k=o(p),R=o(g),M=o(v),D=o(m),A=o(y),N=o(w),P=t.ITEMS=[v.KEY,m.KEY,c.KEY,h.KEY,u.KEY,g.KEY,p.KEY,w.KEY,d.KEY,f.KEY,l.KEY,y.KEY],H=(s={},r(s,y.KEY,A.default),r(s,v.KEY,M.default),r(s,m.KEY,D.default),r(s,c.KEY,S.default),r(s,h.KEY,E.default),r(s,u.KEY,_.default),r(s,g.KEY,R.default),r(s,p.KEY,k.default),r(s,w.KEY,N.default),r(s,d.KEY,T.default),r(s,f.KEY,O.default),r(s,l.KEY,b.default),s);},function(e,t,n){function o(e,t){return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=o(["The merged cell declared with {row: ",", col: ",", rowspan: \n    ",", colspan: ","} contains negative values, which is not supported. It \n    will not be added to the collection."],["The merged cell declared with {row: ",", col: ",", rowspan: \n    ",", colspan: ","} contains negative values, which is not supported. It \n    will not be added to the collection."]),s=o(["The merged cell declared at [",", ","] is positioned (or positioned partially) \n       outside of the table range. It was not added to the table, please fix your setup."],["The merged cell declared at [",", ","] is positioned (or positioned partially) \n       outside of the table range. It was not added to the table, please fix your setup."]),l=o(["The merged cell declared at [",", ",'] has both "rowspan" \n     and "colspan" declared as "1", which makes it a single cell. It cannot be added to the collection.'],["The merged cell declared at [",", ",'] has both "rowspan" \n     and "colspan" declared as "1", which makes it a single cell. It cannot be added to the collection.']),u=o(["The merged cell declared at [",", ",'] has "rowspan" or "colspan" declared as \n      "0", which is not supported. It cannot be added to the collection.'],["The merged cell declared at [",", ",'] has "rowspan" or "colspan" declared as \n      "0", which is not supported. It cannot be added to the collection.']),c=n(4),h=n(42);t.default=function(){function e(t,n,o,i){r(this,e),this.row=t,this.col=n,this.rowspan=o,this.colspan=i,this.removed=!1;}return i(e,[{key:"normalize",value:function(e){var t=e.countRows(),n=e.countCols();0>this.row?this.row=0:this.row>t-1&&(this.row=t-1),0>this.col?this.col=0:this.col>n-1&&(this.col=n-1),this.row+this.rowspan>t-1&&(this.rowspan=t-this.row),this.col+this.colspan>n-1&&(this.colspan=n-this.col);}},{key:"includes",value:function(e,t){return !(this.row>e||this.col>t||e>this.row+this.rowspan-1||t>this.col+this.colspan-1)}},{key:"includesHorizontally",value:function(e){return e>=this.col&&this.col+this.colspan-1>=e}},{key:"includesVertically",value:function(e){return e>=this.row&&this.row+this.rowspan-1>=e}},{key:"shift",value:function(e,t){var n=e[0]||e[1],o=t+Math.abs(e[0]||e[1])-1,r=e[0]?"colspan":"rowspan",i=e[0]?"col":"row",a=Math.min(t,o),s=Math.max(t,o),l=this[i],u=this[i]+this[r]-1;if(t>l||(this[i]+=n),n>0)u>=t&&t>l&&(this[r]+=n);else if(0>n){if(l>=a&&s>=u)return this.removed=!0,!1;if(l<a||s<l)if(a<l||u<s){if(a>=l&&u>=a&&s>u){var c=u-a+1;this[r]-=c;}}else this[r]+=n;else{var h=s-l+1,f=Math.abs(n)-h;this[i]-=f+n,this[r]-=h;}}return !0}},{key:"isFarther",value:function(e,t){return !e||("down"===t?this.row+this.rowspan-1>e.row+e.rowspan-1:"up"===t?e.row>this.row:"right"===t?this.col+this.colspan-1>e.col+e.colspan-1:"left"===t?e.col>this.col:null)}},{key:"getLastRow",value:function(){return this.row+this.rowspan-1}},{key:"getLastColumn",value:function(){return this.col+this.colspan-1}},{key:"getRange",value:function(){return new c.CellRange(new c.CellCoords(this.row,this.col),new c.CellCoords(this.row,this.col),new c.CellCoords(this.getLastRow(),this.getLastColumn()))}}],[{key:"NEGATIVE_VALUES_WARNING",value:function(e){return (0, h.toSingleLine)(a,e.row,e.col,e.rowspan,e.colspan)}},{key:"IS_OUT_OF_BOUNDS_WARNING",value:function(e){return (0, h.toSingleLine)(s,e.row,e.col)}},{key:"IS_SINGLE_CELL",value:function(e){return (0, h.toSingleLine)(l,e.row,e.col)}},{key:"ZERO_SPAN_WARNING",value:function(e){return (0, h.toSingleLine)(u,e.row,e.col)}},{key:"containsNegativeValues",value:function(e){return 0>e.row||0>e.col||0>e.rowspan||0>e.colspan}},{key:"isSingleCell",value:function(e){return 1===e.colspan&&1===e.rowspan}},{key:"containsZeroSpan",value:function(e){return 0===e.colspan||0===e.rowspan}},{key:"isOutOfBounds",value:function(e,t,n){return 0>e.row||0>e.col||e.row>=t||e.row+e.rowspan-1>=t||e.col>=n||e.col+e.colspan-1>=n}}]),e}();},function(e,t,n){var o=n(100),r=n(45);e.exports=n(67)("Map",function(e){return function(){return e(this,arguments.length>0?arguments[0]:void 0)}},{get:function(e){var t=o.getEntry(r(this,"Map"),e);return t&&t.v},set:function(e,t){return o.def(r(this,"Map"),0===e?0:e,t)}},o,!0);},function(e,t,n){var o=n(20).f,r=n(76),i=n(63),a=n(31),s=n(65),l=n(66),u=n(109),c=n(111),h=n(112),f=n(22),d=n(33).fastKey,p=n(45),g=f?"_s":"size",v=function(e,t){var n,o=d(t);if("F"!==o)return e._i[o];for(n=e._f;n;n=n.n)if(n.k==t)return n};e.exports={getConstructor:function(e,t,n,u){var c=e(function(e,o){s(e,c,t,"_i"),e._t=t,e._i=r(null),e._f=void 0,e._l=void 0,e[g]=0,void 0!=o&&l(o,n,e[u],e);});return i(c.prototype,{clear:function(){for(var e=p(this,t),n=e._i,o=e._f;o;o=o.n)o.r=!0,o.p&&(o.p=o.p.n=void 0),delete n[o.i];e._f=e._l=void 0,e[g]=0;},delete:function(e){var n=p(this,t),o=v(n,e);if(o){var r=o.n,i=o.p;delete n._i[o.i],o.r=!0,i&&(i.n=r),r&&(r.p=i),n._f==o&&(n._f=r),n._l==o&&(n._l=i),n[g]--;}return !!o},forEach:function(e){p(this,t);for(var n,o=a(e,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(o(n.v,n.k,this);n&&n.r;)n=n.p;},has:function(e){return !!v(p(this,t),e)}}),f&&o(c.prototype,"size",{get:function(){return p(this,t)[g]}}),c},def:function(e,t,n){var o,r,i=v(e,t);return i?i.v=n:(e._l=i={i:r=d(t,!0),k:t,v:n,p:o=e._l,n:void 0,r:!1},e._f||(e._f=i),o&&(o.n=i),e[g]++,"F"!==r&&(e._i[r]=i)),e},getEntry:v,setStrong:function(e,t,n){u(e,t,function(e,n){this._t=p(e,t),this._k=n,this._l=void 0;},function(){for(var e=this,t=e._k,n=e._l;n&&n.r;)n=n.p;return e._t&&(e._l=n=n?n.n:e._t._f)?"keys"==t?c(0,n.k):"values"==t?c(0,n.v):c(0,[n.k,n.v]):(e._t=void 0,c(1))},n?"entries":"values",!n,!0),h(t);}};},function(e,t,n){e.exports=!n(22)&&!n(23)(function(){return 7!=Object.defineProperty(n(74)("div"),"a",{get:function(){return 7}}).a});},function(e,t,n){var o=n(28),r=n(24),i=n(103)(!1),a=n(78)("IE_PROTO");e.exports=function(e,t){var n,s=r(e),l=0,u=[];for(n in s)n!=a&&o(s,n)&&u.push(n);for(;t.length>l;)o(s,n=t[l++])&&(~i(u,n)||u.push(n));return u};},function(e,t,n){var o=n(24),r=n(25),i=n(62);e.exports=function(e){return function(t,n,a){var s,l=o(t),u=r(l.length),c=i(a,u);if(e&&n!=n){for(;u>c;)if((s=l[c++])!=s)return !0}else for(;u>c;c++)if((e||c in l)&&l[c]===n)return e||c||0;return !e&&-1}};},function(e,t,n){var o=n(15).document;e.exports=o&&o.documentElement;},function(e,t,n){var o=n(18);e.exports=function(e,t,n,r){try{return r?t(o(n)[0],n[1]):t(n)}catch(t){var i=e.return;throw void 0!==i&&o(i.call(e)),t}};},function(e,t,n){var o=n(53),r=n(13)("iterator"),i=Array.prototype;e.exports=function(e){return void 0!==e&&(o.Array===e||i[r]===e)};},function(e,t,n){var o=n(108),r=n(13)("iterator"),i=n(53);e.exports=n(40).getIteratorMethod=function(e){if(void 0!=e)return e[r]||e["@@iterator"]||i[o(e)]};},function(e,t,n){var o=n(44),r=n(13)("toStringTag"),i="Arguments"==o(function(){return arguments}()),a=function(e,t){try{return e[t]}catch(e){}};e.exports=function(e){var t,n,s;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=a(t=Object(e),r))?n:i?o(t):"Object"==(s=o(t))&&"function"==typeof t.callee?"Arguments":s};},function(e,t,n){var o=n(50),r=n(3),i=n(29),a=n(30),s=n(53),l=n(455),u=n(54),c=n(110),h=n(13)("iterator"),f=!([].keys&&"next"in[].keys()),d=function(){return this};e.exports=function(e,t,n,p,g,v,m){l(n,t,p);var y,w,C,b=function(e){if(!f&&e in O)return O[e];switch(e){case"keys":case"values":return function(){return new n(this,e)}}return function(){return new n(this,e)}},_=t+" Iterator",S="values"==g,E=!1,O=e.prototype,T=O[h]||O["@@iterator"]||g&&O[g],k=T||b(g),R=g?S?b("entries"):k:void 0,M="Array"==t?O.entries||T:T;if(M&&(C=c(M.call(new e)))!==Object.prototype&&C.next&&(u(C,_,!0),o||"function"==typeof C[h]||a(C,h,d)),S&&T&&"values"!==T.name&&(E=!0,k=function(){return T.call(this)}),o&&!m||!f&&!E&&O[h]||a(O,h,k),s[t]=k,s[_]=d,g)if(y={values:S?k:b("values"),keys:v?k:b("keys"),entries:R},m)for(w in y)w in O||i(O,w,y[w]);else r(r.P+r.F*(f||E),t,y);return y};},function(e,t,n){var o=n(28),r=n(32),i=n(78)("IE_PROTO"),a=Object.prototype;e.exports=Object.getPrototypeOf||function(e){return e=r(e),o(e,i)?e[i]:"function"==typeof e.constructor&&e instanceof e.constructor?e.constructor.prototype:e instanceof Object?a:null};},function(e,t){e.exports=function(e,t){return {value:t,done:!!e}};},function(e,t,n){var o=n(15),r=n(20),i=n(22),a=n(13)("species");e.exports=function(e){var t=o[e];i&&t&&!t[a]&&r.f(t,a,{configurable:!0,get:function(){return this}});};},function(e,t,n){var o=n(9),r=n(18),i=function(e,t){if(r(e),!o(t)&&null!==t)throw TypeError(t+": can't set as prototype!")};e.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(e,t,o){try{o=n(31)(Function.call,n(68).f(Object.prototype,"__proto__").set,2),o(e,[]),t=!(e instanceof Array);}catch(e){t=!0;}return function(e,n){return i(e,n),t?e.__proto__=n:o(e,n),e}}({},!1):void 0),check:i};},function(e,t,n){var o=n(100),r=n(45);e.exports=n(67)("Set",function(e){return function(){return e(this,arguments.length>0?arguments[0]:void 0)}},{add:function(e){return o.def(r(this,"Set"),e=0===e?0:e,e)}},o);},function(e,t,n){var o,r=n(69)(0),i=n(29),a=n(33),s=n(117),l=n(118),u=n(9),c=n(23),h=n(45),f=a.getWeak,d=Object.isExtensible,p=l.ufstore,g={},v=function(e){return function(){return e(this,arguments.length>0?arguments[0]:void 0)}},m={get:function(e){if(u(e)){var t=f(e);return !0===t?p(h(this,"WeakMap")).get(e):t?t[this._i]:void 0}},set:function(e,t){return l.def(h(this,"WeakMap"),e,t)}},y=e.exports=n(67)("WeakMap",v,m,l,!0,!0);c(function(){return 7!=(new y).set((Object.freeze||Object)(g),7).get(g)})&&(o=l.getConstructor(v,"WeakMap"),s(o.prototype,m),a.NEED=!0,r(["delete","has","get","set"],function(e){var t=y.prototype,n=t[e];i(t,e,function(t,r){if(u(t)&&!d(t)){this._f||(this._f=new o);var i=this._f[e](t,r);return "set"==e?this:i}return n.call(this,t,r)});}));},function(e,t,n){var o=n(44);e.exports=Array.isArray||function(e){return "Array"==o(e)};},function(e,t,n){var o=n(38),r=n(70),i=n(55),a=n(32),s=n(77),l=Object.assign;e.exports=!l||n(23)(function(){var e={},t={},n=Symbol(),o="abcdefghijklmnopqrst";return e[n]=7,o.split("").forEach(function(e){t[e]=e;}),7!=l({},e)[n]||Object.keys(l({},t)).join("")!=o})?function(e,t){for(var n=a(e),l=arguments.length,u=1,c=r.f,h=i.f;l>u;)for(var f,d=s(arguments[u++]),p=c?o(d).concat(c(d)):o(d),g=p.length,v=0;g>v;)h.call(d,f=p[v++])&&(n[f]=d[f]);return n}:l;},function(e,t,n){var o=n(63),r=n(33).getWeak,i=n(18),a=n(9),s=n(65),l=n(66),u=n(69),c=n(28),h=n(45),f=u(5),d=u(6),p=0,g=function(e){return e._l||(e._l=new v)},v=function(){this.a=[];},m=function(e,t){return f(e.a,function(e){return e[0]===t})};v.prototype={get:function(e){var t=m(this,e);if(t)return t[1]},has:function(e){return !!m(this,e)},set:function(e,t){var n=m(this,e);n?n[1]=t:this.a.push([e,t]);},delete:function(e){var t=d(this.a,function(t){return t[0]===e});return ~t&&this.a.splice(t,1),!!~t}},e.exports={getConstructor:function(e,t,n,i){var u=e(function(e,o){s(e,u,t,"_i"),e._t=t,e._i=p++,e._l=void 0,void 0!=o&&l(o,n,e[i],e);});return o(u.prototype,{delete:function(e){if(!a(e))return !1;var n=r(e);return !0===n?g(h(this,t)).delete(e):n&&c(n,this._i)&&delete n[this._i]},has:function(e){if(!a(e))return !1;var n=r(e);return !0===n?g(h(this,t)).has(e):n&&c(n,this._i)}}),u},def:function(e,t,n){var o=r(i(t),!0);return !0===o?g(e).set(t,n):o[e._i]=n,e},ufstore:g};},function(e,t,n){var o=n(118),r=n(45);n(67)("WeakSet",function(e){return function(){return e(this,arguments.length>0?arguments[0]:void 0)}},{add:function(e){return o.def(r(this,"WeakSet"),e,!0)}},o,!1,!0);},function(e,t,n){var o,r,i,a,s=n(50),l=n(15),u=n(31),c=n(108),h=n(3),f=n(9),d=n(64),p=n(65),g=n(66),v=n(459),m=n(82).set,y=n(461)(),w=n(121),C=n(462),b=n(83),_=n(463),S=l.TypeError,E=l.process,O=E&&E.versions,T=O&&O.v8||"",k=l.Promise,R="process"==c(E),M=function(){},D=r=w.f,A=!!function(){try{var e=k.resolve(1),t=(e.constructor={})[n(13)("species")]=function(e){e(M,M);};return (R||"function"==typeof PromiseRejectionEvent)&&e.then(M)instanceof t&&0!==T.indexOf("6.6")&&-1===b.indexOf("Chrome/66")}catch(e){}}(),N=function(e){var t;return !(!f(e)||"function"!=typeof(t=e.then))&&t},P=function(e,t){if(!e._n){e._n=!0;var n=e._c;y(function(){for(var o=e._v,r=1==e._s,i=0;n.length>i;)!function(t){var n,i,a,s=r?t.ok:t.fail,l=t.resolve,u=t.reject,c=t.domain;try{s?(r||(2==e._h&&x(e),e._h=1),!0===s?n=o:(c&&c.enter(),n=s(o),c&&(c.exit(),a=!0)),n===t.promise?u(S("Promise-chain cycle")):(i=N(n))?i.call(n,l,u):l(n)):u(o);}catch(e){c&&!a&&c.exit(),u(e);}}(n[i++]);e._c=[],e._n=!1,t&&!e._h&&H(e);});}},H=function(e){m.call(l,function(){var t,n,o,r=e._v,i=L(e);if(i&&(t=C(function(){R?E.emit("unhandledRejection",r,e):(n=l.onunhandledrejection)?n({promise:e,reason:r}):(o=l.console)&&o.error&&o.error("Unhandled promise rejection",r);}),e._h=R||L(e)?2:1),e._a=void 0,i&&t.e)throw t.v});},L=function(e){return 1!==e._h&&0===(e._a||e._c).length},x=function(e){m.call(l,function(){var t;R?E.emit("rejectionHandled",e):(t=l.onrejectionhandled)&&t({promise:e,reason:e._v});});},I=function(e){var t=this;t._d||(t._d=!0,t=t._w||t,t._v=e,t._s=2,t._a||(t._a=t._c.slice()),P(t,!0));},j=function(e){var t,n=this;if(!n._d){n._d=!0,n=n._w||n;try{if(n===e)throw S("Promise can't be resolved itself");(t=N(e))?y(function(){var o={_w:n,_d:!1};try{t.call(e,u(j,o,1),u(I,o,1));}catch(e){I.call(o,e);}}):(n._v=e,n._s=1,P(n,!1));}catch(e){I.call({_w:n,_d:!1},e);}}};A||(k=function(e){p(this,k,"Promise","_h"),d(e),o.call(this);try{e(u(j,this,1),u(I,this,1));}catch(e){I.call(this,e);}},o=function(e){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1;},o.prototype=n(63)(k.prototype,{then:function(e,t){var n=D(v(this,k));return n.ok="function"!=typeof e||e,n.fail="function"==typeof t&&t,n.domain=R?E.domain:void 0,this._c.push(n),this._a&&this._a.push(n),this._s&&P(this,!1),n.promise},catch:function(e){return this.then(void 0,e)}}),i=function(){var e=new o;this.promise=e,this.resolve=u(j,e,1),this.reject=u(I,e,1);},w.f=D=function(e){return e===k||e===a?new i(e):r(e)}),h(h.G+h.W+h.F*!A,{Promise:k}),n(54)(k,"Promise"),n(112)("Promise"),a=n(40).Promise,h(h.S+h.F*!A,"Promise",{reject:function(e){var t=D(this);return (0, t.reject)(e),t.promise}}),h(h.S+h.F*(s||!A),"Promise",{resolve:function(e){return _(s&&this===a?k:this,e)}}),h(h.S+h.F*!(A&&n(81)(function(e){k.all(e).catch(M);})),"Promise",{all:function(e){var t=this,n=D(t),o=n.resolve,r=n.reject,i=C(function(){var n=[],i=0,a=1;g(e,!1,function(e){var s=i++,l=!1;n.push(void 0),a++,t.resolve(e).then(function(e){l||(l=!0,n[s]=e,--a||o(n));},r);}),--a||o(n);});return i.e&&r(i.v),n.promise},race:function(e){var t=this,n=D(t),o=n.reject,r=C(function(){g(e,!1,function(e){t.resolve(e).then(n.resolve,o);});});return r.e&&o(r.v),n.promise}});},function(e,t,n){function o(e){var t,n;this.promise=new e(function(e,o){if(void 0!==t||void 0!==n)throw TypeError("Bad Promise constructor");t=e,n=o;}),this.resolve=r(t),this.reject=r(n);}var r=n(64);e.exports.f=function(e){return new o(e)};},function(e,t,n){var o=n(15),r=n(28),i=n(22),a=n(3),s=n(29),l=n(33).KEY,u=n(23),c=n(79),h=n(54),f=n(51),d=n(13),p=n(123),g=n(464),v=n(465),m=n(116),y=n(18),w=n(9),C=n(24),b=n(75),_=n(52),S=n(76),E=n(124),O=n(68),T=n(20),k=n(38),R=O.f,M=T.f,D=E.f,A=o.Symbol,N=o.JSON,P=N&&N.stringify,H=d("_hidden"),L=d("toPrimitive"),x={}.propertyIsEnumerable,I=c("symbol-registry"),j=c("symbols"),F=c("op-symbols"),W=Object.prototype,B="function"==typeof A,Y=o.QObject,V=!Y||!Y.prototype||!Y.prototype.findChild,U=i&&u(function(){return 7!=S(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(e,t,n){var o=R(W,t);o&&delete W[t],M(e,t,n),o&&e!==W&&M(W,t,o);}:M,z=function(e){var t=j[e]=S(A.prototype);return t._k=e,t},G=B&&"symbol"==typeof A.iterator?function(e){return "symbol"==typeof e}:function(e){return e instanceof A},K=function(e,t,n){return e===W&&K(F,t,n),y(e),t=b(t,!0),y(n),r(j,t)?(n.enumerable?(r(e,H)&&e[H][t]&&(e[H][t]=!1),n=S(n,{enumerable:_(0,!1)})):(r(e,H)||M(e,H,_(1,{})),e[H][t]=!0),U(e,t,n)):M(e,t,n)},X=function(e,t){y(e);for(var n,o=v(t=C(t)),r=0,i=o.length;i>r;)K(e,n=o[r++],t[n]);return e},q=function(e,t){return void 0===t?S(e):X(S(e),t)},Z=function(e){var t=x.call(this,e=b(e,!0));return !(this===W&&r(j,e)&&!r(F,e))&&(!(t||!r(this,e)||!r(j,e)||r(this,H)&&this[H][e])||t)},$=function(e,t){if(e=C(e),t=b(t,!0),e!==W||!r(j,t)||r(F,t)){var n=R(e,t);return !n||!r(j,t)||r(e,H)&&e[H][t]||(n.enumerable=!0),n}},J=function(e){for(var t,n=D(C(e)),o=[],i=0;n.length>i;)r(j,t=n[i++])||t==H||t==l||o.push(t);return o},Q=function(e){for(var t,n=e===W,o=D(n?F:C(e)),i=[],a=0;o.length>a;)!r(j,t=o[a++])||n&&!r(W,t)||i.push(j[t]);return i};B||(A=function(){if(this instanceof A)throw TypeError("Symbol is not a constructor!");var e=f(arguments.length>0?arguments[0]:void 0),t=function(n){this===W&&t.call(F,n),r(this,H)&&r(this[H],e)&&(this[H][e]=!1),U(this,e,_(1,n));};return i&&V&&U(W,e,{configurable:!0,set:t}),z(e)},s(A.prototype,"toString",function(){return this._k}),O.f=$,T.f=K,n(84).f=E.f=J,n(55).f=Z,n(70).f=Q,i&&!n(50)&&s(W,"propertyIsEnumerable",Z,!0),p.f=function(e){return z(d(e))}),a(a.G+a.W+a.F*!B,{Symbol:A});for(var ee="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),te=0;ee.length>te;)d(ee[te++]);for(var ne=k(d.store),oe=0;ne.length>oe;)g(ne[oe++]);a(a.S+a.F*!B,"Symbol",{for:function(e){return r(I,e+="")?I[e]:I[e]=A(e)},keyFor:function(e){if(!G(e))throw TypeError(e+" is not a symbol!");for(var t in I)if(I[t]===e)return t},useSetter:function(){V=!0;},useSimple:function(){V=!1;}}),a(a.S+a.F*!B,"Object",{create:q,defineProperty:K,defineProperties:X,getOwnPropertyDescriptor:$,getOwnPropertyNames:J,getOwnPropertySymbols:Q}),N&&a(a.S+a.F*(!B||u(function(){var e=A();return "[null]"!=P([e])||"{}"!=P({a:e})||"{}"!=P(Object(e))})),"JSON",{stringify:function(e){for(var t,n,o=[e],r=1;arguments.length>r;)o.push(arguments[r++]);if(n=t=o[1],(w(t)||void 0!==e)&&!G(e))return m(t)||(t=function(e,t){if("function"==typeof n&&(t=n.call(this,e,t)),!G(t))return t}),o[1]=t,P.apply(N,o)}}),A.prototype[L]||n(30)(A.prototype,L,A.prototype.valueOf),h(A,"Symbol"),h(Math,"Math",!0),h(o.JSON,"JSON",!0);},function(e,t,n){t.f=n(13);},function(e,t,n){var o=n(24),r=n(84).f,i={}.toString,a="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],s=function(e){try{return r(e)}catch(e){return a.slice()}};e.exports.f=function(e){return a&&"[object Window]"==i.call(e)?s(e):r(o(e))};},function(e,t,n){var o=n(9),r=n(33).onFreeze;n(26)("freeze",function(e){return function(t){return e&&o(t)?e(r(t)):t}});},function(e,t,n){var o=n(9),r=n(33).onFreeze;n(26)("seal",function(e){return function(t){return e&&o(t)?e(r(t)):t}});},function(e,t,n){var o=n(9),r=n(33).onFreeze;n(26)("preventExtensions",function(e){return function(t){return e&&o(t)?e(r(t)):t}});},function(e,t,n){var o=n(9);n(26)("isFrozen",function(e){return function(t){return !o(t)||!!e&&e(t)}});},function(e,t,n){var o=n(9);n(26)("isSealed",function(e){return function(t){return !o(t)||!!e&&e(t)}});},function(e,t,n){var o=n(9);n(26)("isExtensible",function(e){return function(t){return !!o(t)&&(!e||e(t))}});},function(e,t,n){var o=n(24),r=n(68).f;n(26)("getOwnPropertyDescriptor",function(){return function(e,t){return r(o(e),t)}});},function(e,t,n){var o=n(32),r=n(110);n(26)("getPrototypeOf",function(){return function(e){return r(o(e))}});},function(e,t,n){var o=n(32),r=n(38);n(26)("keys",function(){return function(e){return r(o(e))}});},function(e,t,n){n(26)("getOwnPropertyNames",function(){return n(124).f});},function(e,t,n){var o=n(3);o(o.S+o.F,"Object",{assign:n(117)});},function(e,t,n){var o=n(3);o(o.S,"Object",{is:n(466)});},function(e,t,n){var o=n(3);o(o.S,"Object",{setPrototypeOf:n(113).set});},function(e,t,n){var o=n(20).f,r=Function.prototype,i=/^\s*function ([^ (]*)/;"name"in r||n(22)&&o(r,"name",{configurable:!0,get:function(){try{return (""+this).match(i)[1]}catch(e){return ""}}});},function(e,t,n){var o=n(3),r=n(24),i=n(25);o(o.S,"String",{raw:function(e){for(var t=r(e.raw),n=i(t.length),o=arguments.length,a=[],s=0;n>s;)a.push(t[s++]+""),o>s&&a.push(arguments[s]+"");return a.join("")}});},function(e,t,n){var o=n(3),r=n(62),i=String.fromCharCode,a=String.fromCodePoint;o(o.S+o.F*(!!a&&1!=a.length),"String",{fromCodePoint:function(e){for(var t,n=[],o=arguments.length,a=0;o>a;){if(t=+arguments[a++],r(t,1114111)!==t)throw RangeError(t+" is not a valid code point");n.push(65536>t?i(t):i(55296+((t-=65536)>>10),t%1024+56320));}return n.join("")}});},function(e,t,n){var o=n(3),r=n(467)(!1);o(o.P,"String",{codePointAt:function(e){return r(this,e)}});},function(e,t,n){var o=n(3);o(o.P,"String",{repeat:n(143)});},function(e,t,n){var o=n(61),r=n(39);e.exports=function(e){var t=r(this)+"",n="",i=o(e);if(0>i||i==1/0)throw RangeError("Count can't be negative");for(;i>0;(i>>>=1)&&(t+=t))1&i&&(n+=t);return n};},function(e,t,n){var o=n(3),r=n(25),i=n(85),a="".startsWith;o(o.P+o.F*n(86)("startsWith"),"String",{startsWith:function(e){var t=i(this,e,"startsWith"),n=r(Math.min(arguments.length>1?arguments[1]:void 0,t.length)),o=e+"";return a?a.call(t,o,n):t.slice(n,n+o.length)===o}});},function(e,t,n){var o=n(9),r=n(44),i=n(13)("match");e.exports=function(e){var t;return o(e)&&(void 0!==(t=e[i])?!!t:"RegExp"==r(e))};},function(e,t,n){var o=n(3),r=n(25),i=n(85),a="".endsWith;o(o.P+o.F*n(86)("endsWith"),"String",{endsWith:function(e){var t=i(this,e,"endsWith"),n=arguments.length>1?arguments[1]:void 0,o=r(t.length),s=void 0===n?o:Math.min(r(n),o),l=e+"";return a?a.call(t,l,s):t.slice(s-l.length,s)===l}});},function(e,t,n){var o=n(3),r=n(85);o(o.P+o.F*n(86)("includes"),"String",{includes:function(e){return !!~r(this,e,"includes").indexOf(e,arguments.length>1?arguments[1]:void 0)}});},function(e,t,n){n(22)&&"g"!=/./g.flags&&n(20).f(RegExp.prototype,"flags",{configurable:!0,get:n(468)});},function(e,t,n){n(71)("match",1,function(e,t,n){return [function(n){var o=e(this),r=void 0==n?void 0:n[t];return void 0!==r?r.call(n,o):RegExp(n)[t](o+"")},n]});},function(e,t,n){n(71)("replace",2,function(e,t,n){return [function(o,r){var i=e(this),a=void 0==o?void 0:o[t];return void 0!==a?a.call(o,i,r):n.call(i+"",o,r)},n]});},function(e,t,n){n(71)("split",2,function(e,t,o){var r=n(145),i=o,a=[].push,s="length";if("c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1)[s]||2!="ab".split(/(?:ab)*/)[s]||4!=".".split(/(.?)(.?)/)[s]||".".split(/()()/)[s]>1||"".split(/.?/)[s]){var l=void 0===/()??/.exec("")[1];o=function(e,t){var n=this+"";if(void 0===e&&0===t)return [];if(!r(e))return i.call(n,e,t);var o,u,c,h,f,d=[],p=(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.unicode?"u":"")+(e.sticky?"y":""),g=0,v=void 0===t?4294967295:t>>>0,m=RegExp(e.source,p+"g");for(l||(o=RegExp("^"+m.source+"$(?!\\s)",p));(u=m.exec(n))&&((c=u.index+u[0][s])<=g||(d.push(n.slice(g,u.index)),!l&&u[s]>1&&u[0].replace(o,function(){for(f=1;arguments[s]-2>f;f++)void 0===arguments[f]&&(u[f]=void 0);}),u[s]>1&&n[s]>u.index&&a.apply(d,u.slice(1)),h=u[0][s],g=c,v>d[s]));)m.lastIndex===u.index&&m.lastIndex++;return g===n[s]?!h&&m.test("")||d.push(""):d.push(n.slice(g)),d[s]>v?d.slice(0,v):d};}else"0".split(void 0,0)[s]&&(o=function(e,t){return void 0===e&&0===t?[]:i.call(this,e,t)});return [function(n,r){var i=e(this),a=void 0==n?void 0:n[t];return void 0!==a?a.call(n,i,r):o.call(i+"",n,r)},o]});},function(e,t,n){n(71)("search",1,function(e,t,n){return [function(n){var o=e(this),r=void 0==n?void 0:n[t];return void 0!==r?r.call(n,o):RegExp(n)[t](o+"")},n]});},function(e,t,n){var o=n(31),r=n(3),i=n(32),a=n(105),s=n(106),l=n(25),u=n(87),c=n(107);r(r.S+r.F*!n(81)(function(e){}),"Array",{from:function(e){var t,n,r,h,f=i(e),d="function"==typeof this?this:Array,p=arguments.length,g=p>1?arguments[1]:void 0,v=void 0!==g,m=0,y=c(f);if(v&&(g=o(g,p>2?arguments[2]:void 0,2)),void 0==y||d==Array&&s(y))for(t=l(f.length),n=new d(t);t>m;m++)u(n,m,v?g(f[m],m):f[m]);else for(h=y.call(f),n=new d;!(r=h.next()).done;m++)u(n,m,v?a(h,g,[r.value,m],!0):r.value);return n.length=m,n}});},function(e,t,n){var o=n(3),r=n(87);o(o.S+o.F*n(23)(function(){function e(){}return !(Array.of.call(e)instanceof e)}),"Array",{of:function(){for(var e=0,t=arguments.length,n=new("function"==typeof this?this:Array)(t);t>e;)r(n,e,arguments[e++]);return n.length=t,n}});},function(e,t,n){var o=n(3);o(o.P,"Array",{copyWithin:n(469)}),n(46)("copyWithin");},function(e,t,n){var o=n(3),r=n(69)(5),i=!0;"find"in[]&&Array(1).find(function(){i=!1;}),o(o.P+o.F*i,"Array",{find:function(e){return r(this,e,arguments.length>1?arguments[1]:void 0)}}),n(46)("find");},function(e,t,n){var o=n(3),r=n(69)(6),i="findIndex",a=!0;i in[]&&Array(1)[i](function(){a=!1;}),o(o.P+o.F*a,"Array",{findIndex:function(e){return r(this,e,arguments.length>1?arguments[1]:void 0)}}),n(46)(i);},function(e,t,n){var o=n(3);o(o.P,"Array",{fill:n(470)}),n(46)("fill");},function(e,t,n){var o=n(3),r=n(15).isFinite;o(o.S,"Number",{isFinite:function(e){return "number"==typeof e&&r(e)}});},function(e,t,n){var o=n(3);o(o.S,"Number",{isInteger:n(161)});},function(e,t,n){var o=n(9),r=Math.floor;e.exports=function(e){return !o(e)&&isFinite(e)&&r(e)===e};},function(e,t,n){var o=n(3),r=n(161),i=Math.abs;o(o.S,"Number",{isSafeInteger:function(e){return r(e)&&9007199254740991>=i(e)}});},function(e,t,n){var o=n(3);o(o.S,"Number",{isNaN:function(e){return e!=e}});},function(e,t,n){var o=n(3);o(o.S,"Number",{EPSILON:Math.pow(2,-52)});},function(e,t,n){var o=n(3);o(o.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991});},function(e,t,n){var o=n(3);o(o.S,"Number",{MAX_SAFE_INTEGER:9007199254740991});},function(e,t,n){var o=n(3),r=n(103)(!0);o(o.P,"Array",{includes:function(e){return r(this,e,arguments.length>1?arguments[1]:void 0)}}),n(46)("includes");},function(e,t,n){var o=n(3),r=n(169)(!1);o(o.S,"Object",{values:function(e){return r(e)}});},function(e,t,n){var o=n(38),r=n(24),i=n(55).f;e.exports=function(e){return function(t){for(var n,a=r(t),s=o(a),l=s.length,u=0,c=[];l>u;)i.call(a,n=s[u++])&&c.push(e?[n,a[n]]:a[n]);return c}};},function(e,t,n){var o=n(3),r=n(169)(!0);o(o.S,"Object",{entries:function(e){return r(e)}});},function(e,t,n){var o=n(3),r=n(471),i=n(24),a=n(68),s=n(87);o(o.S,"Object",{getOwnPropertyDescriptors:function(e){for(var t,n,o=i(e),l=a.f,u=r(o),c={},h=0;u.length>h;)void 0!==(n=l(o,t=u[h++]))&&s(c,t,n);return c}});},function(e,t,n){var o=n(3),r=n(173);o(o.P+o.F*/Version\/10\.\d+(\.\d+)? Safari\//.test(n(83)),"String",{padStart:function(e){return r(this,e,arguments.length>1?arguments[1]:void 0,!0)}});},function(e,t,n){var o=n(25),r=n(143),i=n(39);e.exports=function(e,t,n,a){var s=i(e)+"",l=s.length,u=void 0===n?" ":n+"",c=o(t);if(l>=c||""==u)return s;var h=c-l,f=r.call(u,Math.ceil(h/u.length));return f.length>h&&(f=f.slice(0,h)),a?f+s:s+f};},function(e,t,n){var o=n(3),r=n(173);o(o.P+o.F*/Version\/10\.\d+(\.\d+)? Safari\//.test(n(83)),"String",{padEnd:function(e){return r(this,e,arguments.length>1?arguments[1]:void 0,!1)}});},function(e,t,n){var o=n(3),r=n(82);o(o.G+o.B,{setImmediate:r.set,clearImmediate:r.clear});},function(e,t,n){for(var o=n(88),r=n(38),i=n(29),a=n(15),s=n(30),l=n(53),u=n(13),c=u("iterator"),h=u("toStringTag"),f=l.Array,d={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},p=r(d),g=0;p.length>g;g++){var v,m=p[g],y=d[m],w=a[m],C=w&&w.prototype;if(C&&(C[c]||s(C,c,f),C[h]||s(C,h,m),l[m]=f,y))for(v in o)C[v]||i(C,v,o[v],!0);}},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=new WeakMap;t.default=function(){function e(t,n,r,a,s,l,u){var c=arguments.length>7&&void 0!==arguments[7]?arguments[7]:function(e){return e};o(this,e),i.set(this,{viewportWidth:t,scrollOffset:n,totalColumns:r,columnWidthFn:a,overrideFn:s,onlyFullyVisible:l,stretchingColumnWidthFn:c}),this.count=0,this.startColumn=null,this.endColumn=null,this.startPosition=null,this.stretchAllRatio=0,this.stretchLastWidth=0,this.stretch=u,this.totalTargetWidth=0,this.needVerifyLastColumnWidth=!0,this.stretchAllColumnsWidth=[],this.calculate();}return r(e,null,[{key:"DEFAULT_WIDTH",get:function(){return 50}}]),r(e,[{key:"calculate",value:function(){for(var e=0,t=!0,n=[],o=void 0,r=i.get(this),a=r.onlyFullyVisible,s=r.overrideFn,l=r.scrollOffset,u=r.totalColumns,c=r.viewportWidth,h=0;u>h;h++){o=this._getColumnWidth(h),e>l||a||(this.startColumn=h);var f=l>0?c+1:c;if(l>e||e+o>l+f||(null!==this.startColumn&&void 0!==this.startColumn||(this.startColumn=h),this.endColumn=h),n.push(e),e+=o,a||(this.endColumn=h),e>=l+c){t=!1;break}}if(this.endColumn===u-1&&t)for(this.startColumn=this.endColumn;this.startColumn>0;){var d=n[this.endColumn]+o-n[this.startColumn-1];if(d>c&&a||(this.startColumn-=1),d>c)break}null!==this.startColumn&&s&&s(this),this.startPosition=n[this.startColumn],void 0===this.startPosition&&(this.startPosition=null),null!==this.startColumn&&(this.count=this.endColumn-this.startColumn+1);}},{key:"refreshStretching",value:function(e){if("none"!==this.stretch){var t=e;this.totalTargetWidth=t;for(var n=i.get(this),o=n.totalColumns,r=0,a=0;o>a;a++){var s=this._getColumnWidth(a),l=n.stretchingColumnWidthFn(void 0,a);"number"==typeof l?t-=l:r+=s;}var u=t-r;if("all"===this.stretch&&u>0)this.stretchAllRatio=t/r,this.stretchAllColumnsWidth=[],this.needVerifyLastColumnWidth=!0;else if("last"===this.stretch&&t!==1/0){var c=this._getColumnWidth(o-1),h=u+c;this.stretchLastWidth=0>h?c:h;}}}},{key:"getStretchedColumnWidth",value:function(e,t){var n=null;return "all"===this.stretch&&0!==this.stretchAllRatio?n=this._getStretchedAllColumnWidth(e,t):"last"===this.stretch&&0!==this.stretchLastWidth&&(n=this._getStretchedLastColumnWidth(e)),n}},{key:"_getStretchedAllColumnWidth",value:function(e,t){var n=0,o=i.get(this),r=o.totalColumns;if(!this.stretchAllColumnsWidth[e]){var a=Math.round(t*this.stretchAllRatio),s=o.stretchingColumnWidthFn(a,e);this.stretchAllColumnsWidth[e]=void 0===s?a:isNaN(s)?this._getColumnWidth(e):s;}if(this.stretchAllColumnsWidth.length===r&&this.needVerifyLastColumnWidth){this.needVerifyLastColumnWidth=!1;for(var l=0;this.stretchAllColumnsWidth.length>l;l++)n+=this.stretchAllColumnsWidth[l];n!==this.totalTargetWidth&&(this.stretchAllColumnsWidth[this.stretchAllColumnsWidth.length-1]+=this.totalTargetWidth-n);}return this.stretchAllColumnsWidth[e]}},{key:"_getStretchedLastColumnWidth",value:function(e){return e===i.get(this).totalColumns-1?this.stretchLastWidth:null}},{key:"_getColumnWidth",value:function(t){var n=i.get(this).columnWidthFn(t);return isNaN(n)&&(n=e.DEFAULT_WIDTH),n}}]),e}();},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=new WeakMap;t.default=function(){function e(t,n,r,a,s,l,u){o(this,e),i.set(this,{viewportHeight:t,scrollOffset:n,totalRows:r,rowHeightFn:a,overrideFn:s,onlyFullyVisible:l,horizontalScrollbarHeight:u}),this.count=0,this.startRow=null,this.endRow=null,this.startPosition=null,this.calculate();}return r(e,null,[{key:"DEFAULT_HEIGHT",get:function(){return 23}}]),r(e,[{key:"calculate",value:function(){for(var t=0,n=!0,o=[],r=i.get(this),a=r.onlyFullyVisible,s=r.overrideFn,l=r.rowHeightFn,u=r.scrollOffset,c=r.totalRows,h=r.viewportHeight,f=r.horizontalScrollbarHeight||0,d=void 0,p=0;c>p;p++)if(d=l(p),isNaN(d)&&(d=e.DEFAULT_HEIGHT),t>u||a||(this.startRow=p),u>t||t+d>u+h-f||(null===this.startRow&&(this.startRow=p),this.endRow=p),o.push(t),t+=d,a||(this.endRow=p),t>=u+h-f){n=!1;break}if(this.endRow===c-1&&n)for(this.startRow=this.endRow;this.startRow>0;){var g=o[this.endRow]+d-o[this.startRow-1];if(g>h-f&&a||(this.startRow-=1),g>=h-f)break}null!==this.startRow&&s&&s(this),this.startPosition=o[this.startRow],void 0===this.startPosition&&(this.startPosition=null),null!==this.startRow&&(this.count=this.endRow-this.startRow+1);}}]),e}();},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(57),a=function(e){return e&&e.__esModule?e:{default:e}}(i);t.default=function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t;o(this,e),this.highlight=t,this.from=n,this.to=r;}return r(e,[{key:"setHighlight",value:function(e){return this.highlight=e,this}},{key:"setFrom",value:function(e){return this.from=e,this}},{key:"setTo",value:function(e){return this.to=e,this}},{key:"isValid",value:function(e){return this.from.isValid(e)&&this.to.isValid(e)}},{key:"isSingle",value:function(){return this.from.row===this.to.row&&this.from.col===this.to.col}},{key:"getHeight",value:function(){return Math.max(this.from.row,this.to.row)-Math.min(this.from.row,this.to.row)+1}},{key:"getWidth",value:function(){return Math.max(this.from.col,this.to.col)-Math.min(this.from.col,this.to.col)+1}},{key:"includes",value:function(e){var t=e.row,n=e.col,o=this.getTopLeftCorner(),r=this.getBottomRightCorner();return !(o.row>t||t>r.row||o.col>n||n>r.col)}},{key:"includesRange",value:function(e){return this.includes(e.getTopLeftCorner())&&this.includes(e.getBottomRightCorner())}},{key:"isEqual",value:function(e){return Math.min(this.from.row,this.to.row)===Math.min(e.from.row,e.to.row)&&Math.max(this.from.row,this.to.row)===Math.max(e.from.row,e.to.row)&&Math.min(this.from.col,this.to.col)===Math.min(e.from.col,e.to.col)&&Math.max(this.from.col,this.to.col)===Math.max(e.from.col,e.to.col)}},{key:"overlaps",value:function(e){return e.isSouthEastOf(this.getTopLeftCorner())&&e.isNorthWestOf(this.getBottomRightCorner())}},{key:"isSouthEastOf",value:function(e){return this.getTopLeftCorner().isSouthEastOf(e)||this.getBottomRightCorner().isSouthEastOf(e)}},{key:"isNorthWestOf",value:function(e){return this.getTopLeftCorner().isNorthWestOf(e)||this.getBottomRightCorner().isNorthWestOf(e)}},{key:"isOverlappingHorizontally",value:function(e){return this.getTopRightCorner().col>=e.getTopLeftCorner().col&&this.getTopRightCorner().col<=e.getTopRightCorner().col||this.getTopLeftCorner().col<=e.getTopRightCorner().col&&this.getTopLeftCorner().col>=e.getTopLeftCorner().col}},{key:"isOverlappingVertically",value:function(e){return this.getBottomRightCorner().row>=e.getTopRightCorner().row&&this.getBottomRightCorner().row<=e.getBottomRightCorner().row||this.getTopRightCorner().row<=e.getBottomRightCorner().row&&this.getTopRightCorner().row>=e.getTopRightCorner().row}},{key:"expand",value:function(e){var t=this.getTopLeftCorner(),n=this.getBottomRightCorner();return (t.row>e.row||t.col>e.col||e.row>n.row||e.col>n.col)&&(this.from=new a.default(Math.min(t.row,e.row),Math.min(t.col,e.col)),this.to=new a.default(Math.max(n.row,e.row),Math.max(n.col,e.col)),!0)}},{key:"expandByRange",value:function(e){if(this.includesRange(e)||!this.overlaps(e))return !1;var t=this.getTopLeftCorner(),n=this.getBottomRightCorner(),o=this.getDirection(),r=e.getTopLeftCorner(),i=e.getBottomRightCorner(),s=Math.min(t.row,r.row),l=Math.min(t.col,r.col),u=Math.max(n.row,i.row),c=Math.max(n.col,i.col),h=new a.default(s,l),f=new a.default(u,c);return this.from=h,this.to=f,this.setDirection(o),this.highlight.row===this.getBottomRightCorner().row&&"N-S"===this.getVerticalDirection()&&this.flipDirectionVertically(),this.highlight.col===this.getTopRightCorner().col&&"W-E"===this.getHorizontalDirection()&&this.flipDirectionHorizontally(),!0}},{key:"getDirection",value:function(){return this.from.isNorthWestOf(this.to)?"NW-SE":this.from.isNorthEastOf(this.to)?"NE-SW":this.from.isSouthEastOf(this.to)?"SE-NW":this.from.isSouthWestOf(this.to)?"SW-NE":void 0}},{key:"setDirection",value:function(e){switch(e){case"NW-SE":var t=[this.getTopLeftCorner(),this.getBottomRightCorner()];this.from=t[0],this.to=t[1];break;case"NE-SW":var n=[this.getTopRightCorner(),this.getBottomLeftCorner()];this.from=n[0],this.to=n[1];break;case"SE-NW":var o=[this.getBottomRightCorner(),this.getTopLeftCorner()];this.from=o[0],this.to=o[1];break;case"SW-NE":var r=[this.getBottomLeftCorner(),this.getTopRightCorner()];this.from=r[0],this.to=r[1];}}},{key:"getVerticalDirection",value:function(){return ["NE-SW","NW-SE"].indexOf(this.getDirection())>-1?"N-S":"S-N"}},{key:"getHorizontalDirection",value:function(){return ["NW-SE","SW-NE"].indexOf(this.getDirection())>-1?"W-E":"E-W"}},{key:"flipDirectionVertically",value:function(){switch(this.getDirection()){case"NW-SE":this.setDirection("SW-NE");break;case"NE-SW":this.setDirection("SE-NW");break;case"SE-NW":this.setDirection("NE-SW");break;case"SW-NE":this.setDirection("NW-SE");}}},{key:"flipDirectionHorizontally",value:function(){switch(this.getDirection()){case"NW-SE":this.setDirection("NE-SW");break;case"NE-SW":this.setDirection("NW-SE");break;case"SE-NW":this.setDirection("SW-NE");break;case"SW-NE":this.setDirection("SE-NW");}}},{key:"getTopLeftCorner",value:function(){return new a.default(Math.min(this.from.row,this.to.row),Math.min(this.from.col,this.to.col))}},{key:"getBottomRightCorner",value:function(){return new a.default(Math.max(this.from.row,this.to.row),Math.max(this.from.col,this.to.col))}},{key:"getTopRightCorner",value:function(){return new a.default(Math.min(this.from.row,this.to.row),Math.max(this.from.col,this.to.col))}},{key:"getBottomLeftCorner",value:function(){return new a.default(Math.max(this.from.row,this.to.row),Math.min(this.from.col,this.to.col))}},{key:"isCorner",value:function(e,t){return !!(t&&t.includes(e)&&(this.getTopLeftCorner().isEqual(new a.default(t.from.row,t.from.col))||this.getTopRightCorner().isEqual(new a.default(t.from.row,t.to.col))||this.getBottomLeftCorner().isEqual(new a.default(t.to.row,t.from.col))||this.getBottomRightCorner().isEqual(new a.default(t.to.row,t.to.col))))||(e.isEqual(this.getTopLeftCorner())||e.isEqual(this.getTopRightCorner())||e.isEqual(this.getBottomLeftCorner())||e.isEqual(this.getBottomRightCorner()))}},{key:"getOppositeCorner",value:function(e,t){if(!(e instanceof a.default))return !1;if(t&&t.includes(e)){if(this.getTopLeftCorner().isEqual(new a.default(t.from.row,t.from.col)))return this.getBottomRightCorner();if(this.getTopRightCorner().isEqual(new a.default(t.from.row,t.to.col)))return this.getBottomLeftCorner();if(this.getBottomLeftCorner().isEqual(new a.default(t.to.row,t.from.col)))return this.getTopRightCorner();if(this.getBottomRightCorner().isEqual(new a.default(t.to.row,t.to.col)))return this.getTopLeftCorner()}return e.isEqual(this.getBottomRightCorner())?this.getTopLeftCorner():e.isEqual(this.getTopLeftCorner())?this.getBottomRightCorner():e.isEqual(this.getTopRightCorner())?this.getBottomLeftCorner():e.isEqual(this.getBottomLeftCorner())?this.getTopRightCorner():void 0}},{key:"getBordersSharedWith",value:function(e){if(!this.includesRange(e))return [];var t={top:Math.min(this.from.row,this.to.row),bottom:Math.max(this.from.row,this.to.row),left:Math.min(this.from.col,this.to.col),right:Math.max(this.from.col,this.to.col)},n={top:Math.min(e.from.row,e.to.row),bottom:Math.max(e.from.row,e.to.row),left:Math.min(e.from.col,e.to.col),right:Math.max(e.from.col,e.to.col)},o=[];return t.top===n.top&&o.push("top"),t.right===n.right&&o.push("right"),t.bottom===n.bottom&&o.push("bottom"),t.left===n.left&&o.push("left"),o}},{key:"getInner",value:function(){for(var e=this.getTopLeftCorner(),t=this.getBottomRightCorner(),n=[],o=e.row;t.row>=o;o++)for(var r=e.col;t.col>=r;r++)this.from.row===o&&this.from.col===r||this.to.row===o&&this.to.col===r||n.push(new a.default(o,r));return n}},{key:"getAll",value:function(){for(var e=this.getTopLeftCorner(),t=this.getBottomRightCorner(),n=[],o=e.row;t.row>=o;o++)for(var r=e.col;t.col>=r;r++)n.push(e.row===o&&e.col===r?e:t.row===o&&t.col===r?t:new a.default(o,r));return n}},{key:"forAll",value:function(e){for(var t=this.getTopLeftCorner(),n=this.getBottomRightCorner(),o=t.row;n.row>=o;o++)for(var r=t.col;n.col>=r;r++){var i=e(o,r);if(!1===i)return}}},{key:"toObject",value:function(){return {from:this.from.toObject(),to:this.to.toObject()}}}]),e}();},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}();t.default=function(){function e(t,n,r){o(this,e),this.offset=t,this.total=n,this.countTH=r;}return r(e,[{key:"offsetted",value:function(e){return e+this.offset}},{key:"unOffsetted",value:function(e){return e-this.offset}},{key:"renderedToSource",value:function(e){return this.offsetted(e)}},{key:"sourceToRendered",value:function(e){return this.unOffsetted(e)}},{key:"offsettedTH",value:function(e){return e-this.countTH}},{key:"unOffsettedTH",value:function(e){return e+this.countTH}},{key:"visibleRowHeadedColumnToSourceColumn",value:function(e){return this.renderedToSource(this.offsettedTH(e))}},{key:"sourceColumnToVisibleRowHeadedColumn",value:function(e){return this.unOffsettedTH(this.sourceToRendered(e))}}]),e}();},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}();t.default=function(){function e(t,n,r){o(this,e),this.offset=t,this.total=n,this.countTH=r;}return r(e,[{key:"offsetted",value:function(e){return e+this.offset}},{key:"unOffsetted",value:function(e){return e-this.offset}},{key:"renderedToSource",value:function(e){return this.offsetted(e)}},{key:"sourceToRendered",value:function(e){return this.unOffsetted(e)}},{key:"offsettedTH",value:function(e){return e-this.countTH}},{key:"unOffsettedTH",value:function(e){return e+this.countTH}},{key:"visibleColHeadedRowToSourceRow",value:function(e){return this.renderedToSource(this.offsettedTH(e))}},{key:"sourceRowToVisibleColHeadedRow",value:function(e){return this.unOffsettedTH(this.sourceToRendered(e))}}]),e}();},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(0),s=n(1),l=n(36),u=n(303),c=o(u),h=n(304),f=o(h),d=n(305),p=o(d),g=n(306),v=o(g),m=n(307),y=o(m),w=n(309),C=o(w);t.default=function(){function e(t){r(this,e);var n=[];if(this.guid="wt_"+(0, l.randomString)(),t.cloneSource?(this.cloneSource=t.cloneSource,this.cloneOverlay=t.cloneOverlay,this.wtSettings=t.cloneSource.wtSettings,this.wtTable=new y.default(this,t.table,t.wtRootElement),this.wtScroll=new p.default(this),this.wtViewport=t.cloneSource.wtViewport,this.wtEvent=new c.default(this),this.selections=this.cloneSource.selections):(this.wtSettings=new v.default(this,t),this.wtTable=new y.default(this,t.table),this.wtScroll=new p.default(this),this.wtViewport=new C.default(this),this.wtEvent=new c.default(this),this.selections=this.getSetting("selections"),this.wtOverlays=new f.default(this),this.exportSettingsAsClassNames()),this.wtTable.THEAD.childNodes.length&&this.wtTable.THEAD.childNodes[0].childNodes.length){for(var o=0,i=this.wtTable.THEAD.childNodes[0].childNodes.length;i>o;o++)n.push(this.wtTable.THEAD.childNodes[0].childNodes[o].innerHTML);this.getSetting("columnHeaders").length||this.update("columnHeaders",[function(e,t){(0, a.fastInnerText)(t,n[e]);}]);}this.drawn=!1,this.drawInterrupted=!1;}return i(e,[{key:"draw",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this.drawInterrupted=!1,e||(0, a.isVisible)(this.wtTable.TABLE)?this.wtTable.draw(e):this.drawInterrupted=!0,this}},{key:"getCell",value:function(e){if(1>=arguments.length||void 0===arguments[1]||!arguments[1])return this.wtTable.getCell(e);var t=this.wtSettings.getSetting("totalRows"),n=this.wtSettings.getSetting("fixedRowsTop"),o=this.wtSettings.getSetting("fixedRowsBottom"),r=this.wtSettings.getSetting("fixedColumnsLeft");if(n>e.row&&r>e.col)return this.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell(e);if(n>e.row)return this.wtOverlays.topOverlay.clone.wtTable.getCell(e);if(r>e.col&&e.row>=t-o){if(this.wtOverlays.bottomLeftCornerOverlay&&this.wtOverlays.bottomLeftCornerOverlay.clone)return this.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.getCell(e)}else{if(r>e.col)return this.wtOverlays.leftOverlay.clone.wtTable.getCell(e);if(t>e.row&&e.row>t-o&&this.wtOverlays.bottomOverlay&&this.wtOverlays.bottomOverlay.clone)return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(e)}return this.wtTable.getCell(e)}},{key:"update",value:function(e,t){return this.wtSettings.update(e,t)}},{key:"scrollViewport",value:function(e,t,n,o,r){return this.wtScroll.scrollViewport(e,t,n,o,r)}},{key:"scrollViewportHorizontally",value:function(e,t,n){return this.wtScroll.scrollViewportHorizontally(e,t,n)}},{key:"scrollViewportVertically",value:function(e,t,n){return this.wtScroll.scrollViewportVertically(e,t,n)}},{key:"getViewport",value:function(){return [this.wtTable.getFirstVisibleRow(),this.wtTable.getFirstVisibleColumn(),this.wtTable.getLastVisibleRow(),this.wtTable.getLastVisibleColumn()]}},{key:"getOverlayName",value:function(){return this.cloneOverlay?this.cloneOverlay.type:"master"}},{key:"isOverlayName",value:function(e){return !!this.cloneOverlay&&this.cloneOverlay.type===e}},{key:"exportSettingsAsClassNames",value:function(){var e=this,t={rowHeaders:["array"],columnHeaders:["array"]},n=[],o=[];(0, s.objectEach)(t,function(t,r){t.indexOf("array")>-1&&e.getSetting(r).length&&o.push("ht"+(0, l.toUpperCaseFirst)(r)),n.push("ht"+(0, l.toUpperCaseFirst)(r));}),(0, a.removeClass)(this.wtTable.wtRootElement.parentNode,n),(0, a.addClass)(this.wtTable.wtRootElement.parentNode,o);}},{key:"getSetting",value:function(e,t,n,o,r){return this.wtSettings.getSetting(e,t,n,o,r)}},{key:"hasSetting",value:function(e){return this.wtSettings.has(e)}},{key:"destroy",value:function(){this.wtOverlays.destroy(),this.wtEvent.destroy();}}]),e}();},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e};},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){function o(e){var t=this,n=new l.default(e),o=void 0;this.instance=e;var s=[null,null];this.dblClickTimeout=[null,null];var u=function(e){var n=document.activeElement,o=(0, i.partial)(r.getParent,e.realTarget),a=e.realTarget;if(a!==n&&o(0)!==n&&o(1)!==n){var l=t.parentCell(a);(0, r.hasClass)(a,"corner")?t.instance.getSetting("onCellCornerMouseDown",e,a):l.TD&&t.instance.hasSetting("onCellMouseDown")&&t.instance.getSetting("onCellMouseDown",e,l.coords,l.TD,t.instance),2!==e.button&&l.TD&&(s[0]=l.TD,clearTimeout(t.dblClickTimeout[0]),t.dblClickTimeout[0]=setTimeout(function(){s[0]=null;},1e3));}},c=function(e){if(t.instance.hasSetting("onCellContextMenu")){var n=t.parentCell(e.realTarget);n.TD&&t.instance.getSetting("onCellContextMenu",e,n.coords,n.TD,t.instance);}},h=function(){t.instance.touchMoving=!0;},f=function(e){n.addEventListener(this,"touchmove",h),t.checkIfTouchMove=setTimeout(function(){!0===t.instance.touchMoving&&(t.instance.touchMoving=void 0,n.removeEventListener("touchmove",h,!1)),u(e);},30);},d=function(e){var n=void 0,o=void 0,i=void 0;t.instance.hasSetting("onCellMouseOver")&&(n=t.instance.wtTable.TABLE,o=(0, r.closestDown)(e.realTarget,["TD","TH"],n),i=t.instance.cloneSource||t.instance,o&&o!==i.lastMouseOver&&(0, r.isChildOf)(o,n)&&(i.lastMouseOver=o,t.instance.getSetting("onCellMouseOver",e,t.instance.wtTable.getCoords(o),o,t.instance)));},p=function(e){var n=void 0,o=void 0,i=void 0;t.instance.hasSetting("onCellMouseOut")&&(n=t.instance.wtTable.TABLE,o=(0, r.closestDown)(e.realTarget,["TD","TH"],n),i=(0, r.closestDown)(e.relatedTarget,["TD","TH"],n),o&&o!==i&&(0, r.isChildOf)(o,n)&&t.instance.getSetting("onCellMouseOut",e,t.instance.wtTable.getCoords(o),o,t.instance));},g=function(e){if(2!==e.button){var n=t.parentCell(e.realTarget);n.TD&&t.instance.hasSetting("onCellMouseUp")&&t.instance.getSetting("onCellMouseUp",e,n.coords,n.TD,t.instance),n.TD===s[0]&&n.TD===s[1]?((0, r.hasClass)(e.realTarget,"corner")?t.instance.getSetting("onCellCornerDblClick",e,n.coords,n.TD,t.instance):t.instance.getSetting("onCellDblClick",e,n.coords,n.TD,t.instance),s[0]=null,s[1]=null):n.TD===s[0]&&(s[1]=n.TD,clearTimeout(t.dblClickTimeout[1]),t.dblClickTimeout[1]=setTimeout(function(){s[1]=null;},500));}},v=function(e){var n=t.parentCell(e),r=n.coords;if(o&&r){var i=[r.row,o.from.row],a=i[0],s=i[1],l=[r.col,o.from.col],u=l[0],c=l[1];return a===s&&u===c}return !1},m=function(e){var t=["A","BUTTON","INPUT"],n=e.target;!1!==v(n)&&!1!==t.includes(n.tagName)||(e.preventDefault(),g(e));};if(n.addEventListener(this.instance.wtTable.holder,"mousedown",u),n.addEventListener(this.instance.wtTable.holder,"contextmenu",c),n.addEventListener(this.instance.wtTable.TABLE,"mouseover",d),n.addEventListener(this.instance.wtTable.TABLE,"mouseout",p),n.addEventListener(this.instance.wtTable.holder,"mouseup",g),this.instance.wtTable.holder.parentNode.parentNode&&(0, a.isMobileBrowser)()&&!t.instance.wtTable.isWorkingOnClone()){var y="."+this.instance.wtTable.holder.parentNode.className.split(" ").join(".");n.addEventListener(this.instance.wtTable.holder,"touchstart",function(n){o=e.selections.getCell().cellRange,t.instance.touchApplied=!0,(0, r.isChildOf)(n.target,y)&&f.call(n.target,n);}),n.addEventListener(this.instance.wtTable.holder,"touchend",function(e){t.instance.touchApplied=!1,(0, r.isChildOf)(e.target,y)&&m.call(e.target,e);}),t.instance.momentumScrolling||(t.instance.momentumScrolling={}),n.addEventListener(this.instance.wtTable.holder,"scroll",function(){clearTimeout(t.instance.momentumScrolling._timeout),t.instance.momentumScrolling.ongoing||t.instance.getSetting("onBeforeTouchScroll"),t.instance.momentumScrolling.ongoing=!0,t.instance.momentumScrolling._timeout=setTimeout(function(){t.instance.touchApplied||(t.instance.momentumScrolling.ongoing=!1,t.instance.getSetting("onAfterMomentumScroll"));},200);});}n.addEventListener(window,"resize",function(){"none"!==t.instance.getSetting("stretchH")&&t.instance.draw();}),this.destroy=function(){clearTimeout(this.dblClickTimeout[0]),clearTimeout(this.dblClickTimeout[1]),n.destroy();};}t.__esModule=!0;var r=n(0),i=n(43),a=n(35),s=n(6),l=function(e){return e&&e.__esModule?e:{default:e}}(s);o.prototype.parentCell=function(e){var t={},n=this.instance.wtTable.TABLE,o=(0, r.closestDown)(e,["TD","TH"],n);return o?(t.coords=this.instance.wtTable.getCoords(o),t.TD=o):(0, r.hasClass)(e,"wtBorder")&&(0, r.hasClass)(e,"current")?(t.coords=this.instance.selections.getCell().cellRange.highlight,t.TD=this.instance.wtTable.getCell(t.coords)):(0, r.hasClass)(e,"wtBorder")&&(0, r.hasClass)(e,"area")&&this.instance.selections.createOrGetArea().cellRange&&(t.coords=this.instance.selections.createOrGetArea().cellRange.to,t.TD=this.instance.wtTable.getCell(t.coords)),t},t.default=o;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(0),s=n(2),l=n(21),u=n(35),c=n(6),h=o(c),f=n(27),d=o(f);t.default=function(){function e(t){r(this,e);var n=parseInt(getComputedStyle(document.body).lineHeight,10),o=1.2*parseInt(getComputedStyle(document.body).fontSize,10);this.wot=t,this.instance=this.wot,this.eventManager=new h.default(this.wot),this.wot.update("scrollbarWidth",(0, a.getScrollbarWidth)()),this.wot.update("scrollbarHeight",(0, a.getScrollbarWidth)()),this.scrollableElement=(0, a.getScrollableElement)(this.wot.wtTable.TABLE),this.prepareOverlays(),this.destroyed=!1,this.keyPressed=!1,this.spreaderLastSize={width:null,height:null},this.overlayScrollPositions={master:{top:0,left:0},top:{top:null,left:0},bottom:{top:null,left:0},left:{top:0,left:null}},this.pendingScrollCallbacks={master:{top:0,left:0},top:{left:0},bottom:{left:0},left:{top:0}},this.verticalScrolling=!1,this.horizontalScrolling=!1,this.delegatedScrollCallback=!1,this.registeredListeners=[],this.browserLineHeight=n||o,this.registerListeners();}return i(e,[{key:"prepareOverlays",value:function(){var e=!1;return this.topOverlay?e=this.topOverlay.updateStateOfRendering()||e:this.topOverlay=d.default.createOverlay(d.default.CLONE_TOP,this.wot),d.default.hasOverlay(d.default.CLONE_BOTTOM)||(this.bottomOverlay={needFullRender:!1,updateStateOfRendering:function(){return !1}}),d.default.hasOverlay(d.default.CLONE_BOTTOM_LEFT_CORNER)||(this.bottomLeftCornerOverlay={needFullRender:!1,updateStateOfRendering:function(){return !1}}),this.bottomOverlay?e=this.bottomOverlay.updateStateOfRendering()||e:this.bottomOverlay=d.default.createOverlay(d.default.CLONE_BOTTOM,this.wot),this.leftOverlay?e=this.leftOverlay.updateStateOfRendering()||e:this.leftOverlay=d.default.createOverlay(d.default.CLONE_LEFT,this.wot),this.topOverlay.needFullRender&&this.leftOverlay.needFullRender&&(this.topLeftCornerOverlay?e=this.topLeftCornerOverlay.updateStateOfRendering()||e:this.topLeftCornerOverlay=d.default.createOverlay(d.default.CLONE_TOP_LEFT_CORNER,this.wot)),this.bottomOverlay.needFullRender&&this.leftOverlay.needFullRender&&(this.bottomLeftCornerOverlay?e=this.bottomLeftCornerOverlay.updateStateOfRendering()||e:this.bottomLeftCornerOverlay=d.default.createOverlay(d.default.CLONE_BOTTOM_LEFT_CORNER,this.wot)),this.wot.getSetting("debug")&&!this.debug&&(this.debug=d.default.createOverlay(d.default.CLONE_DEBUG,this.wot)),e}},{key:"refreshAll",value:function(){if(this.wot.drawn){if(!this.wot.wtTable.holder.parentNode)return void this.destroy();this.wot.draw(!0),this.verticalScrolling&&this.leftOverlay.onScroll(),this.horizontalScrolling&&this.topOverlay.onScroll(),this.verticalScrolling=!1,this.horizontalScrolling=!1;}}},{key:"registerListeners",value:function(){var e=this,t=this.topOverlay.mainTableScrollableElement,n=this.leftOverlay.mainTableScrollableElement,o=[];o.push([document.documentElement,"keydown",function(t){return e.onKeyDown(t)}]),o.push([document.documentElement,"keyup",function(){return e.onKeyUp()}]),o.push([document,"visibilitychange",function(){return e.onKeyUp()}]),o.push([t,"scroll",function(t){return e.onTableScroll(t)}]),t!==n&&o.push([n,"scroll",function(t){return e.onTableScroll(t)}]);var r=window.devicePixelRatio&&window.devicePixelRatio>1;for(r||!(0, u.isChrome)()?o.push([this.instance.wtTable.wtRootElement.parentNode,"wheel",function(t){return e.onCloneWheel(t)}]):(this.topOverlay.needFullRender&&o.push([this.topOverlay.clone.wtTable.holder,"wheel",function(t){return e.onCloneWheel(t)}]),this.bottomOverlay.needFullRender&&o.push([this.bottomOverlay.clone.wtTable.holder,"wheel",function(t){return e.onCloneWheel(t)}]),this.leftOverlay.needFullRender&&o.push([this.leftOverlay.clone.wtTable.holder,"wheel",function(t){return e.onCloneWheel(t)}]),this.topLeftCornerOverlay&&this.topLeftCornerOverlay.needFullRender&&o.push([this.topLeftCornerOverlay.clone.wtTable.holder,"wheel",function(t){return e.onCloneWheel(t)}]),this.bottomLeftCornerOverlay&&this.bottomLeftCornerOverlay.needFullRender&&o.push([this.bottomLeftCornerOverlay.clone.wtTable.holder,"wheel",function(t){return e.onCloneWheel(t)}])),this.topOverlay.trimmingContainer!==window&&this.leftOverlay.trimmingContainer!==window&&o.push([window,"wheel",function(t){var n=void 0,o=t.wheelDeltaY||t.deltaY,r=t.wheelDeltaX||t.deltaX;e.topOverlay.clone.wtTable.holder.contains(t.realTarget)?n="top":e.bottomOverlay.clone&&e.bottomOverlay.clone.wtTable.holder.contains(t.realTarget)?n="bottom":e.leftOverlay.clone.wtTable.holder.contains(t.realTarget)?n="left":e.topLeftCornerOverlay&&e.topLeftCornerOverlay.clone&&e.topLeftCornerOverlay.clone.wtTable.holder.contains(t.realTarget)?n="topLeft":e.bottomLeftCornerOverlay&&e.bottomLeftCornerOverlay.clone&&e.bottomLeftCornerOverlay.clone.wtTable.holder.contains(t.realTarget)&&(n="bottomLeft"),("top"===n&&0!==o||"left"===n&&0!==r||"bottom"===n&&0!==o||("topLeft"===n||"bottomLeft"===n)&&(0!==o||0!==r))&&t.preventDefault();}]);o.length;){var i=o.pop();this.eventManager.addEventListener(i[0],i[1],i[2]),this.registeredListeners.push(i);}}},{key:"deregisterListeners",value:function(){for(;this.registeredListeners.length;){var e=this.registeredListeners.pop();this.eventManager.removeEventListener(e[0],e[1],e[2]);}}},{key:"onTableScroll",value:function(e){var t=this.leftOverlay.mainTableScrollableElement,n=this.topOverlay.mainTableScrollableElement,o=e.target;this.keyPressed&&(n!==window&&o!==window&&!e.target.contains(n)||t!==window&&o!==window&&!e.target.contains(t))||this.syncScrollPositions(e);}},{key:"onCloneWheel",value:function(e){this.scrollableElement!==window&&e.preventDefault();var t=this.leftOverlay.mainTableScrollableElement,n=this.topOverlay.mainTableScrollableElement,o=e.target,r=n!==window&&o!==window&&!e.target.contains(n),i=t!==window&&o!==window&&!e.target.contains(t);this.keyPressed&&(r||i)||this.translateMouseWheelToScroll(e);}},{key:"onKeyDown",value:function(e){this.keyPressed=(0, l.isKey)(e.keyCode,"ARROW_UP|ARROW_RIGHT|ARROW_DOWN|ARROW_LEFT");}},{key:"onKeyUp",value:function(){this.keyPressed=!1;}},{key:"translateMouseWheelToScroll",value:function(e){var t=isNaN(e.deltaY)?-1*e.wheelDeltaY:e.deltaY,n=isNaN(e.deltaX)?-1*e.wheelDeltaX:e.deltaX;return 1===e.deltaMode&&(n+=n*this.browserLineHeight,t+=t*this.browserLineHeight),this.scrollVertically(t),this.scrollHorizontally(n),!1}},{key:"scrollVertically",value:function(e){if(0===e)return 0;this.scrollableElement.scrollTop+=e;}},{key:"scrollHorizontally",value:function(e){if(0===e)return 0;this.scrollableElement.scrollLeft+=e;}},{key:"syncScrollPositions",value:function(){if(!this.destroyed){var e=this.topOverlay.clone.wtTable.holder,t=this.leftOverlay.clone.wtTable.holder,n=[this.scrollableElement.scrollLeft,this.scrollableElement.scrollTop],o=n[0],r=n[1];if(this.horizontalScrolling=e.scrollLeft!==o,this.verticalScrolling=t.scrollTop!==r,this.horizontalScrolling){e.scrollLeft=o;var i=this.bottomOverlay.needFullRender?this.bottomOverlay.clone.wtTable.holder:null;i&&(i.scrollLeft=o);}this.verticalScrolling&&(t.scrollTop=r),this.refreshAll();}}},{key:"syncScrollWithMaster",value:function(){var e=this.topOverlay.mainTableScrollableElement,t=e.scrollLeft,n=e.scrollTop;this.topOverlay.needFullRender&&(this.topOverlay.clone.wtTable.holder.scrollLeft=t),this.bottomOverlay.needFullRender&&(this.bottomOverlay.clone.wtTable.holder.scrollLeft=t),this.leftOverlay.needFullRender&&(this.leftOverlay.clone.wtTable.holder.scrollTop=n);}},{key:"updateMainScrollableElements",value:function(){this.deregisterListeners(),this.leftOverlay.updateMainScrollableElement(),this.topOverlay.updateMainScrollableElement(),this.bottomOverlay.needFullRender&&this.bottomOverlay.updateMainScrollableElement(),this.scrollableElement=(0, a.getScrollableElement)(this.wot.wtTable.TABLE),this.registerListeners();}},{key:"destroy",value:function(){this.eventManager.destroy(),this.topOverlay.destroy(),this.bottomOverlay.clone&&this.bottomOverlay.destroy(),this.leftOverlay.destroy(),this.topLeftCornerOverlay&&this.topLeftCornerOverlay.destroy(),this.bottomLeftCornerOverlay&&this.bottomLeftCornerOverlay.clone&&this.bottomLeftCornerOverlay.destroy(),this.debug&&this.debug.destroy(),this.destroyed=!0;}},{key:"refresh",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.topOverlay.areElementSizesAdjusted&&this.leftOverlay.areElementSizesAdjusted){var t=this.wot.wtTable.wtRootElement.parentNode||this.wot.wtTable.wtRootElement,n=t.clientWidth,o=t.clientHeight;n===this.spreaderLastSize.width&&o===this.spreaderLastSize.height||(this.spreaderLastSize.width=n,this.spreaderLastSize.height=o,this.adjustElementsSize());}this.bottomOverlay.clone&&this.bottomOverlay.refresh(e),this.leftOverlay.refresh(e),this.topOverlay.refresh(e),this.topLeftCornerOverlay&&this.topLeftCornerOverlay.refresh(e),this.bottomLeftCornerOverlay&&this.bottomLeftCornerOverlay.clone&&this.bottomLeftCornerOverlay.refresh(e),this.debug&&this.debug.refresh(e);}},{key:"adjustElementsSize",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=this.wot.getSetting("totalColumns"),n=this.wot.getSetting("totalRows"),o=this.wot.wtViewport.getRowHeaderWidth(),r=this.wot.wtViewport.getColumnHeaderHeight(),i=this.wot.wtTable.hider.style;i.width=o+this.leftOverlay.sumCellSizes(0,t)+"px",i.height=r+this.topOverlay.sumCellSizes(0,n)+1+"px",this.topOverlay.adjustElementsSize(e),this.leftOverlay.adjustElementsSize(e),this.bottomOverlay.clone&&this.bottomOverlay.adjustElementsSize(e);}},{key:"applyToDOM",value:function(){this.topOverlay.areElementSizesAdjusted&&this.leftOverlay.areElementSizesAdjusted||this.adjustElementsSize(),this.topOverlay.applyToDOM(),this.bottomOverlay.clone&&this.bottomOverlay.applyToDOM(),this.leftOverlay.applyToDOM();}},{key:"getParentOverlay",value:function(e){if(!e)return null;var t=[this.topOverlay,this.leftOverlay,this.bottomOverlay,this.topLeftCornerOverlay,this.bottomLeftCornerOverlay],n=null;return (0, s.arrayEach)(t,function(t){t&&t.clone&&t.clone.wtTable.TABLE.contains(e)&&(n=t.clone);}),n}}]),e}();},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(0),a=n(5);t.default=function(){function e(t){o(this,e),this.wot=t,this.instance=t;}return r(e,[{key:"scrollViewport",value:function(e,t,n,o,r){var i=this.scrollViewportHorizontally(e.col,n,r),a=this.scrollViewportVertically(e.row,t,o);return i||a}},{key:"scrollViewportHorizontally",value:function(e,t,n){if(!this.wot.drawn)return !1;var o=this._getVariables(),r=o.fixedColumnsLeft,i=o.leftOverlay,a=o.totalColumns,s=!1;return 0>e||e>Math.max(a-1,0)||(r>e||e>=this.getFirstVisibleColumn()&&!n?(e>this.getLastVisibleColumn()||t)&&(s=i.scrollTo(e,!0)):s=i.scrollTo(e)),s}},{key:"scrollViewportVertically",value:function(e,t,n){if(!this.wot.drawn)return !1;var o=this._getVariables(),r=o.fixedRowsBottom,i=o.fixedRowsTop,a=o.topOverlay,s=o.totalRows,l=!1;return 0>e||e>Math.max(s-1,0)||(i>e||e>=this.getFirstVisibleRow()&&!t?(e>this.getLastVisibleRow()&&s-r>e||n)&&(l=a.scrollTo(e,!0)):l=a.scrollTo(e)),l}},{key:"getFirstVisibleRow",value:function(){var e=this._getVariables(),t=e.topOverlay,n=e.wtTable,o=e.wtViewport,r=e.totalRows,s=e.fixedRowsTop,l=n.getFirstVisibleRow();if(t.mainTableScrollableElement===window){var u=(0, i.offset)(n.wtRootElement),c=(0, i.innerHeight)(n.hider),h=(0, i.innerHeight)(window),f=(0, i.getScrollTop)(window);if(f>=u.top+c-h){var d=o.getColumnHeaderHeight();d+=t.sumCellSizes(0,s),(0, a.rangeEachReverse)(r,1,function(e){if(d+=t.sumCellSizes(e-1,e),f>=u.top+c-d)return l=e,!1});}}return l}},{key:"getLastVisibleRow",value:function(){var e=this._getVariables(),t=e.topOverlay,n=e.wtTable,o=e.wtViewport,r=e.totalRows,s=n.getLastVisibleRow();if(t.mainTableScrollableElement===window){var l=(0, i.offset)(n.wtRootElement),u=(0, i.innerHeight)(window),c=(0, i.getScrollTop)(window);if(l.top>c){var h=o.getColumnHeaderHeight();(0, a.rangeEach)(1,r,function(e){if(h+=t.sumCellSizes(e-1,e),l.top+h-c>=u)return s=e-2,!1});}}return s}},{key:"getFirstVisibleColumn",value:function(){var e=this._getVariables(),t=e.leftOverlay,n=e.wtTable,o=e.wtViewport,r=e.totalColumns,s=n.getFirstVisibleColumn();if(t.mainTableScrollableElement===window){var l=(0, i.offset)(n.wtRootElement),u=(0, i.innerWidth)(n.hider),c=(0, i.innerWidth)(window),h=(0, i.getScrollLeft)(window);if(h>=l.left+u-c){var f=o.getRowHeaderWidth();(0, a.rangeEachReverse)(r,1,function(e){if(f+=t.sumCellSizes(e-1,e),h>=l.left+u-f)return s=e,!1});}}return s}},{key:"getLastVisibleColumn",value:function(){var e=this._getVariables(),t=e.leftOverlay,n=e.wtTable,o=e.wtViewport,r=e.totalColumns,s=n.getLastVisibleColumn();if(t.mainTableScrollableElement===window){var l=(0, i.offset)(n.wtRootElement),u=(0, i.innerWidth)(window),c=(0, i.getScrollLeft)(window);if(l.left>c){var h=o.getRowHeaderWidth();(0, a.rangeEach)(1,r,function(e){if(h+=t.sumCellSizes(e-1,e),l.left+h-c>=u)return s=e-2,!1});}}return s}},{key:"_getVariables",value:function(){var e=this.wot;return {topOverlay:e.wtOverlays.topOverlay,leftOverlay:e.wtOverlays.leftOverlay,wtTable:e.wtTable,wtViewport:e.wtViewport,totalRows:e.getSetting("totalRows"),totalColumns:e.getSetting("totalColumns"),fixedRowsTop:e.getSetting("fixedRowsTop"),fixedRowsBottom:e.getSetting("fixedRowsBottom"),fixedColumnsLeft:e.getSetting("fixedColumnsLeft")}}}]),e}();},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(0),a=n(1);t.default=function(){function e(t,n){var r=this;o(this,e),this.wot=t,this.instance=t,this.defaults={table:void 0,debug:!1,externalRowCalculator:!1,stretchH:"none",currentRowClassName:null,currentColumnClassName:null,preventOverflow:function(){return !1},data:void 0,freezeOverlays:!1,fixedColumnsLeft:0,fixedRowsTop:0,fixedRowsBottom:0,minSpareRows:0,rowHeaders:function(){return []},columnHeaders:function(){return []},totalRows:void 0,totalColumns:void 0,cellRenderer:function(e,t,n){var o=r.getSetting("data",e,t);(0, i.fastInnerText)(n,void 0===o||null===o?"":o);},columnWidth:function(){},rowHeight:function(){},defaultRowHeight:23,defaultColumnWidth:50,selections:null,hideBorderOnMouseDownOver:!1,viewportRowCalculatorOverride:null,viewportColumnCalculatorOverride:null,onCellMouseDown:null,onCellContextMenu:null,onCellMouseOver:null,onCellMouseOut:null,onCellMouseUp:null,onCellDblClick:null,onCellCornerMouseDown:null,onCellCornerDblClick:null,beforeDraw:null,onDraw:null,onBeforeRemoveCellClassNames:null,onAfterDrawSelection:null,onBeforeDrawBorders:null,onScrollVertically:null,onScrollHorizontally:null,onBeforeTouchScroll:null,onAfterMomentumScroll:null,onBeforeStretchingColumnWidth:function(e){return e},onModifyRowHeaderWidth:null,onModifyGetCellCoords:null,scrollbarWidth:10,scrollbarHeight:10,renderAllRows:!1,groups:!1,rowHeaderWidth:null,columnHeaderHeight:null,headerClassName:null},this.settings={},(0, a.objectEach)(this.defaults,function(e,t){if(void 0!==n[t])r.settings[t]=n[t];else{if(void 0===e)throw Error('A required setting "'+t+'" was not provided');r.settings[t]=e;}});}return r(e,[{key:"update",value:function(e,t){var n=this;return void 0===t?(0, a.objectEach)(e,function(e,t){n.settings[t]=e;}):this.settings[e]=t,this.wot}},{key:"getSetting",value:function(e,t,n,o,r){return "function"==typeof this.settings[e]?this.settings[e](t,n,o,r):void 0!==t&&Array.isArray(this.settings[e])?this.settings[e][t]:this.settings[e]}},{key:"has",value:function(e){return !!this.settings[e]}}]),e}();},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);e.length>t;t++)n[t]=e[t];return n}return Array.from(e)}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},s=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),l=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),u=n(0),c=n(43),h=n(57),f=o(h),d=n(180),p=o(d),g=n(181),v=o(g),m=n(308),y=o(m),w=n(27),C=o(w);t.default=function(){function e(t,n){var o=this;i(this,e),this.wot=t,this.instance=this.wot,this.TABLE=n,this.TBODY=null,this.THEAD=null,this.COLGROUP=null,this.tableOffset=0,this.holderOffset=0,(0, u.removeTextNodes)(this.TABLE),this.spreader=this.createSpreader(this.TABLE),this.hider=this.createHider(this.spreader),this.holder=this.createHolder(this.hider),this.wtRootElement=this.holder.parentNode,this.alignOverlaysWithTrimmingContainer(),this.fixTableDomTree(),this.colgroupChildrenLength=this.COLGROUP.childNodes.length,this.theadChildrenLength=this.THEAD.firstChild?this.THEAD.firstChild.childNodes.length:0,this.tbodyChildrenLength=this.TBODY.childNodes.length,this.rowFilter=null,this.columnFilter=null,this.correctHeaderWidth=!1;var r=this.wot.wtSettings.settings.rowHeaderWidth;this.wot.wtSettings.settings.rowHeaderWidth=function(){return o._modifyRowHeaderWidth(r)};}return l(e,[{key:"fixTableDomTree",value:function(){this.TBODY=this.TABLE.querySelector("tbody"),this.TBODY||(this.TBODY=document.createElement("tbody"),this.TABLE.appendChild(this.TBODY)),this.THEAD=this.TABLE.querySelector("thead"),this.THEAD||(this.THEAD=document.createElement("thead"),this.TABLE.insertBefore(this.THEAD,this.TBODY)),this.COLGROUP=this.TABLE.querySelector("colgroup"),this.COLGROUP||(this.COLGROUP=document.createElement("colgroup"),this.TABLE.insertBefore(this.COLGROUP,this.THEAD)),this.wot.getSetting("columnHeaders").length&&!this.THEAD.childNodes.length&&this.THEAD.appendChild(document.createElement("TR"));}},{key:"createSpreader",value:function(e){var t=e.parentNode,n=void 0;return t&&1===t.nodeType&&(0, u.hasClass)(t,"wtHolder")||(n=document.createElement("div"),n.className="wtSpreader",t&&t.insertBefore(n,e),n.appendChild(e)),n.style.position="relative",n}},{key:"createHider",value:function(e){var t=e.parentNode,n=void 0;return t&&1===t.nodeType&&(0, u.hasClass)(t,"wtHolder")||(n=document.createElement("div"),n.className="wtHider",t&&t.insertBefore(n,e),n.appendChild(e)),n}},{key:"createHolder",value:function(e){var t=e.parentNode,n=void 0;return t&&1===t.nodeType&&(0, u.hasClass)(t,"wtHolder")||(n=document.createElement("div"),n.style.position="relative",n.className="wtHolder",t&&t.insertBefore(n,e),this.isWorkingOnClone()||(n.parentNode.className+="ht_master handsontable"),n.appendChild(e)),n}},{key:"alignOverlaysWithTrimmingContainer",value:function(){var e=(0, u.getTrimmingContainer)(this.wtRootElement);if(!this.isWorkingOnClone())if(this.holder.parentNode.style.position="relative",e===window){var t=this.wot.getSetting("preventOverflow");t||(this.holder.style.overflow="visible",this.wtRootElement.style.overflow="visible");}else this.holder.style.width=(0, u.getStyle)(e,"width"),this.holder.style.height=(0, u.getStyle)(e,"height"),this.holder.style.overflow="";}},{key:"isWorkingOnClone",value:function(){return !!this.wot.cloneSource}},{key:"draw",value:function(e){var t=this.wot,n=t.wtOverlays,o=t.wtViewport,r=this.instance.getSetting("totalRows"),i=this.wot.getSetting("rowHeaders").length,a=this.wot.getSetting("columnHeaders").length,s=!1,l=e;if(!this.isWorkingOnClone()&&(this.holderOffset=(0, u.offset)(this.holder),l=o.createRenderCalculators(l),i&&!this.wot.getSetting("fixedColumnsLeft"))){var c=n.leftOverlay.getScrollPosition(),h=this.correctHeaderWidth;this.correctHeaderWidth=c>0,h!==this.correctHeaderWidth&&(l=!1);}if(this.isWorkingOnClone()||(s=n.prepareOverlays()),l)this.isWorkingOnClone()||o.createVisibleCalculators(),n&&n.refresh(!0);else{this.tableOffset=this.isWorkingOnClone()?this.wot.cloneSource.wtTable.tableOffset:(0, u.offset)(this.TABLE);var f=void 0;f=C.default.isOverlayTypeOf(this.wot.cloneOverlay,C.default.CLONE_DEBUG)||C.default.isOverlayTypeOf(this.wot.cloneOverlay,C.default.CLONE_TOP)||C.default.isOverlayTypeOf(this.wot.cloneOverlay,C.default.CLONE_TOP_LEFT_CORNER)?0:C.default.isOverlayTypeOf(this.instance.cloneOverlay,C.default.CLONE_BOTTOM)||C.default.isOverlayTypeOf(this.instance.cloneOverlay,C.default.CLONE_BOTTOM_LEFT_CORNER)?Math.max(r-this.wot.getSetting("fixedRowsBottom"),0):o.rowsRenderCalculator.startRow;var d=void 0;d=C.default.isOverlayTypeOf(this.wot.cloneOverlay,C.default.CLONE_DEBUG)||C.default.isOverlayTypeOf(this.wot.cloneOverlay,C.default.CLONE_LEFT)||C.default.isOverlayTypeOf(this.wot.cloneOverlay,C.default.CLONE_TOP_LEFT_CORNER)||C.default.isOverlayTypeOf(this.wot.cloneOverlay,C.default.CLONE_BOTTOM_LEFT_CORNER)?0:o.columnsRenderCalculator.startColumn,this.rowFilter=new v.default(f,r,a),this.columnFilter=new p.default(d,this.wot.getSetting("totalColumns"),i),this.alignOverlaysWithTrimmingContainer(),this._doDraw();}return this.refreshSelections(l),this.isWorkingOnClone()||(n.topOverlay.resetFixedPosition(),n.bottomOverlay.clone&&n.bottomOverlay.resetFixedPosition(),n.leftOverlay.resetFixedPosition(),n.topLeftCornerOverlay&&n.topLeftCornerOverlay.resetFixedPosition(),n.bottomLeftCornerOverlay&&n.bottomLeftCornerOverlay.clone&&n.bottomLeftCornerOverlay.resetFixedPosition()),s&&n.syncScrollWithMaster(),this.wot.drawn=!0,this}},{key:"_doDraw",value:function(){new y.default(this).render();}},{key:"removeClassFromCells",value:function(e){for(var t=this.TABLE.querySelectorAll("."+e),n=0,o=t.length;o>n;n++)(0, u.removeClass)(t[n],e);}},{key:"refreshSelections",value:function(e){if(this.wot.selections){var t=Array.from(this.wot.selections),n=t.length;if(e){for(var o=[],r=0;n>r;r++){for(var i=t[r].settings,a=i.highlightHeaderClassName,s=i.highlightRowClassName,l=i.highlightColumnClassName,u=t[r].classNames,c=u.length,h=0;c>h;h++)o.includes(u[h])||o.push(u[h]);a&&!o.includes(a)&&o.push(a),s&&!o.includes(s)&&o.push(s),l&&!o.includes(l)&&o.push(l);}var f=this.wot.getSetting("onBeforeRemoveCellClassNames");if(Array.isArray(f))for(var d=0;f.length>d;d++)o.push(f[d]);for(var p=o.length,g=0;p>g;g++)this.removeClassFromCells(o[g]);}for(var v=0;n>v;v++)t[v].draw(this.wot,e);}}},{key:"getCell",value:function(e){var t=e.row,n=e.col,o=this.wot.getSetting("onModifyGetCellCoords",t,n);if(o&&Array.isArray(o)){var r=s(o,2);t=r[0],n=r[1];}if(this.isRowBeforeRenderedRows(t))return -1;if(this.isRowAfterRenderedRows(t))return -2;var i=this.TBODY.childNodes[this.rowFilter.sourceToRendered(t)];return i?i.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(n)]:void 0}},{key:"getColumnHeader",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=this.THEAD.childNodes[t];if(n)return n.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(e)]}},{key:"getRowHeader",value:function(e){if(0===this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0))return null;var t=this.TBODY.childNodes[this.rowFilter.sourceToRendered(e)];return t?t.childNodes[0]:void 0}},{key:"getCoords",value:function(e){var t=e;if("TD"!==t.nodeName&&"TH"!==t.nodeName&&(t=(0, u.closest)(t,["TD","TH"])),null===t)return null;var n=t.parentNode,o=n.parentNode,r=(0, u.index)(n),i=t.cellIndex;return (0, u.overlayContainsElement)(C.default.CLONE_TOP_LEFT_CORNER,t)||(0, u.overlayContainsElement)(C.default.CLONE_TOP,t)?"THEAD"===o.nodeName&&(r-=o.childNodes.length):r=o===this.THEAD?this.rowFilter.visibleColHeadedRowToSourceRow(r):this.rowFilter.renderedToSource(r),i=(0, u.overlayContainsElement)(C.default.CLONE_TOP_LEFT_CORNER,t)||(0, u.overlayContainsElement)(C.default.CLONE_LEFT,t)?this.columnFilter.offsettedTH(i):this.columnFilter.visibleRowHeadedColumnToSourceColumn(i),new f.default(r,i)}},{key:"getTrForRow",value:function(e){return this.TBODY.childNodes[this.rowFilter.sourceToRendered(e)]}},{key:"getFirstRenderedRow",value:function(){return this.wot.wtViewport.rowsRenderCalculator.startRow}},{key:"getFirstVisibleRow",value:function(){return this.wot.wtViewport.rowsVisibleCalculator.startRow}},{key:"getFirstRenderedColumn",value:function(){return this.wot.wtViewport.columnsRenderCalculator.startColumn}},{key:"getFirstVisibleColumn",value:function(){return this.wot.wtViewport.columnsVisibleCalculator.startColumn}},{key:"getLastRenderedRow",value:function(){return this.wot.wtViewport.rowsRenderCalculator.endRow}},{key:"getLastVisibleRow",value:function(){return this.wot.wtViewport.rowsVisibleCalculator.endRow}},{key:"getLastRenderedColumn",value:function(){return this.wot.wtViewport.columnsRenderCalculator.endColumn}},{key:"getLastVisibleColumn",value:function(){return this.wot.wtViewport.columnsVisibleCalculator.endColumn}},{key:"isRowBeforeRenderedRows",value:function(e){return this.rowFilter&&0>this.rowFilter.sourceToRendered(e)&&e>=0}},{key:"isRowAfterViewport",value:function(e){return this.rowFilter&&this.rowFilter.sourceToRendered(e)>this.getLastVisibleRow()}},{key:"isRowAfterRenderedRows",value:function(e){return this.rowFilter&&this.rowFilter.sourceToRendered(e)>this.getLastRenderedRow()}},{key:"isColumnBeforeViewport",value:function(e){return this.columnFilter&&0>this.columnFilter.sourceToRendered(e)&&e>=0}},{key:"isColumnAfterViewport",value:function(e){return this.columnFilter&&this.columnFilter.sourceToRendered(e)>this.getLastVisibleColumn()}},{key:"isLastRowFullyVisible",value:function(){return this.getLastVisibleRow()===this.getLastRenderedRow()}},{key:"isLastColumnFullyVisible",value:function(){return this.getLastVisibleColumn()===this.getLastRenderedColumn()}},{key:"getRenderedColumnsCount",value:function(){var e=this.wot.wtViewport.columnsRenderCalculator.count,t=this.wot.getSetting("totalColumns");if(this.wot.isOverlayName(C.default.CLONE_DEBUG))e=t;else if(this.wot.isOverlayName(C.default.CLONE_LEFT)||this.wot.isOverlayName(C.default.CLONE_TOP_LEFT_CORNER)||this.wot.isOverlayName(C.default.CLONE_BOTTOM_LEFT_CORNER))return Math.min(this.wot.getSetting("fixedColumnsLeft"),t);return e}},{key:"getRenderedRowsCount",value:function(){var e=this.wot.wtViewport.rowsRenderCalculator.count,t=this.wot.getSetting("totalRows");return this.wot.isOverlayName(C.default.CLONE_DEBUG)?e=t:this.wot.isOverlayName(C.default.CLONE_TOP)||this.wot.isOverlayName(C.default.CLONE_TOP_LEFT_CORNER)?e=Math.min(this.wot.getSetting("fixedRowsTop"),t):(this.wot.isOverlayName(C.default.CLONE_BOTTOM)||this.wot.isOverlayName(C.default.CLONE_BOTTOM_LEFT_CORNER))&&(e=Math.min(this.wot.getSetting("fixedRowsBottom"),t)),e}},{key:"getVisibleRowsCount",value:function(){return this.wot.wtViewport.rowsVisibleCalculator.count}},{key:"allRowsInViewport",value:function(){return this.wot.getSetting("totalRows")===this.getVisibleRowsCount()}},{key:"getRowHeight",value:function(e){var t=this.wot.wtSettings.settings.rowHeight(e),n=this.wot.wtViewport.oversizedRows[e];return void 0!==n&&(t=void 0===t?n:Math.max(t,n)),t}},{key:"getColumnHeaderHeight",value:function(e){var t=this.wot.wtSettings.settings.defaultRowHeight,n=this.wot.wtViewport.oversizedColumnHeaders[e];return void 0!==n&&(t=t?Math.max(t,n):n),t}},{key:"getVisibleColumnsCount",value:function(){return this.wot.wtViewport.columnsVisibleCalculator.count}},{key:"allColumnsInViewport",value:function(){return this.wot.getSetting("totalColumns")===this.getVisibleColumnsCount()}},{key:"getColumnWidth",value:function(e){var t=this.wot.wtSettings.settings.columnWidth;return "function"==typeof t?t=t(e):"object"===(void 0===t?"undefined":a(t))&&(t=t[e]),t||this.wot.wtSettings.settings.defaultColumnWidth}},{key:"getStretchedColumnWidth",value:function(e){var t=this.getColumnWidth(e),n=null===t||void 0===t?this.instance.wtSettings.settings.defaultColumnWidth:t,o=this.wot.wtViewport.columnsRenderCalculator;if(o){var r=o.getStretchedColumnWidth(e,n);r&&(n=r);}return n}},{key:"_modifyRowHeaderWidth",value:function(e){var t=(0, c.isFunction)(e)?e():null;return Array.isArray(t)?(t=[].concat(r(t)),t[t.length-1]=this._correctRowHeaderWidth(t[t.length-1])):t=this._correctRowHeaderWidth(t),t}},{key:"_correctRowHeaderWidth",value:function(e){var t=e;return "number"!=typeof e&&(t=this.wot.getSetting("defaultColumnWidth")),this.correctHeaderWidth&&(t+=1),t}}]),e}();},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){var n=document.createElement("TH");return t.insertBefore(n,e),t.removeChild(e),n}function i(e,t){var n=document.createElement("TD");return t.insertBefore(n,e),t.removeChild(e),n}t.__esModule=!0;var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=function(e,t){return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}(['Performance tip: Handsontable rendered more than 1000 visible rows. Consider limiting the number \n          of rendered rows by specifying the table height and/or turning off the "renderAllRows" option.'],['Performance tip: Handsontable rendered more than 1000 visible rows. Consider limiting the number \n          of rendered rows by specifying the table height and/or turning off the "renderAllRows" option.']),l=n(0),u=n(58),c=n(42),h=n(27),f=function(e){return e&&e.__esModule?e:{default:e}}(h),d=!1;t.default=function(){function e(t){o(this,e),this.wtTable=t,this.wot=t.instance,this.instance=t.instance,this.rowFilter=t.rowFilter,this.columnFilter=t.columnFilter,this.TABLE=t.TABLE,this.THEAD=t.THEAD,this.TBODY=t.TBODY,this.COLGROUP=t.COLGROUP,this.rowHeaders=[],this.rowHeaderCount=0,this.columnHeaders=[],this.columnHeaderCount=0,this.fixedRowsTop=0,this.fixedRowsBottom=0;}return a(e,[{key:"render",value:function(){if(!this.wtTable.isWorkingOnClone()){var e={};if(this.wot.getSetting("beforeDraw",!0,e),!0===e.skipRender)return}this.rowHeaders=this.wot.getSetting("rowHeaders"),this.rowHeaderCount=this.rowHeaders.length,this.fixedRowsTop=this.wot.getSetting("fixedRowsTop"),this.fixedRowsBottom=this.wot.getSetting("fixedRowsBottom"),this.columnHeaders=this.wot.getSetting("columnHeaders"),this.columnHeaderCount=this.columnHeaders.length;var t=this.wtTable.getRenderedColumnsCount(),n=this.wtTable.getRenderedRowsCount(),o=this.wot.getSetting("totalColumns"),r=this.wot.getSetting("totalRows"),i=void 0,a=!1;if((f.default.isOverlayTypeOf(this.wot.cloneOverlay,f.default.CLONE_BOTTOM)||f.default.isOverlayTypeOf(this.wot.cloneOverlay,f.default.CLONE_BOTTOM_LEFT_CORNER))&&(this.columnHeaders=[],this.columnHeaderCount=0),0>o||(this.adjustAvailableNodes(),a=!0,this.renderColumnHeaders(),this.renderRows(r,n,t),this.wtTable.isWorkingOnClone()||(i=this.wot.wtViewport.getWorkspaceWidth(),this.wot.wtViewport.containerWidth=null),this.adjustColumnWidths(t),this.markOversizedColumnHeaders(),this.adjustColumnHeaderHeights()),a||this.adjustAvailableNodes(),this.removeRedundantRows(n),this.wtTable.isWorkingOnClone()&&!this.wot.isOverlayName(f.default.CLONE_BOTTOM)||this.markOversizedRows(),this.wtTable.isWorkingOnClone())this.wot.isOverlayName(f.default.CLONE_BOTTOM)&&this.wot.cloneSource.wtOverlays.adjustElementsSize();else{this.wot.wtViewport.createVisibleCalculators(),this.wot.wtOverlays.refresh(!1),this.wot.wtOverlays.applyToDOM();var s=(0, l.outerWidth)(this.wtTable.hider),u=(0, l.outerWidth)(this.wtTable.TABLE);if(0!==s&&u!==s&&this.adjustColumnWidths(t),i!==this.wot.wtViewport.getWorkspaceWidth()){this.wot.wtViewport.containerWidth=null;var c=this.wtTable.getFirstRenderedColumn(),h=this.wtTable.getLastRenderedColumn(),d=this.wot.getSetting("defaultColumnWidth"),p=this.wot.getSetting("rowHeaderWidth");if(null!==(p=this.instance.getSetting("onModifyRowHeaderWidth",p))&&void 0!==p)for(var g=0;this.rowHeaderCount>g;g++){var v=Array.isArray(p)?p[g]:p;v=null===v||void 0===v?d:v,this.COLGROUP.childNodes[g].style.width=v+"px";}for(var m=c;h>m;m++){var y=this.wtTable.getStretchedColumnWidth(m);this.COLGROUP.childNodes[this.columnFilter.sourceToRendered(m)+this.rowHeaderCount].style.width=y+"px";}}this.wot.getSetting("onDraw",!0);}}},{key:"removeRedundantRows",value:function(e){for(;this.wtTable.tbodyChildrenLength>e;)this.TBODY.removeChild(this.TBODY.lastChild),this.wtTable.tbodyChildrenLength-=1;}},{key:"renderRows",value:function(e,t,n){for(var o=void 0,r=0,i=this.rowFilter.renderedToSource(r),a=this.wtTable.isWorkingOnClone();e>i&&i>=0&&(!d&&r>1e3&&(d=!0,(0, u.warn)((0, c.toSingleLine)(s))),void 0===t||r!==t);){if(o=this.getOrCreateTrForRow(r,o),this.renderRowHeaders(i,o),this.adjustColumns(o,n+this.rowHeaderCount),this.renderCells(i,o,n),a&&!this.wot.isOverlayName(f.default.CLONE_BOTTOM)||this.resetOversizedRow(i),o.firstChild){var l=this.wot.wtTable.getRowHeight(i);l?(l-=1,o.firstChild.style.height=l+"px"):o.firstChild.style.height="";}r+=1,i=this.rowFilter.renderedToSource(r);}}},{key:"resetOversizedRow",value:function(e){this.wot.getSetting("externalRowCalculator")||this.wot.wtViewport.oversizedRows&&this.wot.wtViewport.oversizedRows[e]&&(this.wot.wtViewport.oversizedRows[e]=void 0);}},{key:"markOversizedRows",value:function(){if(!this.wot.getSetting("externalRowCalculator")){var e=this.instance.wtTable.TBODY.childNodes.length,t=e*this.instance.wtSettings.settings.defaultRowHeight,n=(0, l.innerHeight)(this.instance.wtTable.TBODY)-1,o=void 0,r=void 0,i=void 0,a=void 0,s=void 0;if(t!==n||this.instance.getSetting("fixedRowsBottom"))for(;e;)e-=1,i=this.instance.wtTable.rowFilter.renderedToSource(e),o=this.instance.wtTable.getRowHeight(i),a=this.instance.wtTable.getTrForRow(i),s=a.querySelector("th"),r=s?(0, l.innerHeight)(s):(0, l.innerHeight)(a)-1,(!o&&r>this.instance.wtSettings.settings.defaultRowHeight||r>o)&&(r+=1,this.instance.wtViewport.oversizedRows[i]=r);}}},{key:"markOversizedColumnHeaders",value:function(){var e=this.wot.getOverlayName();if(this.columnHeaderCount&&!this.wot.wtViewport.hasOversizedColumnHeadersMarked[e]&&!this.wtTable.isWorkingOnClone()){for(var t=this.wtTable.getRenderedColumnsCount(),n=0;this.columnHeaderCount>n;n++)for(var o=-1*this.rowHeaderCount;t>o;o++)this.markIfOversizedColumnHeader(o);this.wot.wtViewport.hasOversizedColumnHeadersMarked[e]=!0;}}},{key:"adjustColumnHeaderHeights",value:function(){for(var e=this.wot.getSetting("columnHeaders"),t=this.wot.wtTable.THEAD.childNodes,n=this.wot.wtViewport.oversizedColumnHeaders,o=0,r=e.length;r>o;o++)if(n[o]){if(!t[o]||0===t[o].childNodes.length)return;t[o].childNodes[0].style.height=n[o]+"px";}}},{key:"markIfOversizedColumnHeader",value:function(e){for(var t=this.wot.wtTable.columnFilter.renderedToSource(e),n=this.columnHeaderCount,o=this.wot.wtSettings.settings.defaultRowHeight,r=void 0,i=void 0,a=void 0,s=this.wot.getSetting("columnHeaderHeight")||[];n;)n-=1,r=this.wot.wtTable.getColumnHeaderHeight(n),(i=this.wot.wtTable.getColumnHeader(t,n))&&(a=(0, l.innerHeight)(i),(!r&&a>o||a>r)&&(this.wot.wtViewport.oversizedColumnHeaders[n]=a),Array.isArray(s)?null!==s[n]&&void 0!==s[n]&&(this.wot.wtViewport.oversizedColumnHeaders[n]=s[n]):isNaN(s)||(this.wot.wtViewport.oversizedColumnHeaders[n]=s),(s[n]||s)>this.wot.wtViewport.oversizedColumnHeaders[n]&&(this.wot.wtViewport.oversizedColumnHeaders[n]=s[n]||s));}},{key:"renderCells",value:function(e,t,n){for(var o=void 0,r=void 0,a=0;n>a;a++)r=this.columnFilter.renderedToSource(a),o=0===a?t.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(r)]:o.nextSibling,"TH"===o.nodeName&&(o=i(o,t)),(0, l.hasClass)(o,"hide")||(o.className=""),o.removeAttribute("style"),this.wot.wtSettings.settings.cellRenderer(e,r,o);return o}},{key:"adjustColumnWidths",value:function(e){var t=0,n=this.wot.cloneSource?this.wot.cloneSource:this.wot,o=n.wtTable.holder,r=this.wot.getSetting("defaultColumnWidth"),i=this.wot.getSetting("rowHeaderWidth");if(o.scrollHeight>o.offsetHeight&&(t=(0, l.getScrollbarWidth)()),this.wot.wtViewport.columnsRenderCalculator.refreshStretching(this.wot.wtViewport.getViewportWidth()-t),null!==(i=this.instance.getSetting("onModifyRowHeaderWidth",i))&&void 0!==i)for(var a=0;this.rowHeaderCount>a;a++){var s=Array.isArray(i)?i[a]:i;s=null===s||void 0===s?r:s,this.COLGROUP.childNodes[a].style.width=s+"px";}for(var u=0;e>u;u++){this.COLGROUP.childNodes[u+this.rowHeaderCount].style.width=this.wtTable.getStretchedColumnWidth(this.columnFilter.renderedToSource(u))+"px";}}},{key:"appendToTbody",value:function(e){this.TBODY.appendChild(e),this.wtTable.tbodyChildrenLength+=1;}},{key:"getOrCreateTrForRow",value:function(e,t){var n=void 0;return this.wtTable.tbodyChildrenLength>e?n=0===e?this.TBODY.firstChild:t.nextSibling:(n=this.createRow(),this.appendToTbody(n)),n.className&&n.removeAttribute("class"),n}},{key:"createRow",value:function(){for(var e=document.createElement("TR"),t=0;this.rowHeaderCount>t;t++)e.appendChild(document.createElement("TH"));return e}},{key:"renderRowHeader",value:function(e,t,n){n.className="",n.removeAttribute("style"),this.rowHeaders[t](e,n,t);}},{key:"renderRowHeaders",value:function(e,t){for(var n=t.firstChild,o=0;this.rowHeaderCount>o;o++)n?"TD"===n.nodeName&&(n=r(n,t)):(n=document.createElement("TH"),t.appendChild(n)),this.renderRowHeader(e,o,n),n=n.nextSibling;}},{key:"adjustAvailableNodes",value:function(){this.adjustColGroups(),this.adjustThead();}},{key:"renderColumnHeaders",value:function(){if(this.columnHeaderCount)for(var e=this.wtTable.getRenderedColumnsCount(),t=0;this.columnHeaderCount>t;t++)for(var n=this.getTrForColumnHeaders(t),o=-1*this.rowHeaderCount;e>o;o++){var r=this.columnFilter.renderedToSource(o);this.renderColumnHeader(t,r,n.childNodes[o+this.rowHeaderCount]);}}},{key:"adjustColGroups",value:function(){for(var e=this.wtTable.getRenderedColumnsCount();e+this.rowHeaderCount>this.wtTable.colgroupChildrenLength;)this.COLGROUP.appendChild(document.createElement("COL")),this.wtTable.colgroupChildrenLength+=1;for(;this.wtTable.colgroupChildrenLength>e+this.rowHeaderCount;)this.COLGROUP.removeChild(this.COLGROUP.lastChild),this.wtTable.colgroupChildrenLength-=1;this.rowHeaderCount&&(0, l.addClass)(this.COLGROUP.childNodes[0],"rowHeader");}},{key:"adjustThead",value:function(){var e=this.wtTable.getRenderedColumnsCount(),t=this.THEAD.firstChild;if(this.columnHeaders.length){for(var n=0,o=this.columnHeaders.length;o>n;n++){for(t=this.THEAD.childNodes[n],t||(t=document.createElement("TR"),this.THEAD.appendChild(t)),this.theadChildrenLength=t.childNodes.length;e+this.rowHeaderCount>this.theadChildrenLength;)t.appendChild(document.createElement("TH")),this.theadChildrenLength+=1;for(;this.theadChildrenLength>e+this.rowHeaderCount;)t.removeChild(t.lastChild),this.theadChildrenLength-=1;}var r=this.THEAD.childNodes.length;if(r>this.columnHeaders.length)for(var i=this.columnHeaders.length;r>i;i++)this.THEAD.removeChild(this.THEAD.lastChild);}else t&&(0, l.empty)(t);}},{key:"getTrForColumnHeaders",value:function(e){return this.THEAD.childNodes[e]}},{key:"renderColumnHeader",value:function(e,t,n){return n.className="",n.removeAttribute("style"),this.columnHeaders[e](t,n,e)}},{key:"adjustColumns",value:function(e,t){for(var n=e.childNodes.length;t>n;){e.appendChild(document.createElement("TD")),n+=1;}for(;n>t;)e.removeChild(e.lastChild),n-=1;}},{key:"removeRedundantColumns",value:function(e){for(;this.wtTable.tbodyChildrenLength>e;)this.TBODY.removeChild(this.TBODY.lastChild),this.wtTable.tbodyChildrenLength-=1;}}]),e}();},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(0),s=n(1),l=n(6),u=o(l),c=n(177),h=o(c),f=n(178),d=o(f);t.default=function(){function e(t){var n=this;r(this,e),this.wot=t,this.instance=this.wot,this.oversizedRows=[],this.oversizedColumnHeaders=[],this.hasOversizedColumnHeadersMarked={},this.clientHeight=0,this.containerWidth=NaN,this.rowHeaderWidth=NaN,this.rowsVisibleCalculator=null,this.columnsVisibleCalculator=null,this.eventManager=new u.default(this.wot),this.eventManager.addEventListener(window,"resize",function(){n.clientHeight=n.getWorkspaceHeight();});}return i(e,[{key:"getWorkspaceHeight",value:function(){var e=this.instance.wtOverlays.topOverlay.trimmingContainer,t=void 0,n=0;return e===window?n=document.documentElement.clientHeight:(t=(0, a.outerHeight)(e),n=t>0&&e.clientHeight>0?e.clientHeight:1/0),n}},{key:"getWorkspaceWidth",value:function(){var e=void 0,t=this.wot.getSetting("totalColumns"),n=this.instance.wtOverlays.leftOverlay.trimmingContainer,o=void 0,r=this.wot.getSetting("stretchH"),i=document.documentElement.offsetWidth;return this.wot.getSetting("preventOverflow")?(0, a.outerWidth)(this.instance.wtTable.wtRootElement):(e=this.wot.getSetting("freezeOverlays")?Math.min(i-this.getWorkspaceOffset().left,i):Math.min(this.getContainerFillWidth(),i-this.getWorkspaceOffset().left,i),n===window&&t>0&&this.sumColumnWidths(0,t-1)>e?document.documentElement.clientWidth:n===window||"scroll"!==(o=(0, a.getStyle)(this.instance.wtOverlays.leftOverlay.trimmingContainer,"overflow"))&&"hidden"!==o&&"auto"!==o?"none"!==r&&r?e:Math.max(e,(0, a.outerWidth)(this.instance.wtTable.TABLE)):Math.max(e,n.clientWidth))}},{key:"hasVerticalScroll",value:function(){return this.getWorkspaceActualHeight()>this.getWorkspaceHeight()}},{key:"hasHorizontalScroll",value:function(){return this.getWorkspaceActualWidth()>this.getWorkspaceWidth()}},{key:"sumColumnWidths",value:function(e,t){for(var n=this.wot.wtTable,o=0,r=e;t>r;)o+=n.getColumnWidth(r),r+=1;return o}},{key:"getContainerFillWidth",value:function(){if(this.containerWidth)return this.containerWidth;var e=this.instance.wtTable.holder,t=document.createElement("div");t.style.width="100%",t.style.height="1px",e.appendChild(t);var n=t.offsetWidth;return this.containerWidth=n,e.removeChild(t),n}},{key:"getWorkspaceOffset",value:function(){return (0, a.offset)(this.wot.wtTable.TABLE)}},{key:"getWorkspaceActualHeight",value:function(){return (0, a.outerHeight)(this.wot.wtTable.TABLE)}},{key:"getWorkspaceActualWidth",value:function(){return (0, a.outerWidth)(this.wot.wtTable.TABLE)||(0, a.outerWidth)(this.wot.wtTable.TBODY)||(0, a.outerWidth)(this.wot.wtTable.THEAD)}},{key:"getColumnHeaderHeight",value:function(){return isNaN(this.columnHeaderHeight)&&(this.columnHeaderHeight=(0, a.outerHeight)(this.wot.wtTable.THEAD)),this.columnHeaderHeight}},{key:"getViewportHeight",value:function(){var e=this.getWorkspaceHeight();if(e===1/0)return e;var t=this.getColumnHeaderHeight();return t>0&&(e-=t),e}},{key:"getRowHeaderWidth",value:function(){var e=this.instance.getSetting("rowHeaderWidth"),t=this.instance.getSetting("rowHeaders");if(e){this.rowHeaderWidth=0;for(var n=0,o=t.length;o>n;n++)this.rowHeaderWidth+=e[n]||e;}if(this.wot.cloneSource)return this.wot.cloneSource.wtViewport.getRowHeaderWidth();if(isNaN(this.rowHeaderWidth))if(t.length){var r=this.instance.wtTable.TABLE.querySelector("TH");this.rowHeaderWidth=0;for(var i=0,s=t.length;s>i;i++)r?(this.rowHeaderWidth+=(0, a.outerWidth)(r),r=r.nextSibling):this.rowHeaderWidth+=50;}else this.rowHeaderWidth=0;return this.rowHeaderWidth=this.instance.getSetting("onModifyRowHeaderWidth",this.rowHeaderWidth)||this.rowHeaderWidth}},{key:"getViewportWidth",value:function(){var e=this.getWorkspaceWidth();if(e===1/0)return e;var t=this.getRowHeaderWidth();return t>0?e-t:e}},{key:"createRowsCalculator",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=void 0,o=void 0,r=void 0;this.rowHeaderWidth=NaN,n=this.wot.wtSettings.settings.renderAllRows&&!t?1/0:this.getViewportHeight();var i=this.wot.wtOverlays.topOverlay.getScrollPosition()-this.wot.wtOverlays.topOverlay.getTableParentOffset();0>i&&(i=0);var s=this.wot.getSetting("fixedRowsTop"),l=this.wot.getSetting("fixedRowsBottom"),u=this.wot.getSetting("totalRows");return s&&(r=this.wot.wtOverlays.topOverlay.sumCellSizes(0,s),i+=r,n-=r),l&&this.wot.wtOverlays.bottomOverlay.clone&&(r=this.wot.wtOverlays.bottomOverlay.sumCellSizes(u-l,u),n-=r),o=this.wot.wtTable.holder.clientHeight===this.wot.wtTable.holder.offsetHeight?0:(0, a.getScrollbarWidth)(),new d.default(n,i,this.wot.getSetting("totalRows"),function(t){return e.wot.wtTable.getRowHeight(t)},t?null:this.wot.wtSettings.settings.viewportRowCalculatorOverride,t,o)}},{key:"createColumnsCalculator",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=this.getViewportWidth(),o=this.wot.wtOverlays.leftOverlay.getScrollPosition()-this.wot.wtOverlays.leftOverlay.getTableParentOffset();this.columnHeaderHeight=NaN,0>o&&(o=0);var r=this.wot.getSetting("fixedColumnsLeft");if(r){var i=this.wot.wtOverlays.leftOverlay.sumCellSizes(0,r);o+=i,n-=i;}return this.wot.wtTable.holder.clientWidth!==this.wot.wtTable.holder.offsetWidth&&(n-=(0, a.getScrollbarWidth)()),new h.default(n,o,this.wot.getSetting("totalColumns"),function(t){return e.wot.wtTable.getColumnWidth(t)},t?null:this.wot.wtSettings.settings.viewportColumnCalculatorOverride,t,this.wot.getSetting("stretchH"),function(t,n){return e.wot.getSetting("onBeforeStretchingColumnWidth",t,n)})}},{key:"createRenderCalculators",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=e;if(t){var n=this.createRowsCalculator(!0),o=this.createColumnsCalculator(!0);this.areAllProposedVisibleRowsAlreadyRendered(n)&&this.areAllProposedVisibleColumnsAlreadyRendered(o)||(t=!1);}return t||(this.rowsRenderCalculator=this.createRowsCalculator(),this.columnsRenderCalculator=this.createColumnsCalculator()),this.rowsVisibleCalculator=null,this.columnsVisibleCalculator=null,t}},{key:"createVisibleCalculators",value:function(){this.rowsVisibleCalculator=this.createRowsCalculator(!0),this.columnsVisibleCalculator=this.createColumnsCalculator(!0);}},{key:"areAllProposedVisibleRowsAlreadyRendered",value:function(e){return !!this.rowsVisibleCalculator&&(!(this.rowsRenderCalculator.startRow>e.startRow||e.startRow===this.rowsRenderCalculator.startRow&&e.startRow>0)&&!(e.endRow>this.rowsRenderCalculator.endRow||e.endRow===this.rowsRenderCalculator.endRow&&e.endRow<this.wot.getSetting("totalRows")-1))}},{key:"areAllProposedVisibleColumnsAlreadyRendered",value:function(e){return !!this.columnsVisibleCalculator&&(!(this.columnsRenderCalculator.startColumn>e.startColumn||e.startColumn===this.columnsRenderCalculator.startColumn&&e.startColumn>0)&&!(e.endColumn>this.columnsRenderCalculator.endColumn||e.endColumn===this.columnsRenderCalculator.endColumn&&e.endColumn<this.wot.getSetting("totalColumns")-1))}},{key:"resetHasOversizedColumnHeadersMarked",value:function(){(0, s.objectEach)(this.hasOversizedColumnHeadersMarked,function(e,t,n){n[t]=void 0;});}}]),e}();},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var i=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),l=n(12),u=n(1),c=n(35),h=n(6),f=o(h),d=n(57),p=o(d);t.default=function(){function e(t,n){r(this,e),n&&(this.eventManager=new f.default(t),this.instance=t,this.wot=t,this.settings=n,this.mouseDown=!1,this.main=null,this.top=null,this.left=null,this.bottom=null,this.right=null,this.topStyle=null,this.leftStyle=null,this.bottomStyle=null,this.rightStyle=null,this.cornerDefaultStyle={width:"6px",height:"6px",borderWidth:"1px",borderStyle:"solid",borderColor:"#FFF"},this.corner=null,this.cornerStyle=null,this.createBorders(n),this.registerListeners());}return a(e,[{key:"registerListeners",value:function(){var e=this;this.eventManager.addEventListener(document.body,"mousedown",function(){return e.onMouseDown()}),this.eventManager.addEventListener(document.body,"mouseup",function(){return e.onMouseUp()});for(var t=0,n=this.main.childNodes.length;n>t;t++)!function(t,n){e.eventManager.addEventListener(e.main.childNodes[t],"mouseenter",function(n){return e.onMouseEnter(n,e.main.childNodes[t])});}(t);}},{key:"onMouseDown",value:function(){this.mouseDown=!0;}},{key:"onMouseUp",value:function(){this.mouseDown=!1;}},{key:"onMouseEnter",value:function(e,t){function n(e){return e.clientY<Math.floor(i.top)||(e.clientY>Math.ceil(i.top+i.height)||(e.clientX<Math.floor(i.left)||(e.clientX>Math.ceil(i.left+i.width)||void 0)))}function o(e){n(e)&&(r.eventManager.removeEventListener(document.body,"mousemove",o),t.style.display="block");}if(this.mouseDown&&this.wot.getSetting("hideBorderOnMouseDownOver")){e.preventDefault(),(0, l.stopImmediatePropagation)(e);var r=this,i=t.getBoundingClientRect();t.style.display="none",this.eventManager.addEventListener(document.body,"mousemove",o);}}},{key:"createBorders",value:function(e){this.main=document.createElement("div");var t=["top","left","bottom","right","corner"],n=this.main.style;n.position="absolute",n.top=0,n.left=0;for(var o=0;5>o;o++){var r=t[o],i=document.createElement("div");i.className="wtBorder "+(this.settings.className||""),this.settings[r]&&this.settings[r].hide&&(i.className+=" hidden"),n=i.style,n.backgroundColor=this.settings[r]&&this.settings[r].color?this.settings[r].color:e.border.color,n.height=this.settings[r]&&this.settings[r].width?this.settings[r].width+"px":e.border.width+"px",n.width=this.settings[r]&&this.settings[r].width?this.settings[r].width+"px":e.border.width+"px",this.main.appendChild(i);}this.top=this.main.childNodes[0],this.left=this.main.childNodes[1],this.bottom=this.main.childNodes[2],this.right=this.main.childNodes[3],this.topStyle=this.top.style,this.leftStyle=this.left.style,this.bottomStyle=this.bottom.style,this.rightStyle=this.right.style,this.corner=this.main.childNodes[4],this.corner.className+=" corner",this.cornerStyle=this.corner.style,this.cornerStyle.width=this.cornerDefaultStyle.width,this.cornerStyle.height=this.cornerDefaultStyle.height,this.cornerStyle.border=[this.cornerDefaultStyle.borderWidth,this.cornerDefaultStyle.borderStyle,this.cornerDefaultStyle.borderColor].join(" "),(0, c.isMobileBrowser)()&&this.createMultipleSelectorHandles(),this.disappear();var a=this.wot.wtTable.bordersHolder;a||(a=document.createElement("div"),a.className="htBorders",this.wot.wtTable.bordersHolder=a,this.wot.wtTable.spreader.appendChild(a)),a.appendChild(this.main);}},{key:"createMultipleSelectorHandles",value:function(){var e=this;this.selectionHandles={topLeft:document.createElement("DIV"),topLeftHitArea:document.createElement("DIV"),bottomRight:document.createElement("DIV"),bottomRightHitArea:document.createElement("DIV")};this.selectionHandles.topLeft.className="topLeftSelectionHandle",this.selectionHandles.topLeftHitArea.className="topLeftSelectionHandle-HitArea",this.selectionHandles.bottomRight.className="bottomRightSelectionHandle",this.selectionHandles.bottomRightHitArea.className="bottomRightSelectionHandle-HitArea",this.selectionHandles.styles={topLeft:this.selectionHandles.topLeft.style,topLeftHitArea:this.selectionHandles.topLeftHitArea.style,bottomRight:this.selectionHandles.bottomRight.style,bottomRightHitArea:this.selectionHandles.bottomRightHitArea.style};var t={position:"absolute",height:"40px",width:"40px","border-radius":parseInt(40/1.5,10)+"px"};(0, u.objectEach)(t,function(t,n){e.selectionHandles.styles.bottomRightHitArea[n]=t,e.selectionHandles.styles.topLeftHitArea[n]=t;});var n={position:"absolute",height:"10px",width:"10px","border-radius":parseInt(10/1.5,10)+"px",background:"#F5F5FF",border:"1px solid #4285c8"};(0, u.objectEach)(n,function(t,n){e.selectionHandles.styles.bottomRight[n]=t,e.selectionHandles.styles.topLeft[n]=t;}),this.main.appendChild(this.selectionHandles.topLeft),this.main.appendChild(this.selectionHandles.bottomRight),this.main.appendChild(this.selectionHandles.topLeftHitArea),this.main.appendChild(this.selectionHandles.bottomRightHitArea);}},{key:"isPartRange",value:function(e,t){var n=this.wot.selections.createOrGetArea();return !(!n.cellRange||e===n.cellRange.to.row&&t===n.cellRange.to.col)}},{key:"updateMultipleSelectionHandlesPosition",value:function(e,t,n,o,r,i){var a=parseInt(this.selectionHandles.styles.topLeft.width,10),s=parseInt(this.selectionHandles.styles.topLeftHitArea.width,10);this.selectionHandles.styles.topLeft.top=parseInt(n-a,10)+"px",this.selectionHandles.styles.topLeft.left=parseInt(o-a,10)+"px",this.selectionHandles.styles.topLeftHitArea.top=parseInt(n-s/4*3,10)+"px",this.selectionHandles.styles.topLeftHitArea.left=parseInt(o-s/4*3,10)+"px",this.selectionHandles.styles.bottomRight.top=parseInt(n+i,10)+"px",this.selectionHandles.styles.bottomRight.left=parseInt(o+r,10)+"px",this.selectionHandles.styles.bottomRightHitArea.top=parseInt(n+i-s/4,10)+"px",this.selectionHandles.styles.bottomRightHitArea.left=parseInt(o+r-s/4,10)+"px",this.settings.border.cornerVisible&&this.settings.border.cornerVisible()?(this.selectionHandles.styles.topLeft.display="block",this.selectionHandles.styles.topLeftHitArea.display="block",this.isPartRange(e,t)?(this.selectionHandles.styles.bottomRight.display="none",this.selectionHandles.styles.bottomRightHitArea.display="none"):(this.selectionHandles.styles.bottomRight.display="block",this.selectionHandles.styles.bottomRightHitArea.display="block")):(this.selectionHandles.styles.topLeft.display="none",this.selectionHandles.styles.bottomRight.display="none",this.selectionHandles.styles.topLeftHitArea.display="none",this.selectionHandles.styles.bottomRightHitArea.display="none"),e===this.wot.wtSettings.getSetting("fixedRowsTop")||t===this.wot.wtSettings.getSetting("fixedColumnsLeft")?(this.selectionHandles.styles.topLeft.zIndex="9999",this.selectionHandles.styles.topLeftHitArea.zIndex="9999"):(this.selectionHandles.styles.topLeft.zIndex="",this.selectionHandles.styles.topLeftHitArea.zIndex="");}},{key:"appear",value:function(e){if(!this.disabled){for(var t=void 0,n=void 0,o=void 0,r=void 0,a=this.wot.wtTable.getRenderedRowsCount(),l=0;a>l;l+=1){var u=this.wot.wtTable.rowFilter.renderedToSource(l);if(u>=e[0]&&e[2]>=u){t=u;break}}for(var h=a-1;h>=0;h-=1){var f=this.wot.wtTable.rowFilter.renderedToSource(h);if(f>=e[0]&&e[2]>=f){n=f;break}}for(var d=this.wot.wtTable.getRenderedColumnsCount(),g=0;d>g;g+=1){var v=this.wot.wtTable.columnFilter.renderedToSource(g);if(v>=e[1]&&e[3]>=v){o=v;break}}for(var m=d-1;m>=0;m-=1){var y=this.wot.wtTable.columnFilter.renderedToSource(m);if(y>=e[1]&&e[3]>=y){r=y;break}}if(void 0===t||void 0===o)return void this.disappear();var w=this.wot.wtTable.getCell(new p.default(t,o)),C=t!==n||o!==r,b=C?this.wot.wtTable.getCell(new p.default(n,r)):w,_=(0, s.offset)(w),S=C?(0, s.offset)(b):_,E=(0, s.offset)(this.wot.wtTable.TABLE),O=_.top,T=_.left,k=T-E.left-1,R=S.left+(0, s.outerWidth)(b)-T;if(this.isEntireColumnSelected(t,n)){var M=this.getDimensionsFromHeader("columns",o,r,E),D=null;if(M){var A=i(M,3);D=A[0],k=A[1],R=A[2];}D&&(w=D);}var N=O-E.top-1,P=S.top+(0, s.outerHeight)(b)-O;if(this.isEntireRowSelected(o,r)){var H=this.getDimensionsFromHeader("rows",t,n,E),L=null;if(H){var x=i(H,3);L=x[0],N=x[1],P=x[2];}L&&(w=L);}var I=(0, s.getComputedStyle)(w);parseInt(I.borderTopWidth,10)>0&&(N+=1,P=P>0?P-1:0),parseInt(I.borderLeftWidth,10)>0&&(k+=1,R=R>0?R-1:0),this.topStyle.top=N+"px",this.topStyle.left=k+"px",this.topStyle.width=R+"px",this.topStyle.display="block",this.leftStyle.top=N+"px",this.leftStyle.left=k+"px",this.leftStyle.height=P+"px",this.leftStyle.display="block";var j=Math.floor(this.settings.border.width/2);this.bottomStyle.top=N+P-j+"px",this.bottomStyle.left=k+"px",this.bottomStyle.width=R+"px",this.bottomStyle.display="block",this.rightStyle.top=N+"px",this.rightStyle.left=k+R-j+"px",this.rightStyle.height=P+1+"px",this.rightStyle.display="block";var F=this.settings.border.cornerVisible;F="function"==typeof F?F(this.settings.layerLevel):F;var W=this.wot.getSetting("onModifyGetCellCoords",n,r),B=n,Y=r;if(W&&Array.isArray(W)){var V=i(W,4);B=V[2],Y=V[3];}if((0, c.isMobileBrowser)()||!F||this.isPartRange(B,Y))this.cornerStyle.display="none";else{this.cornerStyle.top=N+P-4+"px",this.cornerStyle.left=k+R-4+"px",this.cornerStyle.borderRightWidth=this.cornerDefaultStyle.borderWidth,this.cornerStyle.width=this.cornerDefaultStyle.width,this.cornerStyle.display="none";var U=(0, s.getTrimmingContainer)(this.wot.wtTable.TABLE),z=U===window;if(z&&(U=document.documentElement),r===this.wot.getSetting("totalColumns")-1){(z?b.getBoundingClientRect().left:b.offsetLeft)+(0, s.outerWidth)(b)+parseInt(this.cornerDefaultStyle.width,10)/2>=(0, s.innerWidth)(U)&&(this.cornerStyle.left=Math.floor(k+R-3-parseInt(this.cornerDefaultStyle.width,10)/2)+"px",this.cornerStyle.borderRightWidth=0);}if(n===this.wot.getSetting("totalRows")-1){(z?b.getBoundingClientRect().top:b.offsetTop)+(0, s.outerHeight)(b)+parseInt(this.cornerDefaultStyle.height,10)/2>=(0, s.innerHeight)(U)&&(this.cornerStyle.top=Math.floor(N+P-3-parseInt(this.cornerDefaultStyle.height,10)/2)+"px",this.cornerStyle.borderBottomWidth=0);}this.cornerStyle.display="block";}(0, c.isMobileBrowser)()&&this.updateMultipleSelectionHandlesPosition(n,r,N,k,R,P);}}},{key:"isEntireColumnSelected",value:function(e,t){return e===this.wot.wtTable.getFirstRenderedRow()&&t===this.wot.wtTable.getLastRenderedRow()}},{key:"isEntireRowSelected",value:function(e,t){return e===this.wot.wtTable.getFirstRenderedColumn()&&t===this.wot.wtTable.getLastRenderedColumn()}},{key:"getDimensionsFromHeader",value:function(e,t,n,o){var r=this,i=this.wot.wtTable.wtRootElement.parentNode,a=null,l=null,u=null,c=null,h=null,f=null,d=null,p=null;switch(e){case"rows":a=function(){var e;return (e=r.wot.wtTable).getRowHeader.apply(e,arguments)},l=function(){return s.outerHeight.apply(void 0,arguments)},u="ht__selection--rows",f="top";break;case"columns":a=function(){var e;return (e=r.wot.wtTable).getColumnHeader.apply(e,arguments)},l=function(){return s.outerWidth.apply(void 0,arguments)},u="ht__selection--columns",f="left";}if(i.className.includes(u)){var g=this.wot.getSetting("columnHeaders").length;if(d=a(t,g-1),p=a(n,g-1),!d||!p)return !1;var v=(0, s.offset)(d),m=(0, s.offset)(p);return d&&p&&(c=v[f]-o[f]-1,h=m[f]+l(p)-v[f]),[d,c,h]}return !1}},{key:"changeBorderStyle",value:function(e,t){var n=this[e].style,o=t[e];!o||o.hide?(0, s.addClass)(this[e],"hidden"):((0, s.hasClass)(this[e],"hidden")&&(0, s.removeClass)(this[e],"hidden"),n.backgroundColor=o.color,"top"!==e&&"bottom"!==e||(n.height=o.width+"px"),"right"!==e&&"left"!==e||(n.width=o.width+"px"));}},{key:"changeBorderToDefaultStyle",value:function(e){var t=this[e].style;t.backgroundColor="#000",t.width="1px",t.height="1px";}},{key:"toggleHiddenClass",value:function(e,t){this.changeBorderToDefaultStyle(e),t?(0, s.addClass)(this[e],"hidden"):(0, s.removeClass)(this[e],"hidden");}},{key:"disappear",value:function(){this.topStyle.display="none",this.leftStyle.display="none",this.bottomStyle.display="none",this.rightStyle.display="none",this.cornerStyle.display="none",(0, c.isMobileBrowser)()&&(this.selectionHandles.styles.topLeft.display="none",this.selectionHandles.styles.bottomRight.display="none");}}]),e}();},function(e,t,n){function o(e){f=!1;var t=this.getActiveEditor();if((0, r.isPrintableChar)(e.keyCode)||e.keyCode===r.KEY_CODES.BACKSPACE||e.keyCode===r.KEY_CODES.DELETE||e.keyCode===r.KEY_CODES.INSERT){var n=0;if(e.keyCode===r.KEY_CODES.C&&(e.ctrlKey||e.metaKey))return;t.isOpened()||(n+=10),t.htEditor&&t.instance._registerTimeout(function(){t.queryChoices(t.TEXTAREA.value),f=!0;},n);}}t.__esModule=!0;var r=n(21),i=n(10),a=n(36),s=n(2),l=n(0),u=n(312),c=function(e){return e&&e.__esModule?e:{default:e}}(u),h=c.default.prototype.extend();h.prototype.init=function(){for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];c.default.prototype.init.apply(this,t),this.query=null,this.strippedChoices=[],this.rawChoices=[];},h.prototype.getValue=function(){var e=this,t=this.rawChoices.find(function(t){return e.stripValueIfNeeded(t)===e.TEXTAREA.value});return (0, i.isDefined)(t)?t:this.TEXTAREA.value},h.prototype.createElements=function(){for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];c.default.prototype.createElements.apply(this,t),(0, l.addClass)(this.htContainer,"autocompleteEditor"),(0, l.addClass)(this.htContainer,-1===window.navigator.platform.indexOf("Mac")?"":"htMacScroll");};var f=!1;h.prototype.prepare=function(){for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];c.default.prototype.prepare.apply(this,t);},h.prototype.open=function(){this.instance.addHook("beforeKeyDown",o),this.TEXTAREA_PARENT.style.overflow="auto";for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];c.default.prototype.open.apply(this,t),this.TEXTAREA_PARENT.style.overflow="";var r=this.htEditor.getInstance(),a=this,s=void 0===this.cellProperties.trimDropdown||this.cellProperties.trimDropdown;this.showEditableElement(),this.focus(),r.updateSettings({colWidths:s?[(0, l.outerWidth)(this.TEXTAREA)-2]:void 0,width:s?(0, l.outerWidth)(this.TEXTAREA)+(0, l.getScrollbarWidth)()+2:void 0,afterRenderer:function(e,t,n,o,r){var s=a.cellProperties,l=s.filteringCaseSensitive,u=s.allowHtml,c=(0, i.stringify)(r),h=void 0,f=void 0;c&&!u&&-1!==(h=!0===l?c.indexOf(this.query):c.toLowerCase().indexOf(a.query.toLowerCase()))&&(f=c.substr(h,a.query.length),c=c.replace(f,"<strong>"+f+"</strong>")),e.innerHTML=c;},autoColumnSize:!0,modifyColWidth:function(e,t){var n=this.getPlugin("autoColumnSize").widths,o=e;return n[t]&&(o=n[t]),s?o:o+15}}),this.htEditor.view.wt.wtTable.holder.parentNode.style["padding-right"]=(0, l.getScrollbarWidth)()+2+"px",f&&(f=!1),a.instance._registerTimeout(function(){a.queryChoices(a.TEXTAREA.value);});},h.prototype.queryChoices=function(e){var t=this;this.query=e;var n=this.cellProperties.source;"function"==typeof n?n.call(this.cellProperties,e,function(e){t.rawChoices=e,t.updateChoicesList(t.stripValuesIfNeeded(e));}):Array.isArray(n)?(this.rawChoices=n,this.updateChoicesList(this.stripValuesIfNeeded(n))):this.updateChoicesList([]);},h.prototype.updateChoicesList=function(e){var t=(0, l.getCaretPosition)(this.TEXTAREA),n=(0, l.getSelectionEndPosition)(this.TEXTAREA),o=this.cellProperties.sortByRelevance,r=this.cellProperties.filter,i=null,a=null,u=e;o&&(i=h.sortByRelevance(this.stripValueIfNeeded(this.getValue()),u,this.cellProperties.filteringCaseSensitive));var c=Array.isArray(i)?i.length:0;if(!1===r)c&&(a=i[0]);else{for(var f=[],d=0,p=u.length;p>d&&(!o||d<c);d++)f.push(c?u[i[d]]:u[d]);a=0,u=f;}this.strippedChoices=u,this.htEditor.loadData((0, s.pivot)([u])),this.updateDropdownHeight(),this.flipDropdownIfNeeded(),!0===this.cellProperties.strict&&this.highlightBestMatchingChoice(a),this.instance.listen(!1),(0, l.setCaretPosition)(this.TEXTAREA,t,t===n?void 0:n);},h.prototype.flipDropdownIfNeeded=function(){var e=(0, l.offset)(this.TEXTAREA),t=(0, l.outerHeight)(this.TEXTAREA),n=this.getDropdownHeight(),o=(0, l.getTrimmingContainer)(this.instance.view.wt.wtTable.TABLE),r=o.scrollTop,i=(0, l.outerHeight)(this.instance.view.wt.wtTable.THEAD),a={row:0,col:0};o!==window&&(a=(0, l.offset)(o));var s=e.top-a.top-i+r,u=o.scrollHeight-s-i-t,c=n>u&&s>u;return c?this.flipDropdown(n):this.unflipDropdown(),this.limitDropdownIfNeeded(c?s:u,n),c},h.prototype.limitDropdownIfNeeded=function(e,t){if(t>e){var n=0,o=0,r=0,i=null;do{r=this.htEditor.getRowHeight(o)||this.htEditor.view.wt.wtSettings.settings.defaultRowHeight,n+=r,o+=1;}while(e>n);i=n-r,this.htEditor.flipped&&(this.htEditor.rootElement.style.top=parseInt(this.htEditor.rootElement.style.top,10)+t-i+"px"),this.setDropdownHeight(n-r);}},h.prototype.flipDropdown=function(e){var t=this.htEditor.rootElement.style;t.position="absolute",t.top=-e+"px",this.htEditor.flipped=!0;},h.prototype.unflipDropdown=function(){var e=this.htEditor.rootElement.style;"absolute"===e.position&&(e.position="",e.top=""),this.htEditor.flipped=void 0;},h.prototype.updateDropdownHeight=function(){var e=this.htEditor.getColWidth(0)+(0, l.getScrollbarWidth)()+2,t=this.cellProperties.trimDropdown;this.htEditor.updateSettings({height:this.getDropdownHeight(),width:t?void 0:e}),this.htEditor.view.wt.wtTable.alignOverlaysWithTrimmingContainer();},h.prototype.setDropdownHeight=function(e){this.htEditor.updateSettings({height:e});},h.prototype.finishEditing=function(e){for(var t=arguments.length,n=Array(t>1?t-1:0),o=1;t>o;o++)n[o-1]=arguments[o];c.default.prototype.finishEditing.apply(this,[e].concat(n));},h.prototype.highlightBestMatchingChoice=function(e){"number"==typeof e?this.htEditor.selectCell(e,0,void 0,void 0,void 0,!1):this.htEditor.deselectCell();},h.sortByRelevance=function(e,t,n){var o=[],r=void 0,s=e.length,l=void 0,u=void 0,c=[],h=void 0,f=t.length;if(0===s){for(h=0;f>h;h++)c.push(h);return c}for(h=0;f>h;h++)r=(0, a.stripTags)((0, i.stringify)(t[h])),-1!==(l=n?r.indexOf(e):r.toLowerCase().indexOf(e.toLowerCase()))&&(u=r.length-l-s,o.push({baseIndex:h,index:l,charsLeft:u,value:r}));for(o.sort(function(e,t){if(-1===t.index)return -1;if(-1===e.index)return 1;if(t.index>e.index)return -1;if(e.index>t.index)return 1;if(e.index===t.index){if(t.charsLeft>e.charsLeft)return -1;if(e.charsLeft>t.charsLeft)return 1}return 0}),h=0,f=o.length;f>h;h++)c.push(o[h].baseIndex);return c},h.prototype.getDropdownHeight=function(){var e=this.htEditor.getInstance().getRowHeight(0)||23,t=this.cellProperties.visibleRows;return t>this.strippedChoices.length?this.strippedChoices.length*e+8:t*e},h.prototype.stripValueIfNeeded=function(e){return this.stripValuesIfNeeded([e])[0]},h.prototype.stripValuesIfNeeded=function(e){var t=this.cellProperties.allowHtml,n=(0, s.arrayMap)(e,function(e){return (0, i.stringify)(e)});return (0, s.arrayMap)(n,function(e){return t?e:(0, a.stripTags)(e)})},h.prototype.allowKeyEventPropagation=function(e){var t=this.htEditor.getSelectedRangeLast(),n={row:t?t.from.row:-1},o=!1;return e===r.KEY_CODES.ARROW_DOWN&&n.row>0&&n.row<this.htEditor.countRows()-1&&(o=!0),e===r.KEY_CODES.ARROW_UP&&n.row>-1&&(o=!0),o},h.prototype.close=function(){this.instance.removeHook("beforeKeyDown",o);for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];c.default.prototype.close.apply(this,t);},h.prototype.discardEditor=function(){for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];c.default.prototype.discardEditor.apply(this,t),this.instance.view.render();},t.default=h;},function(e,t,n){t.__esModule=!0;var o=n(21),r=n(1),i=n(0),a=n(12),s=n(59),l=function(e){return e&&e.__esModule?e:{default:e}}(s),u=l.default.prototype.extend();u.prototype.createElements=function(){for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];l.default.prototype.createElements.apply(this,t);var o=document.createElement("DIV");o.className="handsontableEditor",this.TEXTAREA_PARENT.appendChild(o),this.htContainer=o,this.assignHooks();},u.prototype.prepare=function(e,t,n,o,i,a){for(var s=arguments.length,u=Array(s>6?s-6:0),c=6;s>c;c++)u[c-6]=arguments[c];l.default.prototype.prepare.apply(this,[e,t,n,o,i,a].concat(u));var h=this,f={startRows:0,startCols:0,minRows:0,minCols:0,className:"listbox",copyPaste:!1,autoColumnSize:!1,autoRowSize:!1,readOnly:!0,fillHandle:!1,autoWrapCol:!1,autoWrapRow:!1,afterOnCellMouseDown:function(e,t){var n=this.getSourceData(t.row,t.col);void 0!==n&&h.setValue(n),h.instance.destroyEditor();}};this.cellProperties.handsontable&&(0, r.extend)(f,a.handsontable),this.htOptions=f;};var c=function(e){if(!(0, a.isImmediatePropagationStopped)(e)){var t=this.getActiveEditor(),n=t.htEditor.getInstance(),r=void 0,i=void 0;if(e.keyCode===o.KEY_CODES.ARROW_DOWN)if(n.getSelectedLast()||n.flipped){if(n.getSelectedLast())if(n.flipped)r=n.getSelectedLast()[0]+1;else if(!n.flipped){var s=n.countRows()-1;i=n.getSelectedLast()[0],r=Math.min(s,i+1);}}else r=0;else e.keyCode===o.KEY_CODES.ARROW_UP&&(!n.getSelectedLast()&&n.flipped?r=n.countRows()-1:n.getSelectedLast()&&(n.flipped?(i=n.getSelectedLast()[0],r=Math.max(0,i-1)):(i=n.getSelectedLast()[0],r=i-1)));void 0!==r&&(0>r||n.flipped&&r>n.countRows()-1?n.deselectCell():n.selectCell(r,0),n.getData().length&&(e.preventDefault(),(0, a.stopImmediatePropagation)(e),t.instance.listen(),t.TEXTAREA.focus()));}};u.prototype.open=function(){this.instance.addHook("beforeKeyDown",c);for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];l.default.prototype.open.apply(this,t),this.htEditor&&this.htEditor.destroy(),"none"===this.htContainer.style.display&&(this.htContainer.style.display=""),this.htEditor=new this.instance.constructor(this.htContainer,this.htOptions),this.htEditor.init(),this.htEditor.rootElement.style.display="",this.cellProperties.strict?this.htEditor.selectCell(0,0):this.htEditor.deselectCell(),(0, i.setCaretPosition)(this.TEXTAREA,0,this.TEXTAREA.value.length);},u.prototype.close=function(){this.htEditor.rootElement.style.display="none",this.instance.removeHook("beforeKeyDown",c);for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];l.default.prototype.close.apply(this,t);},u.prototype.focus=function(){for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];l.default.prototype.focus.apply(this,t);},u.prototype.beginEditing=function(){var e=this.instance.getSettings().onBeginEditing;if(!e||!1!==e()){for(var t=arguments.length,n=Array(t),o=0;t>o;o++)n[o]=arguments[o];l.default.prototype.beginEditing.apply(this,n);}},u.prototype.finishEditing=function(){if(this.htEditor&&this.htEditor.isListening()&&this.instance.listen(),this.htEditor&&this.htEditor.getSelectedLast()){var e=this.htEditor.getInstance().getValue();void 0!==e&&this.setValue(e);}for(var t=arguments.length,n=Array(t),o=0;t>o;o++)n[o]=arguments[o];return l.default.prototype.finishEditing.apply(this,n)},u.prototype.assignHooks=function(){var e=this;this.instance.addHook("afterDestroy",function(){e.htEditor&&e.htEditor.destroy();});},t.default=u;},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){var o,o;!function(t){e.exports=t();}(function(){return function e(t,n,r){function i(s,l){if(!n[s]){if(!t[s]){var u="function"==typeof o&&o;if(!l&&u)return o(s,!0);if(a)return a(s,!0);var c=Error("Cannot find module '"+s+"'");throw c.code="MODULE_NOT_FOUND",c}var h=n[s]={exports:{}};t[s][0].call(h.exports,function(e){return i(t[s][1][e]||e)},h,h.exports,e,t,n,r);}return n[s].exports}for(var a="function"==typeof o&&o,s=0;r.length>s;s++)i(r[s]);return i}({1:[function(e,t,n){!function(e){function n(e){function t(e,n){var o,r,i,a,s,l,u=this;if(!(u instanceof t))return V&&D(26,"constructor call without new",e),new t(e,n);if(null!=n&&U(n,2,64,H,"base")){if(n|=0,l=e+"",10==n)return u=new t(e instanceof t?e:l),A(u,I+u.e+1,j);if((a="number"==typeof e)&&0*e!=0||!RegExp("^-?"+(o="["+w.slice(0,n)+"]+")+"(?:\\."+o+")?$",37>n?"i":"").test(l))return P(u,l,a,n);a?(u.s=0>1/e?(l=l.slice(1),-1):1,V&&l.replace(/^0\.0*|\./,"").length>15&&D(H,y,e),a=!1):u.s=45===l.charCodeAt(0)?(l=l.slice(1),-1):1,l=f(l,10,n,u.s);}else{if(e instanceof t)return u.s=e.s,u.e=e.e,u.c=(e=e.c)?e.slice():e,void(H=0);if((a="number"==typeof e)&&0*e==0){if(u.s=0>1/e?(e=-e,-1):1,e===~~e){for(r=0,i=e;i>=10;i/=10,r++);return u.e=r,u.c=[e],void(H=0)}l=e+"";}else{if(!d.test(l=e+""))return P(u,l,a);u.s=45===l.charCodeAt(0)?(l=l.slice(1),-1):1;}}for((r=l.indexOf("."))>-1&&(l=l.replace(".","")),(i=l.search(/e/i))>0?(0>r&&(r=i),r+=+l.slice(i+1),l=l.substring(0,i)):0>r&&(r=l.length),i=0;48===l.charCodeAt(i);i++);for(s=l.length;48===l.charCodeAt(--s););if(l=l.slice(i,s+1))if(s=l.length,a&&V&&s>15&&(e>_||e!==g(e))&&D(H,y,u.s*e),(r=r-i-1)>Y)u.c=u.e=null;else if(B>r)u.c=[u.e=0];else{if(u.e=r,u.c=[],i=(r+1)%b,0>r&&(i+=b),s>i){for(i&&u.c.push(+l.slice(0,i)),s-=b;s>i;)u.c.push(+l.slice(i,i+=b));l=l.slice(i),i=b-l.length;}else i-=s;for(;i--;l+="0");u.c.push(+l);}else u.c=[u.e=0];H=0;}function f(e,n,o,i){var a,s,u,h,f,d,p,g=e.indexOf("."),v=I,m=j;for(37>o&&(e=e.toLowerCase()),g>=0&&(u=K,K=0,e=e.replace(".",""),f=(p=new t(o)).pow(e.length-g),K=u,p.c=l(c(r(f.c),f.e),10,n),p.e=p.c.length),s=u=(d=l(e,o,n)).length;0==d[--u];d.pop());if(!d[0])return "0";if(0>g?--s:(f.c=d,f.e=s,f.s=i,d=(f=N(f,p,v,m,n)).c,h=f.r,s=f.e),a=s+v+1,g=d[a],u=n/2,h=h||0>a||null!=d[a+1],h=4>m?(null!=g||h)&&(0==m||m==(0>f.s?3:2)):g>u||g==u&&(4==m||h||6==m&&1&d[a-1]||m==(0>f.s?8:7)),1>a||!d[0])e=h?c("1",-v):"0";else{if(d.length=a,h)for(--n;++d[--a]>n;)d[a]=0,a||(++s,d=[1].concat(d));for(u=d.length;!d[--u];);for(g=0,e="";u>=g;e+=w.charAt(d[g++]));e=c(e,s);}return e}function T(e,n,o,i){var a,s,l,h,f;if(o=null!=o&&U(o,0,8,i,m)?0|o:j,!e.c)return ""+e;if(a=e.c[0],l=e.e,null==n)f=r(e.c),f=19==i||24==i&&F>=l?u(f,l):c(f,l);else if(e=A(new t(e),n,o),s=e.e,f=r(e.c),h=f.length,19!=i&&(24!=i||s<n&&F<s)){if(n-=l,f=c(f,s),s+1>h){if(--n>0)for(f+=".";n--;f+="0");}else if((n+=s-h)>0)for(s+1==h&&(f+=".");n--;f+="0");}else{for(;n>h;f+="0",h++);f=u(f,s);}return 0>e.s&&a?"-"+f:f}function k(e,n){var o,r,i=0;for(s(e[0])&&(e=e[0]),o=new t(e[0]);++i<e.length;){if(!(r=new t(e[i])).s){o=r;break}n.call(o,r)&&(o=r);}return o}function R(e,t,n,o,r){return (t>e||e>n||e!=h(e))&&D(o,(r||"decimal places")+(t>e||e>n?" out of range":" not an integer"),e),!0}function M(e,t,n){for(var o=1,r=t.length;!t[--r];t.pop());for(r=t[0];r>=10;r/=10,o++);return (n=o+n*b-1)>Y?e.c=e.e=null:B>n?e.c=[e.e=0]:(e.e=n,e.c=t),e}function D(e,t,n){var o=Error(["new BigNumber","cmp","config","div","divToInt","eq","gt","gte","lt","lte","minus","mod","plus","precision","random","round","shift","times","toDigits","toExponential","toFixed","toFormat","toFraction","pow","toPrecision","toString","BigNumber"][e]+"() "+t+": "+n);throw o.name="BigNumber Error",H=0,o}function A(e,t,n,o){var r,i,a,s,l,u,c,h=e.c,f=S;if(h){e:{for(r=1,s=h[0];s>=10;s/=10,r++);if(0>(i=t-r))i+=b,a=t,c=(l=h[u=0])/f[r-a-1]%10|0;else if((u=p((i+1)/b))<h.length){for(l=s=h[u],r=1;s>=10;s/=10,r++);c=0>(a=(i%=b)-b+r)?0:l/f[r-a-1]%10|0;}else{if(!o)break e;for(;u>=h.length;h.push(0));l=c=0,r=1,a=(i%=b)-b+1;}if(o=o||0>t||null!=h[u+1]||(0>a?l:l%f[r-a-1]),o=4>n?(c||o)&&(0==n||n==(0>e.s?3:2)):c>5||5==c&&(4==n||o||6==n&&(i>0?a>0?l/f[r-a]:0:h[u-1])%10&1||n==(0>e.s?8:7)),1>t||!h[0])return h.length=0,o?(t-=e.e+1,h[0]=f[(b-t%b)%b],e.e=-t||0):h[0]=e.e=0,e;if(0==i?(h.length=u,s=1,u--):(h.length=u+1,s=f[b-i],h[u]=a>0?g(l/f[r-a]%f[a])*s:0),o)for(;;){if(0==u){for(i=1,a=h[0];a>=10;a/=10,i++);for(a=h[0]+=s,s=1;a>=10;a/=10,s++);i!=s&&(e.e++,h[0]==C&&(h[0]=1));break}if((h[u]+=s)!=C)break;h[u--]=0,s=1;}for(i=h.length;0===h[--i];h.pop());}e.e>Y?e.c=e.e=null:B>e.e&&(e.c=[e.e=0]);}return e}var N,P,H=0,L=t.prototype,x=new t(1),I=20,j=4,F=-7,W=21,B=-1e7,Y=1e7,V=!0,U=R,z=!1,G=1,K=0,X={decimalSeparator:".",groupSeparator:",",groupSize:3,secondaryGroupSize:0,fractionGroupSeparator:"",fractionGroupSize:0};return t.another=n,t.ROUND_UP=0,t.ROUND_DOWN=1,t.ROUND_CEIL=2,t.ROUND_FLOOR=3,t.ROUND_HALF_UP=4,t.ROUND_HALF_DOWN=5,t.ROUND_HALF_EVEN=6,t.ROUND_HALF_CEIL=7,t.ROUND_HALF_FLOOR=8,t.EUCLID=9,t.config=t.set=function(){var e,t,n=0,o={},r=arguments,i=r[0],l=i&&"object"==typeof i?function(){if(i.hasOwnProperty(t))return null!=(e=i[t])}:function(){if(r.length>n)return null!=(e=r[n++])};return l(t="DECIMAL_PLACES")&&U(e,0,O,2,t)&&(I=0|e),o[t]=I,l(t="ROUNDING_MODE")&&U(e,0,8,2,t)&&(j=0|e),o[t]=j,l(t="EXPONENTIAL_AT")&&(s(e)?U(e[0],-O,0,2,t)&&U(e[1],0,O,2,t)&&(F=0|e[0],W=0|e[1]):U(e,-O,O,2,t)&&(F=-(W=0|(0>e?-e:e)))),o[t]=[F,W],l(t="RANGE")&&(s(e)?U(e[0],-O,-1,2,t)&&U(e[1],1,O,2,t)&&(B=0|e[0],Y=0|e[1]):U(e,-O,O,2,t)&&(0|e?B=-(Y=0|(0>e?-e:e)):V&&D(2,t+" cannot be zero",e))),o[t]=[B,Y],l(t="ERRORS")&&(e===!!e||1===e||0===e?(H=0,U=(V=!!e)?R:a):V&&D(2,t+v,e)),o[t]=V,l(t="CRYPTO")&&(!0===e||!1===e||1===e||0===e?e?!(e="undefined"==typeof crypto)&&crypto&&(crypto.getRandomValues||crypto.randomBytes)?z=!0:V?D(2,"crypto unavailable",e?void 0:crypto):z=!1:z=!1:V&&D(2,t+v,e)),o[t]=z,l(t="MODULO_MODE")&&U(e,0,9,2,t)&&(G=0|e),o[t]=G,l(t="POW_PRECISION")&&U(e,0,O,2,t)&&(K=0|e),o[t]=K,l(t="FORMAT")&&("object"==typeof e?X=e:V&&D(2,t+" not an object",e)),o[t]=X,o},t.max=function(){return k(arguments,L.lt)},t.min=function(){return k(arguments,L.gt)},t.random=function(){var e=9007199254740992*Math.random()&2097151?function(){return g(9007199254740992*Math.random())}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)};return function(n){var o,r,i,a,s,l=0,u=[],c=new t(x);if(n=null!=n&&U(n,0,O,14)?0|n:I,a=p(n/b),z)if(crypto.getRandomValues){for(o=crypto.getRandomValues(new Uint32Array(a*=2));a>l;)9e15>(s=131072*o[l]+(o[l+1]>>>11))?(u.push(s%1e14),l+=2):(r=crypto.getRandomValues(new Uint32Array(2)),o[l]=r[0],o[l+1]=r[1]);l=a/2;}else if(crypto.randomBytes){for(o=crypto.randomBytes(a*=7);a>l;)9e15>(s=281474976710656*(31&o[l])+1099511627776*o[l+1]+4294967296*o[l+2]+16777216*o[l+3]+(o[l+4]<<16)+(o[l+5]<<8)+o[l+6])?(u.push(s%1e14),l+=7):crypto.randomBytes(7).copy(o,l);l=a/7;}else z=!1,V&&D(14,"crypto unavailable",crypto);if(!z)for(;a>l;)9e15>(s=e())&&(u[l++]=s%1e14);for(a=u[--l],n%=b,a&&n&&(s=S[b-n],u[l]=g(a/s)*s);0===u[l];u.pop(),l--);if(0>l)u=[i=0];else{for(i=-1;0===u[0];u.splice(0,1),i-=b);for(l=1,s=u[0];s>=10;s/=10,l++);b>l&&(i-=b-l);}return c.e=i,c.c=u,c}}(),N=function(){function e(e,t,n){var o,r,i,a,s=0,l=e.length,u=t%E,c=t/E|0;for(e=e.slice();l--;)s=((r=u*(i=e[l]%E)+(o=c*i+(a=e[l]/E|0)*u)%E*E+s)/n|0)+(o/E|0)+c*a,e[l]=r%n;return s&&(e=[s].concat(e)),e}function n(e,t,n,o){var r,i;if(n!=o)i=n>o?1:-1;else for(r=i=0;n>r;r++)if(e[r]!=t[r]){i=e[r]>t[r]?1:-1;break}return i}function r(e,t,n,o){for(var r=0;n--;)e[n]-=r,r=t[n]>e[n]?1:0,e[n]=r*o+e[n]-t[n];for(;!e[0]&&e.length>1;e.splice(0,1));}return function(i,a,s,l,u){var c,h,f,d,p,v,m,y,w,_,S,E,O,T,k,R,M,D=i.s==a.s?1:-1,N=i.c,P=a.c;if(!(N&&N[0]&&P&&P[0]))return new t(i.s&&a.s&&(N?!P||N[0]!=P[0]:P)?N&&0==N[0]||!P?0*D:D/0:NaN);for(w=(y=new t(D)).c=[],D=s+(h=i.e-a.e)+1,u||(u=C,h=o(i.e/b)-o(a.e/b),D=D/b|0),f=0;P[f]==(N[f]||0);f++);if(P[f]>(N[f]||0)&&h--,0>D)w.push(1),d=!0;else{for(T=N.length,R=P.length,f=0,D+=2,(p=g(u/(P[0]+1)))>1&&(P=e(P,p,u),N=e(N,p,u),R=P.length,T=N.length),O=R,S=(_=N.slice(0,R)).length;R>S;_[S++]=0);M=P.slice(),M=[0].concat(M),k=P[0],P[1]>=u/2&&k++;do{if(p=0,0>(c=n(P,_,R,S))){if(E=_[0],R!=S&&(E=E*u+(_[1]||0)),(p=g(E/k))>1)for(p>=u&&(p=u-1),m=(v=e(P,p,u)).length,S=_.length;1==n(v,_,m,S);)p--,r(v,m>R?M:P,m,u),m=v.length,c=1;else 0==p&&(c=p=1),m=(v=P.slice()).length;if(S>m&&(v=[0].concat(v)),r(_,v,S,u),S=_.length,-1==c)for(;1>n(P,_,R,S);)p++,r(_,S>R?M:P,S,u),S=_.length;}else 0===c&&(p++,_=[0]);w[f++]=p,_[0]?_[S++]=N[O]||0:(_=[N[O]],S=1);}while((O++<T||null!=_[0])&&D--);d=null!=_[0],w[0]||w.splice(0,1);}if(u==C){for(f=1,D=w[0];D>=10;D/=10,f++);A(y,s+(y.e=f+h*b-1)+1,l,d);}else y.e=h,y.r=+d;return y}}(),P=function(){var e=/^(-?)0([xbo])(?=\w[\w.]*$)/i,n=/^([^.]+)\.$/,o=/^\.([^.]+)$/,r=/^-?(Infinity|NaN)$/,i=/^\s*\+(?=[\w.])|^\s+|\s+$/g;return function(a,s,l,u){var c,h=l?s:s.replace(i,"");if(r.test(h))a.s=isNaN(h)?null:0>h?-1:1;else{if(!l&&(h=h.replace(e,function(e,t,n){return c="x"==(n=n.toLowerCase())?16:"b"==n?2:8,u&&u!=c?e:t}),u&&(c=u,h=h.replace(n,"$1").replace(o,"0.$1")),s!=h))return new t(h,c);V&&D(H,"not a"+(u?" base "+u:"")+" number",s),a.s=null;}a.c=a.e=null,H=0;}}(),L.absoluteValue=L.abs=function(){var e=new t(this);return 0>e.s&&(e.s=1),e},L.ceil=function(){return A(new t(this),this.e+1,2)},L.comparedTo=L.cmp=function(e,n){return H=1,i(this,new t(e,n))},L.decimalPlaces=L.dp=function(){var e,t,n=this.c;if(!n)return null;if(e=((t=n.length-1)-o(this.e/b))*b,t=n[t])for(;t%10==0;t/=10,e--);return 0>e&&(e=0),e},L.dividedBy=L.div=function(e,n){return H=3,N(this,new t(e,n),I,j)},L.dividedToIntegerBy=L.divToInt=function(e,n){return H=4,N(this,new t(e,n),0,1)},L.equals=L.eq=function(e,n){return H=5,0===i(this,new t(e,n))},L.floor=function(){return A(new t(this),this.e+1,3)},L.greaterThan=L.gt=function(e,n){return H=6,i(this,new t(e,n))>0},L.greaterThanOrEqualTo=L.gte=function(e,n){return H=7,1===(n=i(this,new t(e,n)))||0===n},L.isFinite=function(){return !!this.c},L.isInteger=L.isInt=function(){return !!this.c&&o(this.e/b)>this.c.length-2},L.isNaN=function(){return !this.s},L.isNegative=L.isNeg=function(){return 0>this.s},L.isZero=function(){return !!this.c&&0==this.c[0]},L.lessThan=L.lt=function(e,n){return H=8,0>i(this,new t(e,n))},L.lessThanOrEqualTo=L.lte=function(e,n){return H=9,-1===(n=i(this,new t(e,n)))||0===n},L.minus=L.sub=function(e,n){var r,i,a,s,l=this,u=l.s;if(H=10,e=new t(e,n),n=e.s,!u||!n)return new t(NaN);if(u!=n)return e.s=-n,l.plus(e);var c=l.e/b,h=e.e/b,f=l.c,d=e.c;if(!c||!h){if(!f||!d)return f?(e.s=-n,e):new t(d?l:NaN);if(!f[0]||!d[0])return d[0]?(e.s=-n,e):new t(f[0]?l:3==j?-0:0)}if(c=o(c),h=o(h),f=f.slice(),u=c-h){for((s=0>u)?(u=-u,a=f):(h=c,a=d),a.reverse(),n=u;n--;a.push(0));a.reverse();}else for(i=(s=(u=f.length)<(n=d.length))?u:n,u=n=0;i>n;n++)if(f[n]!=d[n]){s=d[n]>f[n];break}if(s&&(a=f,f=d,d=a,e.s=-e.s),(n=(i=d.length)-(r=f.length))>0)for(;n--;f[r++]=0);for(n=C-1;i>u;){if(f[--i]<d[i]){for(r=i;r&&!f[--r];f[r]=n);--f[r],f[i]+=C;}f[i]-=d[i];}for(;0==f[0];f.splice(0,1),--h);return f[0]?M(e,f,h):(e.s=3==j?-1:1,e.c=[e.e=0],e)},L.modulo=L.mod=function(e,n){var o,r,i=this;return H=11,e=new t(e,n),!i.c||!e.s||e.c&&!e.c[0]?new t(NaN):!e.c||i.c&&!i.c[0]?new t(i):(9==G?(r=e.s,e.s=1,o=N(i,e,0,3),e.s=r,o.s*=r):o=N(i,e,0,G),i.minus(o.times(e)))},L.negated=L.neg=function(){var e=new t(this);return e.s=-e.s||null,e},L.plus=L.add=function(e,n){var r,i=this,a=i.s;if(H=12,e=new t(e,n),n=e.s,!a||!n)return new t(NaN);if(a!=n)return e.s=-n,i.minus(e);var s=i.e/b,l=e.e/b,u=i.c,c=e.c;if(!s||!l){if(!u||!c)return new t(a/0);if(!u[0]||!c[0])return c[0]?e:new t(u[0]?i:0*a)}if(s=o(s),l=o(l),u=u.slice(),a=s-l){for(a>0?(l=s,r=c):(a=-a,r=u),r.reverse();a--;r.push(0));r.reverse();}for(0>(a=u.length)-(n=c.length)&&(r=c,c=u,u=r,n=a),a=0;n;)a=(u[--n]=u[n]+c[n]+a)/C|0,u[n]=C===u[n]?0:u[n]%C;return a&&(u=[a].concat(u),++l),M(e,u,l)},L.precision=L.sd=function(e){var t,n,o=this,r=o.c;if(null!=e&&e!==!!e&&1!==e&&0!==e&&(V&&D(13,"argument"+v,e),e!=!!e&&(e=null)),!r)return null;if(n=r.length-1,t=n*b+1,n=r[n]){for(;n%10==0;n/=10,t--);for(n=r[0];n>=10;n/=10,t++);}return e&&o.e+1>t&&(t=o.e+1),t},L.round=function(e,n){var o=new t(this);return (null==e||U(e,0,O,15))&&A(o,~~e+this.e+1,null!=n&&U(n,0,8,15,m)?0|n:j),o},L.shift=function(e){var n=this;return U(e,-_,_,16,"argument")?n.times("1e"+h(e)):new t(n.c&&n.c[0]&&(-_>e||e>_)?n.s*(0>e?0:1/0):n)},L.squareRoot=L.sqrt=function(){var e,n,i,a,s,l=this,u=l.c,c=l.s,h=l.e,f=I+4,d=new t("0.5");if(1!==c||!u||!u[0])return new t(!c||0>c&&(!u||u[0])?NaN:u?l:1/0);if(0==(c=Math.sqrt(+l))||c==1/0?(((n=r(u)).length+h)%2==0&&(n+="0"),c=Math.sqrt(n),h=o((h+1)/2)-(0>h||h%2),i=new t(n=c==1/0?"1e"+h:(n=c.toExponential()).slice(0,n.indexOf("e")+1)+h)):i=new t(c+""),i.c[0])for(3>(c=(h=i.e)+f)&&(c=0);;)if(s=i,i=d.times(s.plus(N(l,s,f,1))),r(s.c).slice(0,c)===(n=r(i.c)).slice(0,c)){if(h>i.e&&--c,"9999"!=(n=n.slice(c-3,c+1))&&(a||"4999"!=n)){+n&&(+n.slice(1)||"5"!=n.charAt(0))||(A(i,i.e+I+2,1),e=!i.times(i).eq(l));break}if(!a&&(A(s,s.e+I+2,0),s.times(s).eq(l))){i=s;break}f+=4,c+=4,a=1;}return A(i,i.e+I+1,j,e)},L.times=L.mul=function(e,n){var r,i,a,s,l,u,c,h,f,d,p,g,v,m,y,w=this,_=w.c,S=(H=17,e=new t(e,n)).c;if(!(_&&S&&_[0]&&S[0]))return !w.s||!e.s||_&&!_[0]&&!S||S&&!S[0]&&!_?e.c=e.e=e.s=null:(e.s*=w.s,_&&S?(e.c=[0],e.e=0):e.c=e.e=null),e;for(i=o(w.e/b)+o(e.e/b),e.s*=w.s,(c=_.length)<(d=S.length)&&(v=_,_=S,S=v,a=c,c=d,d=a),a=c+d,v=[];a--;v.push(0));for(m=C,y=E,a=d;--a>=0;){for(r=0,p=S[a]%y,g=S[a]/y|0,s=a+(l=c);s>a;)r=((h=p*(h=_[--l]%y)+(u=g*h+(f=_[l]/y|0)*p)%y*y+v[s]+r)/m|0)+(u/y|0)+g*f,v[s--]=h%m;v[s]=r;}return r?++i:v.splice(0,1),M(e,v,i)},L.toDigits=function(e,n){var o=new t(this);return e=null!=e&&U(e,1,O,18,"precision")?0|e:null,n=null!=n&&U(n,0,8,18,m)?0|n:j,e?A(o,e,n):o},L.toExponential=function(e,t){return T(this,null!=e&&U(e,0,O,19)?1+~~e:null,t,19)},L.toFixed=function(e,t){return T(this,null!=e&&U(e,0,O,20)?~~e+this.e+1:null,t,20)},L.toFormat=function(e,t){var n=T(this,null!=e&&U(e,0,O,21)?~~e+this.e+1:null,t,21);if(this.c){var o,r=n.split("."),i=+X.groupSize,a=+X.secondaryGroupSize,s=X.groupSeparator,l=r[0],u=r[1],c=0>this.s,h=c?l.slice(1):l,f=h.length;if(a&&(o=i,i=a,a=o,f-=o),i>0&&f>0){for(o=f%i||i,l=h.substr(0,o);f>o;o+=i)l+=s+h.substr(o,i);a>0&&(l+=s+h.slice(o)),c&&(l="-"+l);}n=u?l+X.decimalSeparator+((a=+X.fractionGroupSize)?u.replace(RegExp("\\d{"+a+"}\\B","g"),"$&"+X.fractionGroupSeparator):u):l;}return n},L.toFraction=function(e){var n,o,i,a,s,l,u,c,h,f=V,d=this,p=d.c,g=new t(x),v=o=new t(x),m=u=new t(x);if(null!=e&&(V=!1,l=new t(e),V=f,(f=l.isInt())&&!l.lt(x)||(V&&D(22,"max denominator "+(f?"out of range":"not an integer"),e),e=!f&&l.c&&A(l,l.e+1,1).gte(x)?l:null)),!p)return ""+d;for(h=r(p),a=g.e=h.length-d.e-1,g.c[0]=S[0>(s=a%b)?b+s:s],e=!e||l.cmp(g)>0?a>0?g:v:l,s=Y,Y=1/0,l=new t(h),u.c[0]=0;c=N(l,g,0,1),1!=(i=o.plus(c.times(m))).cmp(e);)o=m,m=i,v=u.plus(c.times(i=v)),u=i,g=l.minus(c.times(i=g)),l=i;return i=N(e.minus(o),m,0,1),u=u.plus(i.times(v)),o=o.plus(i.times(m)),u.s=v.s=d.s,a*=2,n=1>N(v,m,a,j).minus(d).abs().cmp(N(u,o,a,j).minus(d).abs())?[""+v,""+m]:[""+u,""+o],Y=s,n},L.toNumber=function(){return +this},L.toPower=L.pow=function(e,n){var o,r,i,a=g(0>e?-e:+e),s=this;if(null!=n&&(H=23,n=new t(n)),!U(e,-_,_,23,"exponent")&&(!isFinite(e)||a>_&&(e/=0)||parseFloat(e)!=e&&!(e=NaN))||0==e)return o=Math.pow(+s,e),new t(n?o%n:o);for(n?e>1&&s.gt(x)&&s.isInt()&&n.gt(x)&&n.isInt()?s=s.mod(n):(i=n,n=null):K&&(o=p(K/b+2)),r=new t(x);;){if(a%2){if(!(r=r.times(s)).c)break;o?r.c.length>o&&(r.c.length=o):n&&(r=r.mod(n));}if(!(a=g(a/2)))break;s=s.times(s),o?s.c&&s.c.length>o&&(s.c.length=o):n&&(s=s.mod(n));}return n?r:(0>e&&(r=x.div(r)),i?r.mod(i):o?A(r,K,j):r)},L.toPrecision=function(e,t){return T(this,null!=e&&U(e,1,O,24,"precision")?0|e:null,t,24)},L.toString=function(e){var t,n=this,o=n.s,i=n.e;return null===i?o?(t="Infinity",0>o&&(t="-"+t)):t="NaN":(t=r(n.c),t=null!=e&&U(e,2,64,25,"base")?f(c(t,i),0|e,10,o):i>F&&W>i?c(t,i):u(t,i),0>o&&n.c[0]&&(t="-"+t)),t},L.truncated=L.trunc=function(){return A(new t(this),this.e+1,1)},L.valueOf=L.toJSON=function(){var e,t=this,n=t.e;return null===n?""+t:(e=r(t.c),e=n>F&&W>n?c(e,n):u(e,n),0>t.s?"-"+e:e)},L.isBigNumber=!0,null!=e&&t.config(e),t}function o(e){var t=0|e;return e>0||e===t?t:t-1}function r(e){for(var t,n,o=1,r=e.length,i=e[0]+"";r>o;){for(t=e[o++]+"",n=b-t.length;n--;t="0"+t);i+=t;}for(r=i.length;48===i.charCodeAt(--r););return i.slice(0,r+1||1)}function i(e,t){var n,o,r=e.c,i=t.c,a=e.s,s=t.s,l=e.e,u=t.e;if(!a||!s)return null;if(n=r&&!r[0],o=i&&!i[0],n||o)return n?o?0:-s:a;if(a!=s)return a;if(n=0>a,o=l==u,!r||!i)return o?0:!r^n?1:-1;if(!o)return l>u^n?1:-1;for(s=(l=r.length)<(u=i.length)?l:u,a=0;s>a;a++)if(r[a]!=i[a])return r[a]>i[a]^n?1:-1;return l==u?0:l>u^n?1:-1}function a(e,t,n){return (e=h(e))>=t&&n>=e}function s(e){return "[object Array]"==Object.prototype.toString.call(e)}function l(e,t,n){for(var o,r,i=[0],a=0,s=e.length;s>a;){for(r=i.length;r--;i[r]*=t);for(i[o=0]+=w.indexOf(e.charAt(a++));i.length>o;o++)i[o]>n-1&&(null==i[o+1]&&(i[o+1]=0),i[o+1]+=i[o]/n|0,i[o]%=n);}return i.reverse()}function u(e,t){return (e.length>1?e.charAt(0)+"."+e.slice(1):e)+(0>t?"e":"e+")+t}function c(e,t){var n,o;if(0>t){for(o="0.";++t;o+="0");e=o+e;}else if(n=e.length,++t>n){for(o="0",t-=n;--t;o+="0");e+=o;}else n>t&&(e=e.slice(0,t)+"."+e.slice(t));return e}function h(e){return 0>(e=parseFloat(e))?p(e):g(e)}var f,d=/^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,p=Math.ceil,g=Math.floor,v=" not a boolean or binary digit",m="rounding mode",y="number type has more than 15 significant digits",w="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_",C=1e14,b=14,_=9007199254740991,S=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],E=1e7,O=1e9;(f=n()).default=f.BigNumber=f,void 0!==t&&t.exports?t.exports=f:(e||(e="undefined"!=typeof self?self:Function("return this")()),e.BigNumber=f);}(this);},{}],2:[function(e,t,n){t.exports={languageTag:"en-US",delimiters:{thousands:",",decimal:"."},abbreviations:{thousand:"k",million:"m",billion:"b",trillion:"t"},spaceSeparated:!1,ordinal:function(e){var t=e%10;return 1==~~(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th"},currency:{symbol:"$",position:"prefix",code:"USD"},currencyFormat:{thousandSeparated:!0,totalLength:4,spaceSeparated:!0},formats:{fourDigits:{totalLength:4,spaceSeparated:!0},fullWithTwoDecimals:{output:"currency",thousandSeparated:!0,mantissa:2},fullWithTwoDecimalsNoCurrency:{thousandSeparated:!0,mantissa:2},fullWithNoDecimals:{output:"currency",thousandSeparated:!0,mantissa:0}}};},{}],3:[function(e,t,n){function o(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments[2];if("string"==typeof t&&(t=N.parseFormat(t)),!A.validateFormat(t))return "ERROR: invalid format";var o=t.prefix||"",i=t.postfix||"",a=r(e,t,n);return a=O(a,o),a=T(a,i)}function r(e,t,n){switch(t.output){case"currency":return t=R(t,D.currentCurrencyDefaultFormat()),d(e,t,D);case"percent":return t=R(t,D.currentPercentageDefaultFormat()),f(e,t,D,n);case"byte":return t=R(t,D.currentByteDefaultFormat()),u(e,t,D,n);case"time":return t=R(t,D.currentTimeDefaultFormat()),h(e);case"ordinal":return t=R(t,D.currentOrdinalDefaultFormat()),c(e,t,D);case"number":default:return k({instance:e,providedFormat:t,numbro:n})}}function i(e){var t=H.decimal;return l(e._value,t.suffixes,t.scale).suffix}function a(e){var t=H.binary;return l(e._value,t.suffixes,t.scale).suffix}function s(e){var t=H.general;return l(e._value,t.suffixes,t.scale).suffix}function l(e,t,n){var o=t[0],r=Math.abs(e);if(r>=n){for(var i=1;t.length>i;++i){var a=Math.pow(n,i),s=Math.pow(n,i+1);if(r>=a&&s>r){o=t[i],e/=a;break}}o===t[0]&&(e/=Math.pow(n,t.length-1),o=t[t.length-1]);}return {value:e,suffix:o}}function u(e,t,n,o){var r=t.base||"binary",i=H[r],a=l(e._value,i.suffixes,i.scale),s=a.value,u=a.suffix;return k({instance:o(s),providedFormat:t,state:n,defaults:n.currentByteDefaultFormat()})+(n.currentAbbreviations().spaced?" ":"")+u}function c(e,t,n){var o=n.currentOrdinal(),r=Object.assign({},L,t),i=k({instance:e,providedFormat:t,state:n}),a=o(e._value);return i+(r.spaceSeparated?" ":"")+a}function h(e){var t=Math.floor(e._value/60/60),n=Math.floor((e._value-60*t*60)/60),o=Math.round(e._value-60*t*60-60*n);return t+":"+(10>n?"0":"")+n+":"+(10>o?"0":"")+o}function f(e,t,n,o){var r=t.prefixSymbol,i=k({instance:o(100*e._value),providedFormat:t,state:n}),a=Object.assign({},L,t);return r?"%"+(a.spaceSeparated?" ":"")+i:i+(a.spaceSeparated?" ":"")+"%"}function d(e,t,n){var o=n.currentCurrency(),r=Object.assign({},L,t),i=void 0,a="",s=!!r.totalLength||!!r.forceAverage||r.average,l=t.currencyPosition||o.position,u=t.currencySymbol||o.symbol;r.spaceSeparated&&(a=" "),"infix"===l&&(i=a+u+a);var c=k({instance:e,providedFormat:t,state:n,decimalSeparator:i});return "prefix"===l&&(c=0>e._value&&"sign"===r.negative?"-"+a+u+c.slice(1):u+a+c),l&&"postfix"!==l||(c=c+(a=s?"":a)+u),c}function p(e){var t=e.value,n=e.forceAverage,o=e.abbreviations,r=e.spaceSeparated,i=void 0!==r&&r,a=e.totalLength,s=void 0===a?0:a,l="",u=Math.abs(t),c=-1;u>=Math.pow(10,12)&&!n||"trillion"===n?(l=o.trillion,t/=Math.pow(10,12)):u<Math.pow(10,12)&&u>=Math.pow(10,9)&&!n||"billion"===n?(l=o.billion,t/=Math.pow(10,9)):u<Math.pow(10,9)&&u>=Math.pow(10,6)&&!n||"million"===n?(l=o.million,t/=Math.pow(10,6)):(u<Math.pow(10,6)&&u>=Math.pow(10,3)&&!n||"thousand"===n)&&(l=o.thousand,t/=Math.pow(10,3));var h=i?" ":"";if(l&&(l=h+l),s){var f=(""+t).split(".")[0];c=Math.max(s-f.length,0);}return {value:t,abbreviation:l,mantissaPrecision:c}}function g(e){var t=e.value,n=e.characteristicPrecision,o=void 0===n?0:n,r=t.toExponential().split("e"),i=M(r,2),a=i[0],s=i[1],l=+a;return o?(o>1&&(l*=Math.pow(10,o-1),s=0>(s=+s-(o-1))?s:"+"+s),{value:l,abbreviation:"e"+s}):{value:l,abbreviation:"e"+s}}function v(e){for(var t="",n=0;e>n;n++)t+="0";return t}function m(e,t){var n=""+e,o=n.split("e"),r=M(o,2),i=r[0],a=r[1],s=i.split("."),l=M(s,2),u=l[0],c=l[1],h=void 0===c?"":c;if(+a>0)n=u+h+v(a-h.length);else{var f=".";f=0>+u?"-0"+f:"0"+f;var d=(v(-a-1)+Math.abs(u)+h).substr(0,t);t>d.length&&(d+=v(t-d.length)),n=f+d;}return +a>0&&t>0&&(n+="."+v(t)),n}function y(e,t){return -1!==(""+e).indexOf("e")?m(e,t):(Math.round(+(e+"e+"+t))/Math.pow(10,t)).toFixed(t)}function w(e,t,n,o,r){if(-1===o)return e;var i=y(t,o),a=(""+i).split("."),s=M(a,2),l=s[0],u=s[1],c=void 0===u?"":u;if(c.match(/^0+$/)&&(n||r))return l;var h=c.match(/0+$/);return r&&h?l+"."+(""+c).slice(0,h.index):""+i}function C(e,t,n,o){var r=e,i=(""+r).split("."),a=M(i,2),s=a[0],l=a[1];if(s.match(/^-?0$/)&&n)return l?s.replace("0","")+"."+l:s.replace("0","");if(o>s.length)for(var u=o-s.length,c=0;u>c;c++)r="0"+r;return ""+r}function b(e,t){for(var n=[],o=0,r=e;r>0;r--)o===t&&(n.unshift(r),o=0),o++;return n}function _(e,t,n,o,r){var i=o.currentDelimiters(),a=i.thousands;r=r||i.decimal;var s=i.thousandsSize||3,l=""+e,u=l.split(".")[0],c=l.split(".")[1];return n&&(0>t&&(u=u.slice(1)),b(u.length,s).forEach(function(e,t){u=u.slice(0,e+t)+a+u.slice(e+t);}),0>t&&(u="-"+u)),l=c?u+r+c:u}function S(e,t){return e+t}function E(e,t,n){return 0===t?e:0==+e?e.replace("-",""):t>0?"+"+e:"sign"===n?e:"("+e.replace("-","")+")"}function O(e,t){return t+e}function T(e,t){return e+t}function k(e){var t=e.instance,n=e.providedFormat,o=e.state,r=void 0===o?D:o,i=e.decimalSeparator,a=e.defaults,s=void 0===a?r.currentDefaults():a,l=t._value;if(0===l&&r.hasZeroFormat())return r.getZeroFormat();if(!isFinite(l))return ""+l;var u=Object.assign({},L,s,n),c=u.totalLength,h=c?0:u.characteristic,f=u.optionalCharacteristic,d=u.forceAverage,v=!!c||!!d||u.average,m=c?-1:v&&void 0===n.mantissa?0:u.mantissa,y=!c&&(void 0===n.optionalMantissa?-1===m:u.optionalMantissa),b=u.trimMantissa,O=u.thousandSeparated,T=u.spaceSeparated,k=u.negative,R=u.forceSign,M=u.exponential,A="";if(v){var N=p({value:l,forceAverage:d,abbreviations:r.currentAbbreviations(),spaceSeparated:T,totalLength:c});l=N.value,A+=N.abbreviation,c&&(m=N.mantissaPrecision);}if(M){var P=g({value:l,characteristicPrecision:h});l=P.value,A=P.abbreviation+A;}var H=w(""+l,l,y,m,b);return H=C(H,l,f,h),H=_(H,l,O,r,i),(v||M)&&(H=S(H,A)),(R||0>l)&&(H=E(H,l,k)),H}function R(e,t){if(!e)return t;var n=Object.keys(e);return 1===n.length&&"output"===n[0]?t:e}var M=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),D=e("./globalState"),A=e("./validating"),N=e("./parsing"),P=["B","KB","MB","GB","TB","PB","EB","ZB","YB"],H={general:{scale:1024,suffixes:P,marker:"bd"},binary:{scale:1024,suffixes:["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"],marker:"b"},decimal:{scale:1e3,suffixes:P,marker:"d"}},L={totalLength:0,characteristic:0,forceAverage:!1,average:!1,mantissa:-1,optionalMantissa:!0,thousandSeparated:!1,spaceSeparated:!1,negative:"sign",forceSign:!1};t.exports=function(e){return {format:function(){for(var t=arguments.length,n=Array(t),r=0;t>r;r++)n[r]=arguments[r];return o.apply(void 0,n.concat([e]))},getByteUnit:function(){for(var t=arguments.length,n=Array(t),o=0;t>o;o++)n[o]=arguments[o];return s.apply(void 0,n.concat([e]))},getBinaryByteUnit:function(){for(var t=arguments.length,n=Array(t),o=0;t>o;o++)n[o]=arguments[o];return a.apply(void 0,n.concat([e]))},getDecimalByteUnit:function(){for(var t=arguments.length,n=Array(t),o=0;t>o;o++)n[o]=arguments[o];return i.apply(void 0,n.concat([e]))},formatOrDefault:R}};},{"./globalState":4,"./parsing":8,"./validating":10}],4:[function(e,t,n){function o(e){u=e;}function r(){return c[u]}var i=e("./en-US"),a=e("./validating"),s=e("./parsing"),l={},u=void 0,c={},h=null,f={};l.languages=function(){return Object.assign({},c)},l.currentLanguage=function(){return u},l.currentCurrency=function(){return r().currency},l.currentAbbreviations=function(){return r().abbreviations},l.currentDelimiters=function(){return r().delimiters},l.currentOrdinal=function(){return r().ordinal},l.currentDefaults=function(){return Object.assign({},r().defaults,f)},l.currentOrdinalDefaultFormat=function(){return Object.assign({},l.currentDefaults(),r().ordinalFormat)},l.currentByteDefaultFormat=function(){return Object.assign({},l.currentDefaults(),r().byteFormat)},l.currentPercentageDefaultFormat=function(){return Object.assign({},l.currentDefaults(),r().percentageFormat)},l.currentCurrencyDefaultFormat=function(){return Object.assign({},l.currentDefaults(),r().currencyFormat)},l.currentTimeDefaultFormat=function(){return Object.assign({},l.currentDefaults(),r().timeFormat)},l.setDefaults=function(e){e=s.parseFormat(e),a.validateFormat(e)&&(f=e);},l.getZeroFormat=function(){return h},l.setZeroFormat=function(e){return h="string"==typeof e?e:null},l.hasZeroFormat=function(){return null!==h},l.languageData=function(e){if(e){if(c[e])return c[e];throw Error('Unknown tag "'+e+'"')}return r()},l.registerLanguage=function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!a.validateLanguage(e))throw Error("Invalid language data");c[e.languageTag]=e,t&&o(e.languageTag);},l.setLanguage=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i.languageTag;if(!c[e]){var n=e.split("-")[0],r=Object.keys(c).find(function(e){return e.split("-")[0]===n});return c[r]?void o(r):void o(t)}o(e);},l.registerLanguage(i),u=i.languageTag,t.exports=l;},{"./en-US":2,"./parsing":8,"./validating":10}],5:[function(e,t,n){function o(t,n){t.forEach(function(t){var o=void 0;try{o=e("../languages/"+t);}catch(e){console.error('Unable to load "'+t+'". No matching language file found.');}o&&n.registerLanguage(o);});}t.exports=function(e){return {loadLanguagesInNode:function(t){return o(t,e)}}};},{}],6:[function(e,t,n){function o(e,t,n){var o=new u(e._value),r=t;return n.isNumbro(t)&&(r=t._value),r=new u(r),e._value=o.add(r).toNumber(),e}function r(e,t,n){var o=new u(e._value),r=t;return n.isNumbro(t)&&(r=t._value),r=new u(r),e._value=o.minus(r).toNumber(),e}function i(e,t,n){var o=new u(e._value),r=t;return n.isNumbro(t)&&(r=t._value),r=new u(r),e._value=o.times(r).toNumber(),e}function a(e,t,n){var o=new u(e._value),r=t;return n.isNumbro(t)&&(r=t._value),r=new u(r),e._value=o.dividedBy(r).toNumber(),e}function s(e,t,n){var o=t;return n.isNumbro(t)&&(o=t._value),e._value=o,e}function l(e,t,n){var o=n(e._value);return r(o,t,n),Math.abs(o._value)}var u=e("bignumber.js");t.exports=function(e){return {add:function(t,n){return o(t,n,e)},subtract:function(t,n){return r(t,n,e)},multiply:function(t,n){return i(t,n,e)},divide:function(t,n){return a(t,n,e)},set:function(t,n){return s(t,n,e)},difference:function(t,n){return l(t,n,e)}}};},{"bignumber.js":1}],7:[function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e){var t=e;return i.isNumbro(e)?t=e._value:"string"==typeof e?t=i.unformat(e):isNaN(e)&&(t=NaN),t}function i(e){return new p(r(e))}var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=e("./globalState"),l=e("./validating"),u=e("./loading")(i),c=e("./unformatting"),h=e("./formatting")(i),f=e("./manipulating")(i),d=e("./parsing"),p=function(){function e(t){o(this,e),this._value=t;}return a(e,[{key:"clone",value:function(){return i(this._value)}},{key:"format",value:function(){return h.format(this,arguments.length>0&&void 0!==arguments[0]?arguments[0]:{})}},{key:"formatCurrency",value:function(e){return "string"==typeof e&&(e=d.parseFormat(e)),e=h.formatOrDefault(e,s.currentCurrencyDefaultFormat()),e.output="currency",h.format(this,e)}},{key:"formatTime",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.output="time",h.format(this,e)}},{key:"binaryByteUnits",value:function(){return h.getBinaryByteUnit(this)}},{key:"decimalByteUnits",value:function(){return h.getDecimalByteUnit(this)}},{key:"byteUnits",value:function(){return h.getByteUnit(this)}},{key:"difference",value:function(e){return f.difference(this,e)}},{key:"add",value:function(e){return f.add(this,e)}},{key:"subtract",value:function(e){return f.subtract(this,e)}},{key:"multiply",value:function(e){return f.multiply(this,e)}},{key:"divide",value:function(e){return f.divide(this,e)}},{key:"set",value:function(e){return f.set(this,r(e))}},{key:"value",value:function(){return this._value}},{key:"valueOf",value:function(){return this._value}}]),e}();i.version="2.1.1",i.isNumbro=function(e){return e instanceof p},i.language=s.currentLanguage,i.registerLanguage=s.registerLanguage,i.setLanguage=s.setLanguage,i.languages=s.languages,i.languageData=s.languageData,i.zeroFormat=s.setZeroFormat,i.defaultFormat=s.currentDefaults,i.setDefaults=s.setDefaults,i.defaultCurrencyFormat=s.currentCurrencyDefaultFormat,i.validate=l.validate,i.loadLanguagesInNode=u.loadLanguagesInNode,i.unformat=c.unformat,t.exports=i;},{"./formatting":3,"./globalState":4,"./loading":5,"./manipulating":6,"./parsing":8,"./unformatting":9,"./validating":10}],8:[function(e,t,n){function o(e,t){var n=e.match(/^{([^}]*)}/);return n?(t.prefix=n[1],e.slice(n[0].length)):e}function r(e,t){var n=e.match(/{([^}]*)}$/);return n?(t.postfix=n[1],e.slice(0,-n[0].length)):e}function i(e,t){if(-1===e.indexOf("$")){if(-1===e.indexOf("%"))return -1!==e.indexOf("bd")?(t.output="byte",void(t.base="general")):-1!==e.indexOf("b")?(t.output="byte",void(t.base="binary")):-1!==e.indexOf("d")?(t.output="byte",void(t.base="decimal")):void(-1===e.indexOf(":")?-1!==e.indexOf("o")&&(t.output="ordinal"):t.output="time");t.output="percent";}else t.output="currency";}function a(e,t){-1!==e.indexOf(",")&&(t.thousandSeparated=!0);}function s(e,t){-1!==e.indexOf(" ")&&(t.spaceSeparated=!0);}function l(e,t){var n=e.match(/[1-9]+[0-9]*/);n&&(t.totalLength=+n[0]);}function u(e,t){var n=e.split(".")[0].match(/0+/);n&&(t.characteristic=n[0].length);}function c(e,t){var n=e.split(".")[1];if(n){var o=n.match(/0+/);o&&(t.mantissa=o[0].length);}}function h(e,t){-1!==e.indexOf("a")&&(t.average=!0);}function f(e,t){-1!==e.indexOf("K")?t.forceAverage="thousand":-1!==e.indexOf("M")?t.forceAverage="million":-1!==e.indexOf("B")?t.forceAverage="billion":-1!==e.indexOf("T")&&(t.forceAverage="trillion");}function d(e,t){e.match(/\[\.]/)?t.optionalMantissa=!0:e.match(/\./)&&(t.optionalMantissa=!1);}function p(e,t){if(-1!==e.indexOf(".")){t.optionalCharacteristic=-1===e.split(".")[0].indexOf("0");}}function g(e,t){e.match(/^\+?\([^)]*\)$/)&&(t.negative="parenthesis"),e.match(/^\+?-/)&&(t.negative="sign");}function v(e,t){e.match(/^\+/)&&(t.forceSign=!0);}t.exports={parseFormat:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return "string"!=typeof e?e:(e=o(e,t),e=r(e,t),i(e,t),l(e,t),u(e,t),p(e,t),h(e,t),f(e,t),c(e,t),d(e,t),a(e,t),s(e,t),g(e,t),v(e,t),t)}};},{}],9:[function(e,t,n){function o(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function r(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",i=arguments[3],a=arguments[4],s=arguments[5],l=arguments[6];if(!isNaN(+e))return +e;var c="",h=e.replace(/(^[^(]*)\((.*)\)([^)]*$)/,"$1$2$3");if(h!==e)return -1*r(h,t,n,i,a,s,l);for(var f=0;u.length>f;f++){var d=u[f];if((c=e.replace(d.key,""))!==e)return r(c,t,n,i,a,s,l)*d.factor}if((c=e.replace("%",""))!==e)return r(c,t,n,i,a,s,l)/100;var p=parseFloat(e);if(!isNaN(p)){var g=i(p);if(g&&"."!==g&&(c=e.replace(RegExp(o(g)+"$"),""))!==e)return r(c,t,n,i,a,s,l);var v={};Object.keys(s).forEach(function(e){v[s[e]]=e;});for(var m=Object.keys(v).sort().reverse(),y=m.length,w=0;y>w;w++){var C=m[w],b=v[C];if((c=e.replace(C,""))!==e){var _=void 0;switch(b){case"thousand":_=Math.pow(10,3);break;case"million":_=Math.pow(10,6);break;case"billion":_=Math.pow(10,9);break;case"trillion":_=Math.pow(10,12);}return r(c,t,n,i,a,s,l)*_}}}}function i(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",r=e.replace(n,"");return r=r.replace(RegExp("([0-9])"+o(t.thousands)+"([0-9])","g"),"$1$2"),r=r.replace(t.decimal,".")}function a(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",o=arguments[3],a=arguments[4],s=arguments[5],l=arguments[6];if(""!==e)return isNaN(+e)?e===a?0:r(i(e,t,n),t,n,o,a,s,l):+e}function s(e,t){if(!e.indexOf(":")||":"===t.thousands)return !1;var n=e.split(":");if(3!==n.length)return !1;var o=+n[0],r=+n[1],i=+n[2];return !isNaN(o)&&!isNaN(r)&&!isNaN(i)}function l(e){var t=e.split(":");return +t[2]+60*+t[1]+3600*+t[0]}var u=[{key:"ZiB",factor:Math.pow(1024,7)},{key:"ZB",factor:Math.pow(1e3,7)},{key:"YiB",factor:Math.pow(1024,8)},{key:"YB",factor:Math.pow(1e3,8)},{key:"TiB",factor:Math.pow(1024,4)},{key:"TB",factor:Math.pow(1e3,4)},{key:"PiB",factor:Math.pow(1024,5)},{key:"PB",factor:Math.pow(1e3,5)},{key:"MiB",factor:Math.pow(1024,2)},{key:"MB",factor:Math.pow(1e3,2)},{key:"KiB",factor:Math.pow(1024,1)},{key:"KB",factor:Math.pow(1e3,1)},{key:"GiB",factor:Math.pow(1024,3)},{key:"GB",factor:Math.pow(1e3,3)},{key:"EiB",factor:Math.pow(1024,6)},{key:"EB",factor:Math.pow(1e3,6)},{key:"B",factor:1}];t.exports={unformat:function(t,n){var o=e("./globalState"),r=o.currentDelimiters(),i=o.currentCurrency().symbol,u=o.currentOrdinal(),c=o.getZeroFormat(),h=o.currentAbbreviations(),f=void 0;if("string"==typeof t)f=s(t,r)?l(t):a(t,r,i,u,c,h,n);else{if("number"!=typeof t)return;f=t;}if(void 0!==f)return f}};},{"./globalState":4}],10:[function(e,t,n){function o(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);e.length>t;t++)n[t]=e[t];return n}return Array.from(e)}function r(e){return !!l.unformat(e)}function i(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=Object.keys(e).map(function(o){if(!t[o])return console.error(n+" Invalid key: "+o),!1;var r=e[o],a=t[o];if("string"==typeof a&&(a={type:a}),"format"===a.type){if(!i(r,c,"[Validate "+o+"]",!0))return !1}else if((void 0===r?"undefined":s(r))!==a.type)return console.error(n+" "+o+' type mismatched: "'+a.type+'" expected, "'+(void 0===r?"undefined":s(r))+'" provided'),!1;if(a.restrictions&&a.restrictions.length)for(var l=a.restrictions.length,u=0;l>u;u++){var h=a.restrictions[u],f=h.restriction,d=h.message;if(!f(r,e))return console.error(n+" "+o+" invalid value: "+d),!1}return a.restriction&&!a.restriction(r,e)?(console.error(n+" "+o+" invalid value: "+a.message),!1):a.validValues&&-1===a.validValues.indexOf(r)?(console.error(n+" "+o+" invalid value: must be among "+JSON.stringify(a.validValues)+', "'+r+'" provided'),!1):!(a.children&&!i(r,a.children,"[Validate "+o+"]"))});return r||a.push.apply(a,o(Object.keys(t).map(function(o){var r=t[o];if("string"==typeof r&&(r={type:r}),r.mandatory){var i=r.mandatory;if("function"==typeof i&&(i=i(e)),i&&void 0===e[o])return console.error(n+' Missing mandatory key "'+o+'"'),!1}return !0}))),a.reduce(function(e,t){return e&&t},!0)}function a(e){return i(e,c,"[Validate format]")}var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},l=e("./unformatting"),u=/^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/,c={output:{type:"string",validValues:["currency","percent","byte","time","ordinal","number"]},base:{type:"string",validValues:["decimal","binary","general"],restriction:function(e,t){return "byte"===t.output},message:"`base` must be provided only when the output is `byte`",mandatory:function(e){return "byte"===e.output}},characteristic:{type:"number",restriction:function(e){return e>=0},message:"value must be positive"},prefix:"string",postfix:"string",forceAverage:{type:"string",validValues:["trillion","billion","million","thousand"]},average:"boolean",currencyPosition:{type:"string",validValues:["prefix","infix","postfix"]},currencySymbol:"string",totalLength:{type:"number",restrictions:[{restriction:function(e){return e>=0},message:"value must be positive"},{restriction:function(e,t){return !t.exponential},message:"`totalLength` is incompatible with `exponential`"}]},mantissa:{type:"number",restriction:function(e){return e>=0},message:"value must be positive"},optionalMantissa:"boolean",trimMantissa:"boolean",optionalCharacteristic:"boolean",thousandSeparated:"boolean",spaceSeparated:"boolean",abbreviations:{type:"object",children:{thousand:"string",million:"string",billion:"string",trillion:"string"}},negative:{type:"string",validValues:["sign","parenthesis"]},forceSign:"boolean",exponential:{type:"boolean"},prefixSymbol:{type:"boolean",restriction:function(e,t){return "percent"===t.output},message:"`prefixSymbol` can be provided only when the output is `percent`"}},h={languageTag:{type:"string",mandatory:!0,restriction:function(e){return e.match(u)},message:"the language tag must follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)"},delimiters:{type:"object",children:{thousands:"string",decimal:"string",thousandsSize:"number"},mandatory:!0},abbreviations:{type:"object",children:{thousand:{type:"string",mandatory:!0},million:{type:"string",mandatory:!0},billion:{type:"string",mandatory:!0},trillion:{type:"string",mandatory:!0}},mandatory:!0},spaceSeparated:"boolean",ordinal:{type:"function",mandatory:!0},currency:{type:"object",children:{symbol:"string",position:"string",code:"string"},mandatory:!0},defaults:"format",ordinalFormat:"format",byteFormat:"format",percentageFormat:"format",currencyFormat:"format",timeDefaults:"format",formats:{type:"object",children:{fourDigits:{type:"format",mandatory:!0},fullWithTwoDecimals:{type:"format",mandatory:!0},fullWithTwoDecimalsNoCurrency:{type:"format",mandatory:!0},fullWithNoDecimals:{type:"format",mandatory:!0}}}};t.exports={validate:function(e,t){var n=r(e),o=a(t);return n&&o},validateFormat:a,validateInput:r,validateLanguage:function(e){return i(e,h,"[Validate language]")}};},{"./unformatting":9}]},{},[7])(7)}),window.numbro=n(436);},function(e,t,n){function o(e){var t=new Date(e);return isNaN(new Date(e+"T00:00").getDate())?t:new Date(t.getTime()+6e4*t.getTimezoneOffset())}t.__esModule=!0,t.getNormalizedDate=o;},function(e,t,n){!function(e){function n(e){return e.split('"').length-1}var o={parse:function(e){var t,o,r,i,a,s,l,u=[],c=0;for(r=e.split("\n"),r.length>1&&""===r[r.length-1]&&r.pop(),t=0,o=r.length;o>t;t+=1){for(r[t]=r[t].split("\t"),i=0,a=r[t].length;a>i;i+=1)u[c]||(u[c]=[]),s&&0===i?(l=u[c].length-1,u[c][l]=u[c][l]+"\n"+r[t][0],s&&1&n(r[t][0])&&(s=!1,u[c][l]=u[c][l].substring(0,u[c][l].length-1).replace(/""/g,'"'))):i===a-1&&0===r[t][i].indexOf('"')&&1&n(r[t][i])?(u[c].push(r[t][i].substring(1).replace(/""/g,'"')),s=!0):(u[c].push(r[t][i].replace(/""/g,'"')),s=!1);s||(c+=1);}return u},stringify:function(e){var t,n,o,r,i,a="";for(t=0,n=e.length;n>t;t+=1){for(r=e[t].length,o=0;r>o;o+=1)o>0&&(a+="\t"),i=e[t][o],"string"==typeof i?i.indexOf("\n")>-1?a+='"'+i.replace(/"/g,'""')+'"':a+=i:a+=null===i||void 0===i?"":i;t!==n-1&&(a+="\n");}return a}};t.parse=o.parse,t.stringify=o.stringify;}();},function(e,t,n){function o(e){var t=e.isShiftKey,n=e.isLeftClick,o=e.isRightClick,r=e.coords,i=e.selection,a=e.controller,l=i.isSelected()?i.getSelectedRange().current():null,u=i.isSelectedByCorner(),c=i.isSelectedByRowHeader();if(t&&l)0>r.row||0>r.col||a.cells?!u&&!c||0>r.row||0>r.col||a.cells?u&&0>r.row&&!a.column?i.setRangeEnd(new s.CellCoords(l.to.row,r.col)):c&&0>r.col&&!a.row?i.setRangeEnd(new s.CellCoords(r.row,l.to.col)):(!u&&!c&&0>r.col||u&&0>r.col)&&!a.row?i.selectRows(l.from.row,r.row):(!u&&!c&&0>r.row||c&&0>r.row)&&!a.column&&i.selectColumns(l.from.col,r.col):i.setRangeEnd(new s.CellCoords(r.row,r.col)):i.setRangeEnd(r);else{var h=new s.CellCoords(r.row,r.col);0>h.row&&(h.row=0),0>h.col&&(h.col=0);var f=!i.inInSelection(h),d=n||o&&f;r.row>=0||0>r.col||a.column?r.col>=0||0>r.row||a.row?0>r.col||0>r.row||a.cells?0>r.col&&0>r.row&&i.setRangeStart(r):d&&i.setRangeStart(r):d&&i.selectRows(r.row):d&&i.selectColumns(r.col);}}function r(e){var t=e.isLeftClick,n=e.coords,o=e.selection,r=e.controller;if(t){var i=o.isSelectedByRowHeader(),a=o.isSelectedByColumnHeader(),l=o.tableProps.countCols(),u=o.tableProps.countRows();a&&!r.column?o.setRangeEnd(new s.CellCoords(u-1,n.col)):i&&!r.row?o.setRangeEnd(new s.CellCoords(n.row,l-1)):r.cell||o.setRangeEnd(n);}}function i(e,t){var n=t.coords,o=t.selection,r=t.controller;l.get(e.type)({coords:n,selection:o,controller:r,isShiftKey:e.shiftKey,isLeftClick:(0, a.isLeftClick)(e)||"touchstart"===e.type,isRightClick:(0, a.isRightClick)(e)});}t.__esModule=!0,t.mouseDown=o,t.mouseOver=r,t.handleMouseEvent=i;var a=n(12),s=n(4),l=new Map([["mousedown",o],["mouseover",r],["touchstart",o]]);},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){f.set(e,t);}function i(e){var t=e instanceof u.default?e:a(e),n=void 0;return d.has(t)?n=d.get(t):(n=new h(t),d.set(t,n)),n}function a(e){if(!f.has(e))throw Error("Record translator was not registered for this object identity");return f.get(e)}t.__esModule=!0,t.RecordTranslator=void 0;var s=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}();t.registerIdentity=r,t.getTranslator=i,t.getIdentity=a;var l=n(90),u=function(e){return e&&e.__esModule?e:{default:e}}(l),c=n(1),h=t.RecordTranslator=function(){function e(t){o(this,e),this.hot=t;}return s(e,[{key:"toVisualRow",value:function(e){return this.hot.runHooks("unmodifyRow",e)}},{key:"toVisualColumn",value:function(e){return this.hot.runHooks("unmodifyCol",e)}},{key:"toVisual",value:function(e,t){return (0, c.isObject)(e)?{row:this.toVisualRow(e.row),column:this.toVisualColumn(e.column)}:[this.toVisualRow(e),this.toVisualColumn(t)]}},{key:"toPhysicalRow",value:function(e){return this.hot.runHooks("modifyRow",e)}},{key:"toPhysicalColumn",value:function(e){return this.hot.runHooks("modifyCol",e)}},{key:"toPhysical",value:function(e,t){return (0, c.isObject)(e)?{row:this.toPhysicalRow(e.row),column:this.toPhysicalColumn(e.column)}:[this.toPhysicalRow(e),this.toPhysicalColumn(t)]}}]),e}(),f=new WeakMap,d=new WeakMap;},function(e,t,n){function o(e){a.set(e,!0);}function r(e){return e===s}function i(e){return a.has(e)}t.__esModule=!0,t.registerAsRootInstance=o,t.hasValidParameter=r,t.isRootInstance=i;var a=t.holder=new WeakMap,s=t.rootInstanceSymbol=Symbol("rootInstance");},function(e,t,n){function o(){}t.__esModule=!0;var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=n(10),a=n(1);o.prototype={licenseKey:"trial",data:void 0,dataSchema:void 0,width:void 0,height:void 0,startRows:5,startCols:5,rowHeaders:void 0,colHeaders:null,colWidths:void 0,rowHeights:void 0,columns:void 0,cells:void 0,cell:[],comments:!1,customBorders:!1,minRows:0,minCols:0,maxRows:1/0,maxCols:1/0,minSpareRows:0,minSpareCols:0,allowInsertRow:!0,allowInsertColumn:!0,allowRemoveRow:!0,allowRemoveColumn:!0,selectionMode:"multiple",fillHandle:{autoInsertRow:!1},fixedRowsTop:0,fixedRowsBottom:0,fixedColumnsLeft:0,outsideClickDeselects:!0,enterBeginsEditing:!0,enterMoves:{row:1,col:0},tabMoves:{row:0,col:1},autoWrapRow:!0,autoWrapCol:!0,persistentState:void 0,currentRowClassName:void 0,currentColClassName:void 0,currentHeaderClassName:"ht__highlight",activeHeaderClassName:"ht__active_highlight",className:void 0,tableClassName:void 0,stretchH:"none",isEmptyRow:function(e){var t=void 0,n=void 0,o=void 0,s=void 0;for(t=0,n=this.countCols();n>t;t++)if(""!==(o=this.getDataAtCell(e,t))&&null!==o&&(0, i.isDefined)(o))return "object"===(void 0===o?"undefined":r(o))&&(s=this.getCellMeta(e,t),(0, a.isObjectEqual)(this.getSchema()[s.prop],o));return !0},isEmptyCol:function(e){var t=void 0,n=void 0,o=void 0;for(t=0,n=this.countRows();n>t;t++)if(""!==(o=this.getDataAtCell(t,e))&&null!==o&&(0, i.isDefined)(o))return !1;return !0},observeDOMVisibility:!0,allowInvalid:!0,allowEmpty:!0,invalidCellClassName:"htInvalid",placeholder:void 0,placeholderCellClassName:"htPlaceholder",readOnlyCellClassName:"htDimmed",renderer:void 0,commentedCellClassName:"htCommentCell",fragmentSelection:!1,readOnly:!1,skipColumnOnPaste:!1,search:!1,type:"text",copyable:!0,editor:void 0,visibleRows:10,trimDropdown:!0,debug:!1,wordWrap:!0,noWordWrapClassName:"htNoWrap",contextMenu:void 0,copyPaste:!0,undo:void 0,columnSorting:void 0,manualColumnMove:void 0,manualColumnResize:void 0,manualRowMove:void 0,manualRowResize:void 0,mergeCells:!1,multiColumnSorting:void 0,viewportRowRenderingOffset:"auto",viewportColumnRenderingOffset:"auto",validator:void 0,disableVisualSelection:!1,manualColumnFreeze:void 0,trimWhitespace:!0,source:void 0,title:void 0,checkedTemplate:void 0,uncheckedTemplate:void 0,label:void 0,numericFormat:void 0,language:"en-US",selectOptions:void 0,autoColumnSize:void 0,autoRowSize:void 0,dateFormat:"DD/MM/YYYY",correctFormat:!1,defaultDate:void 0,strict:void 0,allowHtml:!1,renderAllRows:void 0,preventOverflow:!1,bindRowsWithHeaders:void 0,collapsibleColumns:void 0,columnSummary:void 0,dropdownMenu:void 0,filters:void 0,formulas:void 0,ganttChart:void 0,headerTooltips:void 0,hiddenColumns:void 0,hiddenRows:void 0,nestedHeaders:void 0,trimRows:void 0,rowHeaderWidth:void 0,columnHeaderHeight:void 0,observeChanges:void 0,sortByRelevance:!0,filter:!0,filteringCaseSensitive:!1,dragToScroll:!0,nestedRows:void 0},t.default=o;},function(e,t,n){function o(e,t,n){var o=(0, a.getLanguageDictionary)(e);if(null===o)return null;var i=o[t];if((0, l.isUndefined)(i))return null;var s=r(i,n);return Array.isArray(s)?s[0]:s}function r(e,t){var n=e;return (0, i.arrayEach)((0, s.getPhraseFormatters)(),function(o){n=o(e,t);}),n}t.__esModule=!0,t.getTranslatedPhrase=o;var i=n(2),a=n(72),s=n(521),l=n(10);},function(e,t,n){function o(e,t){return (0, c.objectEach)(t,function(t,n){(0, u.isUndefined)(e[n])&&(e[n]=t);}),e}function r(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t,r=n,i=o;if(e>t){var a=[i,r];r=a[0],i=a[1];}return r+"-"+i}function i(e){var t=/^([a-zA-Z]{2})-([a-zA-Z]{2})$/,n=t.exec(e);return n?n[1].toLowerCase()+"-"+n[2].toUpperCase():e}function a(e,t){var n=i(t);(0, d.hasLanguageDictionary)(n)?e.language=n:(e.language=d.DEFAULT_LANGUAGE_CODE,s(t));}function s(e){(0, u.isDefined)(e)&&(0, h.error)((0, f.toSingleLine)(l,e));}t.__esModule=!0;var l=function(e,t){return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}(['Language with code "','" was not found. You should register particular language \n    before using it. Read more about this issue at: https://docs.handsontable.com/i18n/missing-language-code.'],['Language with code "','" was not found. You should register particular language \n    before using it. Read more about this issue at: https://docs.handsontable.com/i18n/missing-language-code.']);t.extendNotExistingKeys=o,t.createCellHeadersRange=r,t.normalizeLanguageCode=i,t.applyLanguageSetting=a,t.warnUserAboutLanguageRegistration=s;var u=n(10),c=n(1),h=n(58),f=n(42),d=n(72);},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0,t.normalizeSelectionFactory=t.detectSelectionType=t.Selection=t.Highlight=t.handleMouseEvent=void 0;var r=n(446),i=o(r),a=n(530),s=o(a),l=n(439),u=n(73);t.handleMouseEvent=l.handleMouseEvent,t.Highlight=i.default,t.Selection=s.default,t.detectSelectionType=u.detectSelectionType,t.normalizeSelectionFactory=u.normalizeSelectionFactory;},function(e,t,n){function o(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);e.length>t;t++)n[t]=e[t];return n}return Array.from(e)}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0,t.CUSTOM_SELECTION=t.HEADER_TYPE=t.FILL_TYPE=t.CELL_TYPE=t.AREA_TYPE=t.ACTIVE_HEADER_TYPE=void 0;var i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(523),s=n(2),l=t.ACTIVE_HEADER_TYPE="active-header",u=t.AREA_TYPE="area",c=t.CELL_TYPE="cell",h=t.FILL_TYPE="fill",f=t.HEADER_TYPE="header",d=t.CUSTOM_SELECTION="custom-selection";t.default=function(){function e(t){r(this,e),this.options=t,this.layerLevel=0,this.cell=(0, a.createHighlight)(c,t),this.fill=(0, a.createHighlight)(h,t),this.areas=new Map,this.headers=new Map,this.activeHeaders=new Map,this.customSelections=[];}return i(e,[{key:"isEnabledFor",value:function(e){var t="current"===e?c:e,n=this.options.disableHighlight;return "string"==typeof n&&(n=[n]),!1===n||Array.isArray(n)&&!n.includes(t)}},{key:"useLayerLevel",value:function(){return this.layerLevel=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,this}},{key:"getCell",value:function(){return this.cell}},{key:"getFill",value:function(){return this.fill}},{key:"createOrGetArea",value:function(){var e=this.layerLevel,t=void 0;return this.areas.has(e)?t=this.areas.get(e):(t=(0, a.createHighlight)(u,Object.assign({layerLevel:e},this.options)),this.areas.set(e,t)),t}},{key:"getAreas",value:function(){return [].concat(o(this.areas.values()))}},{key:"createOrGetHeader",value:function(){var e=this.layerLevel,t=void 0;return this.headers.has(e)?t=this.headers.get(e):(t=(0, a.createHighlight)(f,Object.assign({},this.options)),this.headers.set(e,t)),t}},{key:"getHeaders",value:function(){return [].concat(o(this.headers.values()))}},{key:"createOrGetActiveHeader",value:function(){var e=this.layerLevel,t=void 0;return this.activeHeaders.has(e)?t=this.activeHeaders.get(e):(t=(0, a.createHighlight)(l,Object.assign({},this.options)),this.activeHeaders.set(e,t)),t}},{key:"getActiveHeaders",value:function(){return [].concat(o(this.activeHeaders.values()))}},{key:"getCustomSelections",value:function(){return [].concat(o(this.customSelections.values()))}},{key:"addCustomSelection",value:function(e){this.customSelections.push((0, a.createHighlight)(d,Object.assign({},e)));}},{key:"clear",value:function(){this.cell.clear(),this.fill.clear(),(0, s.arrayEach)(this.areas.values(),function(e){return void e.clear()}),(0, s.arrayEach)(this.headers.values(),function(e){return void e.clear()}),(0, s.arrayEach)(this.activeHeaders.values(),function(e){return void e.clear()});}},{key:Symbol.iterator,value:function(){return [this.cell,this.fill].concat(o(this.areas.values()),o(this.headers.values()),o(this.activeHeaders.values()),o(this.customSelections))[Symbol.iterator]()}}]),e}();},function(e,t,n){function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(1),s=n(5),l=n(10);t.default=function(){function e(t){r(this,e),this.samples=null,this.dataFactory=t,this.customSampleCount=null,this.allowDuplicates=!1;}return i(e,null,[{key:"SAMPLE_COUNT",get:function(){return 3}}]),i(e,[{key:"getSampleCount",value:function(){return this.customSampleCount?this.customSampleCount:e.SAMPLE_COUNT}},{key:"setSampleCount",value:function(e){this.customSampleCount=e;}},{key:"setAllowDuplicates",value:function(e){this.allowDuplicates=e;}},{key:"generateRowSamples",value:function(e,t){return this.generateSamples("row",t,e)}},{key:"generateColumnSamples",value:function(e,t){return this.generateSamples("col",t,e)}},{key:"generateSamples",value:function(e,t,n){var o=this,r=new Map,i="number"==typeof n?{from:n,to:n}:n;return (0, s.rangeEach)(i.from,i.to,function(n){var i=o.generateSample(e,t,n);r.set(n,i);}),r}},{key:"generateSample",value:function(e,t,n){var r=this;if("row"!==e&&"col"!==e)throw Error("Unsupported sample type");var i=new Map,u="row"===e?"col":"row",c=[];return (0, s.rangeEach)(t.from,t.to,function(t){var s="row"===e?r.dataFactory(n,t):r.dataFactory(t,n),h=s.value,f=s.bundleCountSeed,d=f>0,p=void 0;p=(0, a.isObject)(h)?Object.keys(h).length:Array.isArray(h)?h.length:(0, l.stringify)(h).length,d&&(p+=f),i.has(p)||i.set(p,{needed:r.getSampleCount(),strings:[]});var g=i.get(p);if(g.needed){(!(c.indexOf(h)>-1)||r.allowDuplicates||d)&&(g.strings.push(o({value:h},u,t)),c.push(h),g.needed-=1);}}),i}}]),e}();},function(e,t,n){function o(e){if((0, u.isUndefined)(e))return !1;var t=e.column,n=e.sortOrder;return Number.isInteger(t)&&[f,d].includes(n)}function r(e){if(!1===Array.isArray(e)||!1===e.every(function(e){return (0, c.isObject)(e)}))return !1;var t=e.map(function(e){return e.column});return new Set(t).size===t.length&&e.every(o)}function i(e){if(e!==d)return e===f?d:f}function a(e){return e.querySelector("."+p)}function s(e,t){if(0>e||!t.parentNode)return !1;var n=t.parentNode.parentNode.childNodes;return -1==Array.from(n).indexOf(t.parentNode)-n.length}function l(e,t,n){return -1===e&&t>=0&&!1===(0, h.isRightClick)(n)}t.__esModule=!0,t.HEADER_SPAN_CLASS=t.DESC_SORT_STATE=t.ASC_SORT_STATE=void 0,t.areValidSortStates=r,t.getNextSortOrder=i,t.getHeaderSpanElement=a,t.isFirstLevelColumnHeader=s,t.wasHeaderClickedProperly=l;var u=n(10),c=n(1),h=n(12),f=t.ASC_SORT_STATE="asc",d=t.DESC_SORT_STATE="desc",p=t.HEADER_SPAN_CLASS="colHeader";},function(e,t,n){function o(e){return h(f(e)?e:r.COLUMN_DATA_TYPE)}t.__esModule=!0,t.getRootComparator=t.registerRootComparator=void 0,t.getCompareFunctionFactory=o;var r=n(546),i=n(547),a=n(548),s=n(34),l=function(e){return e&&e.__esModule?e:{default:e}}(s),u=(0, l.default)("sorting.compareFunctionFactory"),c=u.register,h=u.getItem,f=u.hasItem,d=(0, l.default)("sorting.mainSortComparator"),p=d.register,g=d.getItem;c(i.COLUMN_DATA_TYPE,i.compareFunctionFactory),c(a.COLUMN_DATA_TYPE,a.compareFunctionFactory),c(r.COLUMN_DATA_TYPE,r.compareFunctionFactory),t.registerRootComparator=p,t.getRootComparator=g;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(5),a=0;t.default=function(){function e(t){o(this,e),this.hot=t,this._element=null,this.state=a;}return r(e,[{key:"appendTo",value:function(e){e.appendChild(this._element),this.state=2;}},{key:"build",value:function(){this._element=document.createElement("div"),this.state=1;}},{key:"destroy",value:function(){this.isAppended()&&this._element.parentElement.removeChild(this._element),this._element=null,this.state=a;}},{key:"isAppended",value:function(){return 2===this.state}},{key:"isBuilt",value:function(){return this.state>=1}},{key:"setPosition",value:function(e,t){(0, i.isNumeric)(e)&&(this._element.style.top=e+"px"),(0, i.isNumeric)(t)&&(this._element.style.left=t+"px");}},{key:"getPosition",value:function(){return {top:this._element.style.top?parseInt(this._element.style.top,10):0,left:this._element.style.left?parseInt(this._element.style.left,10):0}}},{key:"setSize",value:function(e,t){(0, i.isNumeric)(e)&&(this._element.style.width=e+"px"),(0, i.isNumeric)(t)&&(this._element.style.height=t+"px");}},{key:"getSize",value:function(){return {width:this._element.style.width?parseInt(this._element.style.width,10):0,height:this._element.style.height?parseInt(this._element.style.height,10):0}}},{key:"setOffset",value:function(e,t){(0, i.isNumeric)(e)&&(this._element.style.marginTop=e+"px"),(0, i.isNumeric)(t)&&(this._element.style.marginLeft=t+"px");}},{key:"getOffset",value:function(){return {top:this._element.style.marginTop?parseInt(this._element.style.marginTop,10):0,left:this._element.style.marginLeft?parseInt(this._element.style.marginLeft,10):0}}}]),e}();},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=0;t.default=function(){function e(t){o(this,e),this.hot=t,this._element=null,this.state=i;}return r(e,[{key:"appendTo",value:function(e){e.appendChild(this._element),this.state=2;}},{key:"build",value:function(){this._element=document.createElement("div"),this.state=1;}},{key:"destroy",value:function(){this.isAppended()&&this._element.parentElement.removeChild(this._element),this._element=null,this.state=i;}},{key:"isAppended",value:function(){return 2===this.state}},{key:"isBuilt",value:function(){return this.state>=1}},{key:"setPosition",value:function(e,t){void 0!==e&&(this._element.style.top=e+"px"),void 0!==t&&(this._element.style.left=t+"px");}},{key:"getPosition",value:function(){return {top:this._element.style.top?parseInt(this._element.style.top,10):0,left:this._element.style.left?parseInt(this._element.style.left,10):0}}},{key:"setSize",value:function(e,t){e&&(this._element.style.width=e+"px"),t&&(this._element.style.height=t+"px");}},{key:"getSize",value:function(){return {width:this._element.style.width?parseInt(this._element.style.width,10):0,height:this._element.style.height?parseInt(this._element.style.height,10):0}}},{key:"setOffset",value:function(e,t){e&&(this._element.style.marginTop=e+"px"),t&&(this._element.style.marginLeft=t+"px");}},{key:"getOffset",value:function(){return {top:this._element.style.marginTop?parseInt(this._element.style.marginTop,10):0,left:this._element.style.marginLeft?parseInt(this._element.style.marginLeft,10):0}}}]),e}();},function(e,t,n){function o(e,t,n,o){t?t.row===n&&t.col===o?(e.setAttribute("rowspan",""+t.rowspan),e.setAttribute("colspan",""+t.colspan)):(e.removeAttribute("rowspan"),e.removeAttribute("colspan"),e.style.display="none"):(e.removeAttribute("rowspan"),e.removeAttribute("colspan"),e.style.display="");}t.__esModule=!0,t.applySpanProperties=o;},function(e,t,n){function o(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){var n=new h.default(e,t||{},Q.rootInstanceSymbol);return n.init(),n}t.__esModule=!0,n(99),n(114),n(115),n(119),n(120),n(122),n(125),n(126),n(127),n(128),n(129),n(130),n(131),n(132),n(133),n(134),n(135),n(136),n(137),n(138),n(139),n(140),n(141),n(142),n(144),n(146),n(147),n(148),n(149),n(150),n(151),n(152),n(153),n(154),n(155),n(156),n(157),n(158),n(88),n(159),n(160),n(162),n(163),n(164),n(165),n(166),n(167),n(168),n(170),n(171),n(172),n(174),n(175),n(176),n(472),n(473),n(474);var a=n(17),s=n(14),l=n(37),u=n(89),c=n(90),h=r(c),f=n(533),d=r(f),p=n(6),g=r(p),v=n(16),m=r(v),y=n(94),w=r(y),C=n(2),b=o(C),_=n(35),S=o(_),E=n(92),O=o(E),T=n(437),k=o(T),R=n(41),M=o(R),D=n(43),A=o(D),N=n(10),P=o(N),H=n(5),L=o(H),x=n(1),I=o(x),j=n(91),F=o(j),W=n(36),B=o(W),Y=n(21),V=o(Y),U=n(0),z=o(U),G=n(12),K=o(G),X=n(534),q=o(X),Z=n(8),$=n(442),J=r($),Q=n(441),ee=n(443),te=n(7),ne=o(te),oe=n(72);(0, d.default)(i),i.Core=h.default,i.DefaultSettings=J.default,i.EventManager=g.default,i._getListenersCounter=p.getListenersCounter,i.buildDate="07/11/2018 13:05:16",i.packageName="handsontable",i.version="6.2.0";i.hooks=m.default.getSingleton(),i.__GhostTable=w.default;var re=[b,S,O,k,M,A,P,L,I,F,B,V],ie=[z,K];i.helper={},i.dom={},b.arrayEach(re,function(e){b.arrayEach(Object.getOwnPropertyNames(e),function(t){"_"!==t.charAt(0)&&(i.helper[t]=e[t]);});}),b.arrayEach(ie,function(e){b.arrayEach(Object.getOwnPropertyNames(e),function(t){"_"!==t.charAt(0)&&(i.dom[t]=e[t]);});}),i.cellTypes={},b.arrayEach((0, u.getRegisteredCellTypeNames)(),function(e){i.cellTypes[e]=(0, u.getCellType)(e);}),i.cellTypes.registerCellType=u.registerCellType,i.cellTypes.getCellType=u.getCellType,i.editors={},b.arrayEach((0, a.getRegisteredEditorNames)(),function(e){i.editors[B.toUpperCaseFirst(e)+"Editor"]=(0, a.getEditor)(e);}),i.editors.registerEditor=a.registerEditor,i.editors.getEditor=a.getEditor,i.renderers={},b.arrayEach((0, s.getRegisteredRendererNames)(),function(e){var t=(0, s.getRenderer)(e);"base"===e&&(i.renderers.cellDecorator=t),i.renderers[B.toUpperCaseFirst(e)+"Renderer"]=t;}),i.renderers.registerRenderer=s.registerRenderer,i.renderers.getRenderer=s.getRenderer,i.validators={},b.arrayEach((0, l.getRegisteredValidatorNames)(),function(e){i.validators[B.toUpperCaseFirst(e)+"Validator"]=(0, l.getValidator)(e);}),i.validators.registerValidator=l.registerValidator,i.validators.getValidator=l.getValidator,i.plugins={},b.arrayEach(Object.getOwnPropertyNames(q),function(e){var t=q[e];"Base"===e?i.plugins[e+"Plugin"]=t:i.plugins[e]=t;}),i.plugins.registerPlugin=Z.registerPlugin,i.languages={},i.languages.dictionaryKeys=ne,i.languages.getLanguageDictionary=oe.getLanguageDictionary,i.languages.getLanguagesDictionaries=oe.getLanguagesDictionaries,i.languages.registerLanguageDictionary=oe.registerLanguageDictionary,i.languages.getTranslatedPhrase=function(){return ee.getTranslatedPhrase.apply(void 0,arguments)},t.default=i;},function(e,t,n){var o=n(20),r=n(18),i=n(38);e.exports=n(22)?Object.defineProperties:function(e,t){r(e);for(var n,a=i(t),s=a.length,l=0;s>l;)o.f(e,n=a[l++],t[n]);return e};},function(e,t,n){var o=n(76),r=n(52),i=n(54),a={};n(30)(a,n(13)("iterator"),function(){return this}),e.exports=function(e,t,n){e.prototype=o(a,{next:r(1,n)}),i(e,t+" Iterator");};},function(e,t,n){var o=n(9),r=n(113).set;e.exports=function(e,t,n){var i,a=t.constructor;return a!==n&&"function"==typeof a&&(i=a.prototype)!==n.prototype&&o(i)&&r&&r(e,i),e};},function(e,t,n){var o=n(458);e.exports=function(e,t){return new(o(e))(t)};},function(e,t,n){var o=n(9),r=n(116),i=n(13)("species");e.exports=function(e){var t;return r(e)&&(t=e.constructor,"function"!=typeof t||t!==Array&&!r(t.prototype)||(t=void 0),o(t)&&null===(t=t[i])&&(t=void 0)),void 0===t?Array:t};},function(e,t,n){var o=n(18),r=n(64),i=n(13)("species");e.exports=function(e,t){var n,a=o(e).constructor;return void 0===a||void 0==(n=o(a)[i])?t:r(n)};},function(e,t){e.exports=function(e,t,n){var o=void 0===n;switch(t.length){case 0:return o?e():e.call(n);case 1:return o?e(t[0]):e.call(n,t[0]);case 2:return o?e(t[0],t[1]):e.call(n,t[0],t[1]);case 3:return o?e(t[0],t[1],t[2]):e.call(n,t[0],t[1],t[2]);case 4:return o?e(t[0],t[1],t[2],t[3]):e.call(n,t[0],t[1],t[2],t[3])}return e.apply(n,t)};},function(e,t,n){var o=n(15),r=n(82).set,i=o.MutationObserver||o.WebKitMutationObserver,a=o.process,s=o.Promise,l="process"==n(44)(a);e.exports=function(){var e,t,n,u=function(){var o,r;for(l&&(o=a.domain)&&o.exit();e;){r=e.fn,e=e.next;try{r();}catch(o){throw e?n():t=void 0,o}}t=void 0,o&&o.enter();};if(l)n=function(){a.nextTick(u);};else if(!i||o.navigator&&o.navigator.standalone)if(s&&s.resolve){var c=s.resolve(void 0);n=function(){c.then(u);};}else n=function(){r.call(o,u);};else{var h=!0,f=document.createTextNode("");new i(u).observe(f,{characterData:!0}),n=function(){f.data=h=!h;};}return function(o){var r={fn:o,next:void 0};t&&(t.next=r),e||(e=r,n()),t=r;}};},function(e,t){e.exports=function(e){try{return {e:!1,v:e()}}catch(e){return {e:!0,v:e}}};},function(e,t,n){var o=n(18),r=n(9),i=n(121);e.exports=function(e,t){if(o(e),r(t)&&t.constructor===e)return t;var n=i.f(e);return (0, n.resolve)(t),n.promise};},function(e,t,n){var o=n(15),r=n(40),i=n(50),a=n(123),s=n(20).f;e.exports=function(e){var t=r.Symbol||(r.Symbol=i?{}:o.Symbol||{});"_"==e.charAt(0)||e in t||s(t,e,{value:a.f(e)});};},function(e,t,n){var o=n(38),r=n(70),i=n(55);e.exports=function(e){var t=o(e),n=r.f;if(n)for(var a,s=n(e),l=i.f,u=0;s.length>u;)l.call(e,a=s[u++])&&t.push(a);return t};},function(e,t){e.exports=Object.is||function(e,t){return e===t?0!==e||1/e==1/t:e!=e&&t!=t};},function(e,t,n){var o=n(61),r=n(39);e.exports=function(e){return function(t,n){var i,a,s=r(t)+"",l=o(n),u=s.length;return 0>l||l>=u?e?"":void 0:(i=s.charCodeAt(l),55296>i||i>56319||l+1===u||56320>(a=s.charCodeAt(l+1))||a>57343?e?s.charAt(l):i:e?s.slice(l,l+2):a-56320+(i-55296<<10)+65536)}};},function(e,t,n){var o=n(18);e.exports=function(){var e=o(this),t="";return e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.unicode&&(t+="u"),e.sticky&&(t+="y"),t};},function(e,t,n){var o=n(32),r=n(62),i=n(25);e.exports=[].copyWithin||function(e,t){var n=o(this),a=i(n.length),s=r(e,a),l=r(t,a),u=arguments.length>2?arguments[2]:void 0,c=Math.min((void 0===u?a:r(u,a))-l,a-s),h=1;for(s>l&&l+c>s&&(h=-1,l+=c-1,s+=c-1);c-- >0;)l in n?n[s]=n[l]:delete n[s],s+=h,l+=h;return n};},function(e,t,n){var o=n(32),r=n(62),i=n(25);e.exports=function(e){for(var t=o(this),n=i(t.length),a=arguments.length,s=r(a>1?arguments[1]:void 0,n),l=a>2?arguments[2]:void 0,u=void 0===l?n:r(l,n);u>s;)t[s++]=e;return t};},function(e,t,n){var o=n(84),r=n(70),i=n(18),a=n(15).Reflect;e.exports=a&&a.ownKeys||function(e){var t=o.f(i(e)),n=r.f;return n?t.concat(n(e)):t};},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=n(0),s=n(27),l=function(e){return e&&e.__esModule?e:{default:e}}(s),u=function(e){function t(e){o(this,t);var n=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.clone=n.makeClone(l.default.CLONE_DEBUG),n.clone.wtTable.holder.style.opacity=.4,n.clone.wtTable.holder.style.textShadow="0 0 2px #ff0000",(0, a.addClass)(n.clone.wtTable.holder.parentNode,"wtDebugVisible"),n}return i(t,e),t}(l.default);l.default.registerOverlay(l.default.CLONE_DEBUG,u),t.default=u;},function(e,t,n){function o(e){return n(r(e))}function r(e){var t=i[e];if(!(t+1))throw Error("Cannot find module '"+e+"'.");return t}var i={"./af":184,"./af.js":184,"./ar":185,"./ar-dz":186,"./ar-dz.js":186,"./ar-kw":187,"./ar-kw.js":187,"./ar-ly":188,"./ar-ly.js":188,"./ar-ma":189,"./ar-ma.js":189,"./ar-sa":190,"./ar-sa.js":190,"./ar-tn":191,"./ar-tn.js":191,"./ar.js":185,"./az":192,"./az.js":192,"./be":193,"./be.js":193,"./bg":194,"./bg.js":194,"./bm":195,"./bm.js":195,"./bn":196,"./bn.js":196,"./bo":197,"./bo.js":197,"./br":198,"./br.js":198,"./bs":199,"./bs.js":199,"./ca":200,"./ca.js":200,"./cs":201,"./cs.js":201,"./cv":202,"./cv.js":202,"./cy":203,"./cy.js":203,"./da":204,"./da.js":204,"./de":205,"./de-at":206,"./de-at.js":206,"./de-ch":207,"./de-ch.js":207,"./de.js":205,"./dv":208,"./dv.js":208,"./el":209,"./el.js":209,"./en-au":210,"./en-au.js":210,"./en-ca":211,"./en-ca.js":211,"./en-gb":212,"./en-gb.js":212,"./en-ie":213,"./en-ie.js":213,"./en-nz":214,"./en-nz.js":214,"./eo":215,"./eo.js":215,"./es":216,"./es-do":217,"./es-do.js":217,"./es-us":218,"./es-us.js":218,"./es.js":216,"./et":219,"./et.js":219,"./eu":220,"./eu.js":220,"./fa":221,"./fa.js":221,"./fi":222,"./fi.js":222,"./fo":223,"./fo.js":223,"./fr":224,"./fr-ca":225,"./fr-ca.js":225,"./fr-ch":226,"./fr-ch.js":226,"./fr.js":224,"./fy":227,"./fy.js":227,"./gd":228,"./gd.js":228,"./gl":229,"./gl.js":229,"./gom-latn":230,"./gom-latn.js":230,"./gu":231,"./gu.js":231,"./he":232,"./he.js":232,"./hi":233,"./hi.js":233,"./hr":234,"./hr.js":234,"./hu":235,"./hu.js":235,"./hy-am":236,"./hy-am.js":236,"./id":237,"./id.js":237,"./is":238,"./is.js":238,"./it":239,"./it.js":239,"./ja":240,"./ja.js":240,"./jv":241,"./jv.js":241,"./ka":242,"./ka.js":242,"./kk":243,"./kk.js":243,"./km":244,"./km.js":244,"./kn":245,"./kn.js":245,"./ko":246,"./ko.js":246,"./ky":247,"./ky.js":247,"./lb":248,"./lb.js":248,"./lo":249,"./lo.js":249,"./lt":250,"./lt.js":250,"./lv":251,"./lv.js":251,"./me":252,"./me.js":252,"./mi":253,"./mi.js":253,"./mk":254,"./mk.js":254,"./ml":255,"./ml.js":255,"./mr":256,"./mr.js":256,"./ms":257,"./ms-my":258,"./ms-my.js":258,"./ms.js":257,"./mt":259,"./mt.js":259,"./my":260,"./my.js":260,"./nb":261,"./nb.js":261,"./ne":262,"./ne.js":262,"./nl":263,"./nl-be":264,"./nl-be.js":264,"./nl.js":263,"./nn":265,"./nn.js":265,"./pa-in":266,"./pa-in.js":266,"./pl":267,"./pl.js":267,"./pt":268,"./pt-br":269,"./pt-br.js":269,"./pt.js":268,"./ro":270,"./ro.js":270,"./ru":271,"./ru.js":271,"./sd":272,"./sd.js":272,"./se":273,"./se.js":273,"./si":274,"./si.js":274,"./sk":275,"./sk.js":275,"./sl":276,"./sl.js":276,"./sq":277,"./sq.js":277,"./sr":278,"./sr-cyrl":279,"./sr-cyrl.js":279,"./sr.js":278,"./ss":280,"./ss.js":280,"./sv":281,"./sv.js":281,"./sw":282,"./sw.js":282,"./ta":283,"./ta.js":283,"./te":284,"./te.js":284,"./tet":285,"./tet.js":285,"./th":286,"./th.js":286,"./tl-ph":287,"./tl-ph.js":287,"./tlh":288,"./tlh.js":288,"./tr":289,"./tr.js":289,"./tzl":290,"./tzl.js":290,"./tzm":291,"./tzm-latn":292,"./tzm-latn.js":292,"./tzm.js":291,"./uk":293,"./uk.js":293,"./ur":294,"./ur.js":294,"./uz":295,"./uz-latn":296,"./uz-latn.js":296,"./uz.js":295,"./vi":297,"./vi.js":297,"./x-pseudo":298,"./x-pseudo.js":298,"./yo":299,"./yo.js":299,"./zh-cn":300,"./zh-cn.js":300,"./zh-hk":301,"./zh-hk.js":301,"./zh-tw":302,"./zh-tw.js":302};o.keys=function(){return Object.keys(i)},o.resolve=r,e.exports=o,o.id=476;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),l=n(27),u=function(e){return e&&e.__esModule?e:{default:e}}(l),c=function(e){function t(e){o(this,t);var n=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.clone=n.makeClone(u.default.CLONE_LEFT),n}return i(t,e),a(t,[{key:"shouldBeRendered",value:function(){return !(!this.wot.getSetting("fixedColumnsLeft")&&!this.wot.getSetting("rowHeaders").length)}},{key:"resetFixedPosition",value:function(){if(this.needFullRender&&this.wot.wtTable.holder.parentNode){var e=this.clone.wtTable.holder.parentNode,t=0,n=this.wot.getSetting("preventOverflow");if(this.trimmingContainer!==window||n&&"horizontal"===n)t=this.getScrollPosition(),(0, s.resetCssTransform)(e);else{var o=this.wot.wtTable.hider.getBoundingClientRect(),r=Math.ceil(o.left),i=Math.ceil(o.right),a=void 0,l=void 0;l=this.wot.wtTable.hider.style.top,l=""===l?0:l,a=0>r&&i-e.offsetWidth>0?-r:0,t=a,a+="px",(0, s.setOverlayPosition)(e,a,l);}this.adjustHeaderBordersPosition(t),this.adjustElementsSize();}}},{key:"setScrollPosition",value:function(e){var t=!1;return this.mainTableScrollableElement===window&&window.scrollX!==e?(window.scrollTo(e,(0, s.getWindowScrollTop)()),t=!0):this.mainTableScrollableElement.scrollLeft!==e&&(this.mainTableScrollableElement.scrollLeft=e,t=!0),t}},{key:"onScroll",value:function(){this.wot.getSetting("onScrollVertically");}},{key:"sumCellSizes",value:function(e,t){for(var n=this.wot.wtSettings.defaultColumnWidth,o=e,r=0;t>o;)r+=this.wot.wtTable.getStretchedColumnWidth(o)||n,o+=1;return r}},{key:"adjustElementsSize",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.updateTrimmingContainer(),(this.needFullRender||e)&&(this.adjustRootElementSize(),this.adjustRootChildrenSize(),e||(this.areElementSizesAdjusted=!0));}},{key:"adjustRootElementSize",value:function(){var e=this.wot.wtTable.holder,t=e.clientHeight===e.offsetHeight?0:(0, s.getScrollbarWidth)(),n=this.clone.wtTable.holder.parentNode,o=n.style,r=this.wot.getSetting("preventOverflow");if(this.trimmingContainer!==window||"vertical"===r){var i=this.wot.wtViewport.getWorkspaceHeight()-t;i=Math.min(i,(0, s.innerHeight)(this.wot.wtTable.wtRootElement)),o.height=i+"px";}else o.height="";this.clone.wtTable.holder.style.height=o.height;var a=(0, s.outerWidth)(this.clone.wtTable.TABLE);o.width=(0===a?a:a+4)+"px";}},{key:"adjustRootChildrenSize",value:function(){var e=(0, s.getScrollbarWidth)();this.clone.wtTable.hider.style.height=this.hider.style.height,this.clone.wtTable.holder.style.height=this.clone.wtTable.holder.parentNode.style.height,0===e&&(e=30),this.clone.wtTable.holder.style.width=parseInt(this.clone.wtTable.holder.parentNode.style.width,10)+e+"px";}},{key:"applyToDOM",value:function(){var e=this.wot.getSetting("totalColumns");if(this.areElementSizesAdjusted||this.adjustElementsSize(),"number"==typeof this.wot.wtViewport.columnsRenderCalculator.startPosition)this.spreader.style.left=this.wot.wtViewport.columnsRenderCalculator.startPosition+"px";else{if(0!==e)throw Error("Incorrect value of the columnsRenderCalculator");this.spreader.style.left="0";}this.spreader.style.right="",this.needFullRender&&this.syncOverlayOffset();}},{key:"syncOverlayOffset",value:function(){this.clone.wtTable.spreader.style.top="number"==typeof this.wot.wtViewport.rowsRenderCalculator.startPosition?this.wot.wtViewport.rowsRenderCalculator.startPosition+"px":"";}},{key:"scrollTo",value:function(e,t){var n=this.getTableParentOffset(),o=this.wot.cloneSource?this.wot.cloneSource:this.wot,r=o.wtTable.holder,i=0;return t&&r.offsetWidth!==r.clientWidth&&(i=(0, s.getScrollbarWidth)()),t?(n+=this.sumCellSizes(0,e+1),n-=this.wot.wtViewport.getViewportWidth()):n+=this.sumCellSizes(this.wot.getSetting("fixedColumnsLeft"),e),n+=i,this.setScrollPosition(n)}},{key:"getTableParentOffset",value:function(){var e=this.wot.getSetting("preventOverflow"),t=0;return e||this.trimmingContainer!==window||(t=this.wot.wtTable.holderOffset.left),t}},{key:"getScrollPosition",value:function(){return (0, s.getScrollLeft)(this.mainTableScrollableElement)}},{key:"adjustHeaderBordersPosition",value:function(e){var t=this.wot.wtTable.holder.parentNode,n=this.wot.getSetting("rowHeaders"),o=this.wot.getSetting("fixedColumnsLeft");if(this.wot.getSetting("totalRows")?(0, s.removeClass)(t,"emptyRows"):(0, s.addClass)(t,"emptyRows"),o&&!n.length)(0, s.addClass)(t,"innerBorderLeft");else if(!o&&n.length){var r=(0, s.hasClass)(t,"innerBorderLeft");e?(0, s.addClass)(t,"innerBorderLeft"):(0, s.removeClass)(t,"innerBorderLeft"),(!r&&e||r&&!e)&&this.wot.wtOverlays.adjustElementsSize();}}}]),t}(u.default);u.default.registerOverlay(u.default.CLONE_LEFT,c),t.default=c;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),l=n(2),u=n(27),c=function(e){return e&&e.__esModule?e:{default:e}}(u),h=function(e){function t(e){o(this,t);var n=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.clone=n.makeClone(c.default.CLONE_TOP),n}return i(t,e),a(t,[{key:"shouldBeRendered",value:function(){return !(!this.wot.getSetting("fixedRowsTop")&&!this.wot.getSetting("columnHeaders").length)}},{key:"resetFixedPosition",value:function(){if(this.needFullRender&&this.wot.wtTable.holder.parentNode){var e=this.clone.wtTable.holder.parentNode,t=0,n=this.wot.getSetting("preventOverflow");if(this.trimmingContainer!==window||n&&"vertical"===n)t=this.getScrollPosition(),(0, s.resetCssTransform)(e);else{var o=this.wot.wtTable.hider.getBoundingClientRect(),r=Math.ceil(o.top),i=Math.ceil(o.bottom),a=void 0,l=void 0;a=this.wot.wtTable.hider.style.left,a=""===a?0:a,l=0>r&&i-e.offsetHeight>0?-r:0,t=l,l+="px",(0, s.setOverlayPosition)(e,a,l);}this.adjustHeaderBordersPosition(t),this.adjustElementsSize();}}},{key:"setScrollPosition",value:function(e){var t=!1;return this.mainTableScrollableElement===window&&window.scrollY!==e?(window.scrollTo((0, s.getWindowScrollLeft)(),e),t=!0):this.mainTableScrollableElement.scrollTop!==e&&(this.mainTableScrollableElement.scrollTop=e,t=!0),t}},{key:"onScroll",value:function(){this.wot.getSetting("onScrollHorizontally");}},{key:"sumCellSizes",value:function(e,t){for(var n=this.wot.wtSettings.settings.defaultRowHeight,o=e,r=0;t>o;){var i=this.wot.wtTable.getRowHeight(o);r+=void 0===i?n:i,o+=1;}return r}},{key:"adjustElementsSize",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.updateTrimmingContainer(),(this.needFullRender||e)&&(this.adjustRootElementSize(),this.adjustRootChildrenSize(),e||(this.areElementSizesAdjusted=!0));}},{key:"adjustRootElementSize",value:function(){var e=this.wot.wtTable.holder,t=e.clientWidth===e.offsetWidth?0:(0, s.getScrollbarWidth)(),n=this.clone.wtTable.holder.parentNode,o=n.style,r=this.wot.getSetting("preventOverflow");if(this.trimmingContainer!==window||"horizontal"===r){var i=this.wot.wtViewport.getWorkspaceWidth()-t;i=Math.min(i,(0, s.innerWidth)(this.wot.wtTable.wtRootElement)),o.width=i+"px";}else o.width="";this.clone.wtTable.holder.style.width=o.width;var a=(0, s.outerHeight)(this.clone.wtTable.TABLE);o.height=(0===a?a:a+4)+"px";}},{key:"adjustRootChildrenSize",value:function(){var e=(0, s.getScrollbarWidth)();this.clone.wtTable.hider.style.width=this.hider.style.width,this.clone.wtTable.holder.style.width=this.clone.wtTable.holder.parentNode.style.width,0===e&&(e=30),this.clone.wtTable.holder.style.height=parseInt(this.clone.wtTable.holder.parentNode.style.height,10)+e+"px";}},{key:"applyToDOM",value:function(){var e=this.wot.getSetting("totalRows");if(this.areElementSizesAdjusted||this.adjustElementsSize(),"number"==typeof this.wot.wtViewport.rowsRenderCalculator.startPosition)this.spreader.style.top=this.wot.wtViewport.rowsRenderCalculator.startPosition+"px";else{if(0!==e)throw Error("Incorrect value of the rowsRenderCalculator");this.spreader.style.top="0";}this.spreader.style.bottom="",this.needFullRender&&this.syncOverlayOffset();}},{key:"syncOverlayOffset",value:function(){this.clone.wtTable.spreader.style.left="number"==typeof this.wot.wtViewport.columnsRenderCalculator.startPosition?this.wot.wtViewport.columnsRenderCalculator.startPosition+"px":"";}},{key:"scrollTo",value:function(e,t){var n=this.getTableParentOffset(),o=this.wot.cloneSource?this.wot.cloneSource:this.wot,r=o.wtTable.holder,i=0;if(t&&r.offsetHeight!==r.clientHeight&&(i=(0, s.getScrollbarWidth)()),t){var a=this.wot.getSetting("fixedRowsBottom"),l=this.wot.getSetting("totalRows");n+=this.sumCellSizes(0,e+1),n-=this.wot.wtViewport.getViewportHeight()-this.sumCellSizes(l-a,l),n+=1;}else n+=this.sumCellSizes(this.wot.getSetting("fixedRowsTop"),e);return n+=i,this.setScrollPosition(n)}},{key:"getTableParentOffset",value:function(){return this.mainTableScrollableElement===window?this.wot.wtTable.holderOffset.top:0}},{key:"getScrollPosition",value:function(){return (0, s.getScrollTop)(this.mainTableScrollableElement)}},{key:"redrawSelectionBorders",value:function(e){if(e&&e.cellRange){var t=e.getBorder(this.wot),n=e.getCorners();t.disappear(),t.appear(n);}}},{key:"redrawAllSelectionsBorders",value:function(){var e=this,t=this.wot.selections;this.redrawSelectionBorders(t.getCell()),(0, l.arrayEach)(t.getAreas(),function(t){e.redrawSelectionBorders(t);}),this.redrawSelectionBorders(t.getFill()),this.wot.wtTable.wot.wtOverlays.leftOverlay.refresh();}},{key:"adjustHeaderBordersPosition",value:function(e){var t=this.wot.wtTable.holder.parentNode;if(this.wot.getSetting("totalColumns")?(0, s.removeClass)(t,"emptyColumns"):(0, s.addClass)(t,"emptyColumns"),0===this.wot.getSetting("fixedRowsTop")&&this.wot.getSetting("columnHeaders").length>0){var n=(0, s.hasClass)(t,"innerBorderTop");e||0===this.wot.getSetting("totalRows")?(0, s.addClass)(t,"innerBorderTop"):(0, s.removeClass)(t,"innerBorderTop"),(!n&&e||n&&!e)&&(this.wot.wtOverlays.adjustElementsSize(),this.redrawAllSelectionsBorders());}if(0===this.wot.getSetting("rowHeaders").length){var o=this.clone.wtTable.THEAD.querySelectorAll("th:nth-of-type(2)");if(o)for(var r=0;o.length>r;r++)o[r].style["border-left-width"]=0;}}}]),t}(c.default);c.default.registerOverlay(c.default.CLONE_TOP,h),t.default=h;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),l=n(27),u=function(e){return e&&e.__esModule?e:{default:e}}(l),c=function(e){function t(e){o(this,t);var n=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.clone=n.makeClone(u.default.CLONE_TOP_LEFT_CORNER),n}return i(t,e),a(t,[{key:"shouldBeRendered",value:function(){return !(!this.wot.getSetting("fixedRowsTop")&&!this.wot.getSetting("columnHeaders").length||!this.wot.getSetting("fixedColumnsLeft")&&!this.wot.getSetting("rowHeaders").length)}},{key:"resetFixedPosition",value:function(){if(this.updateTrimmingContainer(),this.wot.wtTable.holder.parentNode){var e=this.clone.wtTable.holder.parentNode,t=(0, s.outerHeight)(this.clone.wtTable.TABLE),n=(0, s.outerWidth)(this.clone.wtTable.TABLE),o=this.wot.getSetting("preventOverflow");if(this.trimmingContainer===window){var r=this.wot.wtTable.hider.getBoundingClientRect(),i=Math.ceil(r.top),a=Math.ceil(r.left),l=Math.ceil(r.bottom),u=Math.ceil(r.right),c="0",h="0";o&&"vertical"!==o||0>a&&u-e.offsetWidth>0&&(c=-a+"px"),o&&"horizontal"!==o||0>i&&l-e.offsetHeight>0&&(h=-i+"px"),(0, s.setOverlayPosition)(e,c,h);}else(0, s.resetCssTransform)(e);e.style.height=(0===t?t:t+4)+"px",e.style.width=(0===n?n:n+4)+"px";}}}]),t}(u.default);u.default.registerOverlay(u.default.CLONE_TOP_LEFT_CORNER,c),t.default=c;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),l=n(27),u=function(e){return e&&e.__esModule?e:{default:e}}(l),c=function(e){function t(e){o(this,t);var n=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.clone=n.makeClone(u.default.CLONE_BOTTOM),n}return i(t,e),a(t,[{key:"repositionOverlay",value:function(){var e=(0, s.getScrollbarWidth)(),t=this.clone.wtTable.holder.parentNode;this.wot.wtTable.holder.clientHeight===this.wot.wtTable.holder.offsetHeight&&(e=0),t.style.top="",t.style.bottom=e+"px";}},{key:"shouldBeRendered",value:function(){return !!this.wot.getSetting("fixedRowsBottom")}},{key:"resetFixedPosition",value:function(){if(this.needFullRender&&this.wot.wtTable.holder.parentNode){var e=this.clone.wtTable.holder.parentNode,t=0;if(e.style.top="",this.wot.wtOverlays.leftOverlay.trimmingContainer===window){var n=this.wot.wtTable.hider.getBoundingClientRect(),o=Math.ceil(n.bottom),r=void 0,i=void 0,a=document.body.offsetHeight;r=this.wot.wtTable.hider.style.left,r=""===r?0:r,i=o>a?o-a:0,t=i,i+="px",e.style.top="",e.style.left=r,e.style.bottom=i;}else t=this.getScrollPosition(),(0, s.resetCssTransform)(e),this.repositionOverlay();this.adjustHeaderBordersPosition(t);}}},{key:"setScrollPosition",value:function(e){this.mainTableScrollableElement===window?window.scrollTo((0, s.getWindowScrollLeft)(),e):this.mainTableScrollableElement.scrollTop=e;}},{key:"onScroll",value:function(){this.wot.getSetting("onScrollVertically");}},{key:"sumCellSizes",value:function(e,t){for(var n=e,o=0,r=this.wot.wtSettings.settings.defaultRowHeight;t>n;){var i=this.wot.wtTable.getRowHeight(n);o+=void 0===i?r:i,n+=1;}return o}},{key:"adjustElementsSize",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.updateTrimmingContainer(),(this.needFullRender||e)&&(this.adjustRootElementSize(),this.adjustRootChildrenSize(),e||(this.areElementSizesAdjusted=!0));}},{key:"adjustRootElementSize",value:function(){var e=this.wot.wtTable.holder,t=e.clientWidth===e.offsetWidth?0:(0, s.getScrollbarWidth)(),n=this.clone.wtTable.holder.parentNode,o=n.style;o.width=this.trimmingContainer===window?"":this.wot.wtViewport.getWorkspaceWidth()-t+"px",this.clone.wtTable.holder.style.width=o.width;var r=(0, s.outerHeight)(this.clone.wtTable.TABLE);o.height=r+"px";}},{key:"adjustRootChildrenSize",value:function(){var e=(0, s.getScrollbarWidth)();this.clone.wtTable.hider.style.width=this.hider.style.width,this.clone.wtTable.holder.style.width=this.clone.wtTable.holder.parentNode.style.width,0===e&&(e=30),this.clone.wtTable.holder.style.height=parseInt(this.clone.wtTable.holder.parentNode.style.height,10)+e+"px";}},{key:"applyToDOM",value:function(){var e=this.wot.getSetting("totalRows");if(this.areElementSizesAdjusted||this.adjustElementsSize(),"number"==typeof this.wot.wtViewport.rowsRenderCalculator.startPosition)this.spreader.style.top=this.wot.wtViewport.rowsRenderCalculator.startPosition+"px";else{if(0!==e)throw Error("Incorrect value of the rowsRenderCalculator");this.spreader.style.top="0";}this.spreader.style.bottom="",this.needFullRender&&this.syncOverlayOffset();}},{key:"syncOverlayOffset",value:function(){this.clone.wtTable.spreader.style.left="number"==typeof this.wot.wtViewport.columnsRenderCalculator.startPosition?this.wot.wtViewport.columnsRenderCalculator.startPosition+"px":"";}},{key:"scrollTo",value:function(e,t){var n=this.getTableParentOffset(),o=this.wot.cloneSource?this.wot.cloneSource:this.wot,r=o.wtTable.holder,i=0;t&&r.offsetHeight!==r.clientHeight&&(i=(0, s.getScrollbarWidth)()),t?(n+=this.sumCellSizes(0,e+1),n-=this.wot.wtViewport.getViewportHeight(),n+=1):n+=this.sumCellSizes(this.wot.getSetting("fixedRowsBottom"),e),n+=i,this.setScrollPosition(n);}},{key:"getTableParentOffset",value:function(){return this.mainTableScrollableElement===window?this.wot.wtTable.holderOffset.top:0}},{key:"getScrollPosition",value:function(){return (0, s.getScrollTop)(this.mainTableScrollableElement)}},{key:"adjustHeaderBordersPosition",value:function(e){if(0===this.wot.getSetting("fixedRowsBottom")&&this.wot.getSetting("columnHeaders").length>0){var t=this.wot.wtTable.holder.parentNode,n=(0, s.hasClass)(t,"innerBorderTop");e?(0, s.addClass)(t,"innerBorderTop"):(0, s.removeClass)(t,"innerBorderTop"),(!n&&e||n&&!e)&&this.wot.wtOverlays.adjustElementsSize();}if(0===this.wot.getSetting("rowHeaders").length){var o=this.clone.wtTable.THEAD.querySelector("th:nth-of-type(2)");o&&(o.style["border-left-width"]=0);}}}]),t}(u.default);u.default.registerOverlay(u.default.CLONE_BOTTOM,c),t.default=c;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),l=n(27),u=function(e){return e&&e.__esModule?e:{default:e}}(l),c=function(e){function t(e){o(this,t);var n=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.clone=n.makeClone(u.default.CLONE_BOTTOM_LEFT_CORNER),n}return i(t,e),a(t,[{key:"shouldBeRendered",value:function(){return !(!this.wot.getSetting("fixedRowsBottom")||!this.wot.getSetting("fixedColumnsLeft")&&!this.wot.getSetting("rowHeaders").length)}},{key:"repositionOverlay",value:function(){var e=(0, s.getScrollbarWidth)(),t=this.clone.wtTable.holder.parentNode;this.wot.wtTable.holder.clientHeight===this.wot.wtTable.holder.offsetHeight&&(e=0),t.style.top="",t.style.bottom=e+"px";}},{key:"resetFixedPosition",value:function(){if(this.updateTrimmingContainer(),this.wot.wtTable.holder.parentNode){var e=this.clone.wtTable.holder.parentNode,t=(0, s.outerHeight)(this.clone.wtTable.TABLE),n=(0, s.outerWidth)(this.clone.wtTable.TABLE);if(e.style.top="",this.trimmingContainer===window){var o=this.wot.wtTable.hider.getBoundingClientRect(),r=Math.ceil(o.bottom),i=Math.ceil(o.left),a=void 0,l=void 0,u=document.body.offsetHeight;a=0>i?-i:0,l=r>u?r-u:0,l+="px",a+="px",e.style.top="",e.style.left=a,e.style.bottom=l;}else(0, s.resetCssTransform)(e),this.repositionOverlay();e.style.height=t+"px",e.style.width=n+"px";}}}]),t}(u.default);u.default.registerOverlay(u.default.CLONE_BOTTOM_LEFT_CORNER,c),t.default=c;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var i=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},s=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=n(0),u=n(310),c=o(u),h=n(57),f=o(h),d=n(179),p=o(d);t.default=function(){function e(t,n){r(this,e),this.settings=t,this.cellRange=n||null,this.instanceBorders={},this.classNames=[this.settings.className],this.classNameGenerator=this.linearClassNameGenerator(this.settings.className,this.settings.layerLevel);}return s(e,[{key:"getBorder",value:function(e){return this.instanceBorders[e.guid]||(this.instanceBorders[e.guid]=new c.default(e,this.settings)),this.instanceBorders[e.guid]}},{key:"isEmpty",value:function(){return null===this.cellRange}},{key:"add",value:function(e){return this.isEmpty()?this.cellRange=new p.default(e):this.cellRange.expand(e),this}},{key:"replace",value:function(e,t){if(!this.isEmpty()){if(this.cellRange.from.isEqual(e))return this.cellRange.from=t,!0;if(this.cellRange.to.isEqual(e))return this.cellRange.to=t,!0}return !1}},{key:"clear",value:function(){return this.cellRange=null,this}},{key:"getCorners",value:function(){var e=this.cellRange.getTopLeftCorner(),t=this.cellRange.getBottomRightCorner();return [e.row,e.col,t.row,t.col]}},{key:"addClassAtCoords",value:function(e,t,n,o){var r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=e.wtTable.getCell(new f.default(t,n));if("object"===(void 0===i?"undefined":a(i))){var s=o;r&&(s=this.classNameGenerator(i),this.classNames.includes(s)||this.classNames.push(s)),(0, l.addClass)(i,s);}return this}},{key:"linearClassNameGenerator",value:function(e,t){return function n(o){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;if(0===t||0===r)return e;var i=0>r?t:r,a=e;(i-=1,(0, l.hasClass)(o,0===i?e:e+"-"+i))?a=e+"-"+(i+1):a=n(o,i);return a}}},{key:"draw",value:function(e){if(this.isEmpty())return void(this.settings.border&&this.getBorder(e).disappear());for(var t=e.wtTable.getRenderedRowsCount(),n=e.wtTable.getRenderedColumnsCount(),o=this.getCorners(),r=i(o,4),a=r[0],s=r[1],u=r[2],c=r[3],h=0;n>h;h+=1){var f=e.wtTable.columnFilter.renderedToSource(h);if(f>=s&&c>=f){var d=e.wtTable.getColumnHeader(f);if(d){var p=[];this.settings.highlightHeaderClassName&&p.push(this.settings.highlightHeaderClassName),this.settings.highlightColumnClassName&&p.push(this.settings.highlightColumnClassName),(0, l.addClass)(d,p);}}}for(var g=0;t>g;g+=1){var v=e.wtTable.rowFilter.renderedToSource(g);if(v>=a&&u>=v){var m=e.wtTable.getRowHeader(v);if(m){var y=[];this.settings.highlightHeaderClassName&&y.push(this.settings.highlightHeaderClassName),this.settings.highlightRowClassName&&y.push(this.settings.highlightRowClassName),(0, l.addClass)(m,y);}}for(var w=0;n>w;w+=1){var C=e.wtTable.columnFilter.renderedToSource(w);a>v||v>u||s>C||C>c?a>v||v>u?s>C||C>c||this.settings.highlightColumnClassName&&this.addClassAtCoords(e,v,C,this.settings.highlightColumnClassName):this.settings.highlightRowClassName&&this.addClassAtCoords(e,v,C,this.settings.highlightRowClassName):this.settings.className&&this.addClassAtCoords(e,v,C,this.settings.className,this.settings.markIntersections);var b=e.getSetting("onAfterDrawSelection",v,C,o,this.settings.layerLevel);"string"==typeof b&&this.addClassAtCoords(e,v,C,b);}}e.getSetting("onBeforeDrawBorders",o,this.settings.className),this.settings.border&&this.getBorder(e).appear(o);}}]),e}();},function(e,t,n){function o(){function e(e){return e.currentStyle||document.defaultView.getComputedStyle(e)}var t,n={minHeight:200,maxHeight:300,minWidth:100,maxWidth:300},o=document.body,r=document.createTextNode(""),i=document.createElement("SPAN"),a=function(e,t,n){e.addEventListener(t,n,!1);},s=function(e,t,n){e.removeEventListener(t,n,!1);},l=function(a){var s,l;a?/^[a-zA-Z \.,\\\/\|0-9]$/.test(a)||(a="."):a="",void 0!==r.textContent?r.textContent=t.value+a:r.data=t.value+a,i.style.fontSize=e(t).fontSize,i.style.fontFamily=e(t).fontFamily,i.style.whiteSpace="pre",o.appendChild(i),s=i.clientWidth+2,o.removeChild(i),t.style.height=n.minHeight+"px",t.style.width=n.minWidth>s?n.minWidth+"px":s>n.maxWidth?n.maxWidth+"px":s+"px",l=t.scrollHeight?t.scrollHeight-1:0,n.minHeight>l?t.style.height=n.minHeight+"px":l>n.maxHeight?(t.style.height=n.maxHeight+"px",t.style.overflowY="visible"):t.style.height=l+"px";},u=function(){window.setTimeout(l,0);},c=function(e){if(e&&e.minHeight)if("inherit"==e.minHeight)n.minHeight=t.clientHeight;else{var o=parseInt(e.minHeight);isNaN(o)||(n.minHeight=o);}if(e&&e.maxHeight)if("inherit"==e.maxHeight)n.maxHeight=t.clientHeight;else{var a=parseInt(e.maxHeight);isNaN(a)||(n.maxHeight=a);}if(e&&e.minWidth)if("inherit"==e.minWidth)n.minWidth=t.clientWidth;else{var s=parseInt(e.minWidth);isNaN(s)||(n.minWidth=s);}if(e&&e.maxWidth)if("inherit"==e.maxWidth)n.maxWidth=t.clientWidth;else{var l=parseInt(e.maxWidth);isNaN(l)||(n.maxWidth=l);}i.firstChild||(i.className="autoResize",i.style.display="inline-block",i.appendChild(r));},h=function(e,o,r){t=e,c(o),"TEXTAREA"==t.nodeName&&(t.style.resize="none",t.style.overflowY="",t.style.height=n.minHeight+"px",t.style.minWidth=n.minWidth+"px",t.style.maxWidth=n.maxWidth+"px",t.style.overflowY="hidden"),r&&(a(t,"change",l),a(t,"cut",u),a(t,"paste",u),a(t,"drop",u),a(t,"keydown",u),a(t,"focus",l),a(t,"compositionstart",u),a(t,"compositionupdate",u),a(t,"compositionend",u)),l();};return {init:function(e,t,n){h(e,t,n);},unObserve:function(){s(t,"change",l),s(t,"cut",u),s(t,"paste",u),s(t,"drop",u),s(t,"keydown",u),s(t,"focus",l),s(t,"compositionstart",u),s(t,"compositionupdate",u),s(t,"compositionend",u);},resize:l}}e.exports=o;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(56),l=function(e){return e&&e.__esModule?e:{default:e}}(s),u=n(0);t.default=function(e){function t(){return o(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return i(t,e),a(t,[{key:"beginEditing",value:function(e,t){if(t&&"mouseup"===t.type){var n=this.TD.querySelector('input[type="checkbox"]');(0, u.hasClass)(n,"htBadValue")||n.click();}}},{key:"finishEditing",value:function(){}},{key:"init",value:function(){}},{key:"open",value:function(){}},{key:"close",value:function(){}},{key:"getValue",value:function(){}},{key:"setValue",value:function(){}},{key:"focus",value:function(){}}]),t}(l.default);},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var s=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},u=n(47),c=o(u),h=n(486),f=o(h);n(489);var d=n(0),p=n(1),g=n(6),v=o(g),m=n(21),y=n(12),w=n(59),C=o(w);t.default=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.defaultDateFormat="DD/MM/YYYY",n.isCellEdited=!1,n.parentDestroyed=!1,n}return a(t,e),s(t,[{key:"init",value:function(){var e=this;if("function"!=typeof c.default)throw Error("You need to include moment.js to your project.");if("function"!=typeof f.default)throw Error("You need to include Pikaday to your project.");l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"init",this).call(this),this.instance.addHook("afterDestroy",function(){e.parentDestroyed=!0,e.destroyElements();});}},{key:"createElements",value:function(){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"createElements",this).call(this),this.datePicker=document.createElement("DIV"),this.datePickerStyle=this.datePicker.style,this.datePickerStyle.position="absolute",this.datePickerStyle.top=0,this.datePickerStyle.left=0,this.datePickerStyle.zIndex=9999,(0, d.addClass)(this.datePicker,"htDatepickerHolder"),document.body.appendChild(this.datePicker),this.$datePicker=new f.default(this.getDatePickerConfig()),new v.default(this).addEventListener(this.datePicker,"mousedown",function(e){return (0, y.stopPropagation)(e)}),this.hideDatepicker();}},{key:"destroyElements",value:function(){this.$datePicker.destroy();}},{key:"prepare",value:function(e,n,o,r,i,a){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"prepare",this).call(this,e,n,o,r,i,a);}},{key:"open",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"open",this).call(this),this.showDatepicker(e);}},{key:"close",value:function(){var e=this;this._opened=!1,this.instance._registerTimeout(function(){e.instance._refreshBorders();}),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"close",this).call(this);}},{key:"finishEditing",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(e){var o=this.originalValue;void 0!==o&&this.setValue(o);}this.hideDatepicker(),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"finishEditing",this).call(this,e,n);}},{key:"showDatepicker",value:function(e){this.$datePicker.config(this.getDatePickerConfig());var t=this.TD.getBoundingClientRect(),n=this.cellProperties.dateFormat||this.defaultDateFormat,o=this.$datePicker.config(),r=void 0,i=this.instance.view.isMouseDown(),a=!!e&&(0, m.isMetaKey)(e.keyCode);this.datePickerStyle.top=window.pageYOffset+t.top+(0, d.outerHeight)(this.TD)+"px",this.datePickerStyle.left=window.pageXOffset+t.left+"px",this.$datePicker._onInputFocus=function(){},o.format=n,this.originalValue?(r=this.originalValue,(0, c.default)(r,n,!0).isValid()&&this.$datePicker.setMoment((0, c.default)(r,n),!0),this.getValue()!==this.originalValue&&this.setValue(this.originalValue),a||i||this.setValue("")):this.cellProperties.defaultDate?(r=this.cellProperties.defaultDate,o.defaultDate=r,(0, c.default)(r,n,!0).isValid()&&this.$datePicker.setMoment((0, c.default)(r,n),!0),a||i||this.setValue("")):this.$datePicker.gotoToday(),this.datePickerStyle.display="block",this.$datePicker.show();}},{key:"hideDatepicker",value:function(){this.datePickerStyle.display="none",this.$datePicker.hide();}},{key:"getDatePickerConfig",value:function(){var e=this,t=this.TEXTAREA,n={};this.cellProperties&&this.cellProperties.datePickerConfig&&(0, p.deepExtend)(n,this.cellProperties.datePickerConfig);var o=n.onSelect,r=n.onClose;return n.field=t,n.trigger=t,n.container=this.datePicker,n.bound=!1,n.format=n.format||this.defaultDateFormat,n.reposition=n.reposition||!1,n.onSelect=function(t){var n=t;isNaN(n.getTime())||(n=(0, c.default)(n).format(e.cellProperties.dateFormat||e.defaultDateFormat)),e.setValue(n),e.hideDatepicker(),o&&o();},n.onClose=function(){e.parentDestroyed||e.finishEditing(!1),r&&r();},n}}]),t}(C.default);},function(e,t,n){/*!
 * Pikaday
 *
 * Copyright  2014 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday
 */
!function(t,o){var r;try{r=n(487);}catch(e){}e.exports=o(r);}(0,function(e){var t="function"==typeof e,n=!!window.addEventListener,o=window.document,r=window.setTimeout,i=function(e,t,o,r){n?e.addEventListener(t,o,!!r):e.attachEvent("on"+t,o);},a=function(e,t,o,r){n?e.removeEventListener(t,o,!!r):e.detachEvent("on"+t,o);},s=function(e,t,n){var r;o.createEvent?(r=o.createEvent("HTMLEvents"),r.initEvent(t,!0,!1),r=w(r,n),e.dispatchEvent(r)):o.createEventObject&&(r=o.createEventObject(),r=w(r,n),e.fireEvent("on"+t,r));},l=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")},u=function(e,t){return -1!==(" "+e.className+" ").indexOf(" "+t+" ")},c=function(e,t){u(e,t)||(e.className=""===e.className?t:e.className+" "+t);},h=function(e,t){e.className=l((" "+e.className+" ").replace(" "+t+" "," "));},f=function(e){return /Array/.test(Object.prototype.toString.call(e))},d=function(e){return /Date/.test(Object.prototype.toString.call(e))&&!isNaN(e.getTime())},p=function(e){var t=e.getDay();return 0===t||6===t},g=function(e){return e%4==0&&e%100!=0||e%400==0},v=function(e,t){return [31,g(e)?29:28,31,30,31,30,31,31,30,31,30,31][t]},m=function(e){d(e)&&e.setHours(0,0,0,0);},y=function(e,t){return e.getTime()===t.getTime()},w=function(e,t,n){var o,r;for(o in t)r=void 0!==e[o],r&&"object"==typeof t[o]&&null!==t[o]&&void 0===t[o].nodeName?d(t[o])?n&&(e[o]=new Date(t[o].getTime())):f(t[o])?n&&(e[o]=t[o].slice(0)):e[o]=w({},t[o],n):!n&&r||(e[o]=t[o]);return e},C=function(e){return 0>e.month&&(e.year-=Math.ceil(Math.abs(e.month)/12),e.month+=12),e.month>11&&(e.year+=Math.floor(Math.abs(e.month)/12),e.month-=12),e},b={field:null,bound:void 0,position:"bottom left",reposition:!0,format:"YYYY-MM-DD",defaultDate:null,setDefaultDate:!1,firstDay:0,formatStrict:!1,minDate:null,maxDate:null,yearRange:10,showWeekNumber:!1,minYear:0,maxYear:9999,minMonth:void 0,maxMonth:void 0,startRange:null,endRange:null,isRTL:!1,yearSuffix:"",showMonthAfterYear:!1,showDaysInNextAndPreviousMonths:!1,numberOfMonths:1,mainCalendar:"left",container:void 0,i18n:{previousMonth:"Previous Month",nextMonth:"Next Month",months:["January","February","March","April","May","June","July","August","September","October","November","December"],weekdays:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],weekdaysShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"]},theme:null,onSelect:null,onOpen:null,onClose:null,onDraw:null},_=function(e,t,n){for(t+=e.firstDay;t>=7;)t-=7;return n?e.i18n.weekdaysShort[t]:e.i18n.weekdays[t]},S=function(e){var t=[],n="false";if(e.isEmpty){if(!e.showDaysInNextAndPreviousMonths)return '<td class="is-empty"></td>';t.push("is-outside-current-month");}return e.isDisabled&&t.push("is-disabled"),e.isToday&&t.push("is-today"),e.isSelected&&(t.push("is-selected"),n="true"),e.isInRange&&t.push("is-inrange"),e.isStartRange&&t.push("is-startrange"),e.isEndRange&&t.push("is-endrange"),'<td data-day="'+e.day+'" class="'+t.join(" ")+'" aria-selected="'+n+'"><button class="pika-button pika-day" type="button" data-pika-year="'+e.year+'" data-pika-month="'+e.month+'" data-pika-day="'+e.day+'">'+e.day+"</button></td>"},E=function(e,t,n){var o=new Date(n,0,1);return '<td class="pika-week">'+Math.ceil(((new Date(n,t,e)-o)/864e5+o.getDay()+1)/7)+"</td>"},O=function(e,t){return "<tr>"+(t?e.reverse():e).join("")+"</tr>"},T=function(e){return "<tbody>"+e.join("")+"</tbody>"},k=function(e){var t,n=[];for(e.showWeekNumber&&n.push("<th></th>"),t=0;7>t;t++)n.push('<th scope="col"><abbr title="'+_(e,t)+'">'+_(e,t,!0)+"</abbr></th>");return "<thead><tr>"+(e.isRTL?n.reverse():n).join("")+"</tr></thead>"},R=function(e,t,n,o,r,i){var a,s,l,u,c,h=e._o,d=n===h.minYear,p=n===h.maxYear,g='<div id="'+i+'" class="pika-title" role="heading" aria-live="assertive">',v=!0,m=!0;for(l=[],a=0;12>a;a++)l.push('<option value="'+(n===r?a-t:12+a-t)+'"'+(a===o?' selected="selected"':"")+(d&&h.minMonth>a||p&&a>h.maxMonth?'disabled="disabled"':"")+">"+h.i18n.months[a]+"</option>");for(u='<div class="pika-label">'+h.i18n.months[o]+'<select class="pika-select pika-select-month" tabindex="-1">'+l.join("")+"</select></div>",f(h.yearRange)?(a=h.yearRange[0],s=h.yearRange[1]+1):(a=n-h.yearRange,s=1+n+h.yearRange),l=[];s>a&&h.maxYear>=a;a++)h.minYear>a||l.push('<option value="'+a+'"'+(a===n?' selected="selected"':"")+">"+a+"</option>");return c='<div class="pika-label">'+n+h.yearSuffix+'<select class="pika-select pika-select-year" tabindex="-1">'+l.join("")+"</select></div>",g+=h.showMonthAfterYear?c+u:u+c,!d||0!==o&&o>h.minMonth||(v=!1),!p||11!==o&&h.maxMonth>o||(m=!1),0===t&&(g+='<button class="pika-prev'+(v?"":" is-disabled")+'" type="button">'+h.i18n.previousMonth+"</button>"),t===e._o.numberOfMonths-1&&(g+='<button class="pika-next'+(m?"":" is-disabled")+'" type="button">'+h.i18n.nextMonth+"</button>"),g+="</div>"},M=function(e,t,n){return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="'+n+'">'+k(e)+T(t)+"</table>"},D=function(a){var s=this,l=s.config(a);s._onMouseDown=function(e){if(s._v){e=e||window.event;var t=e.target||e.srcElement;if(t)if(u(t,"is-disabled")||(!u(t,"pika-button")||u(t,"is-empty")||u(t.parentNode,"is-disabled")?u(t,"pika-prev")?s.prevMonth():u(t,"pika-next")&&s.nextMonth():(s.setDate(new Date(t.getAttribute("data-pika-year"),t.getAttribute("data-pika-month"),t.getAttribute("data-pika-day"))),l.bound&&r(function(){s.hide(),l.field&&l.field.blur();},100))),u(t,"pika-select"))s._c=!0;else{if(!e.preventDefault)return e.returnValue=!1,!1;e.preventDefault();}}},s._onChange=function(e){e=e||window.event;var t=e.target||e.srcElement;t&&(u(t,"pika-select-month")?s.gotoMonth(t.value):u(t,"pika-select-year")&&s.gotoYear(t.value));},s._onKeyChange=function(e){if(e=e||window.event,s.isVisible())switch(e.keyCode){case 13:case 27:l.field.blur();break;case 37:e.preventDefault(),s.adjustDate("subtract",1);break;case 38:s.adjustDate("subtract",7);break;case 39:s.adjustDate("add",1);break;case 40:s.adjustDate("add",7);}},s._onInputChange=function(n){var o;n.firedBy!==s&&(t?(o=e(l.field.value,l.format,l.formatStrict),o=o&&o.isValid()?o.toDate():null):o=new Date(Date.parse(l.field.value)),d(o)&&s.setDate(o),s._v||s.show());},s._onInputFocus=function(){s.show();},s._onInputClick=function(){s.show();},s._onInputBlur=function(){var e=o.activeElement;do{if(u(e,"pika-single"))return}while(e=e.parentNode);s._c||(s._b=r(function(){s.hide();},50)),s._c=!1;},s._onClick=function(e){e=e||window.event;var t=e.target||e.srcElement,o=t;if(t){!n&&u(t,"pika-select")&&(t.onchange||(t.setAttribute("onchange","return;"),i(t,"change",s._onChange)));do{if(u(o,"pika-single")||o===l.trigger)return}while(o=o.parentNode);s._v&&t!==l.trigger&&o!==l.trigger&&s.hide();}},s.el=o.createElement("div"),s.el.className="pika-single"+(l.isRTL?" is-rtl":"")+(l.theme?" "+l.theme:""),i(s.el,"mousedown",s._onMouseDown,!0),i(s.el,"touchend",s._onMouseDown,!0),i(s.el,"change",s._onChange),i(o,"keydown",s._onKeyChange),l.field&&(l.container?l.container.appendChild(s.el):l.bound?o.body.appendChild(s.el):l.field.parentNode.insertBefore(s.el,l.field.nextSibling),i(l.field,"change",s._onInputChange),l.defaultDate||(l.defaultDate=t&&l.field.value?e(l.field.value,l.format).toDate():new Date(Date.parse(l.field.value)),l.setDefaultDate=!0));var c=l.defaultDate;d(c)?l.setDefaultDate?s.setDate(c,!0):s.gotoDate(c):s.gotoDate(new Date),l.bound?(this.hide(),s.el.className+=" is-bound",i(l.trigger,"click",s._onInputClick),i(l.trigger,"focus",s._onInputFocus),i(l.trigger,"blur",s._onInputBlur)):this.show();};return D.prototype={config:function(e){this._o||(this._o=w({},b,!0));var t=w(this._o,e,!0);t.isRTL=!!t.isRTL,t.field=t.field&&t.field.nodeName?t.field:null,t.theme="string"==typeof t.theme&&t.theme?t.theme:null,t.bound=!!(void 0!==t.bound?t.field&&t.bound:t.field),t.trigger=t.trigger&&t.trigger.nodeName?t.trigger:t.field,t.disableWeekends=!!t.disableWeekends,t.disableDayFn="function"==typeof t.disableDayFn?t.disableDayFn:null;var n=parseInt(t.numberOfMonths,10)||1;if(t.numberOfMonths=n>4?4:n,d(t.minDate)||(t.minDate=!1),d(t.maxDate)||(t.maxDate=!1),t.minDate&&t.maxDate&&t.minDate>t.maxDate&&(t.maxDate=t.minDate=!1),t.minDate&&this.setMinDate(t.minDate),t.maxDate&&this.setMaxDate(t.maxDate),f(t.yearRange)){var o=(new Date).getFullYear()-10;t.yearRange[0]=parseInt(t.yearRange[0],10)||o,t.yearRange[1]=parseInt(t.yearRange[1],10)||o;}else(t.yearRange=Math.abs(parseInt(t.yearRange,10))||b.yearRange)>100&&(t.yearRange=100);return t},toString:function(n){return d(this._d)?t?e(this._d).format(n||this._o.format):this._d.toDateString():""},getMoment:function(){return t?e(this._d):null},setMoment:function(n,o){t&&e.isMoment(n)&&this.setDate(n.toDate(),o);},getDate:function(){return d(this._d)?new Date(this._d.getTime()):new Date},setDate:function(e,t){if(!e)return this._d=null,this._o.field&&(this._o.field.value="",s(this._o.field,"change",{firedBy:this})),this.draw();if("string"==typeof e&&(e=new Date(Date.parse(e))),d(e)){var n=this._o.minDate,o=this._o.maxDate;d(n)&&n>e?e=n:d(o)&&e>o&&(e=o),this._d=new Date(e.getTime()),m(this._d),this.gotoDate(this._d),this._o.field&&(this._o.field.value=""+this,s(this._o.field,"change",{firedBy:this})),t||"function"!=typeof this._o.onSelect||this._o.onSelect.call(this,this.getDate());}},gotoDate:function(e){var t=!0;if(d(e)){if(this.calendars){var n=new Date(this.calendars[0].year,this.calendars[0].month,1),o=new Date(this.calendars[this.calendars.length-1].year,this.calendars[this.calendars.length-1].month,1),r=e.getTime();o.setMonth(o.getMonth()+1),o.setDate(o.getDate()-1),t=r<n.getTime()||o.getTime()<r;}t&&(this.calendars=[{month:e.getMonth(),year:e.getFullYear()}],"right"===this._o.mainCalendar&&(this.calendars[0].month+=1-this._o.numberOfMonths)),this.adjustCalendars();}},adjustDate:function(n,o){var r,i=this.getDate(),a=24*parseInt(o)*60*60*1e3;"add"===n?r=new Date(i.valueOf()+a):"subtract"===n&&(r=new Date(i.valueOf()-a)),t&&("add"===n?r=e(i).add(o,"days").toDate():"subtract"===n&&(r=e(i).subtract(o,"days").toDate())),this.setDate(r);},adjustCalendars:function(){this.calendars[0]=C(this.calendars[0]);for(var e=1;this._o.numberOfMonths>e;e++)this.calendars[e]=C({month:this.calendars[0].month+e,year:this.calendars[0].year});this.draw();},gotoToday:function(){this.gotoDate(new Date);},gotoMonth:function(e){isNaN(e)||(this.calendars[0].month=parseInt(e,10),this.adjustCalendars());},nextMonth:function(){this.calendars[0].month++,this.adjustCalendars();},prevMonth:function(){this.calendars[0].month--,this.adjustCalendars();},gotoYear:function(e){isNaN(e)||(this.calendars[0].year=parseInt(e,10),this.adjustCalendars());},setMinDate:function(e){e instanceof Date?(m(e),this._o.minDate=e,this._o.minYear=e.getFullYear(),this._o.minMonth=e.getMonth()):(this._o.minDate=b.minDate,this._o.minYear=b.minYear,this._o.minMonth=b.minMonth,this._o.startRange=b.startRange),this.draw();},setMaxDate:function(e){e instanceof Date?(m(e),this._o.maxDate=e,this._o.maxYear=e.getFullYear(),this._o.maxMonth=e.getMonth()):(this._o.maxDate=b.maxDate,this._o.maxYear=b.maxYear,this._o.maxMonth=b.maxMonth,this._o.endRange=b.endRange),this.draw();},setStartRange:function(e){this._o.startRange=e;},setEndRange:function(e){this._o.endRange=e;},draw:function(e){if(this._v||e){var t,n=this._o,o=n.minYear,i=n.maxYear,a=n.minMonth,s=n.maxMonth,l="";this._y>o||(this._y=o,!isNaN(a)&&a>this._m&&(this._m=a)),i>this._y||(this._y=i,!isNaN(s)&&this._m>s&&(this._m=s)),t="pika-title-"+Math.random().toString(36).replace(/[^a-z]+/g,"").substr(0,2);for(var u=0;n.numberOfMonths>u;u++)l+='<div class="pika-lendar">'+R(this,u,this.calendars[u].year,this.calendars[u].month,this.calendars[0].year,t)+this.render(this.calendars[u].year,this.calendars[u].month,t)+"</div>";this.el.innerHTML=l,n.bound&&"hidden"!==n.field.type&&r(function(){n.trigger.focus();},1),"function"==typeof this._o.onDraw&&this._o.onDraw(this),n.bound&&n.field.setAttribute("aria-label","Use the arrow keys to pick a date");}},adjustPosition:function(){var e,t,n,r,i,a,s,l,u,c;if(!this._o.container){if(this.el.style.position="absolute",e=this._o.trigger,t=e,n=this.el.offsetWidth,r=this.el.offsetHeight,i=window.innerWidth||o.documentElement.clientWidth,a=window.innerHeight||o.documentElement.clientHeight,s=window.pageYOffset||o.body.scrollTop||o.documentElement.scrollTop,"function"==typeof e.getBoundingClientRect)c=e.getBoundingClientRect(),l=c.left+window.pageXOffset,u=c.bottom+window.pageYOffset;else for(l=t.offsetLeft,u=t.offsetTop+t.offsetHeight;t=t.offsetParent;)l+=t.offsetLeft,u+=t.offsetTop;(this._o.reposition&&l+n>i||this._o.position.indexOf("right")>-1&&l-n+e.offsetWidth>0)&&(l=l-n+e.offsetWidth),(this._o.reposition&&u+r>a+s||this._o.position.indexOf("top")>-1&&u-r-e.offsetHeight>0)&&(u=u-r-e.offsetHeight),this.el.style.left=l+"px",this.el.style.top=u+"px";}},render:function(e,t,n){var o=this._o,r=new Date,i=v(e,t),a=new Date(e,t,1).getDay(),s=[],l=[];m(r),o.firstDay>0&&0>(a-=o.firstDay)&&(a+=7);for(var u=0===t?11:t-1,c=11===t?0:t+1,h=0===t?e-1:e,f=11===t?e+1:e,g=v(h,u),w=i+a,C=w;C>7;)C-=7;w+=7-C;for(var b=0,_=0;w>b;b++){var T=new Date(e,t,b-a+1),k=!!d(this._d)&&y(T,this._d),R=y(T,r),D=a>b||b>=i+a,A=b-a+1,N=t,P=e,H=o.startRange&&y(o.startRange,T),L=o.endRange&&y(o.endRange,T),x=o.startRange&&o.endRange&&T>o.startRange&&o.endRange>T,I=o.minDate&&o.minDate>T||o.maxDate&&T>o.maxDate||o.disableWeekends&&p(T)||o.disableDayFn&&o.disableDayFn(T);D&&(a>b?(A=g+A,N=u,P=h):(A-=i,N=c,P=f));l.push(S({day:A,month:N,year:P,isSelected:k,isToday:R,isDisabled:I,isEmpty:D,isStartRange:H,isEndRange:L,isInRange:x,showDaysInNextAndPreviousMonths:o.showDaysInNextAndPreviousMonths})),7==++_&&(o.showWeekNumber&&l.unshift(E(b-a,t,e)),s.push(O(l,o.isRTL)),l=[],_=0);}return M(o,s,n)},isVisible:function(){return this._v},show:function(){this.isVisible()||(h(this.el,"is-hidden"),this._v=!0,this.draw(),this._o.bound&&(i(o,"click",this._onClick),this.adjustPosition()),"function"==typeof this._o.onOpen&&this._o.onOpen.call(this));},hide:function(){var e=this._v;!1!==e&&(this._o.bound&&a(o,"click",this._onClick),this.el.style.position="static",this.el.style.left="auto",this.el.style.top="auto",c(this.el,"is-hidden"),this._v=!1,void 0!==e&&"function"==typeof this._o.onClose&&this._o.onClose.call(this));},destroy:function(){this.hide(),a(this.el,"mousedown",this._onMouseDown,!0),a(this.el,"touchend",this._onMouseDown,!0),a(this.el,"change",this._onChange),this._o.field&&(a(this._o.field,"change",this._onInputChange),this._o.bound&&(a(this._o.trigger,"click",this._onInputClick),a(this._o.trigger,"focus",this._onInputFocus),a(this._o.trigger,"blur",this._onInputBlur))),this.el.parentNode&&this.el.parentNode.removeChild(this.el);}},D});},function(e,t,n){(function(e){!function(t,n){e.exports=n();}(0,function(){function t(){return Mo.apply(null,arguments)}function o(e){return e instanceof Array||"[object Array]"===Object.prototype.toString.call(e)}function r(e){return null!=e&&"[object Object]"===Object.prototype.toString.call(e)}function i(e){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(e).length;var t;for(t in e)if(e.hasOwnProperty(t))return !1;return !0}function a(e){return void 0===e}function s(e){return "number"==typeof e||"[object Number]"===Object.prototype.toString.call(e)}function l(e){return e instanceof Date||"[object Date]"===Object.prototype.toString.call(e)}function u(e,t){var n,o=[];for(n=0;e.length>n;++n)o.push(t(e[n],n));return o}function c(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function h(e,t){for(var n in t)c(t,n)&&(e[n]=t[n]);return c(t,"toString")&&(e.toString=t.toString),c(t,"valueOf")&&(e.valueOf=t.valueOf),e}function f(e,t,n,o){return Ot(e,t,n,o,!0).utc()}function d(){return {empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}}function p(e){return null==e._pf&&(e._pf=d()),e._pf}function g(e){if(null==e._isValid){var t=p(e),n=Do.call(t.parsedDateParts,function(e){return null!=e}),o=!isNaN(e._d.getTime())&&0>t.overflow&&!t.empty&&!t.invalidMonth&&!t.invalidWeekday&&!t.weekdayMismatch&&!t.nullInput&&!t.invalidFormat&&!t.userInvalidated&&(!t.meridiem||t.meridiem&&n);if(e._strict&&(o=o&&0===t.charsLeftOver&&0===t.unusedTokens.length&&void 0===t.bigHour),null!=Object.isFrozen&&Object.isFrozen(e))return o;e._isValid=o;}return e._isValid}function v(e){var t=f(NaN);return null!=e?h(p(t),e):p(t).userInvalidated=!0,t}function m(e,t){var n,o,r;if(a(t._isAMomentObject)||(e._isAMomentObject=t._isAMomentObject),a(t._i)||(e._i=t._i),a(t._f)||(e._f=t._f),a(t._l)||(e._l=t._l),a(t._strict)||(e._strict=t._strict),a(t._tzm)||(e._tzm=t._tzm),a(t._isUTC)||(e._isUTC=t._isUTC),a(t._offset)||(e._offset=t._offset),a(t._pf)||(e._pf=p(t)),a(t._locale)||(e._locale=t._locale),Ao.length>0)for(n=0;Ao.length>n;n++)o=Ao[n],r=t[o],a(r)||(e[o]=r);return e}function y(e){m(this,e),this._d=new Date(null!=e._d?e._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===No&&(No=!0,t.updateOffset(this),No=!1);}function w(e){return e instanceof y||null!=e&&null!=e._isAMomentObject}function C(e){return 0>e?Math.ceil(e)||0:Math.floor(e)}function b(e){var t=+e,n=0;return 0!==t&&isFinite(t)&&(n=C(t)),n}function _(e,t,n){var o,r=Math.min(e.length,t.length),i=Math.abs(e.length-t.length),a=0;for(o=0;r>o;o++)(n&&e[o]!==t[o]||!n&&b(e[o])!==b(t[o]))&&a++;return a+i}function S(e){!1===t.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+e);}function E(e,n){var o=!0;return h(function(){if(null!=t.deprecationHandler&&t.deprecationHandler(null,e),o){for(var r,i=[],a=0;arguments.length>a;a++){if(r="","object"==typeof arguments[a]){r+="\n["+a+"] ";for(var s in arguments[0])r+=s+": "+arguments[0][s]+", ";r=r.slice(0,-2);}else r=arguments[a];i.push(r);}S(e+"\nArguments: "+Array.prototype.slice.call(i).join("")+"\n"+Error().stack),o=!1;}return n.apply(this,arguments)},n)}function O(e,n){null!=t.deprecationHandler&&t.deprecationHandler(e,n),Po[e]||(S(n),Po[e]=!0);}function T(e){return e instanceof Function||"[object Function]"===Object.prototype.toString.call(e)}function k(e){var t,n;for(n in e)t=e[n],T(t)?this[n]=t:this["_"+n]=t;this._config=e,this._dayOfMonthOrdinalParseLenient=RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source);}function R(e,t){var n,o=h({},e);for(n in t)c(t,n)&&(r(e[n])&&r(t[n])?(o[n]={},h(o[n],e[n]),h(o[n],t[n])):null!=t[n]?o[n]=t[n]:delete o[n]);for(n in e)c(e,n)&&!c(t,n)&&r(e[n])&&(o[n]=h({},o[n]));return o}function M(e){null!=e&&this.set(e);}function D(e,t,n){var o=this._calendar[e]||this._calendar.sameElse;return T(o)?o.call(t,n):o}function A(e){var t=this._longDateFormat[e],n=this._longDateFormat[e.toUpperCase()];return t||!n?t:this._longDateFormat[e]=n.replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)})}function N(){return this._invalidDate}function P(e){return this._ordinal.replace("%d",e)}function H(e,t,n,o){var r=this._relativeTime[n];return T(r)?r(e,t,n,o):r.replace(/%d/i,e)}function L(e,t){var n=this._relativeTime[e>0?"future":"past"];return T(n)?n(t):n.replace(/%s/i,t)}function x(e,t){var n=e.toLowerCase();Fo[n]=Fo[n+"s"]=Fo[t]=e;}function I(e){return "string"==typeof e?Fo[e]||Fo[e.toLowerCase()]:void 0}function j(e){var t,n,o={};for(n in e)c(e,n)&&(t=I(n))&&(o[t]=e[n]);return o}function F(e,t){Wo[e]=t;}function W(e){var t=[];for(var n in e)t.push({unit:n,priority:Wo[n]});return t.sort(function(e,t){return e.priority-t.priority}),t}function B(e,t,n){var o=""+Math.abs(e),r=t-o.length;return (0>e?"-":n?"+":"")+(""+Math.pow(10,Math.max(0,r))).substr(1)+o}function Y(e,t,n,o){var r=o;"string"==typeof o&&(r=function(){return this[o]()}),e&&(Uo[e]=r),t&&(Uo[t[0]]=function(){return B(r.apply(this,arguments),t[1],t[2])}),n&&(Uo[n]=function(){return this.localeData().ordinal(r.apply(this,arguments),e)});}function V(e){return e.match(/\[[\s\S]/)?e.replace(/^\[|\]$/g,""):e.replace(/\\/g,"")}function U(e){var t,n,o=e.match(Bo);for(t=0,n=o.length;n>t;t++)o[t]=Uo[o[t]]?Uo[o[t]]:V(o[t]);return function(t){var r,i="";for(r=0;n>r;r++)i+=T(o[r])?o[r].call(t,e):o[r];return i}}function z(e,t){return e.isValid()?(t=G(t,e.localeData()),(Vo[t]=Vo[t]||U(t))(e)):e.localeData().invalidDate()}function G(e,t){function n(e){return t.longDateFormat(e)||e}var o=5;for(Yo.lastIndex=0;o>=0&&Yo.test(e);)e=e.replace(Yo,n),Yo.lastIndex=0,o-=1;return e}function K(e,t,n){lr[e]=T(t)?t:function(e,o){return e&&n?n:t};}function X(e,t){return c(lr,e)?lr[e](t._strict,t._locale):RegExp(q(e))}function q(e){return Z(e.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(e,t,n,o,r){return t||n||o||r}))}function Z(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function $(e,t){var n,o=t;for("string"==typeof e&&(e=[e]),s(t)&&(o=function(e,n){n[t]=b(e);}),n=0;e.length>n;n++)ur[e[n]]=o;}function J(e,t){$(e,function(e,n,o,r){o._w=o._w||{},t(e,o._w,o,r);});}function Q(e,t,n){null!=t&&c(ur,e)&&ur[e](t,n._a,n,e);}function ee(e){return te(e)?366:365}function te(e){return e%4==0&&e%100!=0||e%400==0}function ne(){return te(this.year())}function oe(e,n){return function(o){return null!=o?(ie(this,e,o),t.updateOffset(this,n),this):re(this,e)}}function re(e,t){return e.isValid()?e._d["get"+(e._isUTC?"UTC":"")+t]():NaN}function ie(e,t,n){e.isValid()&&!isNaN(n)&&("FullYear"===t&&te(e.year())&&1===e.month()&&29===e.date()?e._d["set"+(e._isUTC?"UTC":"")+t](n,e.month(),ue(n,e.month())):e._d["set"+(e._isUTC?"UTC":"")+t](n));}function ae(e){return e=I(e),T(this[e])?this[e]():this}function se(e,t){if("object"==typeof e){e=j(e);for(var n=W(e),o=0;n.length>o;o++)this[n[o].unit](e[n[o].unit]);}else if(e=I(e),T(this[e]))return this[e](t);return this}function le(e,t){return (e%t+t)%t}function ue(e,t){if(isNaN(e)||isNaN(t))return NaN;var n=le(t,12);return e+=(t-n)/12,1===n?te(e)?29:28:31-n%7%2}function ce(e,t){return e?o(this._months)?this._months[e.month()]:this._months[(this._months.isFormat||br).test(t)?"format":"standalone"][e.month()]:o(this._months)?this._months:this._months.standalone}function he(e,t){return e?o(this._monthsShort)?this._monthsShort[e.month()]:this._monthsShort[br.test(t)?"format":"standalone"][e.month()]:o(this._monthsShort)?this._monthsShort:this._monthsShort.standalone}function fe(e,t,n){var o,r,i,a=e.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],o=0;12>o;++o)i=f([2e3,o]),this._shortMonthsParse[o]=this.monthsShort(i,"").toLocaleLowerCase(),this._longMonthsParse[o]=this.months(i,"").toLocaleLowerCase();return n?"MMM"===t?(r=wr.call(this._shortMonthsParse,a),-1!==r?r:null):(r=wr.call(this._longMonthsParse,a),-1!==r?r:null):"MMM"===t?-1!==(r=wr.call(this._shortMonthsParse,a))?r:(r=wr.call(this._longMonthsParse,a),-1!==r?r:null):-1!==(r=wr.call(this._longMonthsParse,a))?r:(r=wr.call(this._shortMonthsParse,a),-1!==r?r:null)}function de(e,t,n){var o,r,i;if(this._monthsParseExact)return fe.call(this,e,t,n);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),o=0;12>o;o++){if(r=f([2e3,o]),n&&!this._longMonthsParse[o]&&(this._longMonthsParse[o]=RegExp("^"+this.months(r,"").replace(".","")+"$","i"),this._shortMonthsParse[o]=RegExp("^"+this.monthsShort(r,"").replace(".","")+"$","i")),n||this._monthsParse[o]||(i="^"+this.months(r,"")+"|^"+this.monthsShort(r,""),this._monthsParse[o]=RegExp(i.replace(".",""),"i")),n&&"MMMM"===t&&this._longMonthsParse[o].test(e))return o;if(n&&"MMM"===t&&this._shortMonthsParse[o].test(e))return o;if(!n&&this._monthsParse[o].test(e))return o}}function pe(e,t){var n;if(!e.isValid())return e;if("string"==typeof t)if(/^\d+$/.test(t))t=b(t);else if(t=e.localeData().monthsParse(t),!s(t))return e;return n=Math.min(e.date(),ue(e.year(),t)),e._d["set"+(e._isUTC?"UTC":"")+"Month"](t,n),e}function ge(e){return null!=e?(pe(this,e),t.updateOffset(this,!0),this):re(this,"Month")}function ve(){return ue(this.year(),this.month())}function me(e){return this._monthsParseExact?(c(this,"_monthsRegex")||we.call(this),e?this._monthsShortStrictRegex:this._monthsShortRegex):(c(this,"_monthsShortRegex")||(this._monthsShortRegex=Er),this._monthsShortStrictRegex&&e?this._monthsShortStrictRegex:this._monthsShortRegex)}function ye(e){return this._monthsParseExact?(c(this,"_monthsRegex")||we.call(this),e?this._monthsStrictRegex:this._monthsRegex):(c(this,"_monthsRegex")||(this._monthsRegex=Or),this._monthsStrictRegex&&e?this._monthsStrictRegex:this._monthsRegex)}function we(){function e(e,t){return t.length-e.length}var t,n,o=[],r=[],i=[];for(t=0;12>t;t++)n=f([2e3,t]),o.push(this.monthsShort(n,"")),r.push(this.months(n,"")),i.push(this.months(n,"")),i.push(this.monthsShort(n,""));for(o.sort(e),r.sort(e),i.sort(e),t=0;12>t;t++)o[t]=Z(o[t]),r[t]=Z(r[t]);for(t=0;24>t;t++)i[t]=Z(i[t]);this._monthsRegex=RegExp("^("+i.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=RegExp("^("+r.join("|")+")","i"),this._monthsShortStrictRegex=RegExp("^("+o.join("|")+")","i");}function Ce(e,t,n,o,r,i,a){var s=new Date(e,t,n,o,r,i,a);return 100>e&&e>=0&&isFinite(s.getFullYear())&&s.setFullYear(e),s}function be(e){var t=new Date(Date.UTC.apply(null,arguments));return 100>e&&e>=0&&isFinite(t.getUTCFullYear())&&t.setUTCFullYear(e),t}function _e(e,t,n){var o=7+t-n;return -(7+be(e,0,o).getUTCDay()-t)%7+o-1}function Se(e,t,n,o,r){var i,a,s=(7+n-o)%7,l=_e(e,o,r),u=1+7*(t-1)+s+l;return u>0?u>ee(e)?(i=e+1,a=u-ee(e)):(i=e,a=u):(i=e-1,a=ee(i)+u),{year:i,dayOfYear:a}}function Ee(e,t,n){var o,r,i=_e(e.year(),t,n),a=Math.floor((e.dayOfYear()-i-1)/7)+1;return 1>a?(r=e.year()-1,o=a+Oe(r,t,n)):a>Oe(e.year(),t,n)?(o=a-Oe(e.year(),t,n),r=e.year()+1):(r=e.year(),o=a),{week:o,year:r}}function Oe(e,t,n){var o=_e(e,t,n),r=_e(e+1,t,n);return (ee(e)-o+r)/7}function Te(e){return Ee(e,this._week.dow,this._week.doy).week}function ke(){return this._week.dow}function Re(){return this._week.doy}function Me(e){var t=this.localeData().week(this);return null==e?t:this.add(7*(e-t),"d")}function De(e){var t=Ee(this,1,4).week;return null==e?t:this.add(7*(e-t),"d")}function Ae(e,t){return "string"!=typeof e?e:isNaN(e)?(e=t.weekdaysParse(e),"number"==typeof e?e:null):parseInt(e,10)}function Ne(e,t){return "string"==typeof e?t.weekdaysParse(e)%7||7:isNaN(e)?null:e}function Pe(e,t){return e?o(this._weekdays)?this._weekdays[e.day()]:this._weekdays[this._weekdays.isFormat.test(t)?"format":"standalone"][e.day()]:o(this._weekdays)?this._weekdays:this._weekdays.standalone}function He(e){return e?this._weekdaysShort[e.day()]:this._weekdaysShort}function Le(e){return e?this._weekdaysMin[e.day()]:this._weekdaysMin}function xe(e,t,n){var o,r,i,a=e.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],o=0;7>o;++o)i=f([2e3,1]).day(o),this._minWeekdaysParse[o]=this.weekdaysMin(i,"").toLocaleLowerCase(),this._shortWeekdaysParse[o]=this.weekdaysShort(i,"").toLocaleLowerCase(),this._weekdaysParse[o]=this.weekdays(i,"").toLocaleLowerCase();return n?"dddd"===t?(r=wr.call(this._weekdaysParse,a),-1!==r?r:null):"ddd"===t?(r=wr.call(this._shortWeekdaysParse,a),-1!==r?r:null):(r=wr.call(this._minWeekdaysParse,a),-1!==r?r:null):"dddd"===t?-1!==(r=wr.call(this._weekdaysParse,a))?r:-1!==(r=wr.call(this._shortWeekdaysParse,a))?r:(r=wr.call(this._minWeekdaysParse,a),-1!==r?r:null):"ddd"===t?-1!==(r=wr.call(this._shortWeekdaysParse,a))?r:-1!==(r=wr.call(this._weekdaysParse,a))?r:(r=wr.call(this._minWeekdaysParse,a),-1!==r?r:null):-1!==(r=wr.call(this._minWeekdaysParse,a))?r:-1!==(r=wr.call(this._weekdaysParse,a))?r:(r=wr.call(this._shortWeekdaysParse,a),-1!==r?r:null)}function Ie(e,t,n){var o,r,i;if(this._weekdaysParseExact)return xe.call(this,e,t,n);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),o=0;7>o;o++){if(r=f([2e3,1]).day(o),n&&!this._fullWeekdaysParse[o]&&(this._fullWeekdaysParse[o]=RegExp("^"+this.weekdays(r,"").replace(".","\\.?")+"$","i"),this._shortWeekdaysParse[o]=RegExp("^"+this.weekdaysShort(r,"").replace(".","\\.?")+"$","i"),this._minWeekdaysParse[o]=RegExp("^"+this.weekdaysMin(r,"").replace(".","\\.?")+"$","i")),this._weekdaysParse[o]||(i="^"+this.weekdays(r,"")+"|^"+this.weekdaysShort(r,"")+"|^"+this.weekdaysMin(r,""),this._weekdaysParse[o]=RegExp(i.replace(".",""),"i")),n&&"dddd"===t&&this._fullWeekdaysParse[o].test(e))return o;if(n&&"ddd"===t&&this._shortWeekdaysParse[o].test(e))return o;if(n&&"dd"===t&&this._minWeekdaysParse[o].test(e))return o;if(!n&&this._weekdaysParse[o].test(e))return o}}function je(e){if(!this.isValid())return null!=e?this:NaN;var t=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=e?(e=Ae(e,this.localeData()),this.add(e-t,"d")):t}function Fe(e){if(!this.isValid())return null!=e?this:NaN;var t=(this.day()+7-this.localeData()._week.dow)%7;return null==e?t:this.add(e-t,"d")}function We(e){if(!this.isValid())return null!=e?this:NaN;if(null!=e){var t=Ne(e,this.localeData());return this.day(this.day()%7?t:t-7)}return this.day()||7}function Be(e){return this._weekdaysParseExact?(c(this,"_weekdaysRegex")||Ue.call(this),e?this._weekdaysStrictRegex:this._weekdaysRegex):(c(this,"_weekdaysRegex")||(this._weekdaysRegex=Dr),this._weekdaysStrictRegex&&e?this._weekdaysStrictRegex:this._weekdaysRegex)}function Ye(e){return this._weekdaysParseExact?(c(this,"_weekdaysRegex")||Ue.call(this),e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(c(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=Ar),this._weekdaysShortStrictRegex&&e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)}function Ve(e){return this._weekdaysParseExact?(c(this,"_weekdaysRegex")||Ue.call(this),e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(c(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=Nr),this._weekdaysMinStrictRegex&&e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)}function Ue(){function e(e,t){return t.length-e.length}var t,n,o,r,i,a=[],s=[],l=[],u=[];for(t=0;7>t;t++)n=f([2e3,1]).day(t),o=this.weekdaysMin(n,""),r=this.weekdaysShort(n,""),i=this.weekdays(n,""),a.push(o),s.push(r),l.push(i),u.push(o),u.push(r),u.push(i);for(a.sort(e),s.sort(e),l.sort(e),u.sort(e),t=0;7>t;t++)s[t]=Z(s[t]),l[t]=Z(l[t]),u[t]=Z(u[t]);this._weekdaysRegex=RegExp("^("+u.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=RegExp("^("+l.join("|")+")","i"),this._weekdaysShortStrictRegex=RegExp("^("+s.join("|")+")","i"),this._weekdaysMinStrictRegex=RegExp("^("+a.join("|")+")","i");}function ze(){return this.hours()%12||12}function Ge(){return this.hours()||24}function Ke(e,t){Y(e,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),t)});}function Xe(e,t){return t._meridiemParse}function qe(e){return "p"===(e+"").toLowerCase().charAt(0)}function Ze(e,t,n){return e>11?n?"pm":"PM":n?"am":"AM"}function $e(e){return e?e.toLowerCase().replace("_","-"):e}function Je(e){for(var t,n,o,r,i=0;e.length>i;){for(r=$e(e[i]).split("-"),t=r.length,n=$e(e[i+1]),n=n?n.split("-"):null;t>0;){if(o=Qe(r.slice(0,t).join("-")))return o;if(n&&n.length>=t&&_(r,n,!0)>=t-1)break;t--;}i++;}return Pr}function Qe(t){var o=null;if(!Ir[t]&&void 0!==e&&e&&e.exports)try{o=Pr._abbr;n(488)("./"+t),et(o);}catch(e){}return Ir[t]}function et(e,t){var n;return e&&(n=a(t)?ot(e):tt(e,t),n?Pr=n:"undefined"!=typeof console&&console.warn&&console.warn("Locale "+e+" not found. Did you forget to load it?")),Pr._abbr}function tt(e,t){if(null!==t){var n,o=xr;if(t.abbr=e,null!=Ir[e])O("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),o=Ir[e]._config;else if(null!=t.parentLocale)if(null!=Ir[t.parentLocale])o=Ir[t.parentLocale]._config;else{if(null==(n=Qe(t.parentLocale)))return jr[t.parentLocale]||(jr[t.parentLocale]=[]),jr[t.parentLocale].push({name:e,config:t}),null;o=n._config;}return Ir[e]=new M(R(o,t)),jr[e]&&jr[e].forEach(function(e){tt(e.name,e.config);}),et(e),Ir[e]}return delete Ir[e],null}function nt(e,t){if(null!=t){var n,o,r=xr;o=Qe(e),null!=o&&(r=o._config),t=R(r,t),n=new M(t),n.parentLocale=Ir[e],Ir[e]=n,et(e);}else null!=Ir[e]&&(null!=Ir[e].parentLocale?Ir[e]=Ir[e].parentLocale:null!=Ir[e]&&delete Ir[e]);return Ir[e]}function ot(e){var t;if(e&&e._locale&&e._locale._abbr&&(e=e._locale._abbr),!e)return Pr;if(!o(e)){if(t=Qe(e))return t;e=[e];}return Je(e)}function rt(){return Ho(Ir)}function it(e){var t,n=e._a;return n&&-2===p(e).overflow&&(t=0>n[hr]||n[hr]>11?hr:1>n[fr]||n[fr]>ue(n[cr],n[hr])?fr:0>n[dr]||n[dr]>24||24===n[dr]&&(0!==n[pr]||0!==n[gr]||0!==n[vr])?dr:0>n[pr]||n[pr]>59?pr:0>n[gr]||n[gr]>59?gr:0>n[vr]||n[vr]>999?vr:-1,p(e)._overflowDayOfYear&&(cr>t||t>fr)&&(t=fr),p(e)._overflowWeeks&&-1===t&&(t=mr),p(e)._overflowWeekday&&-1===t&&(t=yr),p(e).overflow=t),e}function at(e,t,n){return null!=e?e:null!=t?t:n}function st(e){var n=new Date(t.now());return e._useUTC?[n.getUTCFullYear(),n.getUTCMonth(),n.getUTCDate()]:[n.getFullYear(),n.getMonth(),n.getDate()]}function lt(e){var t,n,o,r,i,a=[];if(!e._d){for(o=st(e),e._w&&null==e._a[fr]&&null==e._a[hr]&&ut(e),null!=e._dayOfYear&&(i=at(e._a[cr],o[cr]),(e._dayOfYear>ee(i)||0===e._dayOfYear)&&(p(e)._overflowDayOfYear=!0),n=be(i,0,e._dayOfYear),e._a[hr]=n.getUTCMonth(),e._a[fr]=n.getUTCDate()),t=0;3>t&&null==e._a[t];++t)e._a[t]=a[t]=o[t];for(;7>t;t++)e._a[t]=a[t]=null==e._a[t]?2===t?1:0:e._a[t];24===e._a[dr]&&0===e._a[pr]&&0===e._a[gr]&&0===e._a[vr]&&(e._nextDay=!0,e._a[dr]=0),e._d=(e._useUTC?be:Ce).apply(null,a),r=e._useUTC?e._d.getUTCDay():e._d.getDay(),null!=e._tzm&&e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),e._nextDay&&(e._a[dr]=24),e._w&&void 0!==e._w.d&&e._w.d!==r&&(p(e).weekdayMismatch=!0);}}function ut(e){var t,n,o,r,i,a,s,l;if(t=e._w,null!=t.GG||null!=t.W||null!=t.E)i=1,a=4,n=at(t.GG,e._a[cr],Ee(Tt(),1,4).year),o=at(t.W,1),(1>(r=at(t.E,1))||r>7)&&(l=!0);else{i=e._locale._week.dow,a=e._locale._week.doy;var u=Ee(Tt(),i,a);n=at(t.gg,e._a[cr],u.year),o=at(t.w,u.week),null!=t.d?(0>(r=t.d)||r>6)&&(l=!0):null!=t.e?(r=t.e+i,(0>t.e||t.e>6)&&(l=!0)):r=i;}1>o||o>Oe(n,i,a)?p(e)._overflowWeeks=!0:null!=l?p(e)._overflowWeekday=!0:(s=Se(n,o,r,i,a),e._a[cr]=s.year,e._dayOfYear=s.dayOfYear);}function ct(e){var t,n,o,r,i,a,s=e._i,l=Fr.exec(s)||Wr.exec(s);if(l){for(p(e).iso=!0,t=0,n=Yr.length;n>t;t++)if(Yr[t][1].exec(l[1])){r=Yr[t][0],o=!1!==Yr[t][2];break}if(null==r)return void(e._isValid=!1);if(l[3]){for(t=0,n=Vr.length;n>t;t++)if(Vr[t][1].exec(l[3])){i=(l[2]||" ")+Vr[t][0];break}if(null==i)return void(e._isValid=!1)}if(!o&&null!=i)return void(e._isValid=!1);if(l[4]){if(!Br.exec(l[4]))return void(e._isValid=!1);a="Z";}e._f=r+(i||"")+(a||""),yt(e);}else e._isValid=!1;}function ht(e,t,n,o,r,i){var a=[ft(e),Sr.indexOf(t),parseInt(n,10),parseInt(o,10),parseInt(r,10)];return i&&a.push(parseInt(i,10)),a}function ft(e){var t=parseInt(e,10);return t>49?t>999?t:1900+t:2e3+t}function dt(e){return e.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").replace(/^\s\s*/,"").replace(/\s\s*$/,"")}function pt(e,t,n){if(e){if(Rr.indexOf(e)!==new Date(t[0],t[1],t[2]).getDay())return p(n).weekdayMismatch=!0,n._isValid=!1,!1}return !0}function gt(e,t,n){if(e)return Gr[e];if(t)return 0;var o=parseInt(n,10),r=o%100;return (o-r)/100*60+r}function vt(e){var t=zr.exec(dt(e._i));if(t){var n=ht(t[4],t[3],t[2],t[5],t[6],t[7]);if(!pt(t[1],n,e))return;e._a=n,e._tzm=gt(t[8],t[9],t[10]),e._d=be.apply(null,e._a),e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),p(e).rfc2822=!0;}else e._isValid=!1;}function mt(e){var n=Ur.exec(e._i);if(null!==n)return void(e._d=new Date(+n[1]));ct(e),!1===e._isValid&&(delete e._isValid,vt(e),!1===e._isValid&&(delete e._isValid,t.createFromInputFallback(e)));}function yt(e){if(e._f===t.ISO_8601)return void ct(e);if(e._f===t.RFC_2822)return void vt(e);e._a=[],p(e).empty=!0;var n,o,r,i,a,s=""+e._i,l=s.length,u=0;for(r=G(e._f,e._locale).match(Bo)||[],n=0;r.length>n;n++)i=r[n],o=(s.match(X(i,e))||[])[0],o&&(a=s.substr(0,s.indexOf(o)),a.length>0&&p(e).unusedInput.push(a),s=s.slice(s.indexOf(o)+o.length),u+=o.length),Uo[i]?(o?p(e).empty=!1:p(e).unusedTokens.push(i),Q(i,o,e)):e._strict&&!o&&p(e).unusedTokens.push(i);p(e).charsLeftOver=l-u,s.length>0&&p(e).unusedInput.push(s),12>=e._a[dr]&&!0===p(e).bigHour&&e._a[dr]>0&&(p(e).bigHour=void 0),p(e).parsedDateParts=e._a.slice(0),p(e).meridiem=e._meridiem,e._a[dr]=wt(e._locale,e._a[dr],e._meridiem),lt(e),it(e);}function wt(e,t,n){var o;return null==n?t:null!=e.meridiemHour?e.meridiemHour(t,n):null!=e.isPM?(o=e.isPM(n),o&&12>t&&(t+=12),o||12!==t||(t=0),t):t}function Ct(e){var t,n,o,r,i;if(0===e._f.length)return p(e).invalidFormat=!0,void(e._d=new Date(NaN));for(r=0;e._f.length>r;r++)i=0,t=m({},e),null!=e._useUTC&&(t._useUTC=e._useUTC),t._f=e._f[r],yt(t),g(t)&&(i+=p(t).charsLeftOver,i+=10*p(t).unusedTokens.length,p(t).score=i,(null==o||o>i)&&(o=i,n=t));h(e,n||t);}function bt(e){if(!e._d){var t=j(e._i);e._a=u([t.year,t.month,t.day||t.date,t.hour,t.minute,t.second,t.millisecond],function(e){return e&&parseInt(e,10)}),lt(e);}}function _t(e){var t=new y(it(St(e)));return t._nextDay&&(t.add(1,"d"),t._nextDay=void 0),t}function St(e){var t=e._i,n=e._f;return e._locale=e._locale||ot(e._l),null===t||void 0===n&&""===t?v({nullInput:!0}):("string"==typeof t&&(e._i=t=e._locale.preparse(t)),w(t)?new y(it(t)):(l(t)?e._d=t:o(n)?Ct(e):n?yt(e):Et(e),g(e)||(e._d=null),e))}function Et(e){var n=e._i;a(n)?e._d=new Date(t.now()):l(n)?e._d=new Date(n.valueOf()):"string"==typeof n?mt(e):o(n)?(e._a=u(n.slice(0),function(e){return parseInt(e,10)}),lt(e)):r(n)?bt(e):s(n)?e._d=new Date(n):t.createFromInputFallback(e);}function Ot(e,t,n,a,s){var l={};return !0!==n&&!1!==n||(a=n,n=void 0),(r(e)&&i(e)||o(e)&&0===e.length)&&(e=void 0),l._isAMomentObject=!0,l._useUTC=l._isUTC=s,l._l=n,l._i=e,l._f=t,l._strict=a,_t(l)}function Tt(e,t,n,o){return Ot(e,t,n,o,!1)}function kt(e,t){var n,r;if(1===t.length&&o(t[0])&&(t=t[0]),!t.length)return Tt();for(n=t[0],r=1;t.length>r;++r)t[r].isValid()&&!t[r][e](n)||(n=t[r]);return n}function Rt(){return kt("isBefore",[].slice.call(arguments,0))}function Mt(){return kt("isAfter",[].slice.call(arguments,0))}function Dt(e){for(var t in e)if(-1===wr.call(Zr,t)||null!=e[t]&&isNaN(e[t]))return !1;for(var n=!1,o=0;Zr.length>o;++o)if(e[Zr[o]]){if(n)return !1;parseFloat(e[Zr[o]])!==b(e[Zr[o]])&&(n=!0);}return !0}function At(){return this._isValid}function Nt(){return $t(NaN)}function Pt(e){var t=j(e),n=t.year||0,o=t.quarter||0,r=t.month||0,i=t.week||0,a=t.day||0,s=t.hour||0,l=t.minute||0,u=t.second||0,c=t.millisecond||0;this._isValid=Dt(t),this._milliseconds=+c+1e3*u+6e4*l+1e3*s*60*60,this._days=+a+7*i,this._months=+r+3*o+12*n,this._data={},this._locale=ot(),this._bubble();}function Ht(e){return e instanceof Pt}function Lt(e){return 0>e?-1*Math.round(-1*e):Math.round(e)}function xt(e,t){Y(e,0,0,function(){var e=this.utcOffset(),n="+";return 0>e&&(e=-e,n="-"),n+B(~~(e/60),2)+t+B(~~e%60,2)});}function It(e,t){var n=(t||"").match(e);if(null===n)return null;var o=n[n.length-1]||[],r=(o+"").match($r)||["-",0,0],i=60*r[1]+b(r[2]);return 0===i?0:"+"===r[0]?i:-i}function jt(e,n){var o,r;return n._isUTC?(o=n.clone(),r=(w(e)||l(e)?e.valueOf():Tt(e).valueOf())-o.valueOf(),o._d.setTime(o._d.valueOf()+r),t.updateOffset(o,!1),o):Tt(e).local()}function Ft(e){return 15*-Math.round(e._d.getTimezoneOffset()/15)}function Wt(e,n,o){var r,i=this._offset||0;if(!this.isValid())return null!=e?this:NaN;if(null!=e){if("string"==typeof e){if(null===(e=It(ir,e)))return this}else 16>Math.abs(e)&&!o&&(e*=60);return !this._isUTC&&n&&(r=Ft(this)),this._offset=e,this._isUTC=!0,null!=r&&this.add(r,"m"),i!==e&&(!n||this._changeInProgress?nn(this,$t(e-i,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,t.updateOffset(this,!0),this._changeInProgress=null)),this}return this._isUTC?i:Ft(this)}function Bt(e,t){return null!=e?("string"!=typeof e&&(e=-e),this.utcOffset(e,t),this):-this.utcOffset()}function Yt(e){return this.utcOffset(0,e)}function Vt(e){return this._isUTC&&(this.utcOffset(0,e),this._isUTC=!1,e&&this.subtract(Ft(this),"m")),this}function Ut(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var e=It(rr,this._i);null!=e?this.utcOffset(e):this.utcOffset(0,!0);}return this}function zt(e){return !!this.isValid()&&(e=e?Tt(e).utcOffset():0,(this.utcOffset()-e)%60==0)}function Gt(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()}function Kt(){if(!a(this._isDSTShifted))return this._isDSTShifted;var e={};if(m(e,this),e=St(e),e._a){var t=e._isUTC?f(e._a):Tt(e._a);this._isDSTShifted=this.isValid()&&_(e._a,t.toArray())>0;}else this._isDSTShifted=!1;return this._isDSTShifted}function Xt(){return !!this.isValid()&&!this._isUTC}function qt(){return !!this.isValid()&&this._isUTC}function Zt(){return !!this.isValid()&&(this._isUTC&&0===this._offset)}function $t(e,t){var n,o,r,i=e,a=null;return Ht(e)?i={ms:e._milliseconds,d:e._days,M:e._months}:s(e)?(i={},t?i[t]=e:i.milliseconds=e):(a=Jr.exec(e))?(n="-"===a[1]?-1:1,i={y:0,d:b(a[fr])*n,h:b(a[dr])*n,m:b(a[pr])*n,s:b(a[gr])*n,ms:b(Lt(1e3*a[vr]))*n}):(a=Qr.exec(e))?(n="-"===a[1]?-1:1,i={y:Jt(a[2],n),M:Jt(a[3],n),w:Jt(a[4],n),d:Jt(a[5],n),h:Jt(a[6],n),m:Jt(a[7],n),s:Jt(a[8],n)}):null==i?i={}:"object"==typeof i&&("from"in i||"to"in i)&&(r=en(Tt(i.from),Tt(i.to)),i={},i.ms=r.milliseconds,i.M=r.months),o=new Pt(i),Ht(e)&&c(e,"_locale")&&(o._locale=e._locale),o}function Jt(e,t){var n=e&&parseFloat(e.replace(",","."));return (isNaN(n)?0:n)*t}function Qt(e,t){var n={milliseconds:0,months:0};return n.months=t.month()-e.month()+12*(t.year()-e.year()),e.clone().add(n.months,"M").isAfter(t)&&--n.months,n.milliseconds=+t-+e.clone().add(n.months,"M"),n}function en(e,t){var n;return e.isValid()&&t.isValid()?(t=jt(t,e),e.isBefore(t)?n=Qt(e,t):(n=Qt(t,e),n.milliseconds=-n.milliseconds,n.months=-n.months),n):{milliseconds:0,months:0}}function tn(e,t){return function(n,o){var r,i;return null===o||isNaN(+o)||(O(t,"moment()."+t+"(period, number) is deprecated. Please use moment()."+t+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),i=n,n=o,o=i),n="string"==typeof n?+n:n,r=$t(n,o),nn(this,r,e),this}}function nn(e,n,o,r){var i=n._milliseconds,a=Lt(n._days),s=Lt(n._months);e.isValid()&&(r=null==r||r,s&&pe(e,re(e,"Month")+s*o),a&&ie(e,"Date",re(e,"Date")+a*o),i&&e._d.setTime(e._d.valueOf()+i*o),r&&t.updateOffset(e,a||s));}function on(e,t){var n=e.diff(t,"days",!0);return -6>n?"sameElse":-1>n?"lastWeek":0>n?"lastDay":1>n?"sameDay":2>n?"nextDay":7>n?"nextWeek":"sameElse"}function rn(e,n){var o=e||Tt(),r=jt(o,this).startOf("day"),i=t.calendarFormat(this,r)||"sameElse";return this.format(n&&(T(n[i])?n[i].call(this,o):n[i])||this.localeData().calendar(i,this,Tt(o)))}function an(){return new y(this)}function sn(e,t){var n=w(e)?e:Tt(e);return !(!this.isValid()||!n.isValid())&&(t=I(a(t)?"millisecond":t),"millisecond"===t?this.valueOf()>n.valueOf():n.valueOf()<this.clone().startOf(t).valueOf())}function ln(e,t){var n=w(e)?e:Tt(e);return !(!this.isValid()||!n.isValid())&&(t=I(a(t)?"millisecond":t),"millisecond"===t?this.valueOf()<n.valueOf():this.clone().endOf(t).valueOf()<n.valueOf())}function un(e,t,n,o){return o=o||"()",("("===o[0]?this.isAfter(e,n):!this.isBefore(e,n))&&(")"===o[1]?this.isBefore(t,n):!this.isAfter(t,n))}function cn(e,t){var n,o=w(e)?e:Tt(e);return !(!this.isValid()||!o.isValid())&&(t=I(t||"millisecond"),"millisecond"===t?this.valueOf()===o.valueOf():(n=o.valueOf(),this.clone().startOf(t).valueOf()<=n&&n<=this.clone().endOf(t).valueOf()))}function hn(e,t){return this.isSame(e,t)||this.isAfter(e,t)}function fn(e,t){return this.isSame(e,t)||this.isBefore(e,t)}function dn(e,t,n){var o,r,i;if(!this.isValid())return NaN;if(o=jt(e,this),!o.isValid())return NaN;switch(r=6e4*(o.utcOffset()-this.utcOffset()),t=I(t)){case"year":i=pn(this,o)/12;break;case"month":i=pn(this,o);break;case"quarter":i=pn(this,o)/3;break;case"second":i=(this-o)/1e3;break;case"minute":i=(this-o)/6e4;break;case"hour":i=(this-o)/36e5;break;case"day":i=(this-o-r)/864e5;break;case"week":i=(this-o-r)/6048e5;break;default:i=this-o;}return n?i:C(i)}function pn(e,t){var n,o,r=12*(t.year()-e.year())+(t.month()-e.month()),i=e.clone().add(r,"months");return 0>t-i?(n=e.clone().add(r-1,"months"),o=(t-i)/(i-n)):(n=e.clone().add(r+1,"months"),o=(t-i)/(n-i)),-(r+o)||0}function gn(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")}function vn(e){if(!this.isValid())return null;var t=!0!==e,n=t?this.clone().utc():this;return 0>n.year()||n.year()>9999?z(n,t?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):T(Date.prototype.toISOString)?t?this.toDate().toISOString():new Date(this.valueOf()+60*this.utcOffset()*1e3).toISOString().replace("Z",z(n,"Z")):z(n,t?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")}function mn(){if(!this.isValid())return "moment.invalid(/* "+this._i+" */)";var e="moment",t="";this.isLocal()||(e=0===this.utcOffset()?"moment.utc":"moment.parseZone",t="Z");return this.format("["+e+'("]'+(0>this.year()||this.year()>9999?"YYYYYY":"YYYY")+"-MM-DD[T]HH:mm:ss.SSS"+t+'[")]')}function yn(e){e||(e=this.isUtc()?t.defaultFormatUtc:t.defaultFormat);var n=z(this,e);return this.localeData().postformat(n)}function wn(e,t){return this.isValid()&&(w(e)&&e.isValid()||Tt(e).isValid())?$t({to:this,from:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()}function Cn(e){return this.from(Tt(),e)}function bn(e,t){return this.isValid()&&(w(e)&&e.isValid()||Tt(e).isValid())?$t({from:this,to:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()}function _n(e){return this.to(Tt(),e)}function Sn(e){var t;return void 0===e?this._locale._abbr:(t=ot(e),null!=t&&(this._locale=t),this)}function En(){return this._locale}function On(e){switch(e=I(e)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":case"date":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0);}return "week"===e&&this.weekday(0),"isoWeek"===e&&this.isoWeekday(1),"quarter"===e&&this.month(3*Math.floor(this.month()/3)),this}function Tn(e){return void 0===(e=I(e))||"millisecond"===e?this:("date"===e&&(e="day"),this.startOf(e).add(1,"isoWeek"===e?"week":e).subtract(1,"ms"))}function kn(){return this._d.valueOf()-6e4*(this._offset||0)}function Rn(){return Math.floor(this.valueOf()/1e3)}function Mn(){return new Date(this.valueOf())}function Dn(){var e=this;return [e.year(),e.month(),e.date(),e.hour(),e.minute(),e.second(),e.millisecond()]}function An(){var e=this;return {years:e.year(),months:e.month(),date:e.date(),hours:e.hours(),minutes:e.minutes(),seconds:e.seconds(),milliseconds:e.milliseconds()}}function Nn(){return this.isValid()?this.toISOString():null}function Pn(){return g(this)}function Hn(){return h({},p(this))}function Ln(){return p(this).overflow}function xn(){return {input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}}function In(e,t){Y(0,[e,e.length],0,t);}function jn(e){return Yn.call(this,e,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)}function Fn(e){return Yn.call(this,e,this.isoWeek(),this.isoWeekday(),1,4)}function Wn(){return Oe(this.year(),1,4)}function Bn(){var e=this.localeData()._week;return Oe(this.year(),e.dow,e.doy)}function Yn(e,t,n,o,r){var i;return null==e?Ee(this,o,r).year:(i=Oe(e,o,r),t>i&&(t=i),Vn.call(this,e,t,n,o,r))}function Vn(e,t,n,o,r){var i=Se(e,t,n,o,r),a=be(i.year,0,i.dayOfYear);return this.year(a.getUTCFullYear()),this.month(a.getUTCMonth()),this.date(a.getUTCDate()),this}function Un(e){return null==e?Math.ceil((this.month()+1)/3):this.month(3*(e-1)+this.month()%3)}function zn(e){var t=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==e?t:this.add(e-t,"d")}function Gn(e,t){t[vr]=b(1e3*("0."+e));}function Kn(){return this._isUTC?"UTC":""}function Xn(){return this._isUTC?"Coordinated Universal Time":""}function qn(e){return Tt(1e3*e)}function Zn(){return Tt.apply(null,arguments).parseZone()}function $n(e){return e}function Jn(e,t,n,o){return ot()[n](f().set(o,t),e)}function Qn(e,t,n){if(s(e)&&(t=e,e=void 0),e=e||"",null!=t)return Jn(e,t,n,"month");var o,r=[];for(o=0;12>o;o++)r[o]=Jn(e,o,n,"month");return r}function eo(e,t,n,o){"boolean"==typeof e?(s(t)&&(n=t,t=void 0),t=t||""):(t=e,n=t,e=!1,s(t)&&(n=t,t=void 0),t=t||"");var r=ot(),i=e?r._week.dow:0;if(null!=n)return Jn(t,(n+i)%7,o,"day");var a,l=[];for(a=0;7>a;a++)l[a]=Jn(t,(a+i)%7,o,"day");return l}function to(e,t){return Qn(e,t,"months")}function no(e,t){return Qn(e,t,"monthsShort")}function oo(e,t,n){return eo(e,t,n,"weekdays")}function ro(e,t,n){return eo(e,t,n,"weekdaysShort")}function io(e,t,n){return eo(e,t,n,"weekdaysMin")}function ao(){var e=this._data;return this._milliseconds=ci(this._milliseconds),this._days=ci(this._days),this._months=ci(this._months),e.milliseconds=ci(e.milliseconds),e.seconds=ci(e.seconds),e.minutes=ci(e.minutes),e.hours=ci(e.hours),e.months=ci(e.months),e.years=ci(e.years),this}function so(e,t,n,o){var r=$t(t,n);return e._milliseconds+=o*r._milliseconds,e._days+=o*r._days,e._months+=o*r._months,e._bubble()}function lo(e,t){return so(this,e,t,1)}function uo(e,t){return so(this,e,t,-1)}function co(e){return 0>e?Math.floor(e):Math.ceil(e)}function ho(){var e,t,n,o,r,i=this._milliseconds,a=this._days,s=this._months,l=this._data;return (0>i||0>a||0>s)&&(i>0||a>0||s>0)&&(i+=864e5*co(po(s)+a),a=0,s=0),l.milliseconds=i%1e3,e=C(i/1e3),l.seconds=e%60,t=C(e/60),l.minutes=t%60,n=C(t/60),l.hours=n%24,a+=C(n/24),r=C(fo(a)),s+=r,a-=co(po(r)),o=C(s/12),s%=12,l.days=a,l.months=s,l.years=o,this}function fo(e){return 4800*e/146097}function po(e){return 146097*e/4800}function go(e){if(!this.isValid())return NaN;var t,n,o=this._milliseconds;if("month"===(e=I(e))||"year"===e)return t=this._days+o/864e5,n=this._months+fo(t),"month"===e?n:n/12;switch(t=this._days+Math.round(po(this._months)),e){case"week":return t/7+o/6048e5;case"day":return t+o/864e5;case"hour":return 24*t+o/36e5;case"minute":return 1440*t+o/6e4;case"second":return 86400*t+o/1e3;case"millisecond":return Math.floor(864e5*t)+o;default:throw Error("Unknown unit "+e)}}function vo(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*b(this._months/12):NaN}function mo(e){return function(){return this.as(e)}}function yo(){return $t(this)}function wo(e){return e=I(e),this.isValid()?this[e+"s"]():NaN}function Co(e){return function(){return this.isValid()?this._data[e]:NaN}}function bo(){return C(this.days()/7)}function _o(e,t,n,o,r){return r.relativeTime(t||1,!!n,e,o)}function So(e,t,n){var o=$t(e).abs(),r=Ti(o.as("s")),i=Ti(o.as("m")),a=Ti(o.as("h")),s=Ti(o.as("d")),l=Ti(o.as("M")),u=Ti(o.as("y")),c=ki.ss>=r&&["s",r]||ki.s>r&&["ss",r]||1>=i&&["m"]||ki.m>i&&["mm",i]||1>=a&&["h"]||ki.h>a&&["hh",a]||1>=s&&["d"]||ki.d>s&&["dd",s]||1>=l&&["M"]||ki.M>l&&["MM",l]||1>=u&&["y"]||["yy",u];return c[2]=t,c[3]=+e>0,c[4]=n,_o.apply(null,c)}function Eo(e){return void 0===e?Ti:"function"==typeof e&&(Ti=e,!0)}function Oo(e,t){return void 0!==ki[e]&&(void 0===t?ki[e]:(ki[e]=t,"s"===e&&(ki.ss=t-1),!0))}function To(e){if(!this.isValid())return this.localeData().invalidDate();var t=this.localeData(),n=So(this,!e,t);return e&&(n=t.pastFuture(+this,n)),t.postformat(n)}function ko(e){return (e>0)-(0>e)||+e}function Ro(){if(!this.isValid())return this.localeData().invalidDate();var e,t,n,o=Ri(this._milliseconds)/1e3,r=Ri(this._days),i=Ri(this._months);e=C(o/60),t=C(e/60),o%=60,e%=60,n=C(i/12),i%=12;var a=n,s=i,l=r,u=t,c=e,h=o?o.toFixed(3).replace(/\.?0+$/,""):"",f=this.asSeconds();if(!f)return "P0D";var d=0>f?"-":"",p=ko(this._months)!==ko(f)?"-":"",g=ko(this._days)!==ko(f)?"-":"",v=ko(this._milliseconds)!==ko(f)?"-":"";return d+"P"+(a?p+a+"Y":"")+(s?p+s+"M":"")+(l?g+l+"D":"")+(u||c||h?"T":"")+(u?v+u+"H":"")+(c?v+c+"M":"")+(h?v+h+"S":"")}var Mo,Do;Do=Array.prototype.some?Array.prototype.some:function(e){for(var t=Object(this),n=t.length>>>0,o=0;n>o;o++)if(o in t&&e.call(this,t[o],o,t))return !0;return !1};var Ao=t.momentProperties=[],No=!1,Po={};t.suppressDeprecationWarnings=!1,t.deprecationHandler=null;var Ho;Ho=Object.keys?Object.keys:function(e){var t,n=[];for(t in e)c(e,t)&&n.push(t);return n};var Lo={sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},xo={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},Io=/\d{1,2}/,jo={future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},Fo={},Wo={},Bo=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,Yo=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,Vo={},Uo={},zo=/\d/,Go=/\d\d/,Ko=/\d{3}/,Xo=/\d{4}/,qo=/[+-]?\d{6}/,Zo=/\d\d?/,$o=/\d\d\d\d?/,Jo=/\d\d\d\d\d\d?/,Qo=/\d{1,3}/,er=/\d{1,4}/,tr=/[+-]?\d{1,6}/,nr=/\d+/,or=/[+-]?\d+/,rr=/Z|[+-]\d\d:?\d\d/gi,ir=/Z|[+-]\d\d(?::?\d\d)?/gi,ar=/[+-]?\d+(\.\d{1,3})?/,sr=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,lr={},ur={},cr=0,hr=1,fr=2,dr=3,pr=4,gr=5,vr=6,mr=7,yr=8;Y("Y",0,0,function(){var e=this.year();return e>9999?"+"+e:""+e}),Y(0,["YY",2],0,function(){return this.year()%100}),Y(0,["YYYY",4],0,"year"),Y(0,["YYYYY",5],0,"year"),Y(0,["YYYYYY",6,!0],0,"year"),x("year","y"),F("year",1),K("Y",or),K("YY",Zo,Go),K("YYYY",er,Xo),K("YYYYY",tr,qo),K("YYYYYY",tr,qo),$(["YYYYY","YYYYYY"],cr),$("YYYY",function(e,n){n[cr]=2===e.length?t.parseTwoDigitYear(e):b(e);}),$("YY",function(e,n){n[cr]=t.parseTwoDigitYear(e);}),$("Y",function(e,t){t[cr]=parseInt(e,10);}),t.parseTwoDigitYear=function(e){return b(e)+(b(e)>68?1900:2e3)};var wr,Cr=oe("FullYear",!0);wr=Array.prototype.indexOf?Array.prototype.indexOf:function(e){var t;for(t=0;this.length>t;++t)if(this[t]===e)return t;return -1},Y("M",["MM",2],"Mo",function(){return this.month()+1}),Y("MMM",0,0,function(e){return this.localeData().monthsShort(this,e)}),Y("MMMM",0,0,function(e){return this.localeData().months(this,e)}),x("month","M"),F("month",8),K("M",Zo),K("MM",Zo,Go),K("MMM",function(e,t){return t.monthsShortRegex(e)}),K("MMMM",function(e,t){return t.monthsRegex(e)}),$(["M","MM"],function(e,t){t[hr]=b(e)-1;}),$(["MMM","MMMM"],function(e,t,n,o){var r=n._locale.monthsParse(e,o,n._strict);null!=r?t[hr]=r:p(n).invalidMonth=e;});var br=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,_r="January_February_March_April_May_June_July_August_September_October_November_December".split("_"),Sr="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),Er=sr,Or=sr;Y("w",["ww",2],"wo","week"),Y("W",["WW",2],"Wo","isoWeek"),x("week","w"),x("isoWeek","W"),F("week",5),F("isoWeek",5),K("w",Zo),K("ww",Zo,Go),K("W",Zo),K("WW",Zo,Go),J(["w","ww","W","WW"],function(e,t,n,o){t[o.substr(0,1)]=b(e);});var Tr={dow:0,doy:6};Y("d",0,"do","day"),Y("dd",0,0,function(e){return this.localeData().weekdaysMin(this,e)}),Y("ddd",0,0,function(e){return this.localeData().weekdaysShort(this,e)}),Y("dddd",0,0,function(e){return this.localeData().weekdays(this,e)}),Y("e",0,0,"weekday"),Y("E",0,0,"isoWeekday"),x("day","d"),x("weekday","e"),x("isoWeekday","E"),F("day",11),F("weekday",11),F("isoWeekday",11),K("d",Zo),K("e",Zo),K("E",Zo),K("dd",function(e,t){return t.weekdaysMinRegex(e)}),K("ddd",function(e,t){return t.weekdaysShortRegex(e)}),K("dddd",function(e,t){return t.weekdaysRegex(e)}),J(["dd","ddd","dddd"],function(e,t,n,o){var r=n._locale.weekdaysParse(e,o,n._strict);null!=r?t.d=r:p(n).invalidWeekday=e;}),J(["d","e","E"],function(e,t,n,o){t[o]=b(e);});var kr="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),Rr="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),Mr="Su_Mo_Tu_We_Th_Fr_Sa".split("_"),Dr=sr,Ar=sr,Nr=sr;Y("H",["HH",2],0,"hour"),Y("h",["hh",2],0,ze),Y("k",["kk",2],0,Ge),Y("hmm",0,0,function(){return ""+ze.apply(this)+B(this.minutes(),2)}),Y("hmmss",0,0,function(){return ""+ze.apply(this)+B(this.minutes(),2)+B(this.seconds(),2)}),Y("Hmm",0,0,function(){return ""+this.hours()+B(this.minutes(),2)}),Y("Hmmss",0,0,function(){return ""+this.hours()+B(this.minutes(),2)+B(this.seconds(),2)}),Ke("a",!0),Ke("A",!1),x("hour","h"),F("hour",13),K("a",Xe),K("A",Xe),K("H",Zo),K("h",Zo),K("k",Zo),K("HH",Zo,Go),K("hh",Zo,Go),K("kk",Zo,Go),K("hmm",$o),K("hmmss",Jo),K("Hmm",$o),K("Hmmss",Jo),$(["H","HH"],dr),$(["k","kk"],function(e,t,n){var o=b(e);t[dr]=24===o?0:o;}),$(["a","A"],function(e,t,n){n._isPm=n._locale.isPM(e),n._meridiem=e;}),$(["h","hh"],function(e,t,n){t[dr]=b(e),p(n).bigHour=!0;}),$("hmm",function(e,t,n){var o=e.length-2;t[dr]=b(e.substr(0,o)),t[pr]=b(e.substr(o)),p(n).bigHour=!0;}),$("hmmss",function(e,t,n){var o=e.length-4,r=e.length-2;t[dr]=b(e.substr(0,o)),t[pr]=b(e.substr(o,2)),t[gr]=b(e.substr(r)),p(n).bigHour=!0;}),$("Hmm",function(e,t,n){var o=e.length-2;t[dr]=b(e.substr(0,o)),t[pr]=b(e.substr(o));}),$("Hmmss",function(e,t,n){var o=e.length-4,r=e.length-2;t[dr]=b(e.substr(0,o)),t[pr]=b(e.substr(o,2)),t[gr]=b(e.substr(r));});var Pr,Hr=/[ap]\.?m?\.?/i,Lr=oe("Hours",!0),xr={calendar:Lo,longDateFormat:xo,invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:Io,relativeTime:jo,months:_r,monthsShort:Sr,week:Tr,weekdays:kr,weekdaysMin:Mr,weekdaysShort:Rr,meridiemParse:Hr},Ir={},jr={},Fr=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,Wr=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,Br=/Z|[+-]\d\d(?::?\d\d)?/,Yr=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],Vr=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],Ur=/^\/?Date\((\-?\d+)/i,zr=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,Gr={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};t.createFromInputFallback=E("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(e){e._d=new Date(e._i+(e._useUTC?" UTC":""));}),t.ISO_8601=function(){},t.RFC_2822=function(){};var Kr=E("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=Tt.apply(null,arguments);return this.isValid()&&e.isValid()?this>e?this:e:v()}),Xr=E("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=Tt.apply(null,arguments);return this.isValid()&&e.isValid()?e>this?this:e:v()}),qr=function(){return Date.now?Date.now():+new Date},Zr=["year","quarter","month","week","day","hour","minute","second","millisecond"];xt("Z",":"),xt("ZZ",""),K("Z",ir),K("ZZ",ir),$(["Z","ZZ"],function(e,t,n){n._useUTC=!0,n._tzm=It(ir,e);});var $r=/([\+\-]|\d\d)/gi;t.updateOffset=function(){};var Jr=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,Qr=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;$t.fn=Pt.prototype,$t.invalid=Nt;var ei=tn(1,"add"),ti=tn(-1,"subtract");t.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",t.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var ni=E("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(e){return void 0===e?this.localeData():this.locale(e)});Y(0,["gg",2],0,function(){return this.weekYear()%100}),Y(0,["GG",2],0,function(){return this.isoWeekYear()%100}),In("gggg","weekYear"),In("ggggg","weekYear"),In("GGGG","isoWeekYear"),In("GGGGG","isoWeekYear"),x("weekYear","gg"),x("isoWeekYear","GG"),F("weekYear",1),F("isoWeekYear",1),K("G",or),K("g",or),K("GG",Zo,Go),K("gg",Zo,Go),K("GGGG",er,Xo),K("gggg",er,Xo),K("GGGGG",tr,qo),K("ggggg",tr,qo),J(["gggg","ggggg","GGGG","GGGGG"],function(e,t,n,o){t[o.substr(0,2)]=b(e);}),J(["gg","GG"],function(e,n,o,r){n[r]=t.parseTwoDigitYear(e);}),Y("Q",0,"Qo","quarter"),x("quarter","Q"),F("quarter",7),K("Q",zo),$("Q",function(e,t){t[hr]=3*(b(e)-1);}),Y("D",["DD",2],"Do","date"),x("date","D"),F("date",9),K("D",Zo),K("DD",Zo,Go),K("Do",function(e,t){return e?t._dayOfMonthOrdinalParse||t._ordinalParse:t._dayOfMonthOrdinalParseLenient}),$(["D","DD"],fr),$("Do",function(e,t){t[fr]=b(e.match(Zo)[0]);});var oi=oe("Date",!0);Y("DDD",["DDDD",3],"DDDo","dayOfYear"),x("dayOfYear","DDD"),F("dayOfYear",4),K("DDD",Qo),K("DDDD",Ko),$(["DDD","DDDD"],function(e,t,n){n._dayOfYear=b(e);}),Y("m",["mm",2],0,"minute"),x("minute","m"),F("minute",14),K("m",Zo),K("mm",Zo,Go),$(["m","mm"],pr);var ri=oe("Minutes",!1);Y("s",["ss",2],0,"second"),x("second","s"),F("second",15),K("s",Zo),K("ss",Zo,Go),$(["s","ss"],gr);var ii=oe("Seconds",!1);Y("S",0,0,function(){return ~~(this.millisecond()/100)}),Y(0,["SS",2],0,function(){return ~~(this.millisecond()/10)}),Y(0,["SSS",3],0,"millisecond"),Y(0,["SSSS",4],0,function(){return 10*this.millisecond()}),Y(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),Y(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),Y(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),Y(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),Y(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),x("millisecond","ms"),F("millisecond",16),K("S",Qo,zo),K("SS",Qo,Go),K("SSS",Qo,Ko);var ai;for(ai="SSSS";9>=ai.length;ai+="S")K(ai,nr);for(ai="S";9>=ai.length;ai+="S")$(ai,Gn);var si=oe("Milliseconds",!1);Y("z",0,0,"zoneAbbr"),Y("zz",0,0,"zoneName");var li=y.prototype;li.add=ei,li.calendar=rn,li.clone=an,li.diff=dn,li.endOf=Tn,li.format=yn,li.from=wn,li.fromNow=Cn,li.to=bn,li.toNow=_n,li.get=ae,li.invalidAt=Ln,li.isAfter=sn,li.isBefore=ln,li.isBetween=un,li.isSame=cn,li.isSameOrAfter=hn,li.isSameOrBefore=fn,li.isValid=Pn,li.lang=ni,li.locale=Sn,li.localeData=En,li.max=Xr,li.min=Kr,li.parsingFlags=Hn,li.set=se,li.startOf=On,li.subtract=ti,li.toArray=Dn,li.toObject=An,li.toDate=Mn,li.toISOString=vn,li.inspect=mn,li.toJSON=Nn,li.toString=gn,li.unix=Rn,li.valueOf=kn,li.creationData=xn,li.year=Cr,li.isLeapYear=ne,li.weekYear=jn,li.isoWeekYear=Fn,li.quarter=li.quarters=Un,li.month=ge,li.daysInMonth=ve,li.week=li.weeks=Me,li.isoWeek=li.isoWeeks=De,li.weeksInYear=Bn,li.isoWeeksInYear=Wn,li.date=oi,li.day=li.days=je,li.weekday=Fe,li.isoWeekday=We,li.dayOfYear=zn,li.hour=li.hours=Lr,li.minute=li.minutes=ri,li.second=li.seconds=ii,li.millisecond=li.milliseconds=si,li.utcOffset=Wt,li.utc=Yt,li.local=Vt,li.parseZone=Ut,li.hasAlignedHourOffset=zt,li.isDST=Gt,li.isLocal=Xt,li.isUtcOffset=qt,li.isUtc=Zt,li.isUTC=Zt,li.zoneAbbr=Kn,li.zoneName=Xn,li.dates=E("dates accessor is deprecated. Use date instead.",oi),li.months=E("months accessor is deprecated. Use month instead",ge),li.years=E("years accessor is deprecated. Use year instead",Cr),li.zone=E("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",Bt),li.isDSTShifted=E("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",Kt);var ui=M.prototype;ui.calendar=D,ui.longDateFormat=A,ui.invalidDate=N,ui.ordinal=P,ui.preparse=$n,ui.postformat=$n,ui.relativeTime=H,ui.pastFuture=L,ui.set=k,ui.months=ce,ui.monthsShort=he,ui.monthsParse=de,ui.monthsRegex=ye,ui.monthsShortRegex=me,ui.week=Te,ui.firstDayOfYear=Re,ui.firstDayOfWeek=ke,ui.weekdays=Pe,ui.weekdaysMin=Le,ui.weekdaysShort=He,ui.weekdaysParse=Ie,ui.weekdaysRegex=Be,ui.weekdaysShortRegex=Ye,ui.weekdaysMinRegex=Ve,ui.isPM=qe,ui.meridiem=Ze,et("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var t=e%10;return e+(1===b(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th")}}),t.lang=E("moment.lang is deprecated. Use moment.locale instead.",et),t.langData=E("moment.langData is deprecated. Use moment.localeData instead.",ot);var ci=Math.abs,hi=mo("ms"),fi=mo("s"),di=mo("m"),pi=mo("h"),gi=mo("d"),vi=mo("w"),mi=mo("M"),yi=mo("y"),wi=Co("milliseconds"),Ci=Co("seconds"),bi=Co("minutes"),_i=Co("hours"),Si=Co("days"),Ei=Co("months"),Oi=Co("years"),Ti=Math.round,ki={ss:44,s:45,m:45,h:22,d:26,M:11},Ri=Math.abs,Mi=Pt.prototype;return Mi.isValid=At,Mi.abs=ao,Mi.add=lo,Mi.subtract=uo,Mi.as=go,Mi.asMilliseconds=hi,Mi.asSeconds=fi,Mi.asMinutes=di,Mi.asHours=pi,Mi.asDays=gi,Mi.asWeeks=vi,Mi.asMonths=mi,Mi.asYears=yi,Mi.valueOf=vo,Mi._bubble=ho,Mi.clone=yo,Mi.get=wo,Mi.milliseconds=wi,Mi.seconds=Ci,Mi.minutes=bi,Mi.hours=_i,Mi.days=Si,Mi.weeks=bo,Mi.months=Ei,Mi.years=Oi,Mi.humanize=To,Mi.toISOString=Ro,Mi.toString=Ro,Mi.toJSON=Ro,Mi.locale=Sn,Mi.localeData=En,Mi.toIsoString=E("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",Ro),Mi.lang=ni,Y("X",0,0,"unix"),Y("x",0,0,"valueOf"),K("x",or),K("X",ar),$("X",function(e,t,n){n._d=new Date(1e3*parseFloat(e,10));}),$("x",function(e,t,n){n._d=new Date(b(e));}),t.version="2.22.2",function(e){Mo=e;}(Tt),t.fn=li,t.min=Rt,t.max=Mt,t.now=qr,t.utc=f,t.unix=qn,t.months=to,t.isDate=l,t.locale=et,t.invalid=v,t.duration=$t,t.isMoment=w,t.weekdays=oo,t.parseZone=Zn,t.localeData=ot,t.isDuration=Ht,t.monthsShort=no,t.weekdaysMin=io,t.defineLocale=tt,t.updateLocale=nt,t.locales=rt,t.weekdaysShort=ro,t.normalizeUnits=I,t.relativeTimeRounding=Eo,t.relativeTimeThreshold=Oo,t.calendarFormat=on,t.prototype=li,t.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"YYYY-[W]WW",MONTH:"YYYY-MM"},t});}).call(t,n(183)(e));},function(e,t,n){function o(e){return n(r(e))}function r(e){var t=i[e];if(!(t+1))throw Error("Cannot find module '"+e+"'.");return t}var i={"./af":313,"./af.js":313,"./ar":314,"./ar-dz":315,"./ar-dz.js":315,"./ar-kw":316,"./ar-kw.js":316,"./ar-ly":317,"./ar-ly.js":317,"./ar-ma":318,"./ar-ma.js":318,"./ar-sa":319,"./ar-sa.js":319,"./ar-tn":320,"./ar-tn.js":320,"./ar.js":314,"./az":321,"./az.js":321,"./be":322,"./be.js":322,"./bg":323,"./bg.js":323,"./bm":324,"./bm.js":324,"./bn":325,"./bn.js":325,"./bo":326,"./bo.js":326,"./br":327,"./br.js":327,"./bs":328,"./bs.js":328,"./ca":329,"./ca.js":329,"./cs":330,"./cs.js":330,"./cv":331,"./cv.js":331,"./cy":332,"./cy.js":332,"./da":333,"./da.js":333,"./de":334,"./de-at":335,"./de-at.js":335,"./de-ch":336,"./de-ch.js":336,"./de.js":334,"./dv":337,"./dv.js":337,"./el":338,"./el.js":338,"./en-au":339,"./en-au.js":339,"./en-ca":340,"./en-ca.js":340,"./en-gb":341,"./en-gb.js":341,"./en-ie":342,"./en-ie.js":342,"./en-il":343,"./en-il.js":343,"./en-nz":344,"./en-nz.js":344,"./eo":345,"./eo.js":345,"./es":346,"./es-do":347,"./es-do.js":347,"./es-us":348,"./es-us.js":348,"./es.js":346,"./et":349,"./et.js":349,"./eu":350,"./eu.js":350,"./fa":351,"./fa.js":351,"./fi":352,"./fi.js":352,"./fo":353,"./fo.js":353,"./fr":354,"./fr-ca":355,"./fr-ca.js":355,"./fr-ch":356,"./fr-ch.js":356,"./fr.js":354,"./fy":357,"./fy.js":357,"./gd":358,"./gd.js":358,"./gl":359,"./gl.js":359,"./gom-latn":360,"./gom-latn.js":360,"./gu":361,"./gu.js":361,"./he":362,"./he.js":362,"./hi":363,"./hi.js":363,"./hr":364,"./hr.js":364,"./hu":365,"./hu.js":365,"./hy-am":366,"./hy-am.js":366,"./id":367,"./id.js":367,"./is":368,"./is.js":368,"./it":369,"./it.js":369,"./ja":370,"./ja.js":370,"./jv":371,"./jv.js":371,"./ka":372,"./ka.js":372,"./kk":373,"./kk.js":373,"./km":374,"./km.js":374,"./kn":375,"./kn.js":375,"./ko":376,"./ko.js":376,"./ky":377,"./ky.js":377,"./lb":378,"./lb.js":378,"./lo":379,"./lo.js":379,"./lt":380,"./lt.js":380,"./lv":381,"./lv.js":381,"./me":382,"./me.js":382,"./mi":383,"./mi.js":383,"./mk":384,"./mk.js":384,"./ml":385,"./ml.js":385,"./mn":386,"./mn.js":386,"./mr":387,"./mr.js":387,"./ms":388,"./ms-my":389,"./ms-my.js":389,"./ms.js":388,"./mt":390,"./mt.js":390,"./my":391,"./my.js":391,"./nb":392,"./nb.js":392,"./ne":393,"./ne.js":393,"./nl":394,"./nl-be":395,"./nl-be.js":395,"./nl.js":394,"./nn":396,"./nn.js":396,"./pa-in":397,"./pa-in.js":397,"./pl":398,"./pl.js":398,"./pt":399,"./pt-br":400,"./pt-br.js":400,"./pt.js":399,"./ro":401,"./ro.js":401,"./ru":402,"./ru.js":402,"./sd":403,"./sd.js":403,"./se":404,"./se.js":404,"./si":405,"./si.js":405,"./sk":406,"./sk.js":406,"./sl":407,"./sl.js":407,"./sq":408,"./sq.js":408,"./sr":409,"./sr-cyrl":410,"./sr-cyrl.js":410,"./sr.js":409,"./ss":411,"./ss.js":411,"./sv":412,"./sv.js":412,"./sw":413,"./sw.js":413,"./ta":414,"./ta.js":414,"./te":415,"./te.js":415,"./tet":416,"./tet.js":416,"./tg":417,"./tg.js":417,"./th":418,"./th.js":418,"./tl-ph":419,"./tl-ph.js":419,"./tlh":420,"./tlh.js":420,"./tr":421,"./tr.js":421,"./tzl":422,"./tzl.js":422,"./tzm":423,"./tzm-latn":424,"./tzm-latn.js":424,"./tzm.js":423,"./ug-cn":425,"./ug-cn.js":425,"./uk":426,"./uk.js":426,"./ur":427,"./ur.js":427,"./uz":428,"./uz-latn":429,"./uz-latn.js":429,"./uz.js":428,"./vi":430,"./vi.js":430,"./x-pseudo":431,"./x-pseudo.js":431,"./yo":432,"./yo.js":432,"./zh-cn":433,"./zh-cn.js":433,"./zh-hk":434,"./zh-hk.js":434,"./zh-tw":435,"./zh-tw.js":435};o.keys=function(){return Object.keys(i)},o.resolve=r,e.exports=o,o.id=488;},function(e,t){},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var s=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},u=n(311),c=o(u),h=n(16),f=o(h),d=function(e){function t(){return r(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return a(t,e),s(t,[{key:"prepare",value:function(e,n,o,r,i,a){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"prepare",this).call(this,e,n,o,r,i,a),this.cellProperties.filter=!1,this.cellProperties.strict=!0;}}]),t}(c.default);f.default.getSingleton().add("beforeValidate",function(e,t,n){var o=this.getCellMeta(t,this.propToCol(n));o.editor===d&&void 0===o.strict&&(o.filter=!1,o.strict=!0);}),t.default=d;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=n(59),s=function(e){return e&&e.__esModule?e:{default:e}}(a);t.default=function(e){function t(){return o(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return i(t,e),t}(s.default);},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},l=n(0),u=n(59),c=function(e){return e&&e.__esModule?e:{default:e}}(u);t.default=function(e){function t(){return o(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return i(t,e),a(t,[{key:"createElements",value:function(){s(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"createElements",this).call(this),this.TEXTAREA=document.createElement("input"),this.TEXTAREA.setAttribute("type","password"),this.TEXTAREA.className="handsontableInput",this.textareaStyle=this.TEXTAREA.style,this.textareaStyle.width=0,this.textareaStyle.height=0,(0, l.empty)(this.TEXTAREA_PARENT),this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);}}]),t}(c.default);},function(e,t,n){t.__esModule=!0;var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r=n(0),i=n(12),a=n(21),s=n(56),l=function(e){return e&&e.__esModule?e:{default:e}}(s),u=n(1),c=l.default.prototype.extend();c.prototype.init=function(){this.select=document.createElement("SELECT"),(0, r.addClass)(this.select,"htSelectEditor"),this.select.style.display="none",this.instance.rootElement.appendChild(this.select),this.registerHooks();},c.prototype.registerHooks=function(){var e=this;this.instance.addHook("afterScrollHorizontally",function(){return e.refreshDimensions()}),this.instance.addHook("afterScrollVertically",function(){return e.refreshDimensions()}),this.instance.addHook("afterColumnResize",function(){return e.refreshDimensions()}),this.instance.addHook("afterRowResize",function(){return e.refreshDimensions()});},c.prototype.prepare=function(){for(var e=this,t=arguments.length,n=Array(t),o=0;t>o;o++)n[o]=arguments[o];l.default.prototype.prepare.apply(this,n);var i=this.cellProperties.selectOptions,a=void 0;a=this.prepareOptions("function"==typeof i?i(this.row,this.col,this.prop):i),(0, r.empty)(this.select),(0, u.objectEach)(a,function(t,n){var o=document.createElement("OPTION");o.value=n,(0, r.fastInnerHTML)(o,t),e.select.appendChild(o);});},c.prototype.prepareOptions=function(e){var t={};if(Array.isArray(e))for(var n=0,r=e.length;r>n;n++)t[e[n]]=e[n];else"object"===(void 0===e?"undefined":o(e))&&(t=e);return t},c.prototype.getValue=function(){return this.select.value},c.prototype.setValue=function(e){this.select.value=e;};var h=function(e){var t=this,n=t.getActiveEditor(),o=n.select.selectedIndex-1,r=n.select.selectedIndex+1;switch(e.keyCode){case a.KEY_CODES.ARROW_UP:0>o||(n.select[o].selected=!0),(0, i.stopImmediatePropagation)(e),e.preventDefault();break;case a.KEY_CODES.ARROW_DOWN:r>n.select.length-1||(n.select[r].selected=!0),(0, i.stopImmediatePropagation)(e),e.preventDefault();}};c.prototype.open=function(){this._opened=!0,this.refreshDimensions(),this.select.style.display="",this.instance.addHook("beforeKeyDown",h);},c.prototype.close=function(){this._opened=!1,this.select.style.display="none",this.instance.removeHook("beforeKeyDown",h);},c.prototype.focus=function(){this.select.focus();},c.prototype.refreshValue=function(){var e=this.instance.getSourceDataAtCell(this.row,this.prop);this.originalValue=e,this.setValue(e),this.refreshDimensions();},c.prototype.refreshDimensions=function(){if(this.state===s.EditorState.EDITING){if(!(this.TD=this.getEditedCell()))return void this.close();var e=(0, r.offset)(this.TD),t=(0, r.offset)(this.instance.rootElement),n=(0, r.getScrollableElement)(this.TD),o=this.checkEditorSection(),i=(0, r.outerWidth)(this.TD)+1,a=(0, r.outerHeight)(this.TD)+1,l=e.top-t.top-1-(n.scrollTop||0),u=e.left-t.left-1-(n.scrollLeft||0),c=void 0;switch(o){case"top":c=(0, r.getCssTransform)(this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.holder.parentNode);break;case"left":c=(0, r.getCssTransform)(this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.holder.parentNode);break;case"top-left-corner":c=(0, r.getCssTransform)(this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.holder.parentNode);break;case"bottom-left-corner":c=(0, r.getCssTransform)(this.instance.view.wt.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.holder.parentNode);break;case"bottom":c=(0, r.getCssTransform)(this.instance.view.wt.wtOverlays.bottomOverlay.clone.wtTable.holder.parentNode);}0===this.instance.getSelectedLast()[0]&&(l+=1),0===this.instance.getSelectedLast()[1]&&(u+=1);var h=this.select.style;c&&-1!==c?h[c[0]]=c[1]:(0, r.resetCssTransform)(this.select);var f=(0, r.getComputedStyle)(this.TD);parseInt(f.borderTopWidth,10)>0&&(a-=1),parseInt(f.borderLeftWidth,10)>0&&(i-=1),h.height=a+"px",h.minWidth=i+"px",h.top=l+"px",h.left=u+"px",h.margin="0px";}},c.prototype.getEditedCell=function(){var e=this.checkEditorSection(),t=void 0;switch(e){case"top":t=this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.getCell({row:this.row,col:this.col}),this.select.style.zIndex=101;break;case"corner":t=this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell({row:this.row,col:this.col}),this.select.style.zIndex=103;break;case"left":t=this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.getCell({row:this.row,col:this.col}),this.select.style.zIndex=102;break;default:t=this.instance.getCell(this.row,this.col),this.select.style.zIndex="";}return -1!==t&&-2!==t?t:void 0},t.default=c;},function(e,t,n){function o(e,t,n,o,i,a,s){var l=[],u=[];s.className&&(t.className=t.className?t.className+" "+s.className:s.className),s.readOnly&&l.push(s.readOnlyCellClassName),!1===s.valid&&s.invalidCellClassName?l.push(s.invalidCellClassName):u.push(s.invalidCellClassName),!1===s.wordWrap&&s.noWordWrapClassName&&l.push(s.noWordWrapClassName),!a&&s.placeholder&&l.push(s.placeholderCellClassName),(0, r.removeClass)(t,u),(0, r.addClass)(t,l);}t.__esModule=!0;var r=n(0);t.default=o;},function(e,t,n){function o(e,t,n,o,i,c,h){for(var f=h.allowHtml?"html":"text",d=u.cloneNode(!0),p=arguments.length,g=Array(p>7?p-7:0),v=7;p>v;v++)g[v-7]=arguments[v];if((0, l.getRenderer)(f).apply(this,[e,t,n,o,i,c,h].concat(g)),t.firstChild||t.appendChild(document.createTextNode(String.fromCharCode(160))),t.insertBefore(d,t.firstChild),(0, r.addClass)(t,"htAutocomplete"),!e.acArrowListener){var m=new a.default(e);e.acArrowListener=function(i){(0, r.hasClass)(i.target,"htAutocompleteArrow")&&e.view.wt.getSetting("onCellDblClick",null,new s.CellCoords(n,o),t);},m.addEventListener(e.rootElement,"mousedown",e.acArrowListener),e.addHookOnce("afterDestroy",function(){m.destroy();});}}t.__esModule=!0;var r=n(0),i=n(6),a=function(e){return e&&e.__esModule?e:{default:e}}(i),s=n(4),l=n(14);document.createElement("DIV").className="htAutocompleteWrapper";var u=document.createElement("DIV");u.className="htAutocompleteArrow",u.appendChild(document.createTextNode(String.fromCharCode(9660))),t.default=o;},function(e,t,n){function o(e,t,n,o,s,l,u){function c(e){var t=(0, v.partial)(g.isKey,e.keyCode);t("SPACE|ENTER|DELETE|BACKSPACE")&&!(0, m.isImmediatePropagationStopped)(e)&&p(function(){(0, m.stopImmediatePropagation)(e),e.preventDefault();}),t("SPACE|ENTER")&&d(),t("DELETE|BACKSPACE")&&d(!0);}function d(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=e.getSelectedRangeLast();if(n){for(var o=n.getTopLeftCorner(),r=o.row,i=o.col,a=n.getBottomRightCorner(),s=a.row,l=a.col,u=[],c=r;s>=c;c+=1)for(var h=i;l>=h;h+=1){var f=e.getCellMeta(c,h);if("checkbox"!==f.type)return;if(!0!==f.readOnly){void 0===f.checkedTemplate&&(f.checkedTemplate=!0),void 0===f.uncheckedTemplate&&(f.uncheckedTemplate=!1);var d=e.getDataAtCell(c,h);!1===t?[f.checkedTemplate,""+f.checkedTemplate].includes(d)?u.push([c,h,f.uncheckedTemplate]):[f.uncheckedTemplate,""+f.uncheckedTemplate,null,void 0].includes(d)&&u.push([c,h,f.checkedTemplate]):u.push([c,h,f.uncheckedTemplate]);}}u.length>0&&e.setDataAtCell(u);}}function p(t){var n=e.getSelectedRangeLast();if(n)for(var o=n.getTopLeftCorner(),r=n.getBottomRightCorner(),i=o.row;r.row>=i;i++)for(var a=o.col;r.col>=a;a++){var s=e.getCellMeta(i,a);if("checkbox"!==s.type)return;var l=e.getCell(i,a);if(null===l||void 0===l)t(i,a,s);else{var u=l.querySelectorAll("input[type=checkbox]");u.length>0&&!s.readOnly&&t(u);}}}for(var C=arguments.length,_=Array(C>7?C-7:0),S=7;C>S;S++)_[S-7]=arguments[S];(0, y.getRenderer)("base").apply(this,[e,t,n,o,s,l,u].concat(_)),r(e);var E=i(),O=u.label,T=!1;if(void 0===u.checkedTemplate&&(u.checkedTemplate=!0),void 0===u.uncheckedTemplate&&(u.uncheckedTemplate=!1),(0, h.empty)(t),l===u.checkedTemplate||(0, f.equalsIgnoreCase)(l,u.checkedTemplate)?E.checked=!0:l===u.uncheckedTemplate||(0, f.equalsIgnoreCase)(l,u.uncheckedTemplate)?E.checked=!1:null===l?(0, h.addClass)(E,"noValue"):(E.style.display="none",(0, h.addClass)(E,b),T=!0),E.setAttribute("data-row",n),E.setAttribute("data-col",o),!T&&O){var k="";O.value?k="function"==typeof O.value?O.value.call(this,n,o,s,l):O.value:O.property&&(k=e.getDataAtRowProp(n,O.property));var R=a(k);"before"===O.position?R.appendChild(E):R.insertBefore(E,R.firstChild),E=R;}t.appendChild(E),T&&t.appendChild(document.createTextNode("#bad-value#")),w.has(e)||(w.set(e,!0),e.addHook("beforeKeyDown",c));}function r(e){var t=C.get(e);return t||(t=new p.default(e),t.addEventListener(e.rootElement,"click",function(t){return l(t,e)}),t.addEventListener(e.rootElement,"mouseup",function(t){return s(t,e)}),t.addEventListener(e.rootElement,"change",function(t){return u(t,e)}),C.set(e,t)),t}function i(){var e=document.createElement("input");return e.className="htCheckboxRendererInput",e.type="checkbox",e.setAttribute("autocomplete","off"),e.setAttribute("tabindex","-1"),e.cloneNode(!1)}function a(e){var t=document.createElement("label");return t.className="htCheckboxRendererLabel",t.appendChild(document.createTextNode(e)),t.cloneNode(!0)}function s(e,t){c(e.target)&&setTimeout(t.listen,10);}function l(e,t){if(!c(e.target))return !1;t.getCellMeta(parseInt(e.target.getAttribute("data-row"),10),parseInt(e.target.getAttribute("data-col"),10)).readOnly&&e.preventDefault();}function u(e,t){if(!c(e.target))return !1;var n=parseInt(e.target.getAttribute("data-row"),10),o=parseInt(e.target.getAttribute("data-col"),10),r=t.getCellMeta(n,o);if(!r.readOnly){var i=null;i=e.target.checked?void 0===r.uncheckedTemplate||r.checkedTemplate:void 0!==r.uncheckedTemplate&&r.uncheckedTemplate,t.setDataAtCell(n,o,i);}}function c(e){return "INPUT"===e.tagName&&"checkbox"===e.getAttribute("type")}t.__esModule=!0;var h=n(0),f=n(36),d=n(6),p=function(e){return e&&e.__esModule?e:{default:e}}(d),g=n(21),v=n(43),m=n(12),y=n(14),w=new WeakMap,C=new WeakMap,b="htBadValue";t.default=o;},function(e,t,n){function o(e,t,n,o,a,s){for(var l=arguments.length,u=Array(l>6?l-6:0),c=6;l>c;c++)u[c-6]=arguments[c];(0, i.getRenderer)("base").apply(this,[e,t,n,o,a,s].concat(u)),(0, r.fastInnerHTML)(t,null===s||void 0===s?"":s);}t.__esModule=!0;var r=n(0),i=n(14);t.default=o;},function(e,t,n){function o(e,t,n,o,r,l,u){var c=l;if((0, s.isNumeric)(c)){var h=u.numericFormat,f=h&&h.culture||"-",d=h&&h.pattern,p=u.className||"",g=p.length?p.split(" "):[];if(void 0!==f&&!i.default.languages()[f]){var v=f.replace("-",""),m=i.default.allLanguages?i.default.allLanguages[f]:i.default[v];m&&i.default.registerLanguage(m);}i.default.setLanguage(f),c=(0, i.default)(c).format(d||"0"),0>g.indexOf("htLeft")&&0>g.indexOf("htCenter")&&0>g.indexOf("htRight")&&0>g.indexOf("htJustify")&&g.push("htRight"),0>g.indexOf("htNumeric")&&g.push("htNumeric"),u.className=g.join(" ");}(0, a.getRenderer)("text")(e,t,n,o,r,c,u);}t.__esModule=!0;var r=n(436),i=function(e){return e&&e.__esModule?e:{default:e}}(r),a=n(14),s=n(5);t.default=o;},function(e,t,n){function o(e,t,n,o,s,l,u){for(var c=arguments.length,h=Array(c>7?c-7:0),f=7;c>f;f++)h[f-7]=arguments[f];(0, i.getRenderer)("text").apply(this,[e,t,n,o,s,l,u].concat(h));var d=u.hashLength||t.innerHTML.length,p=u.hashSymbol||"*",g="";(0, a.rangeEach)(d-1,function(){g+=p;}),(0, r.fastInnerHTML)(t,g);}t.__esModule=!0;var r=n(0),i=n(14),a=n(5);t.default=o;},function(e,t,n){function o(e,t,n,o,s,l,u){for(var c=arguments.length,h=Array(c>7?c-7:0),f=7;c>f;f++)h[f-7]=arguments[f];(0, a.getRenderer)("base").apply(this,[e,t,n,o,s,l,u].concat(h));var d=l;if(!d&&u.placeholder&&(d=u.placeholder),d=(0, i.stringify)(d),e.getSettings().trimWhitespace||(d=d.replace(/ /g,String.fromCharCode(160))),u.rendererTemplate){(0, r.empty)(t);var p=document.createElement("TEMPLATE");p.setAttribute("bind","{{}}"),p.innerHTML=u.rendererTemplate,HTMLTemplateElement.decorate(p),p.model=e.getSourceDataAtRow(n),t.appendChild(p);}else(0, r.fastInnerText)(t,d);}t.__esModule=!0;var r=n(0),i=n(10),a=n(14);t.default=o;},function(e,t,n){function o(e,t){var n=e;if(null!==n&&void 0!==n||(n=""),this.allowEmpty&&""===n)return void t(!0);this.strict&&this.source?"function"==typeof this.source?this.source(n,r(n,t)):r(n,t)(this.source):t(!0);}function r(e,t){var n=e;return function(e){for(var o=!1,r=0,i=e.length;i>r;r++)if(n===e[r]){o=!0;break}t(o);}}t.__esModule=!0,t.default=o;},function(e,t,n){function o(e,t){var n=(0, l.getEditorInstance)("date",this.instance),o=e,i=!0;null!==o&&void 0!==o||(o="");var s=(0, a.default)(new Date(o)).isValid()||(0, a.default)(o,n.defaultDateFormat).isValid(),u=(0, a.default)(o,this.dateFormat||n.defaultDateFormat,!0).isValid();if(this.allowEmpty&&""===o&&(s=!0,u=!0),s||(i=!1),!s&&u&&(i=!0),s&&!u)if(!0===this.correctFormat){var c=r(o,this.dateFormat),h=this.instance.runHooks("unmodifyRow",this.row),f=this.instance.runHooks("unmodifyCol",this.col);this.instance.setDataAtCell(h,f,c,"dateValidator"),i=!0;}else i=!1;t(i);}function r(e,t){var n=(0, a.default)((0, s.getNormalizedDate)(e)),o=(0, a.default)(e,t),r=e.search(/[A-z]/g)>-1,i=void 0;return i=n.isValid()&&n.format("x")===o.format("x")||!o.isValid()||r?n:o,i.format(t)}t.__esModule=!0,t.default=o,t.correctFormat=r;var i=n(47),a=function(e){return e&&e.__esModule?e:{default:e}}(i),s=n(437),l=n(17);},function(e,t,n){function o(e,t){var n=e;null!==n&&void 0!==n||(n=""),t(this.allowEmpty&&""===n?!0:""===n?!1:/^-?\d*(\.|,)?\d*$/.test(n));}t.__esModule=!0,t.default=o;},function(e,t,n){function o(e,t){var n=this.timeFormat||"h:mm:ss a",o=!0,r=e;null===r&&(r=""),r=/^\d{3,}$/.test(r)?parseInt(r,10):r;var s=/^\d{1,2}$/.test(r);s&&(r+=":00");var l=(0, i.default)(r,a,!0).isValid()?(0, i.default)(r):(0, i.default)(r,n),u=l.isValid(),c=(0, i.default)(r,n,!0).isValid()&&!s;if(this.allowEmpty&&""===r&&(u=!0,c=!0),u||(o=!1),!u&&c&&(o=!0),u&&!c)if(!0===this.correctFormat){var h=l.format(n),f=this.instance.runHooks("unmodifyRow",this.row),d=this.instance.runHooks("unmodifyCol",this.col);this.instance.setDataAtCell(f,d,h,"timeValidator"),o=!0;}else o=!1;t(o);}t.__esModule=!0,t.default=o;var r=n(47),i=function(e){return e&&e.__esModule?e:{default:e}}(r),a=["YYYY-MM-DDTHH:mm:ss.SSSZ","X","x"];},function(e,t,n){t.__esModule=!0;var o=n(17),r=n(14),i=n(37);t.default={editor:(0, o.getEditor)("autocomplete"),renderer:(0, r.getRenderer)("autocomplete"),validator:(0, i.getValidator)("autocomplete")};},function(e,t,n){t.__esModule=!0;var o=n(17),r=n(14);t.default={editor:(0, o.getEditor)("checkbox"),renderer:(0, r.getRenderer)("checkbox")};},function(e,t,n){t.__esModule=!0;var o=n(17),r=n(14),i=n(37);t.default={editor:(0, o.getEditor)("date"),renderer:(0, r.getRenderer)("autocomplete"),validator:(0, i.getValidator)("date")};},function(e,t,n){t.__esModule=!0;var o=n(17),r=n(14),i=n(37);t.default={editor:(0, o.getEditor)("dropdown"),renderer:(0, r.getRenderer)("autocomplete"),validator:(0, i.getValidator)("autocomplete")};},function(e,t,n){t.__esModule=!0;var o=n(17),r=n(14);t.default={editor:(0, o.getEditor)("handsontable"),renderer:(0, r.getRenderer)("autocomplete")};},function(e,t,n){t.__esModule=!0;var o=n(17),r=n(14),i=n(37);t.default={editor:(0, o.getEditor)("numeric"),renderer:(0, r.getRenderer)("numeric"),validator:(0, i.getValidator)("numeric"),dataType:"number"};},function(e,t,n){t.__esModule=!0;var o=n(17),r=n(14);t.default={editor:(0, o.getEditor)("password"),renderer:(0, r.getRenderer)("password"),copyable:!1};},function(e,t,n){t.__esModule=!0;var o=n(17),r=n(14);t.default={editor:(0, o.getEditor)("text"),renderer:(0, r.getRenderer)("text")};},function(e,t,n){t.__esModule=!0;var o=n(17),r=n(14),i=n(37);t.default={editor:(0, o.getEditor)("text"),renderer:(0, r.getRenderer)("text"),validator:(0, i.getValidator)("time")};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t,n){var o=this;this.instance=e,this.priv=t,this.GridSettings=n,this.dataSource=this.instance.getSettings().data,this.cachedLength=null,this.skipCache=!1,this.latestSourceRowsCount=0,this.duckSchema=this.dataSource&&this.dataSource[0]?this.recursiveDuckSchema(this.dataSource[0]):{},this.createMap(),this.interval=d.default.create(function(){return o.clearLengthCache()},"15fps"),this.instance.addHook("skipLengthCache",function(e){return o.onSkipLengthCache(e)}),this.onSkipLengthCache(500);}t.__esModule=!0;var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},a=n(438),s=o(a),l=n(92),u=n(91),c=n(1),h=n(2),f=n(515),d=o(f),p=n(5),g=n(516),v=o(g);r.prototype.DESTINATION_RENDERER=1,r.prototype.DESTINATION_CLIPBOARD_GENERATOR=2,r.prototype.recursiveDuckSchema=function(e){return (0, c.duckSchema)(e)},r.prototype.recursiveDuckColumns=function(e,t,n){var o=this,r=t,a=n,s=void 0;return void 0===r&&(r=0,a=""),"object"!==(void 0===e?"undefined":i(e))||Array.isArray(e)||(0, c.objectEach)(e,function(e,t){null===e?(s=a+t,o.colToPropCache.push(s),o.propToColCache.set(s,r),r+=1):r=o.recursiveDuckColumns(e,r,t+".");}),r},r.prototype.createMap=function(){var e=void 0,t=this.getSchema();if(void 0===t)throw Error("trying to create `columns` definition but you didn't provide `schema` nor `data`");this.colToPropCache=[],this.propToColCache=new v.default;var n=this.instance.getSettings().columns;if(n){var o=this.instance.getSettings().maxCols,r=Math.min(o,n.length),i=0,a=!1,s=(0, c.deepObjectSize)(t);for("function"==typeof n&&(r=s>0?s:this.instance.countSourceCols(),a=!0),e=0;r>e;e++){var l=a?n(e):n[e];if((0, c.isObject)(l)){if(void 0!==l.data){var u=a?i:e;this.colToPropCache[u]=l.data,this.propToColCache.set(l.data,u);}i+=1;}}}else this.recursiveDuckColumns(t);},r.prototype.colToProp=function(e){var t=this.instance.runHooks("modifyCol",e);return !isNaN(t)&&this.colToPropCache&&void 0!==this.colToPropCache[t]?this.colToPropCache[t]:t},r.prototype.propToCol=function(e){var t=void 0;return t=void 0===this.propToColCache.get(e)?e:this.propToColCache.get(e),t=this.instance.runHooks("unmodifyCol",t)},r.prototype.getSchema=function(){var e=this.instance.getSettings().dataSchema;return e?"function"==typeof e?e():e:this.duckSchema},r.prototype.createRow=function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,o=arguments[2],r=0,i=e;if("number"==typeof i&&i<this.instance.countSourceRows()||(i=this.instance.countSourceRows()),!1===this.instance.runHooks("beforeCreateRow",i,n,o))return 0;for(var a=this.instance.getSettings().maxRows,s=this.instance.countCols();n>r&&this.instance.countSourceRows()<a;)!function(){var e=null;"array"===t.instance.dataType?t.instance.getSettings().dataSchema?e=(0, c.deepClone)(t.getSchema()):(e=[],(0, p.rangeEach)(s-1,function(){return e.push(null)})):"function"===t.instance.dataType?e=t.instance.getSettings().dataSchema(i):(e={},(0, c.deepExtend)(e,t.getSchema())),i===t.instance.countSourceRows()?t.dataSource.push(e):t.spliceData(i,0,e),r+=1;}();return this.instance.runHooks("afterCreateRow",i,r,o),this.instance.forceFullRender=!0,r},r.prototype.createCol=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments[2];if(!this.instance.isColumnModificationAllowed())throw Error("Cannot create new column. When data source in an object, you can only have as much columns as defined in first data row, data schema or in the 'columns' setting.If you want to be able to add new columns, you have to use array datasource.");var o=this.instance.countSourceRows(),r=this.dataSource,i=this.instance.countCols(),a="number"==typeof e&&i>e?e:i,s=void 0,l=0,c=void 0;this.instance.runHooks("beforeCreateCol",a,t,n),c=a;for(var h=this.instance.getSettings().maxCols;t>l&&this.instance.countCols()<h;){if(s=(0, u.columnFactory)(this.GridSettings,this.priv.columnsSettingConflicts),"number"==typeof a&&a<this.instance.countCols()){for(var f=0;o>f;f++)r[f].splice(c,0,null);this.priv.columnSettings.splice(c,0,s);}else{if(o>0)for(var d=0;o>d;d++)void 0===r[d]&&(r[d]=[]),r[d].push(null);else r.push([null]);this.priv.columnSettings.push(s);}l+=1,c+=1;}return this.instance.runHooks("afterCreateCol",a,l,n),this.instance.forceFullRender=!0,l},r.prototype.removeRow=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments[2],o="number"!=typeof e?-t:e,r=this.instance.runHooks("modifyRemovedAmount",t,o);o=(this.instance.countSourceRows()+o)%this.instance.countSourceRows();var i=this.visualRowsToPhysical(o,r);if(!1!==this.instance.runHooks("beforeRemoveRow",o,r,i,n)){var a=this.dataSource,s=this.filterData(o,r);s&&(a.length=0,Array.prototype.push.apply(a,s)),this.instance.runHooks("afterRemoveRow",o,r,i,n),this.instance.forceFullRender=!0;}},r.prototype.removeCol=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments[2];if("object"===this.instance.dataType||this.instance.getSettings().columns)throw Error("cannot remove column with object data source or columns option specified");var o="number"!=typeof e?-t:e;o=(this.instance.countCols()+o)%this.instance.countCols();var r=this.visualColumnsToPhysical(o,t),i=r.slice(0).sort(function(e,t){return t-e});if(!1!==this.instance.runHooks("beforeRemoveCol",o,t,r,n)){for(var a=!0,s=i.length,l=this.dataSource,u=0;s>u;u++)a&&r[0]!==r[u]-u&&(a=!1);if(a)for(var c=0,h=this.instance.countSourceRows();h>c;c++)l[c].splice(r[0],t);else{for(var f=0,d=this.instance.countSourceRows();d>f;f++)for(var p=0;s>p;p++)l[f].splice(i[p],1);for(var g=0;s>g;g++)this.priv.columnSettings.splice(r[g],1);}this.instance.runHooks("afterRemoveCol",o,t,r,n),this.instance.forceFullRender=!0;}},r.prototype.spliceCol=function(e,t,n){for(var o=this.instance.getDataAtCol(e),r=o.slice(t,t+n),i=o.slice(t+n),a=arguments.length,s=Array(a>3?a-3:0),l=3;a>l;l++)s[l-3]=arguments[l];(0, h.extendArray)(s,i);for(var u=0;n>u;)s.push(null),u+=1;return (0, h.to2dArray)(s),this.instance.populateFromArray(t,e,s,null,null,"spliceCol"),r},r.prototype.spliceRow=function(e,t,n){for(var o=this.instance.getSourceDataAtRow(e),r=o.slice(t,t+n),i=o.slice(t+n),a=arguments.length,s=Array(a>3?a-3:0),l=3;a>l;l++)s[l-3]=arguments[l];(0, h.extendArray)(s,i);for(var u=0;n>u;)s.push(null),u+=1;return this.instance.populateFromArray(e,t,[s],null,null,"spliceRow"),r},r.prototype.spliceData=function(e,t,n){!1!==this.instance.runHooks("beforeDataSplice",e,t,n)&&this.dataSource.splice(e,t,n);},r.prototype.filterData=function(e,t){var n=this.visualRowsToPhysical(e,t);if(!1!==this.instance.runHooks("beforeDataFilter",e,t,n))return this.dataSource.filter(function(e,t){return -1===n.indexOf(t)})},r.prototype.get=function(e,t){var n=this.instance.runHooks("modifyRow",e),o=this.dataSource[n],r=this.instance.runHooks("modifyRowData",n);o=isNaN(r)?r:o;var i=null;if(o&&o.hasOwnProperty&&(0, c.hasOwnProperty)(o,t))i=o[t];else if("string"==typeof t&&t.indexOf(".")>-1){var a=t.split("."),s=o;if(!s)return null;for(var l=0,u=a.length;u>l;l++)if(void 0===(s=s[a[l]]))return null;i=s;}else"function"==typeof t&&(i=t(this.dataSource.slice(n,n+1)[0]));if(this.instance.hasHook("modifyData")){var h=(0, c.createObjectPropListener)(i);this.instance.runHooks("modifyData",n,this.propToCol(t),h,"get"),h.isTouched()&&(i=h.value);}return i};var m=(0, l.cellMethodLookupFactory)("copyable",!1);r.prototype.getCopyable=function(e,t){return m.call(this.instance,e,this.propToCol(t))?this.get(e,t):""},r.prototype.set=function(e,t,n,o){var r=this.instance.runHooks("modifyRow",e,o||"datamapGet"),i=n,a=this.dataSource[r],s=this.instance.runHooks("modifyRowData",r);if(a=isNaN(s)?s:a,this.instance.hasHook("modifyData")){var l=(0, c.createObjectPropListener)(i);this.instance.runHooks("modifyData",r,this.propToCol(t),l,"set"),l.isTouched()&&(i=l.value);}if(a&&a.hasOwnProperty&&(0, c.hasOwnProperty)(a,t))a[t]=i;else if("string"==typeof t&&t.indexOf(".")>-1){var u=t.split("."),h=a,f=0,d=void 0;for(f=0,d=u.length-1;d>f;f++)void 0===h[u[f]]&&(h[u[f]]={}),h=h[u[f]];h[u[f]]=i;}else"function"==typeof t?t(this.dataSource.slice(r,r+1)[0],i):a[t]=i;},r.prototype.visualRowsToPhysical=function(e,t){for(var n=this.instance.countSourceRows(),o=[],r=(n+e)%n,i=t,a=void 0;n>r&&i;)a=this.instance.runHooks("modifyRow",r),o.push(a),i-=1,r+=1;return o},r.prototype.visualColumnsToPhysical=function(e,t){for(var n=this.instance.countCols(),o=(n+e)%n,r=[],i=t;n>o&&i;){r.push(this.instance.runHooks("modifyCol",o)),i-=1,o+=1;}return r},r.prototype.clear=function(){for(var e=0;e<this.instance.countSourceRows();e++)for(var t=0;t<this.instance.countCols();t++)this.set(e,this.colToProp(t),"");},r.prototype.clearLengthCache=function(){this.cachedLength=null;},r.prototype.getLength=function(){var e=this,t=this.instance.getSettings().maxRows,n=void 0;n=0>t||0===t?0:t||1/0;var o=this.instance.countSourceRows();if(this.instance.hasHook("modifyRow")){var r=this.skipCache;this.interval.start(),o!==this.latestSourceRowsCount&&(r=!0),this.latestSourceRowsCount=o,null===this.cachedLength||r?((0, p.rangeEach)(o-1,function(t){null===e.instance.runHooks("modifyRow",t)&&(o-=1);}),this.cachedLength=o):o=this.cachedLength;}else this.interval.stop();return Math.min(o,n)},r.prototype.getAll=function(){var e={row:0,col:0},t={row:Math.max(this.instance.countSourceRows()-1,0),col:Math.max(this.instance.countCols()-1,0)};return e.row-t.row!=0||this.instance.countSourceRows()?this.getRange(e,t,r.prototype.DESTINATION_RENDERER):[]},r.prototype.getRange=function(e,t,n){var o=[],r=void 0,i=void 0,a=void 0,s=this.instance.getSettings().maxRows,l=this.instance.getSettings().maxCols;if(0===s||0===l)return [];var u=n===this.DESTINATION_CLIPBOARD_GENERATOR?this.getCopyable:this.get,c=Math.min(Math.max(s-1,0),Math.max(e.row,t.row)),h=Math.min(Math.max(l-1,0),Math.max(e.col,t.col));for(r=Math.min(e.row,t.row);c>=r;r++){a=[];var f=this.instance.runHooks("modifyRow",r);for(i=Math.min(e.col,t.col);h>=i&&null!==f;i++)a.push(u.call(this,r,this.colToProp(i)));null!==f&&o.push(a);}return o},r.prototype.getText=function(e,t){return s.default.stringify(this.getRange(e,t,this.DESTINATION_RENDERER))},r.prototype.getCopyableText=function(e,t){return s.default.stringify(this.getRange(e,t,this.DESTINATION_CLIPBOARD_GENERATOR))},r.prototype.onSkipLengthCache=function(e){var t=this;this.skipCache=!0,setTimeout(function(){t.skipCache=!1;},e);},r.prototype.destroy=function(){this.interval.stop(),this.interval=null,this.instance=null,this.priv=null,this.GridSettings=null,this.dataSource=null,this.cachedLength=null,this.duckSchema=null;},t.default=r;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e){var t=e;return "string"==typeof t&&/fps$/.test(t)&&(t=1e3/parseInt(t.replace("fps","")||0,10)),t}t.__esModule=!0;var i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}();t.parseDelay=r;var a=n(41);t.default=function(){function e(t,n){var i=this;o(this,e),this.timer=null,this.func=t,this.delay=r(n),this.stopped=!0,this._then=null,this._callback=function(){return i.__callback()};}return i(e,null,[{key:"create",value:function(t,n){return new e(t,n)}}]),i(e,[{key:"start",value:function(){return this.stopped&&(this._then=Date.now(),this.stopped=!1,this.timer=(0, a.requestAnimationFrame)(this._callback)),this}},{key:"stop",value:function(){return this.stopped||(this.stopped=!0,(0, a.cancelAnimationFrame)(this.timer),this.timer=null),this}},{key:"__callback",value:function(){if(this.timer=(0, a.requestAnimationFrame)(this._callback),this.delay){var e=Date.now(),t=e-this._then;t>this.delay&&(this._then=e-t%this.delay,this.func());}else this.func();}}]),e}();},function(e,t,n){function o(){function e(e){return null!==e&&!n(e)&&("string"==typeof e||"number"==typeof e)}function t(e){return null!==e&&("object"===(void 0===e?"undefined":r(e))||"function"==typeof e)}function n(e){return e!==e}var o={arrayMap:[],weakMap:new WeakMap};return {get:function(n){return e(n)?o.arrayMap[n]:t(n)?o.weakMap.get(n):void 0},set:function(n,r){if(e(n))o.arrayMap[n]=r;else{if(!t(n))throw Error("Invalid key type");o.weakMap.set(n,r);}},delete:function(n){e(n)?delete o.arrayMap[n]:t(n)&&o.weakMap.delete(n);}}}t.__esModule=!0;var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};t.default=o;},function(e,t,n){function o(e,t,n){function o(e){var o="function"==typeof t.settings.enterMoves?t.settings.enterMoves(event):t.settings.enterMoves;e?n.transformStart(-o.row,-o.col):n.transformStart(o.row,o.col,!0);}function l(e){e?n.transformEnd(-1,0):n.transformStart(-1,0);}function h(e){e?n.transformEnd(1,0):n.transformStart(1,0);}function f(e){e?n.transformEnd(0,1):n.transformStart(0,1);}function d(e){e?n.transformEnd(0,-1):n.transformStart(0,-1);}function p(s){if(e.isListening()&&(e.runHooks("beforeKeyDown",s),!m&&229!==s.keyCode&&!(0, a.isImmediatePropagationStopped)(s)&&(t.lastKeyCode=s.keyCode,n.isSelected()))){var u=(s.ctrlKey||s.metaKey)&&!s.altKey;if(w&&!w.isWaiting()&&!((0, i.isMetaKey)(s.keyCode)||(0, i.isCtrlMetaKey)(s.keyCode)||u||g.isEditorOpened()))return void g.openEditor("",s);var p=s.shiftKey?n.setRangeEnd:n.setRangeStart,v=void 0;switch(s.keyCode){case i.KEY_CODES.A:!g.isEditorOpened()&&u&&(e.selectAll(),s.preventDefault(),(0, a.stopPropagation)(s));break;case i.KEY_CODES.ARROW_UP:g.isEditorOpened()&&!w.isWaiting()&&g.closeEditorAndSaveChanges(u),l(s.shiftKey),s.preventDefault(),(0, a.stopPropagation)(s);break;case i.KEY_CODES.ARROW_DOWN:g.isEditorOpened()&&!w.isWaiting()&&g.closeEditorAndSaveChanges(u),h(s.shiftKey),s.preventDefault(),(0, a.stopPropagation)(s);break;case i.KEY_CODES.ARROW_RIGHT:g.isEditorOpened()&&!w.isWaiting()&&g.closeEditorAndSaveChanges(u),f(s.shiftKey),s.preventDefault(),(0, a.stopPropagation)(s);break;case i.KEY_CODES.ARROW_LEFT:g.isEditorOpened()&&!w.isWaiting()&&g.closeEditorAndSaveChanges(u),d(s.shiftKey),s.preventDefault(),(0, a.stopPropagation)(s);break;case i.KEY_CODES.TAB:v="function"==typeof t.settings.tabMoves?t.settings.tabMoves(s):t.settings.tabMoves,s.shiftKey?n.transformStart(-v.row,-v.col):n.transformStart(v.row,v.col,!0),s.preventDefault(),(0, a.stopPropagation)(s);break;case i.KEY_CODES.BACKSPACE:case i.KEY_CODES.DELETE:e.emptySelectedCells(),g.prepareEditor(),s.preventDefault();break;case i.KEY_CODES.F2:w&&w.enableFullEditMode(),g.openEditor(null,s),s.preventDefault();break;case i.KEY_CODES.ENTER:g.isEditorOpened()?(w&&w.state!==c.EditorState.WAITING&&g.closeEditorAndSaveChanges(u),o(s.shiftKey)):e.getSettings().enterBeginsEditing?(w&&w.enableFullEditMode(),g.openEditor(null,s)):o(s.shiftKey),s.preventDefault(),(0, a.stopImmediatePropagation)(s);break;case i.KEY_CODES.ESCAPE:g.isEditorOpened()&&(g.closeEditorAndRestoreOriginalValue(u),w.focus()),s.preventDefault();break;case i.KEY_CODES.HOME:s.ctrlKey||s.metaKey?p.call(n,new r.CellCoords(0,n.selectedRange.current().from.col)):p.call(n,new r.CellCoords(n.selectedRange.current().from.row,0)),s.preventDefault(),(0, a.stopPropagation)(s);break;case i.KEY_CODES.END:s.ctrlKey||s.metaKey?p.call(n,new r.CellCoords(e.countRows()-1,n.selectedRange.current().from.col)):p.call(n,new r.CellCoords(n.selectedRange.current().from.row,e.countCols()-1)),s.preventDefault(),(0, a.stopPropagation)(s);break;case i.KEY_CODES.PAGE_UP:n.transformStart(-e.countVisibleRows(),0),s.preventDefault(),(0, a.stopPropagation)(s);break;case i.KEY_CODES.PAGE_DOWN:n.transformStart(e.countVisibleRows(),0),s.preventDefault(),(0, a.stopPropagation)(s);}}}var g=this,v=new u.default(e),m=!1,y=!1,w=void 0;this.lockEditor=function(){y=!0;},this.unlockEditor=function(){y=!1;},this.destroyEditor=function(e){y||this.closeEditor(e);},this.getActiveEditor=function(){return w},this.prepareEditor=function(){if(!y){if(w&&w.isWaiting())return void this.closeEditor(!1,!1,function(e){e&&g.prepareEditor();});var t=e.selection.selectedRange.current().highlight.row,n=e.selection.selectedRange.current().highlight.col,o=e.colToProp(n),r=e.getCell(t,n),i=e.getSourceDataAtCell(e.runHooks("modifyRow",t),n),a=e.getCellMeta(t,n),l=e.getCellEditor(a);l?(w=(0, s.getEditorInstance)(l,e),w.prepare(t,n,o,r,i,a)):w=void 0;}},this.isEditorOpened=function(){return w&&w.isOpened()},this.openEditor=function(e,t){if(w){w.cellProperties.readOnly?t&&t.keyCode===i.KEY_CODES.ENTER&&o():w.beginEditing(e,t);}},this.closeEditor=function(e,t,n){w?w.finishEditing(e,t,n):n&&n(!1);},this.closeEditorAndSaveChanges=function(e){return this.closeEditor(!1,e)},this.closeEditorAndRestoreOriginalValue=function(e){return this.closeEditor(!0,e)},this.destroy=function(){m=!0;},function(){function t(e,t,n){"TD"===n.nodeName&&(w&&w.enableFullEditMode(),g.openEditor(null,e));}e.addHook("afterDocumentKeyDown",p),v.addEventListener(document.documentElement,"keydown",function(t){m||e.runHooks("afterDocumentKeyDown",t);}),v.addEventListener(document.documentElement,"compositionstart",function(t){!m&&w&&!w.isOpened()&&e.isListening()&&g.openEditor("",t);}),e.view.wt.update("onCellDblClick",t);}();}t.__esModule=!0;var r=n(4),i=n(21),a=n(12),s=n(17),l=n(6),u=function(e){return e&&e.__esModule?e:{default:e}}(l),c=n(56),h=new WeakMap;o.getInstance=function(e,t,n,r){var i=h.get(e);return i||(i=new o(e,t,n,r),h.set(e,i)),i},t.default=o;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e){var t=this,n=this;this.eventManager=new l.default(e),this.instance=e,this.settings=e.getSettings(),this.selectionMouseDown=!1;var o=e.rootElement.getAttribute("style");o&&e.rootElement.setAttribute("data-originalstyle",o),(0, a.addClass)(e.rootElement,"handsontable");var r=document.createElement("TABLE");(0, a.addClass)(r,"htCore"),e.getSettings().tableClassName&&(0, a.addClass)(r,e.getSettings().tableClassName),this.THEAD=document.createElement("THEAD"),r.appendChild(this.THEAD),this.TBODY=document.createElement("TBODY"),r.appendChild(this.TBODY),e.table=r,e.container.insertBefore(r,e.container.firstChild),this.eventManager.addEventListener(e.rootElement,"mousedown",function(e){t.selectionMouseDown=!0,n.isTextSelectionAllowed(e.target)||(d(),e.preventDefault(),window.focus());}),this.eventManager.addEventListener(e.rootElement,"mouseup",function(){t.selectionMouseDown=!1;}),this.eventManager.addEventListener(e.rootElement,"mousemove",function(e){t.selectionMouseDown&&!n.isTextSelectionAllowed(e.target)&&(t.settings.fragmentSelection&&d(),e.preventDefault());}),this.eventManager.addEventListener(document.documentElement,"keyup",function(t){e.selection.isInProgress()&&!t.shiftKey&&e.selection.finish();});var i=void 0;this.isMouseDown=function(){return i},this.eventManager.addEventListener(document.documentElement,"mouseup",function(t){e.selection.isInProgress()&&(0, u.isLeftClick)(t)&&e.selection.finish(),i=!1,((0, a.isOutsideInput)(document.activeElement)||!e.selection.isSelected()&&!(0, u.isRightClick)(t))&&e.unlisten();}),this.eventManager.addEventListener(document.documentElement,"contextmenu",function(t){e.selection.isInProgress()&&(0, u.isRightClick)(t)&&(e.selection.finish(),i=!1);}),this.eventManager.addEventListener(document.documentElement,"touchend",function(){e.selection.isInProgress()&&e.selection.finish();}),this.eventManager.addEventListener(document.documentElement,"mousedown",function(t){var o=t.target,r=t.x||t.clientX,s=t.y||t.clientY,l=t.target;if(!i&&e.rootElement){if(l===e.view.wt.wtTable.holder){var u=(0, a.getScrollbarWidth)();if(document.elementFromPoint(r+u,s)!==e.view.wt.wtTable.holder||document.elementFromPoint(r,s+u)!==e.view.wt.wtTable.holder)return}else for(;l!==document.documentElement;){if(null===l){if(t.isTargetWebComponent)break;return}if(l===e.rootElement)return;l=l.parentNode;}("function"==typeof n.settings.outsideClickDeselects?n.settings.outsideClickDeselects(o):n.settings.outsideClickDeselects)?e.deselectCell():e.destroyEditor(!1,!1);}}),this.eventManager.addEventListener(r,"selectstart",function(e){n.settings.fragmentSelection||(0, a.isInput)(e.target)||e.preventDefault();});var s={debug:function(){return n.settings.debug},externalRowCalculator:this.instance.getPlugin("autoRowSize")&&this.instance.getPlugin("autoRowSize").isEnabled(),table:r,preventOverflow:function(){return t.settings.preventOverflow},stretchH:function(){return n.settings.stretchH},data:e.getDataAtCell,totalRows:function(){return e.countRows()},totalColumns:function(){return e.countCols()},fixedColumnsLeft:function(){return n.settings.fixedColumnsLeft},fixedRowsTop:function(){return n.settings.fixedRowsTop},fixedRowsBottom:function(){return n.settings.fixedRowsBottom},minSpareRows:function(){return n.settings.minSpareRows},renderAllRows:n.settings.renderAllRows,rowHeaders:function(){var t=[];return e.hasRowHeaders()&&t.push(function(e,t){return n.appendRowHeader(e,t)}),e.runHooks("afterGetRowHeaderRenderers",t),t},columnHeaders:function(){var t=[];return e.hasColHeaders()&&t.push(function(e,t){n.appendColHeader(e,t);}),e.runHooks("afterGetColumnHeaderRenderers",t),t},columnWidth:e.getColWidth,rowHeight:e.getRowHeight,cellRenderer:function(e,t,o){var r=n.instance.getCellMeta(e,t),i=n.instance.colToProp(t),a=n.instance.getDataAtRowProp(e,i);n.instance.hasHook("beforeValueRender")&&(a=n.instance.runHooks("beforeValueRender",a,r)),n.instance.runHooks("beforeRenderer",o,e,t,i,a,r),n.instance.getCellRenderer(r)(n.instance,o,e,t,i,a,r),n.instance.runHooks("afterRenderer",o,e,t,i,a,r);},selections:n.instance.selection.highlight,hideBorderOnMouseDownOver:function(){return n.settings.fragmentSelection},onCellMouseDown:function(t,o,r,a){var s={row:!1,column:!1,cell:!1};e.listen(),n.activeWt=a,i=!0,e.runHooks("beforeOnCellMouseDown",t,o,r,s),(0, u.isImmediatePropagationStopped)(t)||((0, f.handleMouseEvent)(t,{coords:o,selection:e.selection,controller:s}),e.runHooks("afterOnCellMouseDown",t,o,r),n.activeWt=n.wt);},onCellContextMenu:function(t,o,r,a){n.activeWt=a,i=!1,e.selection.isInProgress()&&e.selection.finish(),e.runHooks("beforeOnCellContextMenu",t,o,r),(0, u.isImmediatePropagationStopped)(t)||(e.runHooks("afterOnCellContextMenu",t,o,r),n.activeWt=n.wt);},onCellMouseOut:function(t,o,r,i){n.activeWt=i,e.runHooks("beforeOnCellMouseOut",t,o,r),(0, u.isImmediatePropagationStopped)(t)||(e.runHooks("afterOnCellMouseOut",t,o,r),n.activeWt=n.wt);},onCellMouseOver:function(t,o,r,a){var s={row:!1,column:!1,cell:!1};n.activeWt=a,e.runHooks("beforeOnCellMouseOver",t,o,r,s),(0, u.isImmediatePropagationStopped)(t)||(i&&(0, f.handleMouseEvent)(t,{coords:o,selection:e.selection,controller:s}),e.runHooks("afterOnCellMouseOver",t,o,r),n.activeWt=n.wt);},onCellMouseUp:function(t,o,r,i){n.activeWt=i,e.runHooks("beforeOnCellMouseUp",t,o,r),e.runHooks("afterOnCellMouseUp",t,o,r),n.activeWt=n.wt;},onCellCornerMouseDown:function(t){t.preventDefault(),e.runHooks("afterOnCellCornerMouseDown",t);},onCellCornerDblClick:function(t){t.preventDefault(),e.runHooks("afterOnCellCornerDblClick",t);},beforeDraw:function(e,t){n.beforeRender(e,t);},onDraw:function(e){n.onDraw(e);},onScrollVertically:function(){e.runHooks("afterScrollVertically");},onScrollHorizontally:function(){e.runHooks("afterScrollHorizontally");},onBeforeRemoveCellClassNames:function(){return e.runHooks("beforeRemoveCellClassNames")},onAfterDrawSelection:function(t,n,o,r){return e.runHooks("afterDrawSelection",t,n,o,r)},onBeforeDrawBorders:function(t,n){e.runHooks("beforeDrawBorders",t,n);},onBeforeTouchScroll:function(){e.runHooks("beforeTouchScroll");},onAfterMomentumScroll:function(){e.runHooks("afterMomentumScroll");},onBeforeStretchingColumnWidth:function(t,n){return e.runHooks("beforeStretchingColumnWidth",t,n)},onModifyRowHeaderWidth:function(t){return e.runHooks("modifyRowHeaderWidth",t)},onModifyGetCellCoords:function(t,n,o){return e.runHooks("modifyGetCellCoords",t,n,o)},viewportRowCalculatorOverride:function(t){var o=e.countRows(),r=n.settings.viewportRowRenderingOffset;if("auto"===r&&n.settings.fixedRowsTop&&(r=10),"number"==typeof r&&(t.startRow=Math.max(t.startRow-r,0),t.endRow=Math.min(t.endRow+r,o-1)),"auto"===r){var i=t.startRow+t.endRow-t.startRow,a=Math.ceil(i/o*12);t.startRow=Math.max(t.startRow-a,0),t.endRow=Math.min(t.endRow+a,o-1);}e.runHooks("afterViewportRowCalculatorOverride",t);},viewportColumnCalculatorOverride:function(t){var o=e.countCols(),r=n.settings.viewportColumnRenderingOffset;if("auto"===r&&n.settings.fixedColumnsLeft&&(r=10),"number"==typeof r&&(t.startColumn=Math.max(t.startColumn-r,0),t.endColumn=Math.min(t.endColumn+r,o-1)),"auto"===r){var i=t.startColumn+t.endColumn-t.startColumn,a=Math.ceil(i/o*12);t.startRow=Math.max(t.startColumn-a,0),t.endColumn=Math.min(t.endColumn+a,o-1);}e.runHooks("afterViewportColumnCalculatorOverride",t);},rowHeaderWidth:function(){return n.settings.rowHeaderWidth},columnHeaderHeight:function(){var t=e.runHooks("modifyColumnHeaderHeight");return n.settings.columnHeaderHeight||t}};e.runHooks("beforeInitWalkontable",s),this.wt=new h.default(s),this.activeWt=this.wt,this.eventManager.addEventListener(n.wt.wtTable.spreader,"mousedown",function(e){e.target===n.wt.wtTable.spreader&&3===e.which&&(0, u.stopPropagation)(e);}),this.eventManager.addEventListener(n.wt.wtTable.spreader,"contextmenu",function(e){e.target===n.wt.wtTable.spreader&&3===e.which&&(0, u.stopPropagation)(e);}),this.eventManager.addEventListener(document.documentElement,"click",function(){n.settings.observeDOMVisibility&&n.wt.drawInterrupted&&(n.instance.forceFullRender=!0,n.render());});}t.__esModule=!0;var i=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),a=n(0),s=n(6),l=o(s),u=n(12),c=n(4),h=o(c),f=n(439),d=function(){window.getSelection?window.getSelection().empty?window.getSelection().empty():window.getSelection().removeAllRanges&&window.getSelection().removeAllRanges():document.selection&&document.selection.empty();};r.prototype.isTextSelectionAllowed=function(e){if((0, a.isInput)(e))return !0;var t=(0, a.isChildOf)(e,this.instance.view.wt.wtTable.spreader);return !(!0!==this.settings.fragmentSelection||!t)||(!("cell"!==this.settings.fragmentSelection||!this.isSelectedOnlyCell()||!t)||!(this.settings.fragmentSelection||!this.isCellEdited()||!this.isSelectedOnlyCell()))},r.prototype.isSelectedOnlyCell=function(){var e=this.instance.getSelectedLast()||[],t=i(e,4),n=t[0],o=t[1],r=t[2],a=t[3];return void 0!==n&&n===r&&o===a},r.prototype.isCellEdited=function(){var e=this.instance.getActiveEditor();return e&&e.isOpened()},r.prototype.beforeRender=function(e,t){e&&this.instance.runHooks("beforeRender",this.instance.forceFullRender,t);},r.prototype.onDraw=function(e){e&&this.instance.runHooks("afterRender",this.instance.forceFullRender);},r.prototype.render=function(){this.wt.draw(!this.instance.forceFullRender),this.instance.forceFullRender=!1,this.instance.renderCall=!1;},r.prototype.getCellAtCoords=function(e,t){var n=this.wt.getCell(e,t);return 0>n?null:n},r.prototype.scrollViewport=function(e,t,n,o,r){return this.wt.scrollViewport(e,t,n,o,r)},r.prototype.scrollViewportHorizontally=function(e,t,n){return this.wt.scrollViewportHorizontally(e,t,n)},r.prototype.scrollViewportVertically=function(e,t,n){return this.wt.scrollViewportVertically(e,t,n)},r.prototype.appendRowHeader=function(e,t){if(t.firstChild){var n=t.firstChild;if(!(0, a.hasClass)(n,"relative"))return (0, a.empty)(t),void this.appendRowHeader(e,t);this.updateCellHeader(n.querySelector(".rowHeader"),e,this.instance.getRowHeader);}else{var o=document.createElement("div"),r=document.createElement("span");o.className="relative",r.className="rowHeader",this.updateCellHeader(r,e,this.instance.getRowHeader),o.appendChild(r),t.appendChild(o);}this.instance.runHooks("afterGetRowHeader",e,t);},r.prototype.appendColHeader=function(e,t){if(t.firstChild){var n=t.firstChild;(0, a.hasClass)(n,"relative")?this.updateCellHeader(n.querySelector(".colHeader"),e,this.instance.getColHeader):((0, a.empty)(t),this.appendColHeader(e,t));}else{var o=document.createElement("div"),r=document.createElement("span");o.className="relative",r.className="colHeader",this.updateCellHeader(r,e,this.instance.getColHeader),o.appendChild(r),t.appendChild(o);}this.instance.runHooks("afterGetColHeader",e,t);},r.prototype.updateCellHeader=function(e,t,n){var o=t,r=this.wt.wtOverlays.getParentOverlay(e)||this.wt;e.parentNode&&((0, a.hasClass)(e,"colHeader")?o=r.wtTable.columnFilter.sourceToRendered(t):(0, a.hasClass)(e,"rowHeader")&&(o=r.wtTable.rowFilter.sourceToRendered(t))),o>-1?(0, a.fastInnerHTML)(e,n(t)):((0, a.fastInnerText)(e,String.fromCharCode(160)),(0, a.addClass)(e,"cornerHeader"));},r.prototype.maximumVisibleElementWidth=function(e){var t=this.wt.wtViewport.getWorkspaceWidth(),n=t-e;return n>0?n:0},r.prototype.maximumVisibleElementHeight=function(e){var t=this.wt.wtViewport.getWorkspaceHeight(),n=t-e;return n>0?n:0},r.prototype.mainViewIsActive=function(){return this.wt===this.activeWt},r.prototype.destroy=function(){this.wt.destroy(),this.eventManager.destroy();},t.default=r;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(1),a=n(2),s=n(5);t.default=function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];o(this,e),this.hot=t,this.data=n,this.dataType="array",this.colToProp=function(){},this.propToCol=function(){};}return r(e,[{key:"getData",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=this.data;return e&&(t=this.getByRange({row:0,col:0},{row:Math.max(this.countRows()-1,0),col:Math.max(this.countColumns()-1,0)},!0)),t}},{key:"setData",value:function(e){this.data=e;}},{key:"getAtColumn",value:function(e){var t=this,n=[];return (0, a.arrayEach)(this.data,function(o){var r=t.colToProp(e),a=void 0;a="string"==typeof r?(0, i.getProperty)(o,r):"function"==typeof r?r(o):o[r],n.push(a);}),n}},{key:"getAtRow",value:function(e){return this.data[e]}},{key:"getAtCell",value:function(e,t){var n=null,o=this.hot.runHooks("modifyRowData",e),r=isNaN(o)?o:this.data[e];if(r){var a=this.colToProp(t);n="string"==typeof a?(0, i.getProperty)(r,a):"function"==typeof a?a(this.data.slice(e,e+1)[0]):r[a];}return n}},{key:"getByRange",value:function(e,t){var n=this,o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=Math.min(e.row,t.row),i=Math.min(e.col,t.col),a=Math.max(e.row,t.row),l=Math.max(e.col,t.col),u=[];return (0, s.rangeEach)(r,a,function(e){var t=n.getAtRow(e),r=void 0;"array"===n.dataType?r=t.slice(i,l+1):"object"===n.dataType&&(r=o?[]:{},(0, s.rangeEach)(i,l,function(e){var i=n.colToProp(e);o?r.push(t[i]):r[i]=t[i];})),u.push(r);}),u}},{key:"countRows",value:function(){return Array.isArray(this.data)?this.data.length:0}},{key:"countColumns",value:function(){var e=0;return Array.isArray(this.data)&&("array"===this.dataType?e=this.data[0].length:"object"===this.dataType&&(e=Object.keys(this.data[0]).length)),e}},{key:"destroy",value:function(){this.data=null,this.hot=null;}}]),e}();},function(e,t,n){function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}t.__esModule=!0;var r,i=n(7),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(i);t.default=(r={languageCode:"en-US"},o(r,a.CONTEXTMENU_ITEMS_ROW_ABOVE,"Insert row above"),o(r,a.CONTEXTMENU_ITEMS_ROW_BELOW,"Insert row below"),o(r,a.CONTEXTMENU_ITEMS_INSERT_LEFT,"Insert column left"),o(r,a.CONTEXTMENU_ITEMS_INSERT_RIGHT,"Insert column right"),o(r,a.CONTEXTMENU_ITEMS_REMOVE_ROW,["Remove row","Remove rows"]),o(r,a.CONTEXTMENU_ITEMS_REMOVE_COLUMN,["Remove column","Remove columns"]),o(r,a.CONTEXTMENU_ITEMS_UNDO,"Undo"),o(r,a.CONTEXTMENU_ITEMS_REDO,"Redo"),o(r,a.CONTEXTMENU_ITEMS_READ_ONLY,"Read only"),o(r,a.CONTEXTMENU_ITEMS_CLEAR_COLUMN,"Clear column"),o(r,a.CONTEXTMENU_ITEMS_ALIGNMENT,"Alignment"),o(r,a.CONTEXTMENU_ITEMS_ALIGNMENT_LEFT,"Left"),o(r,a.CONTEXTMENU_ITEMS_ALIGNMENT_CENTER,"Center"),o(r,a.CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT,"Right"),o(r,a.CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY,"Justify"),o(r,a.CONTEXTMENU_ITEMS_ALIGNMENT_TOP,"Top"),o(r,a.CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE,"Middle"),o(r,a.CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM,"Bottom"),o(r,a.CONTEXTMENU_ITEMS_FREEZE_COLUMN,"Freeze column"),o(r,a.CONTEXTMENU_ITEMS_UNFREEZE_COLUMN,"Unfreeze column"),o(r,a.CONTEXTMENU_ITEMS_BORDERS,"Borders"),o(r,a.CONTEXTMENU_ITEMS_BORDERS_TOP,"Top"),o(r,a.CONTEXTMENU_ITEMS_BORDERS_RIGHT,"Right"),o(r,a.CONTEXTMENU_ITEMS_BORDERS_BOTTOM,"Bottom"),o(r,a.CONTEXTMENU_ITEMS_BORDERS_LEFT,"Left"),o(r,a.CONTEXTMENU_ITEMS_REMOVE_BORDERS,"Remove border(s)"),o(r,a.CONTEXTMENU_ITEMS_ADD_COMMENT,"Add comment"),o(r,a.CONTEXTMENU_ITEMS_EDIT_COMMENT,"Edit comment"),o(r,a.CONTEXTMENU_ITEMS_REMOVE_COMMENT,"Delete comment"),o(r,a.CONTEXTMENU_ITEMS_READ_ONLY_COMMENT,"Read-only comment"),o(r,a.CONTEXTMENU_ITEMS_MERGE_CELLS,"Merge cells"),o(r,a.CONTEXTMENU_ITEMS_UNMERGE_CELLS,"Unmerge cells"),o(r,a.CONTEXTMENU_ITEMS_COPY,"Copy"),o(r,a.CONTEXTMENU_ITEMS_CUT,"Cut"),o(r,a.CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD,"Insert child row"),o(r,a.CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD,"Detach from parent"),o(r,a.CONTEXTMENU_ITEMS_HIDE_COLUMN,["Hide column","Hide columns"]),o(r,a.CONTEXTMENU_ITEMS_SHOW_COLUMN,["Show column","Show columns"]),o(r,a.CONTEXTMENU_ITEMS_HIDE_ROW,["Hide row","Hide rows"]),o(r,a.CONTEXTMENU_ITEMS_SHOW_ROW,["Show row","Show rows"]),o(r,a.FILTERS_CONDITIONS_NONE,"None"),o(r,a.FILTERS_CONDITIONS_EMPTY,"Is empty"),o(r,a.FILTERS_CONDITIONS_NOT_EMPTY,"Is not empty"),o(r,a.FILTERS_CONDITIONS_EQUAL,"Is equal to"),o(r,a.FILTERS_CONDITIONS_NOT_EQUAL,"Is not equal to"),o(r,a.FILTERS_CONDITIONS_BEGINS_WITH,"Begins with"),o(r,a.FILTERS_CONDITIONS_ENDS_WITH,"Ends with"),o(r,a.FILTERS_CONDITIONS_CONTAINS,"Contains"),o(r,a.FILTERS_CONDITIONS_NOT_CONTAIN,"Does not contain"),o(r,a.FILTERS_CONDITIONS_GREATER_THAN,"Greater than"),o(r,a.FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL,"Greater than or equal to"),o(r,a.FILTERS_CONDITIONS_LESS_THAN,"Less than"),o(r,a.FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL,"Less than or equal to"),o(r,a.FILTERS_CONDITIONS_BETWEEN,"Is between"),o(r,a.FILTERS_CONDITIONS_NOT_BETWEEN,"Is not between"),o(r,a.FILTERS_CONDITIONS_AFTER,"After"),o(r,a.FILTERS_CONDITIONS_BEFORE,"Before"),o(r,a.FILTERS_CONDITIONS_TODAY,"Today"),o(r,a.FILTERS_CONDITIONS_TOMORROW,"Tomorrow"),o(r,a.FILTERS_CONDITIONS_YESTERDAY,"Yesterday"),o(r,a.FILTERS_VALUES_BLANK_CELLS,"Blank cells"),o(r,a.FILTERS_DIVS_FILTER_BY_CONDITION,"Filter by condition"),o(r,a.FILTERS_DIVS_FILTER_BY_VALUE,"Filter by value"),o(r,a.FILTERS_LABELS_CONJUNCTION,"And"),o(r,a.FILTERS_LABELS_DISJUNCTION,"Or"),o(r,a.FILTERS_BUTTONS_SELECT_ALL,"Select all"),o(r,a.FILTERS_BUTTONS_CLEAR,"Clear"),o(r,a.FILTERS_BUTTONS_OK,"OK"),o(r,a.FILTERS_BUTTONS_CANCEL,"Cancel"),o(r,a.FILTERS_BUTTONS_PLACEHOLDER_SEARCH,"Search"),o(r,a.FILTERS_BUTTONS_PLACEHOLDER_VALUE,"Value"),o(r,a.FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE,"Second value"),r);},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){h(e,t);}function i(){return f()}t.__esModule=!0,t.getPhraseFormatters=t.registerPhraseFormatter=void 0,t.register=r,t.getAll=i;var a=n(34),s=o(a),l=n(522),u=o(l),c=(0, s.default)("phraseFormatters"),h=c.register,f=c.getValues;t.registerPhraseFormatter=r,t.getPhraseFormatters=i,r("pluralize",u.default);},function(e,t,n){function o(e,t){return Array.isArray(e)&&Number.isInteger(t)?e[t]:e}t.__esModule=!0,t.default=o;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){return b(e)(t)}t.__esModule=!0,t.createHighlight=void 0;var i=n(34),a=o(i),s=n(524),l=o(s),u=n(525),c=o(u),h=n(526),f=o(h),d=n(527),p=o(d),g=n(528),v=o(g),m=n(529),y=o(m),w=(0, a.default)("highlight/types"),C=w.register,b=w.getItem;C("active-header",l.default),C("area",c.default),C("cell",f.default),C("custom-selection",p.default),C("fill",v.default),C("header",y.default),t.createHighlight=r;},function(e,t,n){function o(e){return new r.Selection({highlightHeaderClassName:e.activeHeaderClassName})}t.__esModule=!0;var r=n(4);t.default=o;},function(e,t,n){function o(e){var t=e.layerLevel,n=e.areaCornerVisible;return new r.Selection({className:"area",markIntersections:!0,layerLevel:Math.min(t,7),border:{width:1,color:"#4b89ff",cornerVisible:n}})}t.__esModule=!0;var r=n(4);t.default=o;},function(e,t,n){function o(e){return new r.Selection({className:"current",border:{width:2,color:"#4b89ff",cornerVisible:e.cellCornerVisible}})}t.__esModule=!0;var r=n(4);t.default=o;},function(e,t,n){function o(e){return new r.Selection(e.border,e.cellRange)}t.__esModule=!0;var r=n(4);t.default=o;},function(e,t,n){function o(){return new r.Selection({className:"fill",border:{width:1,color:"#ff0000"}})}t.__esModule=!0;var r=n(4);t.default=o;},function(e,t,n){function o(e){return new r.Selection({className:"highlight",highlightHeaderClassName:e.headerClassName,highlightRowClassName:e.rowClassName,highlightColumnClassName:e.columnClassName})}t.__esModule=!0;var r=n(4);t.default=o;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var i=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=function(e,t){return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}(["Unsupported format of the selection ranges was passed. To select cells pass \n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, columnEnd/columnPropEnd]]) \n        or as an array of CellRange objects."],["Unsupported format of the selection ranges was passed. To select cells pass \n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, columnEnd/columnPropEnd]]) \n        or as an array of CellRange objects."]),l=n(446),u=o(l),c=n(531),h=o(c),f=n(4),d=n(93),p=n(1),g=n(10),v=n(2),m=n(48),y=o(m),w=n(532),C=o(w),b=n(73),_=n(42),S=function(){function e(t,n){var o=this;r(this,e),this.settings=t,this.tableProps=n,this.inProgress=!1,this.selectedByCorner=!1,this.selectedByRowHeader=new Set,this.selectedByColumnHeader=new Set,this.selectedRange=new h.default,this.highlight=new u.default({headerClassName:t.currentHeaderClassName,activeHeaderClassName:t.activeHeaderClassName,rowClassName:t.currentRowClassName,columnClassName:t.currentColClassName,disableHighlight:this.settings.disableVisualSelection,cellCornerVisible:function(){return o.isCellCornerVisible.apply(o,arguments)},areaCornerVisible:function(){return o.isAreaCornerVisible.apply(o,arguments)}}),this.transformation=new C.default(this.selectedRange,{countRows:function(){return o.tableProps.countRows()},countCols:function(){return o.tableProps.countCols()},fixedRowsBottom:function(){return t.fixedRowsBottom},minSpareRows:function(){return t.minSpareRows},minSpareCols:function(){return t.minSpareCols},autoWrapRow:function(){return t.autoWrapRow},autoWrapCol:function(){return t.autoWrapCol}}),this.transformation.addLocalHook("beforeTransformStart",function(){for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];return o.runLocalHooks.apply(o,["beforeModifyTransformStart"].concat(t))}),this.transformation.addLocalHook("afterTransformStart",function(){for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];return o.runLocalHooks.apply(o,["afterModifyTransformStart"].concat(t))}),this.transformation.addLocalHook("beforeTransformEnd",function(){for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];return o.runLocalHooks.apply(o,["beforeModifyTransformEnd"].concat(t))}),this.transformation.addLocalHook("afterTransformEnd",function(){for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];return o.runLocalHooks.apply(o,["afterModifyTransformEnd"].concat(t))}),this.transformation.addLocalHook("insertRowRequire",function(){for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];return o.runLocalHooks.apply(o,["insertRowRequire"].concat(t))}),this.transformation.addLocalHook("insertColRequire",function(){for(var e=arguments.length,t=Array(e),n=0;e>n;n++)t[n]=arguments[n];return o.runLocalHooks.apply(o,["insertColRequire"].concat(t))});}return a(e,[{key:"getSelectedRange",value:function(){return this.selectedRange}},{key:"begin",value:function(){this.inProgress=!0;}},{key:"finish",value:function(){this.runLocalHooks("afterSelectionFinished",Array.from(this.selectedRange)),this.inProgress=!1;}},{key:"isInProgress",value:function(){return this.inProgress}},{key:"setRangeStart",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o="multiple"===this.settings.selectionMode,r=(0, g.isUndefined)(t)?(0, d.isPressedCtrlKey)():t,i=0>e.row,a=0>e.col,s=i&&a;i&&(e.row=0),a&&(e.col=0),this.selectedByCorner=s,this.runLocalHooks("beforeSetRangeStart"+(n?"Only":""),e),(!o||o&&!r&&(0, g.isUndefined)(t))&&this.selectedRange.clear(),this.selectedRange.add(e),0===this.getLayerLevel()&&(this.selectedByRowHeader.clear(),this.selectedByColumnHeader.clear()),!s&&a&&this.selectedByRowHeader.add(this.getLayerLevel()),!s&&i&&this.selectedByColumnHeader.add(this.getLayerLevel()),n||this.setRangeEnd(e);}},{key:"setRangeStartOnly",value:function(e,t){this.setRangeStart(e,t,!0);}},{key:"setRangeEnd",value:function(e){if(!this.selectedRange.isEmpty()){this.runLocalHooks("beforeSetRangeEnd",e),this.begin();var t=this.selectedRange.current();"single"!==this.settings.selectionMode&&t.setTo(new f.CellCoords(e.row,e.col)),this.highlight.getCell().clear(),this.highlight.isEnabledFor(l.CELL_TYPE)&&this.highlight.getCell().add(this.selectedRange.current().highlight);var n=this.getLayerLevel();this.highlight.layerLevel>n&&((0, v.arrayEach)(this.highlight.getAreas(),function(e){return void e.clear()}),(0, v.arrayEach)(this.highlight.getHeaders(),function(e){return void e.clear()}),(0, v.arrayEach)(this.highlight.getActiveHeaders(),function(e){return void e.clear()})),this.highlight.useLayerLevel(n);var o=this.highlight.createOrGetArea(),r=this.highlight.createOrGetHeader(),i=this.highlight.createOrGetActiveHeader();if(o.clear(),r.clear(),i.clear(),!this.highlight.isEnabledFor(l.AREA_TYPE)||!this.isMultiple()&&1>n||(o.add(t.from).add(t.to),1===n&&(this.highlight.useLayerLevel(n-1).createOrGetArea().add(this.selectedRange.previous().from),this.highlight.useLayerLevel(n))),this.highlight.isEnabledFor(l.HEADER_TYPE)&&("single"===this.settings.selectionMode?r.add(t.highlight):r.add(t.from).add(t.to)),this.isSelectedByRowHeader()){this.tableProps.countCols()===t.getWidth()&&i.add(new f.CellCoords(t.from.row,-1)).add(new f.CellCoords(t.to.row,-1));}if(this.isSelectedByColumnHeader()){this.tableProps.countRows()===t.getHeight()&&i.add(new f.CellCoords(-1,t.from.col)).add(new f.CellCoords(-1,t.to.col));}this.runLocalHooks("afterSetRangeEnd",e);}}},{key:"isMultiple",value:function(){var e=(0, p.createObjectPropListener)(!this.selectedRange.current().isSingle());return this.runLocalHooks("afterIsMultipleSelection",e),e.value}},{key:"transformStart",value:function(e,t,n){this.setRangeStart(this.transformation.transformStart(e,t,n));}},{key:"transformEnd",value:function(e,t){this.setRangeEnd(this.transformation.transformEnd(e,t));}},{key:"getLayerLevel",value:function(){return this.selectedRange.size()-1}},{key:"isSelected",value:function(){return !this.selectedRange.isEmpty()}},{key:"isSelectedByRowHeader",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.getLayerLevel();return -1===e?this.selectedByRowHeader.size>0:this.selectedByRowHeader.has(e)}},{key:"isSelectedByColumnHeader",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.getLayerLevel();return -1===e?this.selectedByColumnHeader.size>0:this.selectedByColumnHeader.has(e)}},{key:"isSelectedByAnyHeader",value:function(){return this.isSelectedByRowHeader(-1)||this.isSelectedByColumnHeader(-1)}},{key:"isSelectedByCorner",value:function(){return this.selectedByCorner}},{key:"inInSelection",value:function(e){return this.selectedRange.includes(e)}},{key:"isCellCornerVisible",value:function(){return this.settings.fillHandle&&!this.tableProps.isEditorOpened()&&!this.isMultiple()}},{key:"isAreaCornerVisible",value:function(e){return (!Number.isInteger(e)||e===this.getLayerLevel())&&(this.settings.fillHandle&&!this.tableProps.isEditorOpened()&&this.isMultiple())}},{key:"clear",value:function(){this.selectedRange.clear(),this.highlight.clear();}},{key:"deselect",value:function(){this.isSelected()&&(this.inProgress=!1,this.clear(),this.runLocalHooks("afterDeselect"));}},{key:"selectAll",value:function(){this.clear(),this.setRangeStart(new f.CellCoords(-1,-1)),this.selectedByRowHeader.add(this.getLayerLevel()),this.selectedByColumnHeader.add(this.getLayerLevel()),this.setRangeEnd(new f.CellCoords(this.tableProps.countRows()-1,this.tableProps.countCols()-1));}},{key:"selectCells",value:function(e){var t=this,n=(0, b.detectSelectionType)(e);if(n===b.SELECTION_TYPE_EMPTY)return !1;if(n===b.SELECTION_TYPE_UNRECOGNIZED)throw Error((0, _.toSingleLine)(s));var o=(0, b.normalizeSelectionFactory)(n,{propToCol:function(e){return t.tableProps.propToCol(e)},keepDirection:!0}),r=this.tableProps.countRows(),a=this.tableProps.countCols(),l=!e.some(function(e){var t=o(e),n=i(t,4),s=n[0],l=n[1],u=n[2],c=n[3];return !((0, b.isValidCoord)(s,r)&&(0, b.isValidCoord)(l,a)&&(0, b.isValidCoord)(u,r)&&(0, b.isValidCoord)(c,a))});return l&&(this.clear(),(0, v.arrayEach)(e,function(e){var n=o(e),r=i(n,4),a=r[0],s=r[1],l=r[2],u=r[3];t.setRangeStartOnly(new f.CellCoords(a,s),!1),t.setRangeEnd(new f.CellCoords(l,u)),t.finish();})),l}},{key:"selectColumns",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e,n="string"==typeof e?this.tableProps.propToCol(e):e,o="string"==typeof t?this.tableProps.propToCol(t):t,r=this.tableProps.countCols(),i=(0, b.isValidCoord)(n,r)&&(0, b.isValidCoord)(o,r);return i&&(this.setRangeStartOnly(new f.CellCoords(-1,n)),this.setRangeEnd(new f.CellCoords(this.tableProps.countRows()-1,o)),this.finish()),i}},{key:"selectRows",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e,n=this.tableProps.countRows(),o=(0, b.isValidCoord)(e,n)&&(0, b.isValidCoord)(t,n);return o&&(this.setRangeStartOnly(new f.CellCoords(e,-1)),this.setRangeEnd(new f.CellCoords(t,this.tableProps.countCols()-1)),this.finish()),o}}]),e}();(0, p.mixin)(S,y.default),t.default=S;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(4);t.default=function(){function e(){o(this,e),this.ranges=[];}return r(e,[{key:"isEmpty",value:function(){return 0===this.size()}},{key:"set",value:function(e){return this.clear(),this.ranges.push(new i.CellRange(e)),this}},{key:"add",value:function(e){return this.ranges.push(new i.CellRange(e)),this}},{key:"current",value:function(){return this.peekByIndex(0)}},{key:"previous",value:function(){return this.peekByIndex(-1)}},{key:"includes",value:function(e){return this.ranges.some(function(t){return t.includes(e)})}},{key:"clear",value:function(){return this.ranges.length=0,this}},{key:"size",value:function(){return this.ranges.length}},{key:"peekByIndex",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=this.size()+e-1,n=void 0;return 0>t||(n=this.ranges[t]),n}},{key:Symbol.iterator,value:function(){return this.ranges[Symbol.iterator]()}}]),e}();},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(4),a=n(1),s=n(48),l=function(e){return e&&e.__esModule?e:{default:e}}(s),u=function(){function e(t,n){o(this,e),this.range=t,this.options=n;}return r(e,[{key:"transformStart",value:function(e,t,n){var o=new i.CellCoords(e,t);this.runLocalHooks("beforeTransformStart",o);var r=this.options.countRows(),a=this.options.countCols(),s=this.options.fixedRowsBottom(),l=this.options.minSpareRows(),u=this.options.minSpareCols(),c=this.options.autoWrapRow(),h=this.options.autoWrapCol(),f=this.range.current().highlight;f.row+e>r-1?n&&l>0&&(!s||r-s-1>f.row)?(this.runLocalHooks("insertRowRequire",r),r=this.options.countRows()):h&&(o.row=1-r,o.col=f.col+o.col===a-1?1-a:1):h&&0>f.row+o.row&&f.col+o.col>=0&&(o.row=r-1,o.col=f.col+o.col===0?a-1:-1),f.col+o.col>a-1?n&&u>0?(this.runLocalHooks("insertColRequire",a),a=this.options.countCols()):c&&(o.row=f.row+o.row===r-1?1-r:1,o.col=1-a):c&&0>f.col+o.col&&f.row+o.row>=0&&(o.row=f.row+o.row===0?r-1:-1,o.col=a-1);var d=new i.CellCoords(f.row+o.row,f.col+o.col),p=0,g=0;return 0>d.row?(p=-1,d.row=0):d.row>0&&d.row>=r&&(p=1,d.row=r-1),0>d.col?(g=-1,d.col=0):d.col>0&&d.col>=a&&(g=1,d.col=a-1),this.runLocalHooks("afterTransformStart",d,p,g),d}},{key:"transformEnd",value:function(e,t){var n=new i.CellCoords(e,t);this.runLocalHooks("beforeTransformEnd",n);var o=this.options.countRows(),r=this.options.countCols(),a=this.range.current(),s=new i.CellCoords(a.to.row+n.row,a.to.col+n.col),l=0,u=0;return 0>s.row?(l=-1,s.row=0):s.row>0&&s.row>=o&&(l=1,s.row=o-1),0>s.col?(u=-1,s.col=0):s.col>0&&s.col>=r&&(u=1,s.col=r-1),this.runLocalHooks("afterTransformEnd",s,l,u),s}}]),e}();(0, a.mixin)(u,l.default),t.default=u;},function(e,t,n){function o(e){var t="undefined"!=typeof window&&window.jQuery;t&&(t.fn.handsontable=function(t){var n=this.first(),o=n.data("handsontable");if("string"!=typeof t){var r=t||{};return o?o.updateSettings(r):(o=new e.Core(n[0],r),n.data("handsontable",o),o.init()),n}var i=void 0;if(o){if(void 0===o[t])throw Error("Handsontable do not provide action: "+t);for(var a,s=arguments.length,l=Array(s>1?s-1:0),u=1;s>u;u++)l[u-1]=arguments[u];i=(a=o[t]).call.apply(a,[o].concat(l)),"destroy"===t&&n.removeData();}return i});}t.__esModule=!0,t.default=o;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0,t.Base=t.UndoRedo=t.TouchScroll=t.Search=t.PersistentState=t.ObserveChanges=t.MultipleSelectionHandles=t.MergeCells=t.ManualRowResize=t.ManualRowMove=t.ManualColumnResize=t.ManualColumnMove=t.ManualColumnFreeze=t.DragToScroll=t.CustomBorders=t.CopyPaste=t.ContextMenu=t.Comments=t.ColumnSorting=t.AutoRowSize=t.AutoFill=t.AutoColumnSize=void 0;var r=n(535),i=o(r),a=n(537),s=o(a),l=n(538),u=o(l),c=n(540),h=o(c),f=n(541),d=o(f),p=n(552),g=o(p),v=n(556),m=o(v),y=n(573),w=o(y),C=n(581),b=o(C),_=n(588),S=o(_),E=n(589),O=o(E),T=n(593),k=o(T),R=n(598),M=o(R),D=n(599),A=o(D),N=n(604),P=o(N),H=n(605),L=o(H),x=n(611),I=o(x),j=n(612),F=o(j),W=n(616),B=o(W),Y=n(617),V=o(Y),U=n(618),z=o(U),G=n(11),K=o(G);t.AutoColumnSize=s.default,t.AutoFill=u.default,t.AutoRowSize=h.default,t.ColumnSorting=d.default,t.Comments=g.default,t.ContextMenu=m.default,t.CopyPaste=w.default,t.CustomBorders=b.default,t.DragToScroll=S.default,t.ManualColumnFreeze=O.default,t.ManualColumnMove=k.default,t.ManualColumnResize=M.default,t.ManualRowMove=A.default,t.ManualRowResize=P.default,t.MergeCells=L.default,t.MultipleSelectionHandles=I.default,t.ObserveChanges=F.default,t.PersistentState=i.default,t.Search=B.default,t.TouchScroll=V.default,t.UndoRedo=z.default,t.Base=K.default;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var s=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},u=n(11),c=o(u),h=n(8),f=n(536),d=o(f),p=n(16),g=o(p);g.default.getSingleton().register("persistentStateSave"),g.default.getSingleton().register("persistentStateLoad"),g.default.getSingleton().register("persistentStateReset");var v=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.storage=void 0,n}return a(t,e),s(t,[{key:"isEnabled",value:function(){return !!this.hot.getSettings().persistentState}},{key:"enablePlugin",value:function(){var e=this;this.enabled||(this.storage||(this.storage=new d.default(this.hot.rootElement.id)),this.addHook("persistentStateSave",function(t,n){return e.saveValue(t,n)}),this.addHook("persistentStateLoad",function(t,n){return e.loadValue(t,n)}),this.addHook("persistentStateReset",function(){return e.resetValue()}),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this));}},{key:"disablePlugin",value:function(){this.storage=void 0,l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"updatePlugin",value:function(){this.disablePlugin(),this.enablePlugin(),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updatePlugin",this).call(this);}},{key:"loadValue",value:function(e,t){t.value=this.storage.loadValue(e);}},{key:"saveValue",value:function(e,t){this.storage.saveValue(e,t);}},{key:"resetValue",value:function(e){void 0===e?this.storage.resetAll():this.storage.reset(e);}},{key:"destroy",value:function(){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}}]),t}(c.default);(0, h.registerPlugin)("persistentState",v),t.default=v;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(2);t.default=function(){function e(t){o(this,e),this.prefix=t,this.savedKeys=[],this.loadSavedKeys();}return r(e,[{key:"saveValue",value:function(e,t){window.localStorage.setItem(this.prefix+"_"+e,JSON.stringify(t)),-1===this.savedKeys.indexOf(e)&&(this.savedKeys.push(e),this.saveSavedKeys());}},{key:"loadValue",value:function(e,t){var n=void 0===e?t:e,o=window.localStorage.getItem(this.prefix+"_"+n);return null===o?void 0:JSON.parse(o)}},{key:"reset",value:function(e){window.localStorage.removeItem(this.prefix+"_"+e);}},{key:"resetAll",value:function(){var e=this;(0, i.arrayEach)(this.savedKeys,function(t,n){window.localStorage.removeItem(e.prefix+"_"+e.savedKeys[n]);}),this.clearSavedKeys();}},{key:"loadSavedKeys",value:function(){var e=window.localStorage.getItem(this.prefix+"__persistentStateKeys");this.savedKeys=("string"==typeof e?JSON.parse(e):void 0)||[];}},{key:"saveSavedKeys",value:function(){window.localStorage.setItem(this.prefix+"__persistentStateKeys",JSON.stringify(this.savedKeys));}},{key:"clearSavedKeys",value:function(){this.savedKeys.length=0,this.saveSavedKeys();}}]),e}();},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var s=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},u=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(11),h=o(c),f=n(2),d=n(41),p=n(0),g=n(94),v=o(g),m=n(1),y=n(5),w=n(8),C=n(447),b=o(C),_=n(36),S=n(4),E=new WeakMap,O=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return E.set(n,{cachedColumnHeaders:[]}),n.widths=[],n.ghostTable=new v.default(n.hot),n.samplesGenerator=new b.default(function(e,t){var o=n.hot.getCellMeta(e,t),r="";o.spanned||(r=n.hot.getDataAtCell(e,t));var i=0;if(o.label){var a=o.label,s=a.value,l=a.property,u="";s?u="function"==typeof s?s(e,t,n.hot.colToProp(t),r):s:l&&(u=n.hot.getDataAtRowProp(e,l)),i=u.length;}return {value:r,bundleCountSeed:i}}),n.firstCalculation=!0,n.inProgress=!1,n.addHook("beforeColumnResize",function(e,t,o){return n.onBeforeColumnResize(e,t,o)}),n}return a(t,e),u(t,null,[{key:"CALCULATION_STEP",get:function(){return 50}},{key:"SYNC_CALCULATION_LIMIT",get:function(){return 50}}]),u(t,[{key:"isEnabled",value:function(){return !1!==this.hot.getSettings().autoColumnSize&&!this.hot.getSettings().colWidths}},{key:"enablePlugin",value:function(){var e=this;if(!this.enabled){var n=this.hot.getSettings().autoColumnSize;n&&null!==n.useHeaders&&void 0!==n.useHeaders&&this.ghostTable.setSetting("useHeaders",n.useHeaders),this.setSamplingOptions(),this.addHook("afterLoadData",function(){return e.onAfterLoadData()}),this.addHook("beforeChange",function(t){return e.onBeforeChange(t)}),this.addHook("beforeRender",function(t){return e.onBeforeRender(t)}),this.addHook("modifyColWidth",function(t,n){return e.getColumnWidth(n,t)}),this.addHook("afterInit",function(){return e.onAfterInit()}),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this);}}},{key:"updatePlugin",value:function(){var e=this.findColumnsWhereHeaderWasChanged();e.length&&this.clearCache(e),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updatePlugin",this).call(this);}},{key:"disablePlugin",value:function(){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"calculateColumnsWidth",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{from:0,to:this.hot.countCols()-1},t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{from:0,to:this.hot.countRows()-1},o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r="number"==typeof e?{from:e,to:e}:e,i="number"==typeof n?{from:n,to:n}:n;(0, y.rangeEach)(r.from,r.to,function(e){if(o||void 0===t.widths[e]&&!t.hot._getColWidthFromSettings(e)){var n=t.samplesGenerator.generateColumnSamples(e,i);(0, f.arrayEach)(n,function(e){var n=s(e,2);return t.ghostTable.addColumn(n[0],n[1])});}}),this.ghostTable.columns.length&&(this.ghostTable.getWidths(function(e,n){t.widths[e]=n;}),this.ghostTable.clean());}},{key:"calculateAllColumnsWidth",value:function(){var e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{from:0,to:this.hot.countRows()-1},o=0,r=this.hot.countCols()-1,i=null;this.inProgress=!0;var a=this.getSyncCalculationLimit();this.firstCalculation&&a>=0&&(this.calculateColumnsWidth({from:0,to:a},n),this.firstCalculation=!1,o=a+1),r>o?function a(){if(!e.hot)return (0, d.cancelAnimationFrame)(i),void(e.inProgress=!1);e.calculateColumnsWidth({from:o,to:Math.min(o+t.CALCULATION_STEP,r)},n),o=o+t.CALCULATION_STEP+1,r>o?i=(0, d.requestAnimationFrame)(a):((0, d.cancelAnimationFrame)(i),e.inProgress=!1,e.hot.view.wt.wtOverlays.adjustElementsSize(!0),e.hot.view.wt.wtOverlays.leftOverlay.needFullRender&&e.hot.view.wt.wtOverlays.leftOverlay.clone.draw());}():this.inProgress=!1;}},{key:"setSamplingOptions",value:function(){var e=this.hot.getSettings().autoColumnSize,t=e&&(0, m.hasOwnProperty)(e,"samplingRatio")?this.hot.getSettings().autoColumnSize.samplingRatio:void 0,n=e&&(0, m.hasOwnProperty)(e,"allowSampleDuplicates")?this.hot.getSettings().autoColumnSize.allowSampleDuplicates:void 0;t&&!isNaN(t)&&this.samplesGenerator.setSampleCount(parseInt(t,10)),n&&this.samplesGenerator.setAllowDuplicates(n);}},{key:"recalculateAllColumnsWidth",value:function(){this.hot.view&&(0, p.isVisible)(this.hot.view.wt.wtTable.TABLE)&&(this.clearCache(),this.calculateAllColumnsWidth());}},{key:"getSyncCalculationLimit",value:function(){var e=t.SYNC_CALCULATION_LIMIT,n=this.hot.countCols()-1;return (0, m.isObject)(this.hot.getSettings().autoColumnSize)&&(e=this.hot.getSettings().autoColumnSize.syncLimit,(0, _.isPercentValue)(e)?e=(0, y.valueAccordingPercent)(n,e):e>>=0),Math.min(e,n)}},{key:"getColumnWidth",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=2>=arguments.length||void 0===arguments[2]||arguments[2],o=t;return void 0===o&&(o=this.widths[e],n&&"number"==typeof o&&(o=Math.max(o,S.ViewportColumnsCalculator.DEFAULT_WIDTH))),o}},{key:"getFirstVisibleColumn",value:function(){var e=this.hot.view.wt;return e.wtViewport.columnsVisibleCalculator?e.wtTable.getFirstVisibleColumn():e.wtViewport.columnsRenderCalculator?e.wtTable.getFirstRenderedColumn():-1}},{key:"getLastVisibleColumn",value:function(){var e=this.hot.view.wt;return e.wtViewport.columnsVisibleCalculator?e.wtTable.getLastVisibleColumn():e.wtViewport.columnsRenderCalculator?e.wtTable.getLastRenderedColumn():-1}},{key:"findColumnsWhereHeaderWasChanged",value:function(){var e=this.hot.getColHeader(),t=E.get(this),n=t.cachedColumnHeaders;return (0, f.arrayReduce)(e,function(e,t,o){var r=n.length;return (o>r-1||n[o]!==t)&&e.push(o),o>r-1?n.push(t):n[o]=t,e},[])}},{key:"clearCache",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];t.length?(0, f.arrayEach)(t,function(t){e.widths[t]=void 0;}):this.widths.length=0;}},{key:"isNeedRecalculate",value:function(){return !!(0, f.arrayFilter)(this.widths,function(e){return void 0===e}).length}},{key:"onBeforeRender",value:function(){var e=this.hot.renderCall;this.hot.countRows()&&(this.calculateColumnsWidth({from:this.getFirstVisibleColumn(),to:this.getLastVisibleColumn()},void 0,e),this.isNeedRecalculate()&&!this.inProgress&&this.calculateAllColumnsWidth());}},{key:"onAfterLoadData",value:function(){var e=this;this.hot.view?this.recalculateAllColumnsWidth():setTimeout(function(){e.hot&&e.recalculateAllColumnsWidth();},0);}},{key:"onBeforeChange",value:function(e){var t=this;this.clearCache((0, f.arrayMap)(e,function(e){var n=s(e,2);return t.hot.propToCol(n[1])}));}},{key:"onBeforeColumnResize",value:function(e,t,n){var o=t;return n&&(this.calculateColumnsWidth(e,void 0,!0),o=this.getColumnWidth(e,void 0,!1)),o}},{key:"onAfterInit",value:function(){E.get(this).cachedColumnHeaders=this.hot.getColHeader();}},{key:"destroy",value:function(){this.ghostTable.clean(),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}}]),t}(h.default);(0, w.registerPlugin)("autoColumnSize",O),t.default=O;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);e.length>t;t++)n[t]=e[t];return n}return Array.from(e)}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function a(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var l=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),u=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},c=n(11),h=o(c),f=n(16),d=o(f),p=n(0),g=n(6),v=o(g),m=n(8),y=n(4),w=n(539);d.default.getSingleton().register("modifyAutofillRange"),d.default.getSingleton().register("beforeAutofill");var C=function(e){function t(e){i(this,t);var n=a(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.eventManager=new v.default(n),n.addingStarted=!1,n.mouseDownOnCellCorner=!1,n.mouseDragOutside=!1,n.handleDraggedCells=0,n.directions=[],n.autoInsertRow=!1,n}return s(t,e),l(t,[{key:"isEnabled",value:function(){return this.hot.getSettings().fillHandle}},{key:"enablePlugin",value:function(){var e=this;this.enabled||(this.mapSettings(),this.registerEvents(),this.addHook("afterOnCellCornerMouseDown",function(t){return e.onAfterCellCornerMouseDown(t)}),this.addHook("afterOnCellCornerDblClick",function(t){return e.onCellCornerDblClick(t)}),this.addHook("beforeOnCellMouseOver",function(t,n){return e.onBeforeCellMouseOver(n)}),u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this));}},{key:"updatePlugin",value:function(){this.disablePlugin(),this.enablePlugin(),u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updatePlugin",this).call(this);}},{key:"disablePlugin",value:function(){this.clearMappedSettings(),u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"getSelectionData",value:function(){var e={from:this.hot.getSelectedRangeLast().from,to:this.hot.getSelectedRangeLast().to};return this.hot.getData(e.from.row,e.from.col,e.to.row,e.to.col)}},{key:"fillIn",value:function(){if(this.hot.selection.highlight.getFill().isEmpty())return !1;var e=this.hot.selection.highlight.getFill().getCorners();this.resetSelectionOfDraggedArea();var t=this.getCornersOfSelectedCells();e=this.hot.runHooks("modifyAutofillRange",e,t);var n=(0, w.getDragDirectionAndRange)(t,e),o=n.directionOfDrag,r=n.startOfDragCoords,i=n.endOfDragCoords;if(r&&r.row>-1&&r.col>-1){var a=this.getSelectionData();this.hot.runHooks("beforeAutofill",r,i,a);var s=(0, w.getDeltas)(r,i,a,o),l=a;if(["up","left"].indexOf(o)>-1){l=[];var u=null,c=null;if("up"===o){u=i.row-r.row+1,c=u%a.length;for(var h=0;u>h;h++)l.push(a[(h+(a.length-c))%a.length]);}else{u=i.col-r.col+1,c=u%a[0].length;for(var f=0;a.length>f;f++){l.push([]);for(var d=0;u>d;d++)l[f].push(a[f][(d+(a[f].length-c))%a[f].length]);}}}this.hot.populateFromArray(r.row,r.col,l,i.row,i.col,this.pluginName+".fill",null,o,s),this.setSelection(e);}else this.hot._refreshBorders();return !0}},{key:"reduceSelectionAreaIfNeeded",value:function(e){return 0>e.row&&(e.row=0),0>e.col&&(e.col=0),e}},{key:"getCoordsOfDragAndDropBorders",value:function(e){var t=this.hot.getSelectedRangeLast().getTopLeftCorner(),n=this.hot.getSelectedRangeLast().getBottomRightCorner(),o=void 0;if(this.directions.includes(w.DIRECTIONS.vertical)&&(e.row>n.row||t.row>e.row))o=new y.CellCoords(e.row,n.col);else{if(!this.directions.includes(w.DIRECTIONS.horizontal))return;o=new y.CellCoords(n.row,e.col);}return this.reduceSelectionAreaIfNeeded(o)}},{key:"showBorder",value:function(e){var t=this.getCoordsOfDragAndDropBorders(e);t&&this.redrawBorders(t);}},{key:"addRow",value:function(){var e=this;this.hot._registerTimeout(setTimeout(function(){e.hot.alter("insert_row",void 0,1,e.pluginName+".fill"),e.addingStarted=!1;},200));}},{key:"addNewRowIfNeeded",value:function(){if(this.hot.selection.highlight.getFill().cellRange&&!1===this.addingStarted&&this.autoInsertRow){var e=this.hot.getSelectedLast(),t=this.hot.selection.highlight.getFill().getCorners(),n=this.hot.countRows();n-1>e[2]&&t[2]===n-1&&(this.addingStarted=!0,this.addRow());}}},{key:"getCornersOfSelectedCells",value:function(){return this.hot.selection.isMultiple()?this.hot.selection.highlight.createOrGetArea().getCorners():this.hot.selection.highlight.getCell().getCorners()}},{key:"getIndexOfLastAdjacentFilledInRow",value:function(e){for(var t=this.hot.getData(),n=this.hot.countRows(),o=void 0,r=e[2]+1;n>r;r++){for(var i=e[1];e[3]>=i;i++){if(t[r][i])return -1}var a=t[r][e[1]-1],s=t[r][e[3]+1];(a||s)&&(o=r);}return o}},{key:"addSelectionFromStartAreaToSpecificRowIndex",value:function(e,t){this.hot.selection.highlight.getFill().clear().add(new y.CellCoords(e[0],e[1])).add(new y.CellCoords(t,e[3]));}},{key:"setSelection",value:function(e){var t;(t=this.hot).selectCell.apply(t,r(e).concat([!1,!1]));}},{key:"selectAdjacent",value:function(){var e=this.getCornersOfSelectedCells(),t=this.getIndexOfLastAdjacentFilledInRow(e);return -1!==t&&void 0!==t&&(this.addSelectionFromStartAreaToSpecificRowIndex(e,t),!0)}},{key:"resetSelectionOfDraggedArea",value:function(){this.handleDraggedCells=0,this.hot.selection.highlight.getFill().clear();}},{key:"redrawBorders",value:function(e){this.hot.selection.highlight.getFill().clear().add(this.hot.getSelectedRangeLast().from).add(this.hot.getSelectedRangeLast().to).add(e),this.hot.view.render();}},{key:"getIfMouseWasDraggedOutside",value:function(e){var t=(0, p.offset)(this.hot.table).top-(window.pageYOffset||document.documentElement.scrollTop)+(0, p.outerHeight)(this.hot.table),n=(0, p.offset)(this.hot.table).left-(window.pageXOffset||document.documentElement.scrollLeft)+(0, p.outerWidth)(this.hot.table);return e.clientY>t&&n>=e.clientX}},{key:"registerEvents",value:function(){var e=this;this.eventManager.addEventListener(document.documentElement,"mouseup",function(){return e.onMouseUp()}),this.eventManager.addEventListener(document.documentElement,"mousemove",function(t){return e.onMouseMove(t)});}},{key:"onCellCornerDblClick",value:function(){this.selectAdjacent()&&this.fillIn();}},{key:"onAfterCellCornerMouseDown",value:function(){this.handleDraggedCells=1,this.mouseDownOnCellCorner=!0;}},{key:"onBeforeCellMouseOver",value:function(e){this.mouseDownOnCellCorner&&!this.hot.view.isMouseDown()&&this.handleDraggedCells&&(this.handleDraggedCells+=1,this.showBorder(e),this.addNewRowIfNeeded());}},{key:"onMouseUp",value:function(){this.handleDraggedCells&&(this.handleDraggedCells>1&&this.fillIn(),this.handleDraggedCells=0,this.mouseDownOnCellCorner=!1);}},{key:"onMouseMove",value:function(e){var t=this.getIfMouseWasDraggedOutside(e);!1===this.addingStarted&&this.handleDraggedCells>0&&t?(this.mouseDragOutside=!0,this.addingStarted=!0):this.mouseDragOutside=!1,this.mouseDragOutside&&this.autoInsertRow&&this.addRow();}},{key:"clearMappedSettings",value:function(){this.directions.length=0,this.autoInsertRow=!1;}},{key:"mapSettings",value:function(){var e=(0, w.getMappedFillHandleSetting)(this.hot.getSettings().fillHandle);this.directions=e.directions,this.autoInsertRow=e.autoInsertRow;}},{key:"destroy",value:function(){u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}}]),t}(h.default);(0, m.registerPlugin)("autofill",C),t.default=C;},function(e,t,n){function o(e,t,n,o){var r=n.length,i=n?n[0].length:0,a=[],s=t.row-e.row,l=t.col-e.col;if(-1!==["down","up"].indexOf(o)){for(var u=[],c=0;l>=c;c++){var h=parseInt(n[0][c],10),f=parseInt(n[r-1][c],10);u.push(("down"===o?f-h:h-f)/(r-1)||0);}a.push(u);}if(-1!==["right","left"].indexOf(o))for(var d=0;s>=d;d++){var p=parseInt(n[d][0],10),g=parseInt(n[d][i-1],10),v=("right"===o?g-p:p-g)/(i-1)||0;a.push([v]);}return a}function r(e,t){var n=void 0,o=void 0,r=void 0;return t[0]===e[0]&&e[1]>t[1]?(r="left",n=new l.CellCoords(t[0],t[1]),o=new l.CellCoords(t[2],e[1]-1)):t[2]===e[2]&&t[0]===e[0]&&t[3]>e[3]?(r="right",n=new l.CellCoords(t[0],e[3]+1),o=new l.CellCoords(t[2],t[3])):e[0]>t[0]&&t[1]===e[1]?(r="up",n=new l.CellCoords(t[0],t[1]),o=new l.CellCoords(e[0]-1,t[3])):t[2]>e[2]&&t[1]===e[1]&&(r="down",n=new l.CellCoords(e[2]+1,t[1]),o=new l.CellCoords(t[2],t[3])),{directionOfDrag:r,startOfDragCoords:n,endOfDragCoords:o}}function i(e){var t={};return !0===e?(t.directions=Object.keys(u),t.autoInsertRow=!0):(0, a.isObject)(e)?(t.autoInsertRow=!!(0, s.isDefined)(e.autoInsertRow)&&(e.direction!==u.horizontal&&e.autoInsertRow),t.directions=(0, s.isDefined)(e.direction)?[e.direction]:Object.keys(u)):"string"==typeof e?(t.directions=[e],t.autoInsertRow=!0):(t.directions=[],t.autoInsertRow=!1),t}t.__esModule=!0,t.DIRECTIONS=void 0,t.getDeltas=o,t.getDragDirectionAndRange=r,t.getMappedFillHandleSetting=i;var a=n(1),s=n(10),l=n(4),u=t.DIRECTIONS={horizontal:"horizontal",vertical:"vertical"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var s=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},u=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(11),h=o(c),f=n(2),d=n(41),p=n(0),g=n(94),v=o(g),m=n(1),y=n(5),w=n(8),C=n(447),b=o(C),_=n(36),S=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.heights=[],n.ghostTable=new v.default(n.hot),n.samplesGenerator=new b.default(function(e,t){var o=void 0;return 0>e?-1===e&&(o=n.hot.getColHeader(t)):o=n.hot.getDataAtCell(e,t),{value:o}}),n.firstCalculation=!0,n.inProgress=!1,n.addHook("beforeRowResize",function(e,t,o){return n.onBeforeRowResize(e,t,o)}),n}return a(t,e),u(t,null,[{key:"CALCULATION_STEP",get:function(){return 50}},{key:"SYNC_CALCULATION_LIMIT",get:function(){return 500}}]),u(t,[{key:"isEnabled",value:function(){return !0===this.hot.getSettings().autoRowSize||(0, m.isObject)(this.hot.getSettings().autoRowSize)}},{key:"enablePlugin",value:function(){var e=this;this.enabled||(this.setSamplingOptions(),this.addHook("afterLoadData",function(){return e.onAfterLoadData()}),this.addHook("beforeChange",function(t){return e.onBeforeChange(t)}),this.addHook("beforeColumnMove",function(){return e.recalculateAllRowsHeight()}),this.addHook("beforeColumnResize",function(){return e.recalculateAllRowsHeight()}),this.addHook("beforeColumnSort",function(){return e.clearCache()}),this.addHook("beforeRender",function(t){return e.onBeforeRender(t)}),this.addHook("beforeRowMove",function(t,n){return e.onBeforeRowMove(t,n)}),this.addHook("modifyRowHeight",function(t,n){return e.getRowHeight(n,t)}),this.addHook("modifyColumnHeaderHeight",function(){return e.getColumnHeaderHeight()}),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this));}},{key:"disablePlugin",value:function(){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"calculateRowsHeight",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{from:0,to:this.hot.countRows()-1},t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{from:0,to:this.hot.countCols()-1},o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r="number"==typeof e?{from:e,to:e}:e,i="number"==typeof n?{from:n,to:n}:n;if(null!==this.hot.getColHeader(0)){this.ghostTable.addColumnHeadersRow(this.samplesGenerator.generateRowSamples(-1,i).get(-1));}(0, y.rangeEach)(r.from,r.to,function(e){if(o||void 0===t.heights[e]){var n=t.samplesGenerator.generateRowSamples(e,i);(0, f.arrayEach)(n,function(e){var n=s(e,2);return t.ghostTable.addRow(n[0],n[1])});}}),this.ghostTable.rows.length&&(this.ghostTable.getHeights(function(e,n){t.heights[e]=n;}),this.ghostTable.clean());}},{key:"calculateAllRowsHeight",value:function(){var e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{from:0,to:this.hot.countCols()-1},o=0,r=this.hot.countRows()-1,i=null;this.inProgress=!0;var a=this.getSyncCalculationLimit();this.firstCalculation&&a>=0&&(this.calculateRowsHeight({from:0,to:a},n),this.firstCalculation=!1,o=a+1),r>o?function a(){if(!e.hot)return (0, d.cancelAnimationFrame)(i),void(e.inProgress=!1);e.calculateRowsHeight({from:o,to:Math.min(o+t.CALCULATION_STEP,r)},n),o=o+t.CALCULATION_STEP+1,r>o?i=(0, d.requestAnimationFrame)(a):((0, d.cancelAnimationFrame)(i),e.inProgress=!1,e.hot.view.wt.wtOverlays.adjustElementsSize(!0),e.hot.view.wt.wtOverlays.leftOverlay.needFullRender&&e.hot.view.wt.wtOverlays.leftOverlay.clone.draw());}():(this.inProgress=!1,this.hot.view.wt.wtOverlays.adjustElementsSize(!1));}},{key:"setSamplingOptions",value:function(){var e=this.hot.getSettings().autoRowSize,t=e&&(0, m.hasOwnProperty)(e,"samplingRatio")?this.hot.getSettings().autoRowSize.samplingRatio:void 0,n=e&&(0, m.hasOwnProperty)(e,"allowSampleDuplicates")?this.hot.getSettings().autoRowSize.allowSampleDuplicates:void 0;t&&!isNaN(t)&&this.samplesGenerator.setSampleCount(parseInt(t,10)),n&&this.samplesGenerator.setAllowDuplicates(n);}},{key:"recalculateAllRowsHeight",value:function(){(0, p.isVisible)(this.hot.view.wt.wtTable.TABLE)&&(this.clearCache(),this.calculateAllRowsHeight());}},{key:"getSyncCalculationLimit",value:function(){var e=t.SYNC_CALCULATION_LIMIT,n=this.hot.countRows()-1;return (0, m.isObject)(this.hot.getSettings().autoRowSize)&&(e=this.hot.getSettings().autoRowSize.syncLimit,(0, _.isPercentValue)(e)?e=(0, y.valueAccordingPercent)(n,e):e>>=0),Math.min(e,n)}},{key:"getRowHeight",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=t;return void 0!==this.heights[e]&&this.heights[e]>(t||0)&&(n=this.heights[e]),n}},{key:"getColumnHeaderHeight",value:function(){return this.heights[-1]}},{key:"getFirstVisibleRow",value:function(){var e=this.hot.view.wt;return e.wtViewport.rowsVisibleCalculator?e.wtTable.getFirstVisibleRow():e.wtViewport.rowsRenderCalculator?e.wtTable.getFirstRenderedRow():-1}},{key:"getLastVisibleRow",value:function(){var e=this.hot.view.wt;return e.wtViewport.rowsVisibleCalculator?e.wtTable.getLastVisibleRow():e.wtViewport.rowsRenderCalculator?e.wtTable.getLastRenderedRow():-1}},{key:"clearCache",value:function(){this.heights.length=0,this.heights[-1]=void 0;}},{key:"clearCacheByRange",value:function(e){var t=this,n="number"==typeof e?{from:e,to:e}:e,o=n.from,r=n.to;(0, y.rangeEach)(Math.min(o,r),Math.max(o,r),function(e){t.heights[e]=void 0;});}},{key:"isNeedRecalculate",value:function(){return !!(0, f.arrayFilter)(this.heights,function(e){return void 0===e}).length}},{key:"onBeforeRender",value:function(){var e=this.hot.renderCall,t=this.hot.getSettings().fixedRowsBottom;if(this.calculateRowsHeight({from:this.getFirstVisibleRow(),to:this.getLastVisibleRow()},void 0,e),t){var n=this.hot.countRows()-1;this.calculateRowsHeight({from:n-t,to:n});}this.isNeedRecalculate()&&!this.inProgress&&this.calculateAllRowsHeight();}},{key:"onBeforeRowMove",value:function(e,t){this.clearCacheByRange({from:e,to:t}),this.calculateAllRowsHeight();}},{key:"onBeforeRowResize",value:function(e,t,n){var o=t;return n&&(this.calculateRowsHeight(e,void 0,!0),o=this.getRowHeight(e)),o}},{key:"onAfterLoadData",value:function(){var e=this;this.hot.view?this.recalculateAllRowsHeight():setTimeout(function(){e.hot&&e.recalculateAllRowsHeight();},0);}},{key:"onBeforeChange",value:function(e){var t=null;1===e.length?t=e[0][0]:e.length>1&&(t={from:e[0][0],to:e[e.length-1][0]}),null!==t&&this.clearCacheByRange(t);}},{key:"destroy",value:function(){this.ghostTable.clean(),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}}]),t}(h.default);(0, w.registerPlugin)("autoRowSize",S),t.default=S;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);e.length>t;t++)n[t]=e[t];return n}return Array.from(e)}function i(e,t){var n={};for(var o in e)0>t.indexOf(o)&&Object.prototype.hasOwnProperty.call(e,o)&&(n[o]=e[o]);return n}function a(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function s(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var u=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},h=n(0),f=n(10),d=n(1),p=n(2),g=n(5),v=n(11),m=o(v),y=n(8),w=n(16),C=o(w),b=n(93),_=n(542),S=n(448),E=n(543),O=n(544),T=o(O),k=n(545),R=n(60),M="columnSorting";(0, R.registerRootComparator)(M,k.rootComparator),C.default.getSingleton().register("beforeColumnSort"),C.default.getSingleton().register("afterColumnSort");var D=function(e){function t(e){a(this,t);var n=s(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.columnStatesManager=new _.ColumnStatesManager,n.rowsMapper=new T.default(n),n.blockPluginTranslation=!0,n.columnMetaCache=new Map,n.pluginKey=M,n}return l(t,e),u(t,[{key:"isEnabled",value:function(){return !!this.hot.getSettings()[this.pluginKey]}},{key:"enablePlugin",value:function(){var e=this;this.enabled||((0, f.isUndefined)(this.hot.getSettings().observeChanges)&&this.enableObserveChangesPlugin(),this.addHook("afterTrimRow",function(){return e.sortByPresetSortStates()}),this.addHook("afterUntrimRow",function(){return e.sortByPresetSortStates()}),this.addHook("modifyRow",function(t,n){return e.onModifyRow(t,n)}),this.addHook("unmodifyRow",function(t,n){return e.onUnmodifyRow(t,n)}),this.addHook("afterGetColHeader",function(t,n){return e.onAfterGetColHeader(t,n)}),this.addHook("beforeOnCellMouseDown",function(t,n,o,r){return e.onBeforeOnCellMouseDown(t,n,o,r)}),this.addHook("afterOnCellMouseDown",function(t,n){return e.onAfterOnCellMouseDown(t,n)}),this.addHook("afterCreateRow",function(t,n){return e.onAfterCreateRow(t,n)}),this.addHook("afterRemoveRow",function(t,n){return e.onAfterRemoveRow(t,n)}),this.addHook("afterInit",function(){return e.loadOrSortBySettings()}),this.addHook("afterLoadData",function(t){return e.onAfterLoadData(t)}),this.addHook("afterCreateCol",function(){return e.onAfterCreateCol()}),this.addHook("afterRemoveCol",function(){return e.onAfterRemoveCol()}),this.hot.view&&this.loadOrSortBySettings(),c(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this));}},{key:"disablePlugin",value:function(){var e=this,n=function(t,n){var o=(0, S.getHeaderSpanElement)(n);!1!==(0, S.isFirstLevelColumnHeader)(t,n)&&null!==o&&e.updateHeaderClasses(o);};this.hot.addHook("afterGetColHeader",n),this.hot.addHookOnce("afterRender",function(){e.hot.removeHook("afterGetColHeader",n);}),this.rowsMapper.clearMap(),c(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"sort",value:function(e){var t=this,n=this.getSortConfig(),o=this.getNormalizedSortConfigs(e),r=this.areValidSortConfigs(o);if(!1!==this.hot.runHooks("beforeColumnSort",n,o,r)){if(r){var a=function(e){var n=e.column,o=i(e,["column"]);return Object.assign({column:t.hot.toPhysicalColumn(n)},o)};this.columnStatesManager.setSortStates((0, p.arrayMap)(o,function(e){return a(e)})),this.sortByPresetSortStates(),this.saveAllSortSettings(),this.hot.render(),this.hot.view.wt.draw(!0);}this.hot.runHooks("afterColumnSort",n,this.getSortConfig(),r);}}},{key:"clearSort",value:function(){this.sort([]);}},{key:"isSorted",value:function(){return this.enabled&&!this.columnStatesManager.isListOfSortedColumnsEmpty()}},{key:"getSortConfig",value:function(e){var t=this,n=function(e){var n=e.column,o=i(e,["column"]);return Object.assign({column:t.hot.toVisualColumn(n)},o)};if(!(0, f.isDefined)(e)){var o=this.columnStatesManager.getSortStates();return (0, p.arrayMap)(o,function(e){return n(e)})}var r=this.hot.toPhysicalColumn(e),a=this.columnStatesManager.getColumnSortState(r);if((0, f.isDefined)(a))return n(a)}},{key:"setSortConfig",value:function(e){var t=this,n=this.getNormalizedSortConfigs(e);if(this.areValidSortConfigs(n)){var o=function(e){var n=e.column,o=i(e,["column"]);return Object.assign({column:t.hot.toPhysicalColumn(n)},o)};this.columnStatesManager.setSortStates((0, p.arrayMap)(n,function(e){return o(e)}));}}},{key:"getNormalizedSortConfigs",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return Array.isArray(e)?e.slice(0,1):[e].slice(0,1)}},{key:"areValidSortConfigs",value:function(e){if(!1===Array.isArray(e))return !1;var t=e.map(function(e){return e.column}),n=this.hot.countCols(),o=t.every(function(e){return n>=e&&e>=0});return (0, S.areValidSortStates)(e)&&o}},{key:"saveAllSortSettings",value:function(){var e=this.columnStatesManager.getAllColumnsProperties();e.initialConfig=this.columnStatesManager.getSortStates(),this.hot.runHooks("persistentStateSave","columnSorting",e);}},{key:"getAllSavedSortSettings",value:function(){var e=this,t={};this.hot.runHooks("persistentStateLoad","columnSorting",t);var n=t.value,o=function(t){var n=t.column,o=i(t,["column"]);return Object.assign({column:e.hot.toVisualColumn(n)},o)};return (0, f.isDefined)(n)&&Array.isArray(n.initialConfig)&&(n.initialConfig=(0, p.arrayMap)(n.initialConfig,o)),n}},{key:"getColumnNextConfig",value:function(e){if(this.columnStatesManager.isColumnSorted(this.hot.toPhysicalColumn(e))){var t=this.getSortConfig(e),n=(0, S.getNextSortOrder)(t.sortOrder);if((0, f.isDefined)(n))return t.sortOrder=n,t}else{var o=this.hot.countCols();if(Number.isInteger(e)&&e>=0&&o>e)return {column:e,sortOrder:(0, S.getNextSortOrder)()}}}},{key:"getNextSortConfig",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"append",n=this.hot.toPhysicalColumn(e),o=this.columnStatesManager.getIndexOfColumnInSortQueue(n),i=this.columnStatesManager.isColumnSorted(n),a=this.getSortConfig(),s=this.getColumnNextConfig(e);if(i){if((0, f.isUndefined)(s))return [].concat(r(a.slice(0,o)),r(a.slice(o+1)));if("append"===t)return [].concat(r(a.slice(0,o)),r(a.slice(o+1)),[s]);if("replace"===t)return [].concat(r(a.slice(0,o)),[s],r(a.slice(o+1)))}return (0, f.isDefined)(s)?a.concat(s):a}},{key:"setMergedPluginSettings",value:function(e){var t=this.hot.toPhysicalColumn(e),n=this.hot.getSettings()[this.pluginKey],o=this.columnStatesManager.getAllColumnsProperties(),r=this.hot.getCellMeta(0,e),i=Object.getPrototypeOf(r),a=Object.hasOwnProperty.call(i,this.pluginKey),s=a?i[this.pluginKey]:{};this.columnMetaCache.set(t,Object.assign(o,n,s));}},{key:"getFirstCellSettings",value:function(e){var t=this,n=this.blockPluginTranslation;if(this.blockPluginTranslation=!0,0===this.columnMetaCache.size){var o=this.hot.countCols();(0, g.rangeEach)(o,function(e){return t.setMergedPluginSettings(e)});}var r=this.hot.getCellMeta(0,e);this.blockPluginTranslation=n;var i=Object.create(r);return i[this.pluginKey]=this.columnMetaCache.get(this.hot.toPhysicalColumn(e)),i}},{key:"getNumberOfRowsToSort",value:function(e){var t=this.hot.getSettings();return t.maxRows>e?e-t.minSpareRows:t.maxRows}},{key:"sortByPresetSortStates",value:function(){var e=this;if(this.columnStatesManager.isListOfSortedColumnsEmpty())return void this.rowsMapper.clearMap();var t=[],n=this.columnStatesManager.getSortedColumns(),o=this.hot.countRows();this.blockPluginTranslation=!0;for(var r=function(t){return (0, p.arrayMap)(n,function(n){return e.hot.getDataAtCell(t,e.hot.toVisualColumn(n))})},i=0;i<this.getNumberOfRowsToSort(o);i+=1)t.push([i].concat(r(i)));(0, R.sort)(t,this.pluginKey,(0, p.arrayMap)(n,function(t){return e.columnStatesManager.getSortOrderOfColumn(t)}),(0, p.arrayMap)(n,function(t){return e.getFirstCellSettings(e.hot.toVisualColumn(t))}));for(var a=t.length;o>a;a+=1)t.push([a].concat(r(a)));this.blockPluginTranslation=!1,this.rowsMapper._arrayMap=(0, p.arrayMap)(t,function(e){return e[0]});}},{key:"loadOrSortBySettings",value:function(){this.columnMetaCache.clear();var e=this.getAllSavedSortSettings();if((0, d.isObject)(e))this.sortBySettings(e);else{this.sortBySettings(this.hot.getSettings()[this.pluginKey]);}}},{key:"sortBySettings",value:function(e){if((0, d.isObject)(e)){this.columnStatesManager.updateAllColumnsProperties(e);var t=e.initialConfig;(Array.isArray(t)||(0, d.isObject)(t))&&this.sort(t);}else this.hot.render();}},{key:"enableObserveChangesPlugin",value:function(){var e=this;this.hot._registerTimeout(setTimeout(function(){e.hot.updateSettings({observeChanges:!0});},0));}},{key:"onModifyRow",value:function(e,t){if(!1===this.blockPluginTranslation&&t!==this.pluginName&&this.isSorted()){var n=this.rowsMapper.getValueByIndex(e);e=null===n?e:n;}return e}},{key:"onUnmodifyRow",value:function(e,t){return !1===this.blockPluginTranslation&&t!==this.pluginName&&this.isSorted()&&(e=this.rowsMapper.getIndexByValue(e)),e}},{key:"onAfterGetColHeader",value:function(e,t){var n=(0, S.getHeaderSpanElement)(t);if(!1!==(0, S.isFirstLevelColumnHeader)(e,t)&&null!==n){var o=this.hot.toPhysicalColumn(e),r=this.getFirstCellSettings(e)[this.pluginKey];this.updateHeaderClasses(n,this.columnStatesManager,o,r.indicator,r.headerAction);}}},{key:"updateHeaderClasses",value:function(e){if((0, h.removeClass)(e,(0, E.getClassedToRemove)(e)),!1!==this.enabled){for(var t=arguments.length,n=Array(t>1?t-1:0),o=1;t>o;o++)n[o-1]=arguments[o];(0, h.addClass)(e,E.getClassesToAdd.apply(void 0,n));}}},{key:"onUpdateSettings",value:function(e){c(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"onUpdateSettings",this).call(this),this.columnMetaCache.clear(),(0, f.isDefined)(e[this.pluginKey])&&this.sortBySettings(e[this.pluginKey]);}},{key:"onAfterLoadData",value:function(e){this.rowsMapper.clearMap(),!0===e&&this.hot.view&&this.loadOrSortBySettings();}},{key:"onAfterCreateRow",value:function(e,t){this.rowsMapper.shiftItems(e,t);}},{key:"onAfterRemoveRow",value:function(e,t){this.rowsMapper.unshiftItems(e,t);}},{key:"onAfterCreateCol",value:function(){this.columnMetaCache.clear();}},{key:"onAfterRemoveCol",value:function(){this.columnMetaCache.clear();}},{key:"wasClickableHeaderClicked",value:function(e,t){return this.getFirstCellSettings(t)[this.pluginKey].headerAction&&"SPAN"===e.realTarget.nodeName}},{key:"onBeforeOnCellMouseDown",value:function(e,t,n,o){!1!==(0, S.wasHeaderClickedProperly)(t.row,t.col,e)&&this.wasClickableHeaderClicked(e,t.col)&&(0, b.isPressedCtrlKey)()&&(o.column=!0);}},{key:"onAfterOnCellMouseDown",value:function(e,t){!1!==(0, S.wasHeaderClickedProperly)(t.row,t.col,e)&&this.wasClickableHeaderClicked(e,t.col)&&((0, b.isPressedCtrlKey)()&&(this.hot.deselectCell(),this.hot.selectColumns(t.col)),this.sort(this.getColumnNextConfig(t.col)));}},{key:"destroy",value:function(){this.rowsMapper.destroy(),this.columnStatesManager.destroy(),c(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}}]),t}(m.default);(0, y.registerPlugin)(M,D),t.default=D;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0,t.ColumnStatesManager=void 0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(1),a=n(2),s=["sortEmptyCells","indicator","headerAction","compareFunctionFactory"],l=!1,u=!0,c=!0;t.ColumnStatesManager=function(){function e(){o(this,e),this.sortedColumnsStates=[],this.sortEmptyCells=l,this.indicator=u,this.headerAction=c,this.compareFunctionFactory=void 0;}return r(e,[{key:"updateAllColumnsProperties",value:function(e){var t=this;(0, i.isObject)(e)&&(0, i.objectEach)(e,function(e,n){s.includes(n)&&(t[n]=e);});}},{key:"getAllColumnsProperties",value:function(){var e={sortEmptyCells:this.sortEmptyCells,indicator:this.indicator,headerAction:this.headerAction};return "function"==typeof this.compareFunctionFactory&&(e.compareFunctionFactory=this.compareFunctionFactory),e}},{key:"getFirstSortedColumn",value:function(){var e=void 0;return this.getNumberOfSortedColumns()>0&&(e=this.sortedColumnsStates[0].column),e}},{key:"getSortOrderOfColumn",value:function(e){var t=this.sortedColumnsStates.find(function(t){return e===t.column}),n=void 0;return (0, i.isObject)(t)&&(n=t.sortOrder),n}},{key:"getSortedColumns",value:function(){return (0, a.arrayMap)(this.sortedColumnsStates,function(e){return e.column})}},{key:"getIndexOfColumnInSortQueue",value:function(e){return this.getSortedColumns().indexOf(e)}},{key:"getNumberOfSortedColumns",value:function(){return this.sortedColumnsStates.length}},{key:"isListOfSortedColumnsEmpty",value:function(){return 0===this.getNumberOfSortedColumns()}},{key:"isColumnSorted",value:function(e){return this.getSortedColumns().includes(e)}},{key:"getSortStates",value:function(){return (0, i.deepClone)(this.sortedColumnsStates)}},{key:"getColumnSortState",value:function(e){if(this.isColumnSorted(e))return (0, i.deepClone)(this.sortedColumnsStates[this.getIndexOfColumnInSortQueue(e)])}},{key:"setSortStates",value:function(e){this.sortedColumnsStates=e;}},{key:"destroy",value:function(){this.sortedColumnsStates.length=0,this.sortedColumnsStates=null;}}]),e}();},function(e,t,n){function o(e,t,n,o){var r=[s];if(o&&r.push(l),!1===n)r.push(a);else if(e.isColumnSorted(t)){var i=e.getSortOrderOfColumn(t);r.push(u.get(i));}return r}function r(){return Array.from(u.values()).concat(l,a,s)}t.__esModule=!0,t.getClassesToAdd=o,t.getClassedToRemove=r;var i=n(448),a="indicatorDisabled",s="columnSorting",l="sortAction",u=new Map([[i.ASC_SORT_STATE,"ascending"],[i.DESC_SORT_STATE,"descending"]]);},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(95),a=function(e){return e&&e.__esModule?e:{default:e}}(i),s=n(1),l=n(5),u=function(){function e(){o(this,e);}return r(e,[{key:"createMap",value:function(e){var t=this,n=void 0===e?this._arrayMap.length:e;this._arrayMap.length=0,(0, l.rangeEach)(n-1,function(e){t._arrayMap[e]=e;});}},{key:"destroy",value:function(){this._arrayMap=null;}}]),e}();(0, s.mixin)(u,a.default),t.default=u;},function(e,t,n){function o(e){return Array.isArray(e)?e:Array.from(e)}function r(e,t){return function(n,r){var a=o(n),s=a.slice(1),l=o(r),u=l.slice(1);return function(n){var o=e[n],r=t[n],a=s[n],l=u[n],c=r.columnSorting;return (c.compareFunctionFactory?c.compareFunctionFactory:(0, i.getCompareFunctionFactory)(r.type))(o,r,c)(a,l)}(0)}}t.__esModule=!0,t.rootComparator=r;var i=n(60);},function(e,t,n){function o(e,t,n){return function(t,o){var a=n.sortEmptyCells;return "string"==typeof t&&(t=t.toLowerCase()),"string"==typeof o&&(o=o.toLowerCase()),t===o?i.DO_NOT_SWAP:(0, r.isEmpty)(t)?(0, r.isEmpty)(o)?i.DO_NOT_SWAP:a&&"asc"===e?i.FIRST_BEFORE_SECOND:i.FIRST_AFTER_SECOND:(0, r.isEmpty)(o)?a&&"asc"===e?i.FIRST_AFTER_SECOND:i.FIRST_BEFORE_SECOND:isNaN(t)&&!isNaN(o)?"asc"===e?i.FIRST_AFTER_SECOND:i.FIRST_BEFORE_SECOND:!isNaN(t)&&isNaN(o)?"asc"===e?i.FIRST_BEFORE_SECOND:i.FIRST_AFTER_SECOND:(isNaN(t)||isNaN(o)||(t=parseFloat(t),o=parseFloat(o)),o>t?"asc"===e?i.FIRST_BEFORE_SECOND:i.FIRST_AFTER_SECOND:t>o?"asc"===e?i.FIRST_AFTER_SECOND:i.FIRST_BEFORE_SECOND:i.DO_NOT_SWAP)}}t.__esModule=!0,t.COLUMN_DATA_TYPE=void 0,t.compareFunctionFactory=o;var r=n(10),i=n(60);t.COLUMN_DATA_TYPE="default";},function(e,t,n){function o(e,t,n){return function(t,o){var a=parseFloat(t),s=parseFloat(o),l=n.sortEmptyCells;if(a===s||isNaN(a)&&isNaN(s))return i.DO_NOT_SWAP;if(l){if((0, r.isEmpty)(t))return "asc"===e?i.FIRST_BEFORE_SECOND:i.FIRST_AFTER_SECOND;if((0, r.isEmpty)(o))return "asc"===e?i.FIRST_AFTER_SECOND:i.FIRST_BEFORE_SECOND}return isNaN(a)?i.FIRST_AFTER_SECOND:isNaN(s)?i.FIRST_BEFORE_SECOND:s>a?"asc"===e?i.FIRST_BEFORE_SECOND:i.FIRST_AFTER_SECOND:a>s?"asc"===e?i.FIRST_AFTER_SECOND:i.FIRST_BEFORE_SECOND:i.DO_NOT_SWAP}}t.__esModule=!0,t.COLUMN_DATA_TYPE=void 0,t.compareFunctionFactory=o;var r=n(10),i=n(60);t.COLUMN_DATA_TYPE="numeric";},function(e,t,n){function o(e,t,n){return function(o,r){var l=n.sortEmptyCells;if(o===r)return s.DO_NOT_SWAP;if((0, a.isEmpty)(o))return (0, a.isEmpty)(r)?s.DO_NOT_SWAP:l&&"asc"===e?s.FIRST_BEFORE_SECOND:s.FIRST_AFTER_SECOND;if((0, a.isEmpty)(r))return l&&"asc"===e?s.FIRST_AFTER_SECOND:s.FIRST_BEFORE_SECOND;var u=t.dateFormat,c=(0, i.default)(o,u),h=(0, i.default)(r,u);return c.isValid()?h.isValid()?h.isAfter(c)?"asc"===e?s.FIRST_BEFORE_SECOND:s.FIRST_AFTER_SECOND:h.isBefore(c)?"asc"===e?s.FIRST_AFTER_SECOND:s.FIRST_BEFORE_SECOND:s.DO_NOT_SWAP:s.FIRST_BEFORE_SECOND:s.FIRST_AFTER_SECOND}}t.__esModule=!0,t.COLUMN_DATA_TYPE=void 0,t.compareFunctionFactory=o;var r=n(47),i=function(e){return e&&e.__esModule?e:{default:e}}(r),a=n(10),s=n(60);t.COLUMN_DATA_TYPE="date";},function(e,t,n){function o(e,t){for(var n=(0, a.getRootComparator)(t),o=arguments.length,r=Array(o>2?o-2:0),s=2;o>s;s++)r[s-2]=arguments[s];(0, i.default)(e,n.apply(void 0,r));}t.__esModule=!0,t.FIRST_AFTER_SECOND=t.FIRST_BEFORE_SECOND=t.DO_NOT_SWAP=void 0,t.sort=o;var r=n(550),i=function(e){return e&&e.__esModule?e:{default:e}}(r),a=n(449);t.DO_NOT_SWAP=0,t.FIRST_BEFORE_SECOND=-1,t.FIRST_AFTER_SECOND=1;},function(e,t,n){function o(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:s,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length;if(1>=Math.abs(i-n))return [];var a=Math.ceil((n+i)/2);return o(e,t,n,a),o(e,t,a,i),r(e,t,n,a,i)}function r(e,t,n,o,r){for(var i=new a.default,s=new a.default,l=o-n,u=r-o,c=Math.max(l,u),h=r-n,f=0;c>f;f+=1)l>f&&i.push(e[n+f]),u>f&&s.push(e[o+f]);for(var d=0;h>d;)e[n+d]=i.first&&s.first?t(i.first.data,s.first.data)>0?s.shift().data:i.shift().data:i.first?i.shift().data:s.shift().data,d+=1;return e}t.__esModule=!0,t.default=o;var i=n(551),a=function(e){return e&&e.__esModule?e:{default:e}}(i),s=function(e,t){var n=""+e,o=""+t;return n===o?0:o>n?-1:1};},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=function e(t){o(this,e),this.data=t,this.next=null,this.prev=null;},a=function(){function e(){o(this,e),this.first=null,this.last=null;}return r(e,[{key:"push",value:function(e){var t=new i(e);if(null===this.first)this.first=t,this.last=t;else{var n=this.last;this.last=t,t.prev=n,n.next=t;}}},{key:"unshift",value:function(e){var t=new i(e);if(null===this.first)this.first=t,this.last=t;else{var n=this.first;this.first=t,t.next=n,n.prev=t;}}},{key:"inorder",value:function(e){for(var t=this.first;t;)e(t),t=t.next;}},{key:"remove",value:function(e){if(null===this.first)return !1;for(var t=this.first,n=void 0,o=void 0;t;){if(t.data===e)return n=t.next,o=t.prev,n&&(n.prev=o),o&&(o.next=n),t===this.first&&(this.first=n),t===this.last&&(this.last=o),!0;t=t.next;}return !1}},{key:"hasCycle",value:function(){for(var e=this.first,t=this.first;;){if(null===e)return !1;if(null===(e=e.next))return !1;if(e=e.next,t=t.next,e===t)return !0}}},{key:"pop",value:function(){if(null===this.last)return null;var e=this.last;return this.last=this.last.prev,e}},{key:"shift",value:function(){if(null===this.first)return null;var e=this.first;return this.first=this.first.next,e}},{key:"recursiveReverse",value:function(){function e(t,n){n&&(e(n,n.next),n.next=t);}if(this.first){e(this.first,this.first.next),this.first.next=null;var t=this.first;this.first=this.last,this.last=t;}}},{key:"reverse",value:function(){if(this.first&&this.first.next){for(var e=this.first.next,t=this.first,n=void 0;e;)n=e.next,e.next=t,t.prev=e,t=e,e=n;this.first.next=null,this.last.prev=null,n=this.first,this.first=t,this.last=n;}}}]),e}();t.NodeStructure=i,t.default=a;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function a(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var l=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),u=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},c=n(0),h=n(1),f=n(6),d=o(f),p=n(4),g=n(8),v=n(11),m=o(v),y=n(553),w=o(y),C=n(19),b=n(554),_=o(b),S=n(7),E=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(S);n(555);var O=new WeakMap,T=function(e){function t(e){i(this,t);var n=a(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.editor=null,n.displaySwitch=null,n.eventManager=null,n.range={},n.mouseDown=!1,n.contextMenuEvent=!1,n.timer=null,O.set(n,{tempEditorDimensions:{},cellBelowCursor:null}),n}return s(t,e),l(t,[{key:"isEnabled",value:function(){return !!this.hot.getSettings().comments}},{key:"enablePlugin",value:function(){var e=this;this.enabled||(this.editor||(this.editor=new w.default),this.eventManager||(this.eventManager=new d.default(this)),this.displaySwitch||(this.displaySwitch=new _.default(this.getDisplayDelaySetting())),this.addHook("afterContextMenuDefaultOptions",function(t){return e.addToContextMenu(t)}),this.addHook("afterRenderer",function(t,n,o,r,i,a){return e.onAfterRenderer(t,a)}),this.addHook("afterScrollHorizontally",function(){return e.hide()}),this.addHook("afterScrollVertically",function(){return e.hide()}),this.addHook("afterBeginEditing",function(){return e.onAfterBeginEditing()}),this.displaySwitch.addLocalHook("hide",function(){return e.hide()}),this.displaySwitch.addLocalHook("show",function(t,n){return e.showAtCell(t,n)}),this.registerListeners(),u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this));}},{key:"updatePlugin",value:function(){this.disablePlugin(),this.enablePlugin(),u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updatePlugin",this).call(this),this.displaySwitch.updateDelay(this.getDisplayDelaySetting());}},{key:"disablePlugin",value:function(){u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"registerListeners",value:function(){var e=this;this.eventManager.addEventListener(document,"mouseover",function(t){return e.onMouseOver(t)}),this.eventManager.addEventListener(document,"mousedown",function(t){return e.onMouseDown(t)}),this.eventManager.addEventListener(document,"mouseup",function(){return e.onMouseUp()}),this.eventManager.addEventListener(this.editor.getInputElement(),"blur",function(){return e.onEditorBlur()}),this.eventManager.addEventListener(this.editor.getInputElement(),"mousedown",function(t){return e.onEditorMouseDown(t)}),this.eventManager.addEventListener(this.editor.getInputElement(),"mouseup",function(t){return e.onEditorMouseUp(t)});}},{key:"setRange",value:function(e){this.range=e;}},{key:"clearRange",value:function(){this.range={};}},{key:"targetIsCellWithComment",value:function(e){var t=(0, c.closest)(e.target,"TD","TBODY");return !!(t&&(0, c.hasClass)(t,"htCommentCell")&&(0, c.closest)(t,[this.hot.rootElement]))}},{key:"targetIsCommentTextArea",value:function(e){return this.editor.getInputElement()===e.target}},{key:"setComment",value:function(e){if(!this.range.from)throw Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');var t=this.editor.getValue(),n="";null!==e&&void 0!==e?n=e:null!==t&&void 0!==t&&(n=t),this.updateCommentMeta(this.range.from.row,this.range.from.col,r({},"value",n)),this.hot.render();}},{key:"setCommentAtCell",value:function(e,t,n){this.setRange({from:new p.CellCoords(e,t)}),this.setComment(n);}},{key:"removeComment",value:function(){var e=0>=arguments.length||void 0===arguments[0]||arguments[0];if(!this.range.from)throw Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');this.hot.setCellMeta(this.range.from.row,this.range.from.col,"comment",void 0),e&&this.hot.render(),this.hide();}},{key:"removeCommentAtCell",value:function(e,t){var n=2>=arguments.length||void 0===arguments[2]||arguments[2];this.setRange({from:new p.CellCoords(e,t)}),this.removeComment(n);}},{key:"getComment",value:function(){return this.getCommentMeta(this.range.from.row,this.range.from.col,"value")}},{key:"getCommentAtCell",value:function(e,t){return this.getCommentMeta(e,t,"value")}},{key:"show",value:function(){if(!this.range.from)throw Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');var e=this.hot.getCellMeta(this.range.from.row,this.range.from.col);return this.refreshEditor(!0),this.editor.setValue(e.comment?e.comment.value:""),this.editor.hidden&&this.editor.show(),!0}},{key:"showAtCell",value:function(e,t){return this.setRange({from:new p.CellCoords(e,t)}),this.show()}},{key:"hide",value:function(){this.editor.hidden||this.editor.hide();}},{key:"refreshEditor",value:function(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0]||this.range.from&&this.editor.isVisible()){var e=(0, c.getScrollableElement)(this.hot.view.wt.wtTable.TABLE),t=this.hot.view.wt.wtTable.getCell(this.range.from),n=this.range.from.row,o=this.range.from.col,r=(0, c.offset)(t),i=this.hot.view.wt.wtTable.getStretchedColumnWidth(o),a=0>r.top?0:r.top,s=r.left;this.hot.view.wt.wtViewport.hasVerticalScroll()&&e!==window&&(a-=this.hot.view.wt.wtOverlays.topOverlay.getScrollPosition()),this.hot.view.wt.wtViewport.hasHorizontalScroll()&&e!==window&&(s-=this.hot.view.wt.wtOverlays.leftOverlay.getScrollPosition());var l=s+i,u=a,h=this.getCommentMeta(n,o,"style"),f=this.getCommentMeta(n,o,"readOnly");h?this.editor.setSize(h.width,h.height):this.editor.resetSize(),this.editor.setReadOnlyState(f),this.editor.setPosition(l,u);}}},{key:"checkSelectionCommentsConsistency",value:function(){var e=this.hot.getSelectedRangeLast();if(!e)return !1;var t=!1,n=e.from;return this.getCommentMeta(n.row,n.col,"value")&&(t=!0),t}},{key:"updateCommentMeta",value:function(e,t,n){var o=this.hot.getCellMeta(e,t).comment,r=void 0;o?(r=(0, h.deepClone)(o),(0, h.deepExtend)(r,n)):r=n,this.hot.setCellMeta(e,t,"comment",r);}},{key:"getCommentMeta",value:function(e,t,n){var o=this.hot.getCellMeta(e,t);if(o.comment)return o.comment[n]}},{key:"onMouseDown",value:function(e){if(this.mouseDown=!0,this.hot.view&&this.hot.view.wt){if(!this.contextMenuEvent&&!this.targetIsCommentTextArea(e)){var t=(0, c.closest)(e.target,"TD","TBODY"),n=null;t&&(n=this.hot.view.wt.wtTable.getCoords(t)),(!t||this.range.from&&n&&(this.range.from.row!==n.row||this.range.from.col!==n.col))&&this.hide();}this.contextMenuEvent=!1;}}},{key:"onMouseOver",value:function(e){var t=O.get(this);if(t.cellBelowCursor=document.elementFromPoint(e.clientX,e.clientY),!(this.mouseDown||this.editor.isFocused()||(0, c.hasClass)(e.target,"wtBorder")||t.cellBelowCursor!==e.target)&&this.editor)if(this.targetIsCellWithComment(e)){var n=this.hot.view.wt.wtTable.getCoords(e.target),o={from:new p.CellCoords(n.row,n.col)};this.displaySwitch.show(o);}else(0, c.isChildOf)(e.target,document)&&!this.targetIsCommentTextArea(e)&&this.displaySwitch.hide();}},{key:"onMouseUp",value:function(){this.mouseDown=!1;}},{key:"onAfterRenderer",value:function(e,t){t.comment&&t.comment.value&&(0, c.addClass)(e,t.commentedCellClassName);}},{key:"onEditorBlur",value:function(){this.setComment();}},{key:"onEditorMouseDown",value:function(e){O.get(this).tempEditorDimensions={width:(0, c.outerWidth)(e.target),height:(0, c.outerHeight)(e.target)};}},{key:"onEditorMouseUp",value:function(e){var t=O.get(this),n=(0, c.outerWidth)(e.target),o=(0, c.outerHeight)(e.target);n===t.tempEditorDimensions.width+1&&o===t.tempEditorDimensions.height+2||this.updateCommentMeta(this.range.from.row,this.range.from.col,r({},"style",{width:n,height:o}));}},{key:"onContextMenuAddComment",value:function(){var e=this;this.displaySwitch.cancelHiding();var t=this.hot.getSelectedRangeLast();this.contextMenuEvent=!0,this.setRange({from:t.from}),this.show(),setTimeout(function(){e.hot&&(e.hot.deselectCell(),e.editor.focus());},10);}},{key:"onContextMenuRemoveComment",value:function(){var e=this.hot.getSelectedRangeLast(),t=e.from,n=e.to;this.contextMenuEvent=!0;for(var o=t.row;n.row>=o;o++)for(var r=t.col;n.col>=r;r++)this.removeCommentAtCell(o,r,!1);this.hot.render();}},{key:"onContextMenuMakeReadOnly",value:function(){var e=this.hot.getSelectedRangeLast(),t=e.from,n=e.to;this.contextMenuEvent=!0;for(var o=t.row;n.row>=o;o++)for(var i=t.col;n.col>=i;i++){var a=!!this.getCommentMeta(o,i,"readOnly");this.updateCommentMeta(o,i,r({},"readOnly",!a));}}},{key:"addToContextMenu",value:function(e){var t=this;e.items.push({name:"---------"},{key:"commentsAddEdit",name:function(){return t.hot.getTranslatedPhrase(t.checkSelectionCommentsConsistency()?E.CONTEXTMENU_ITEMS_EDIT_COMMENT:E.CONTEXTMENU_ITEMS_ADD_COMMENT)},callback:function(){return t.onContextMenuAddComment()},disabled:function(){return !(this.getSelectedLast()&&!this.selection.isSelectedByCorner())}},{key:"commentsRemove",name:function(){return this.getTranslatedPhrase(E.CONTEXTMENU_ITEMS_REMOVE_COMMENT)},callback:function(){return t.onContextMenuRemoveComment()},disabled:function(){return t.hot.selection.isSelectedByCorner()}},{key:"commentsReadOnly",name:function(){var e=this,t=this.getTranslatedPhrase(E.CONTEXTMENU_ITEMS_READ_ONLY_COMMENT);return (0, C.checkSelectionConsistency)(this.getSelectedRangeLast(),function(t,n){var o=e.getCellMeta(t,n).comment;if(o&&(o=o.readOnly),o)return !0})&&(t=(0, C.markLabelAsSelected)(t)),t},callback:function(){return t.onContextMenuMakeReadOnly()},disabled:function(){return t.hot.selection.isSelectedByCorner()||!t.checkSelectionCommentsConsistency()}});}},{key:"getDisplayDelaySetting",value:function(){var e=this.hot.getSettings().comments;if((0, h.isObject)(e))return e.displayDelay}},{key:"onAfterBeginEditing",value:function(){this.hide();}},{key:"destroy",value:function(){this.editor&&this.editor.destroy(),this.displaySwitch&&this.displaySwitch.destroy(),u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}}]),t}(m.default);(0, g.registerPlugin)("comments",T),t.default=T;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(0);t.default=function(){function e(){o(this,e),this.editor=this.createEditor(),this.editorStyle=this.editor.style,this.hidden=!0,this.hide();}return r(e,null,[{key:"CLASS_EDITOR_CONTAINER",get:function(){return "htCommentsContainer"}},{key:"CLASS_EDITOR",get:function(){return "htComments"}},{key:"CLASS_INPUT",get:function(){return "htCommentTextArea"}},{key:"CLASS_CELL",get:function(){return "htCommentCell"}}]),r(e,[{key:"setPosition",value:function(e,t){this.editorStyle.left=e+"px",this.editorStyle.top=t+"px";}},{key:"setSize",value:function(e,t){if(e&&t){var n=this.getInputElement();n.style.width=e+"px",n.style.height=t+"px";}}},{key:"resetSize",value:function(){var e=this.getInputElement();e.style.width="",e.style.height="";}},{key:"setReadOnlyState",value:function(e){this.getInputElement().readOnly=e;}},{key:"show",value:function(){this.editorStyle.display="block",this.hidden=!1;}},{key:"hide",value:function(){this.editorStyle.display="none",this.hidden=!0;}},{key:"isVisible",value:function(){return "block"===this.editorStyle.display}},{key:"setValue",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=e||"";this.getInputElement().value=t;}},{key:"getValue",value:function(){return this.getInputElement().value}},{key:"isFocused",value:function(){return document.activeElement===this.getInputElement()}},{key:"focus",value:function(){this.getInputElement().focus();}},{key:"createEditor",value:function(){var t=document.createElement("div"),n=document.createElement("textarea"),o=document.querySelector("."+e.CLASS_EDITOR_CONTAINER);return o||(o=document.createElement("div"),(0, i.addClass)(o,e.CLASS_EDITOR_CONTAINER),document.body.appendChild(o)),(0, i.addClass)(t,e.CLASS_EDITOR),(0, i.addClass)(n,e.CLASS_INPUT),t.appendChild(n),o.appendChild(t),t}},{key:"getInputElement",value:function(){return this.editor.querySelector("."+e.CLASS_INPUT)}},{key:"destroy",value:function(){this.editor.parentNode.removeChild(this.editor),this.editor=null,this.editorStyle=null;}}]),e}();},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(43),a=n(1),s=n(48),l=function(e){return e&&e.__esModule?e:{default:e}}(s),u=function(){function e(t){o(this,e),this.wasLastActionShow=!0,this.showDebounced=null,this.hidingTimer=null,this.updateDelay(t);}return r(e,[{key:"hide",value:function(){var e=this;this.wasLastActionShow=!1,this.hidingTimer=setTimeout(function(){!1===e.wasLastActionShow&&e.runLocalHooks("hide");},250);}},{key:"show",value:function(e){this.wasLastActionShow=!0,this.showDebounced(e);}},{key:"cancelHiding",value:function(){this.wasLastActionShow=!0,clearTimeout(this.hidingTimer),this.hidingTimer=null;}},{key:"updateDelay",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:250;this.showDebounced=(0, i.debounce)(function(t){e.wasLastActionShow&&e.runLocalHooks("show",t.from.row,t.from.col);},t);}},{key:"destroy",value:function(){this.clearLocalHooks();}}]),e}();(0, a.mixin)(u,l.default),t.default=u;},function(e,t){},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var s=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},l=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),u=n(11),c=o(u),h=n(16),f=o(h),d=n(2),p=n(557),g=o(p),v=n(6),m=o(v),y=n(558),w=o(y),C=n(570),b=o(C),_=n(8),S=n(12),E=n(0),O=n(97);n(572),f.default.getSingleton().register("afterContextMenuDefaultOptions"),f.default.getSingleton().register("beforeContextMenuShow"),f.default.getSingleton().register("afterContextMenuShow"),f.default.getSingleton().register("afterContextMenuHide"),f.default.getSingleton().register("afterContextMenuExecute");var T=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.eventManager=new m.default(n),n.commandExecutor=new g.default(n.hot),n.itemsFactory=null,n.menu=null,n}return a(t,e),l(t,null,[{key:"DEFAULT_ITEMS",get:function(){return [O.ROW_ABOVE,O.ROW_BELOW,O.SEPARATOR,O.COLUMN_LEFT,O.COLUMN_RIGHT,O.SEPARATOR,O.REMOVE_ROW,O.REMOVE_COLUMN,O.SEPARATOR,O.UNDO,O.REDO,O.SEPARATOR,O.READ_ONLY,O.SEPARATOR,O.ALIGNMENT]}}]),l(t,[{key:"isEnabled",value:function(){return this.hot.getSettings().contextMenu}},{key:"enablePlugin",value:function(){var e=this;if(!this.enabled){this.itemsFactory=new w.default(this.hot,t.DEFAULT_ITEMS);var n=this.hot.getSettings().contextMenu,o={items:this.itemsFactory.getItems(n)};"function"==typeof n.callback&&this.commandExecutor.setCommonCallback(n.callback),s(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this);var r=function(){if(e.hot){e.hot.runHooks("afterContextMenuDefaultOptions",o),e.itemsFactory.setPredefinedItems(o.items);var t=e.itemsFactory.getItems(n);e.menu=new b.default(e.hot,{className:"htContextMenu",keepInViewport:!0}),e.hot.runHooks("beforeContextMenuSetItems",t),e.menu.setMenuItems(t),e.menu.addLocalHook("beforeOpen",function(){return e.onMenuBeforeOpen()}),e.menu.addLocalHook("afterOpen",function(){return e.onMenuAfterOpen()}),e.menu.addLocalHook("afterClose",function(){return e.onMenuAfterClose()}),e.menu.addLocalHook("executeCommand",function(){for(var t,n=arguments.length,o=Array(n),r=0;n>r;r++)o[r]=arguments[r];return (t=e.executeCommand).call.apply(t,[e].concat(o))}),e.addHook("afterOnCellContextMenu",function(t){return e.onAfterOnCellContextMenu(t)}),(0, d.arrayEach)(t,function(t){return e.commandExecutor.registerCommand(t.key,t)});}};this.callOnPluginsReady(function(){e.isPluginsReady?setTimeout(r,0):r();});}}},{key:"updatePlugin",value:function(){this.disablePlugin(),this.enablePlugin(),s(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updatePlugin",this).call(this);}},{key:"disablePlugin",value:function(){this.close(),this.menu&&(this.menu.destroy(),this.menu=null),s(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"open",value:function(e){this.menu&&(this.menu.open(),this.menu.setPosition({top:parseInt((0, S.pageY)(e),10)-(0, E.getWindowScrollTop)(),left:parseInt((0, S.pageX)(e),10)-(0, E.getWindowScrollLeft)()}),this.menu.hotMenu.isHotTableEnv=this.hot.isHotTableEnv);}},{key:"close",value:function(){this.menu&&this.menu.close();}},{key:"executeCommand",value:function(e){for(var t,n=arguments.length,o=Array(n>1?n-1:0),r=1;n>r;r++)o[r-1]=arguments[r];(t=this.commandExecutor).execute.apply(t,[e].concat(o));}},{key:"onAfterOnCellContextMenu",value:function(e){var t=this.hot.getSettings(),n=t.rowHeaders,o=t.colHeaders,r=e.realTarget;this.close(),(0, E.hasClass)(r,"handsontableInput")||(e.preventDefault(),(0, S.stopPropagation)(e),(n||o||function(e){return "TD"===e.nodeName||"TD"===e.parentNode.nodeName}(r)||(0, E.hasClass)(r,"current")&&(0, E.hasClass)(r,"wtBorder"))&&this.open(e));}},{key:"onMenuBeforeOpen",value:function(){this.hot.runHooks("beforeContextMenuShow",this);}},{key:"onMenuAfterOpen",value:function(){this.hot.runHooks("afterContextMenuShow",this);}},{key:"onMenuAfterClose",value:function(){this.hot.listen(),this.hot.runHooks("afterContextMenuHide",this);}},{key:"destroy",value:function(){this.close(),this.menu&&this.menu.destroy(),s(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}}]),t}(c.default);T.SEPARATOR={name:O.SEPARATOR},(0, _.registerPlugin)("contextMenu",T),t.default=T;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){var n=void 0;return (0, a.arrayEach)(t,function(t){var o=t.key?t.key.split(":"):null;if(Array.isArray(o)&&o[1]===e)return n=t,!1}),n}t.__esModule=!0;var i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(2),s=n(1);t.default=function(){function e(t){o(this,e),this.hot=t,this.commands={},this.commonCallback=null;}return i(e,[{key:"registerCommand",value:function(e,t){this.commands[e]=t;}},{key:"setCommonCallback",value:function(e){this.commonCallback=e;}},{key:"execute",value:function(e){for(var t=this,n=arguments.length,o=Array(n>1?n-1:0),i=1;n>i;i++)o[i-1]=arguments[i];var l=e.split(":"),u=l[0],c=2===l.length?l[1]:null,h=this.commands[u];if(!h)throw Error("Menu command '"+u+"' not exists.");if(c&&h.submenu&&(h=r(c,h.submenu.items)),!0!==h.disabled&&("function"!=typeof h.disabled||!0!==h.disabled.call(this.hot))&&!(0, s.hasOwnProperty)(h,"submenu")){var f=[];"function"==typeof h.callback&&f.push(h.callback),"function"==typeof this.commonCallback&&f.push(this.commonCallback),o.unshift(l.join(":")),(0, a.arrayEach)(f,function(e){return e.apply(t.hot,o)});}}}]),e}();},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=[],r=e;return r&&r.items?r=r.items:Array.isArray(r)||(r=t),(0, a.isObject)(r)?(0, a.objectEach)(r,function(e,t){var r=n["string"==typeof e?e:t];r||(r=e),(0, a.isObject)(e)?(0, a.extend)(r,e):"string"==typeof r&&(r={name:r}),void 0===r.key&&(r.key=t),o.push(r);}):(0, s.arrayEach)(r,function(e,t){var r=n[e];(r||0>l.ITEMS.indexOf(e))&&(r||(r={name:e,key:""+t}),(0, a.isObject)(e)&&(0, a.extend)(r,e),void 0===r.key&&(r.key=t),o.push(r));}),o}t.__esModule=!0;var i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(1),s=n(2),l=n(97);t.default=function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;o(this,e),this.hot=t,this.predefinedItems=(0, l.predefinedItems)(),this.defaultOrderPattern=n;}return i(e,[{key:"setPredefinedItems",value:function(e){var t=this,n={};this.defaultOrderPattern.length=0,(0, a.objectEach)(e,function(e,o){var r="";e.name===l.SEPARATOR?(n[l.SEPARATOR]=e,r=l.SEPARATOR):isNaN(parseInt(o,10))?(e.key=void 0===e.key?o:e.key,n[o]=e,r=e.key):(n[e.key]=e,r=e.key),t.defaultOrderPattern.push(r);}),this.predefinedItems=n;}},{key:"getItems",value:function(){return r(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,this.defaultOrderPattern,this.predefinedItems)}}]),e}();},function(e,t,n){function o(){return {key:l,name:function(){return this.getTranslatedPhrase(s.CONTEXTMENU_ITEMS_ALIGNMENT)},disabled:function(){return !(this.getSelectedRange()&&!this.selection.isSelectedByCorner())},submenu:{items:[{key:l+":left",name:function(){var e=this,t=this.getTranslatedPhrase(s.CONTEXTMENU_ITEMS_ALIGNMENT_LEFT);return (0, r.checkSelectionConsistency)(this.getSelectedRange(),function(t,n){var o=e.getCellMeta(t,n).className;if(o&&-1!==o.indexOf("htLeft"))return !0})&&(t=(0, r.markLabelAsSelected)(t)),t},callback:function(){var e=this,t=this.getSelectedRange(),n=(0, r.getAlignmentClasses)(t,function(t,n){return e.getCellMeta(t,n).className});this.runHooks("beforeCellAlignment",n,t,"horizontal","htLeft"),(0, r.align)(t,"horizontal","htLeft",function(t,n){return e.getCellMeta(t,n)},function(t,n,o,r){return e.setCellMeta(t,n,o,r)}),this.render();},disabled:!1},{key:l+":center",name:function(){var e=this,t=this.getTranslatedPhrase(s.CONTEXTMENU_ITEMS_ALIGNMENT_CENTER);return (0, r.checkSelectionConsistency)(this.getSelectedRange(),function(t,n){var o=e.getCellMeta(t,n).className;if(o&&-1!==o.indexOf("htCenter"))return !0})&&(t=(0, r.markLabelAsSelected)(t)),t},callback:function(){var e=this,t=this.getSelectedRange(),n=(0, r.getAlignmentClasses)(t,function(t,n){return e.getCellMeta(t,n).className});this.runHooks("beforeCellAlignment",n,t,"horizontal","htCenter"),(0, r.align)(t,"horizontal","htCenter",function(t,n){return e.getCellMeta(t,n)},function(t,n,o,r){return e.setCellMeta(t,n,o,r)}),this.render();},disabled:!1},{key:l+":right",name:function(){var e=this,t=this.getTranslatedPhrase(s.CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT);return (0, r.checkSelectionConsistency)(this.getSelectedRange(),function(t,n){var o=e.getCellMeta(t,n).className;if(o&&-1!==o.indexOf("htRight"))return !0})&&(t=(0, r.markLabelAsSelected)(t)),t},callback:function(){var e=this,t=this.getSelectedRange(),n=(0, r.getAlignmentClasses)(t,function(t,n){return e.getCellMeta(t,n).className});this.runHooks("beforeCellAlignment",n,t,"horizontal","htRight"),(0, r.align)(t,"horizontal","htRight",function(t,n){return e.getCellMeta(t,n)},function(t,n,o,r){return e.setCellMeta(t,n,o,r)}),this.render();},disabled:!1},{key:l+":justify",name:function(){var e=this,t=this.getTranslatedPhrase(s.CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY);return (0, r.checkSelectionConsistency)(this.getSelectedRange(),function(t,n){var o=e.getCellMeta(t,n).className;if(o&&-1!==o.indexOf("htJustify"))return !0})&&(t=(0, r.markLabelAsSelected)(t)),t},callback:function(){var e=this,t=this.getSelectedRange(),n=(0, r.getAlignmentClasses)(t,function(t,n){return e.getCellMeta(t,n).className});this.runHooks("beforeCellAlignment",n,t,"horizontal","htJustify"),(0, r.align)(t,"horizontal","htJustify",function(t,n){return e.getCellMeta(t,n)},function(t,n,o,r){return e.setCellMeta(t,n,o,r)}),this.render();},disabled:!1},{name:i.KEY},{key:l+":top",name:function(){var e=this,t=this.getTranslatedPhrase(s.CONTEXTMENU_ITEMS_ALIGNMENT_TOP);return (0, r.checkSelectionConsistency)(this.getSelectedRange(),function(t,n){var o=e.getCellMeta(t,n).className;if(o&&-1!==o.indexOf("htTop"))return !0})&&(t=(0, r.markLabelAsSelected)(t)),t},callback:function(){var e=this,t=this.getSelectedRange(),n=(0, r.getAlignmentClasses)(t,function(t,n){return e.getCellMeta(t,n).className});this.runHooks("beforeCellAlignment",n,t,"vertical","htTop"),(0, r.align)(t,"vertical","htTop",function(t,n){return e.getCellMeta(t,n)},function(t,n,o,r){return e.setCellMeta(t,n,o,r)}),this.render();},disabled:!1},{key:l+":middle",name:function(){var e=this,t=this.getTranslatedPhrase(s.CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE);return (0, r.checkSelectionConsistency)(this.getSelectedRange(),function(t,n){var o=e.getCellMeta(t,n).className;if(o&&-1!==o.indexOf("htMiddle"))return !0})&&(t=(0, r.markLabelAsSelected)(t)),t},callback:function(){var e=this,t=this.getSelectedRange(),n=(0, r.getAlignmentClasses)(t,function(t,n){return e.getCellMeta(t,n).className});this.runHooks("beforeCellAlignment",n,t,"vertical","htMiddle"),(0, r.align)(t,"vertical","htMiddle",function(t,n){return e.getCellMeta(t,n)},function(t,n,o,r){return e.setCellMeta(t,n,o,r)}),this.render();},disabled:!1},{key:l+":bottom",name:function(){var e=this,t=this.getTranslatedPhrase(s.CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM);return (0, r.checkSelectionConsistency)(this.getSelectedRange(),function(t,n){var o=e.getCellMeta(t,n).className;if(o&&-1!==o.indexOf("htBottom"))return !0})&&(t=(0, r.markLabelAsSelected)(t)),t},callback:function(){var e=this,t=this.getSelectedRange(),n=(0, r.getAlignmentClasses)(t,function(t,n){return e.getCellMeta(t,n).className});this.runHooks("beforeCellAlignment",n,t,"vertical","htBottom"),(0, r.align)(t,"vertical","htBottom",function(t,n){return e.getCellMeta(t,n)},function(t,n,o,r){return e.setCellMeta(t,n,o,r)}),this.render();},disabled:!1}]}}}t.__esModule=!0,t.KEY=void 0,t.default=o;var r=n(19),i=n(96),a=n(7),s=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(a),l=t.KEY="alignment";},function(e,t,n){function o(){return {key:l,name:function(){return this.getTranslatedPhrase(s.CONTEXTMENU_ITEMS_CLEAR_COLUMN)},callback:function(e,t){var n=t[0].start.col;this.countRows()&&this.populateFromArray(0,n,[[null]],Math.max(t[0].start.row,t[0].end.row),n,"ContextMenu.clearColumn");},disabled:function(){var e=(0, i.getValidSelection)(this);if(!e)return !0;var t=r(e[0],3),n=t[0],o=t[1],a=t[2],s=[n,0,a,this.countCols()-1],l=s.join(",")===e.join(",");return 0>o||this.countCols()>=this.getSettings().maxCols||l}}}t.__esModule=!0,t.KEY=void 0;var r=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();t.default=o;var i=n(19),a=n(7),s=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(a),l=t.KEY="clear_column";},function(e,t,n){function o(){return {key:l,name:function(){return this.getTranslatedPhrase(s.CONTEXTMENU_ITEMS_INSERT_LEFT)},callback:function(e,t){this.alter("insert_col",t[Math.max(t.length-1,0)].start.col,1,"ContextMenu.columnLeft");},disabled:function(){var e=(0, i.getValidSelection)(this);if(!e)return !0;if(!this.isColumnModificationAllowed())return !0;var t=r(e[0],3),n=t[0],o=t[1],a=t[2],s=[n,0,a,this.countCols()-1],l=s.join(",")===e.join(","),u=1===this.countCols();return 0>o||this.countCols()>=this.getSettings().maxCols||!u&&l},hidden:function(){return !this.getSettings().allowInsertColumn}}}t.__esModule=!0,t.KEY=void 0;var r=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();t.default=o;var i=n(19),a=n(7),s=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(a),l=t.KEY="col_left";},function(e,t,n){function o(){return {key:l,name:function(){return this.getTranslatedPhrase(s.CONTEXTMENU_ITEMS_INSERT_RIGHT)},callback:function(e,t){this.alter("insert_col",t[Math.max(t.length-1,0)].end.col+1,1,"ContextMenu.columnRight");},disabled:function(){var e=(0, i.getValidSelection)(this);if(!e)return !0;if(!this.isColumnModificationAllowed())return !0;var t=r(e[0],3),n=t[0],o=t[1],a=t[2],s=[n,0,a,this.countCols()-1],l=s.join(",")===e.join(","),u=1===this.countCols();return 0>o||this.countCols()>=this.getSettings().maxCols||!u&&l},hidden:function(){return !this.getSettings().allowInsertColumn}}}t.__esModule=!0,t.KEY=void 0;var r=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();t.default=o;var i=n(19),a=n(7),s=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(a),l=t.KEY="col_right";},function(e,t,n){function o(){return {key:l,name:function(){var e=this,t=this.getTranslatedPhrase(s.CONTEXTMENU_ITEMS_READ_ONLY);return (0, r.checkSelectionConsistency)(this.getSelectedRange(),function(t,n){return e.getCellMeta(t,n).readOnly})&&(t=(0, r.markLabelAsSelected)(t)),t},callback:function(){var e=this,t=this.getSelectedRange(),n=(0, r.checkSelectionConsistency)(t,function(t,n){return e.getCellMeta(t,n).readOnly});(0, i.arrayEach)(t,function(t){t.forAll(function(t,o){e.setCellMeta(t,o,"readOnly",!n);});}),this.render();},disabled:function(){return !(this.getSelectedRange()&&!this.selection.isSelectedByCorner())}}}t.__esModule=!0,t.KEY=void 0,t.default=o;var r=n(19),i=n(2),a=n(7),s=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(a),l=t.KEY="make_read_only";},function(e,t,n){function o(){return {key:a,name:function(){return this.getTranslatedPhrase(i.CONTEXTMENU_ITEMS_REDO)},callback:function(){this.redo();},disabled:function(){return this.undoRedo&&!this.undoRedo.isRedoAvailable()}}}t.__esModule=!0,t.KEY=void 0,t.default=o;var r=n(7),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(r),a=t.KEY="redo";},function(e,t,n){function o(){return {key:u,name:function(){var e=this.getSelected(),t=0;if(e)if(e.length>1)t=1;else{var n=r(e[0],4),o=n[1],i=n[3];o-i!=0&&(t=1);}return this.getTranslatedPhrase(l.CONTEXTMENU_ITEMS_REMOVE_COLUMN,t)},callback:function(){this.alter("remove_col",(0, a.transformSelectionToColumnDistance)(this.getSelected()),null,"ContextMenu.removeColumn");},disabled:function(){var e=(0, i.getValidSelection)(this),t=this.countCols();return !e||(this.selection.isSelectedByRowHeader()||this.selection.isSelectedByCorner()||!this.isColumnModificationAllowed()||!t)},hidden:function(){return !this.getSettings().allowRemoveColumn}}}t.__esModule=!0,t.KEY=void 0;var r=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();t.default=o;var i=n(19),a=n(73),s=n(7),l=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(s),u=t.KEY="remove_col";},function(e,t,n){function o(){return {key:u,name:function(){var e=this.getSelected(),t=0;if(e)if(e.length>1)t=1;else{var n=r(e[0],3),o=n[0],i=n[2];o-i!=0&&(t=1);}return this.getTranslatedPhrase(l.CONTEXTMENU_ITEMS_REMOVE_ROW,t)},callback:function(){this.alter("remove_row",(0, a.transformSelectionToRowDistance)(this.getSelected()),null,"ContextMenu.removeRow");},disabled:function(){var e=(0, i.getValidSelection)(this),t=this.countRows();return !e||(this.selection.isSelectedByColumnHeader()||this.selection.isSelectedByCorner()||!t)},hidden:function(){return !this.getSettings().allowRemoveRow}}}t.__esModule=!0,t.KEY=void 0;var r=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();t.default=o;var i=n(19),a=n(73),s=n(7),l=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(s),u=t.KEY="remove_row";},function(e,t,n){function o(){return {key:s,name:function(){return this.getTranslatedPhrase(a.CONTEXTMENU_ITEMS_ROW_ABOVE)},callback:function(e,t){this.alter("insert_row",t[Math.max(t.length-1,0)].start.row,1,"ContextMenu.rowAbove");},disabled:function(){return !(0, r.getValidSelection)(this)||this.selection.isSelectedByColumnHeader()||this.countRows()>=this.getSettings().maxRows},hidden:function(){return !this.getSettings().allowInsertRow}}}t.__esModule=!0,t.KEY=void 0,t.default=o;var r=n(19),i=n(7),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(i),s=t.KEY="row_above";},function(e,t,n){function o(){return {key:s,name:function(){return this.getTranslatedPhrase(a.CONTEXTMENU_ITEMS_ROW_BELOW)},callback:function(e,t){this.alter("insert_row",t[Math.max(t.length-1,0)].end.row+1,1,"ContextMenu.rowBelow");},disabled:function(){return !(0, r.getValidSelection)(this)||this.selection.isSelectedByColumnHeader()||this.countRows()>=this.getSettings().maxRows},hidden:function(){return !this.getSettings().allowInsertRow}}}t.__esModule=!0,t.KEY=void 0,t.default=o;var r=n(19),i=n(7),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(i),s=t.KEY="row_below";},function(e,t,n){function o(){return {key:a,name:function(){return this.getTranslatedPhrase(i.CONTEXTMENU_ITEMS_UNDO)},callback:function(){this.undo();},disabled:function(){return this.undoRedo&&!this.undoRedo.isUndoAvailable()}}}t.__esModule=!0,t.KEY=void 0,t.default=o;var r=n(7),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(r),a=t.KEY="undo";},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(90),s=o(a),l=n(0),u=n(2),c=n(571),h=o(c),f=n(6),d=o(f),p=n(1),g=n(10),v=n(43),m=n(19),y=n(21),w=n(48),C=o(w),b=n(97),_=n(12),S=215,E=function(){function e(t,n){r(this,e),this.hot=t,this.options=n||{parent:null,name:null,className:"",keepInViewport:!0,standalone:!1,minWidth:S},this.eventManager=new d.default(this),this.container=this.createContainer(this.options.name),this.hotMenu=null,this.hotSubMenus={},this.parentMenu=this.options.parent||null,this.menuItems=null,this.origOutsideClickDeselects=null,this.keyEvent=!1,this.offset={above:0,below:0,left:0,right:0},this._afterScrollCallback=null,this.registerEvents();}return i(e,[{key:"registerEvents",value:function(){var e=this;this.eventManager.addEventListener(document.documentElement,"mousedown",function(t){return e.onDocumentMouseDown(t)});}},{key:"setMenuItems",value:function(e){this.menuItems=e;}},{key:"setOffset",value:function(e){this.offset[e]=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;}},{key:"isSubMenu",value:function(){return null!==this.parentMenu}},{key:"open",value:function(){var e=this;this.runLocalHooks("beforeOpen"),this.container.removeAttribute("style"),this.container.style.display="block";var t=(0, v.debounce)(function(t){return e.openSubMenu(t)},300),n=this.options.minWidth||S,o=(0, u.arrayFilter)(this.menuItems,function(t){return (0, m.isItemHidden)(t,e.hot)});o=(0, m.filterSeparators)(o,b.SEPARATOR);var r={data:o,colHeaders:!1,autoColumnSize:!0,modifyColWidth:function(e){return (0, g.isDefined)(e)&&n>e?n:e},autoRowSize:!1,readOnly:!0,copyPaste:!1,columns:[{data:"name",renderer:function(t,n,o,r,i,a){return e.menuItemRenderer(t,n,o,r,i,a)}}],renderAllRows:!0,fragmentSelection:"cell",disableVisualSelection:"area",beforeKeyDown:function(t){return e.onBeforeKeyDown(t)},afterOnCellMouseOver:function(n,o){e.isAllSubMenusClosed()?t(o.row):e.openSubMenu(o.row);},rowHeights:function(e){return o[e].name===b.SEPARATOR?1:23}};this.origOutsideClickDeselects=this.hot.getSettings().outsideClickDeselects,this.hot.getSettings().outsideClickDeselects=!1,this.hotMenu=new s.default(this.container,r),this.hotMenu.addHook("afterInit",function(){return e.onAfterInit()}),this.hotMenu.addHook("afterSelection",function(){return e.onAfterSelection.apply(e,arguments)}),this.hotMenu.init(),this.hotMenu.listen(),this.blockMainTableCallbacks(),this.runLocalHooks("afterOpen");}},{key:"close",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.isOpened()&&(e&&this.parentMenu?this.parentMenu.close():(this.closeAllSubMenus(),this.container.style.display="none",this.releaseMainTableCallbacks(),this.hotMenu.destroy(),this.hotMenu=null,this.hot.getSettings().outsideClickDeselects=this.origOutsideClickDeselects,this.runLocalHooks("afterClose"),this.parentMenu&&this.parentMenu.hotMenu.listen()));}},{key:"openSubMenu",value:function(t){if(!this.hotMenu)return !1;var n=this.hotMenu.getCell(t,0);if(this.closeAllSubMenus(),!n||!(0, m.hasSubMenu)(n))return !1;var o=this.hotMenu.getSourceDataAtRow(t),r=new e(this.hot,{parent:this,name:o.name,className:this.options.className,keepInViewport:!0});return r.setMenuItems(o.submenu.items),r.open(),r.setPosition(n.getBoundingClientRect()),this.hotSubMenus[o.key]=r,r}},{key:"closeSubMenu",value:function(e){var t=this.hotMenu.getSourceDataAtRow(e),n=this.hotSubMenus[t.key];n&&(n.destroy(),delete this.hotSubMenus[t.key]);}},{key:"closeAllSubMenus",value:function(){var e=this;(0, u.arrayEach)(this.hotMenu.getData(),function(t,n){return e.closeSubMenu(n)});}},{key:"isAllSubMenusClosed",value:function(){return 0===Object.keys(this.hotSubMenus).length}},{key:"destroy",value:function(){this.clearLocalHooks(),this.close(),this.parentMenu=null,this.eventManager.destroy();}},{key:"isOpened",value:function(){return null!==this.hotMenu}},{key:"executeCommand",value:function(e){if(this.isOpened()&&this.hotMenu.getSelectedLast()){var t=this.hotMenu.getSourceDataAtRow(this.hotMenu.getSelectedLast()[0]);if(this.runLocalHooks("select",t,e),!1!==t.isCommand&&t.name!==b.SEPARATOR){var n=this.hot.getSelectedRange(),o=n?(0, m.normalizeSelection)(n):[],r=!0;(!0===t.disabled||"function"==typeof t.disabled&&!0===t.disabled.call(this.hot)||t.submenu)&&(r=!1),this.runLocalHooks("executeCommand",t.key,o,e),this.isSubMenu()&&this.parentMenu.runLocalHooks("executeCommand",t.key,o,e),r&&this.close(!0);}}}},{key:"setPosition",value:function(e){var t=new h.default(e);this.options.keepInViewport?(t.fitsBelow(this.container)?this.setPositionBelowCursor(t):t.fitsAbove(this.container)?this.setPositionAboveCursor(t):this.setPositionBelowCursor(t),t.fitsOnRight(this.container)?this.setPositionOnRightOfCursor(t):this.setPositionOnLeftOfCursor(t)):(this.setPositionBelowCursor(t),this.setPositionOnRightOfCursor(t));}},{key:"setPositionAboveCursor",value:function(e){var t=this.offset.above+e.top-this.container.offsetHeight;this.isSubMenu()&&(t=e.top+e.cellHeight-this.container.offsetHeight+3),this.container.style.top=t+"px";}},{key:"setPositionBelowCursor",value:function(e){var t=this.offset.below+e.top;this.isSubMenu()&&(t=e.top-1),this.container.style.top=t+"px";}},{key:"setPositionOnRightOfCursor",value:function(e){var t=void 0;t=this.isSubMenu()?1+e.left+e.cellWidth:this.offset.right+1+e.left,this.container.style.left=t+"px";}},{key:"setPositionOnLeftOfCursor",value:function(e){this.container.style.left=this.offset.left+e.left-this.container.offsetWidth+(0, l.getScrollbarWidth)()+4+"px";}},{key:"selectFirstCell",value:function(){var e=this.hotMenu.getCell(0,0);(0, m.isSeparator)(e)||(0, m.isDisabled)(e)||(0, m.isSelectionDisabled)(e)?this.selectNextCell(0,0):this.hotMenu.selectCell(0,0);}},{key:"selectLastCell",value:function(){var e=this.hotMenu.countRows()-1,t=this.hotMenu.getCell(e,0);(0, m.isSeparator)(t)||(0, m.isDisabled)(t)||(0, m.isSelectionDisabled)(t)?this.selectPrevCell(e,0):this.hotMenu.selectCell(e,0);}},{key:"selectNextCell",value:function(e,t){var n=e+1,o=n<this.hotMenu.countRows()?this.hotMenu.getCell(n,t):null;o&&((0, m.isSeparator)(o)||(0, m.isDisabled)(o)||(0, m.isSelectionDisabled)(o)?this.selectNextCell(n,t):this.hotMenu.selectCell(n,t));}},{key:"selectPrevCell",value:function(e,t){var n=e-1,o=0>n?null:this.hotMenu.getCell(n,t);o&&((0, m.isSeparator)(o)||(0, m.isDisabled)(o)||(0, m.isSelectionDisabled)(o)?this.selectPrevCell(n,t):this.hotMenu.selectCell(n,t));}},{key:"menuItemRenderer",value:function(e,t,n,o,r,i){var a=this,s=e.getSourceDataAtRow(n),u=document.createElement("div"),c=function(e){return e.disableSelection},h=i;"function"==typeof h&&(h=h.call(this.hot)),(0, l.empty)(t),(0, l.addClass)(u,"htItemWrapper"),t.appendChild(u),!function(e){return RegExp(b.SEPARATOR,"i").test(e.name)}(s)?"function"==typeof s.renderer?((0, l.addClass)(t,"htCustomMenuRenderer"),t.appendChild(s.renderer(e,u,n,o,r,h))):(0, l.fastInnerHTML)(u,h):(0, l.addClass)(t,"htSeparator"),!function(e){return !0===e.disabled||"function"==typeof e.disabled&&!0===e.disabled.call(a.hot)}(s)?c(s)?((0, l.addClass)(t,"htSelectionDisabled"),this.eventManager.addEventListener(t,"mouseenter",function(){return e.deselectCell()})):!function(e){return (0, p.hasOwnProperty)(e,"submenu")}(s)?((0, l.removeClass)(t,"htSubmenu"),(0, l.removeClass)(t,"htDisabled"),c(s)?this.eventManager.addEventListener(t,"mouseenter",function(){return e.deselectCell()}):this.eventManager.addEventListener(t,"mouseenter",function(){return e.selectCell(n,o,void 0,void 0,!1,!1)})):((0, l.addClass)(t,"htSubmenu"),c(s)?this.eventManager.addEventListener(t,"mouseenter",function(){return e.deselectCell()}):this.eventManager.addEventListener(t,"mouseenter",function(){return e.selectCell(n,o,void 0,void 0,!1,!1)})):((0, l.addClass)(t,"htDisabled"),this.eventManager.addEventListener(t,"mouseenter",function(){return e.deselectCell()}));}},{key:"createContainer",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=e,n=void 0;return t?((0, v.isFunction)(t)&&(t=t.call(this.hot),t=null===t||(0, g.isUndefined)(t)?"":""+t),t=t.replace(/[^A-z0-9]/g,"_"),t=this.options.className+"Sub_"+t,n=document.querySelector("."+this.options.className+"."+t)):n=document.querySelector("."+this.options.className),n||(n=document.createElement("div"),(0, l.addClass)(n,"htMenu "+this.options.className),t&&(0, l.addClass)(n,t),document.getElementsByTagName("body")[0].appendChild(n)),n}},{key:"blockMainTableCallbacks",value:function(){this._afterScrollCallback=function(){},this.hot.addHook("afterScrollVertically",this._afterScrollCallback),this.hot.addHook("afterScrollHorizontally",this._afterScrollCallback);}},{key:"releaseMainTableCallbacks",value:function(){this._afterScrollCallback&&(this.hot.removeHook("afterScrollVertically",this._afterScrollCallback),this.hot.removeHook("afterScrollHorizontally",this._afterScrollCallback),this._afterScrollCallback=null);}},{key:"onBeforeKeyDown",value:function(e){var t=this.hotMenu.getSelectedLast(),n=!1;switch(this.keyEvent=!0,e.keyCode){case y.KEY_CODES.ESCAPE:this.close(),n=!0;break;case y.KEY_CODES.ENTER:t&&(this.hotMenu.getSourceDataAtRow(t[0]).submenu?n=!0:(this.executeCommand(e),this.close(!0)));break;case y.KEY_CODES.ARROW_DOWN:t?this.selectNextCell(t[0],t[1]):this.selectFirstCell(),n=!0;break;case y.KEY_CODES.ARROW_UP:t?this.selectPrevCell(t[0],t[1]):this.selectLastCell(),n=!0;break;case y.KEY_CODES.ARROW_RIGHT:if(t){var o=this.openSubMenu(t[0]);o&&o.selectFirstCell();}n=!0;break;case y.KEY_CODES.ARROW_LEFT:t&&this.isSubMenu()&&(this.close(),this.parentMenu&&this.parentMenu.hotMenu.listen(),n=!0);}n&&(e.preventDefault(),(0, _.stopImmediatePropagation)(e)),this.keyEvent=!1;}},{key:"onAfterInit",value:function(){var e=this.hotMenu.getSettings().data,t=this.hotMenu.view.wt.wtTable.hider.style,n=this.hotMenu.view.wt.wtTable.holder.style,o=parseInt(t.width,10),r=(0, u.arrayReduce)(e,function(e,t){return e+(t.name===b.SEPARATOR?1:26)},0);n.width=o+22+"px",n.height=r+4+"px",t.height=n.height;}},{key:"onAfterSelection",value:function(e,t,n,o,r){!1===this.keyEvent&&(r.value=!0);}},{key:"onDocumentMouseDown",value:function(e){this.isOpened()&&(this.container&&(0, l.isChildOf)(e.target,this.container)&&this.executeCommand(e),this.options.standalone&&this.hotMenu&&!(0, l.isChildOf)(e.target,this.hotMenu.rootElement)?this.close(!0):(this.isAllSubMenusClosed()||this.isSubMenu())&&!(0, l.isChildOf)(e.target,".htMenu")&&(0, l.isChildOf)(e.target,document)&&this.close(!0));}}]),e}();(0, p.mixin)(E,C.default),t.default=E;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(0),a=n(12);t.default=function(){function e(t){o(this,e);var n=(0, i.getWindowScrollTop)(),r=(0, i.getWindowScrollLeft)(),s=void 0,l=void 0,u=void 0,c=void 0,h=void 0,f=void 0;this.type=this.getSourceType(t),"literal"===this.type?(s=parseInt(t.top,10),u=parseInt(t.left,10),h=t.height||0,f=t.width||0,l=s,c=u,s+=n,u+=r):"event"===this.type&&(s=parseInt((0, a.pageY)(t),10),u=parseInt((0, a.pageX)(t),10),h=t.target.clientHeight,f=t.target.clientWidth,l=s-n,c=u-r),this.top=s,this.topRelative=l,this.left=u,this.leftRelative=c,this.scrollTop=n,this.scrollLeft=r,this.cellHeight=h,this.cellWidth=f;}return r(e,[{key:"getSourceType",value:function(e){var t="literal";return e instanceof Event&&(t="event"),t}},{key:"fitsAbove",value:function(e){return this.topRelative>=e.offsetHeight}},{key:"fitsBelow",value:function(e){return (arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.innerHeight)>=this.topRelative+e.offsetHeight}},{key:"fitsOnRight",value:function(e){return (arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.innerWidth)>=this.leftRelative+this.cellWidth+e.offsetWidth}},{key:"fitsOnLeft",value:function(e){return this.leftRelative>=e.offsetWidth}}]),e}();},function(e,t){},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var s=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},u=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},h=n(11),f=o(h),d=n(16),p=o(d),g=n(438),v=o(g),m=n(2),y=n(5),w=n(0),C=n(8),b=n(574),_=o(b),S=n(575),E=o(S),O=n(576),T=o(O),k=n(578),R=n(579);n(580),p.default.getSingleton().register("afterCopyLimit"),p.default.getSingleton().register("modifyCopyableRange"),p.default.getSingleton().register("beforeCut"),p.default.getSingleton().register("afterCut"),p.default.getSingleton().register("beforePaste"),p.default.getSingleton().register("afterPaste"),p.default.getSingleton().register("beforeCopy"),p.default.getSingleton().register("afterCopy");var M=1e3,D=1e3,A=new WeakMap,N=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.columnsLimit=D,n.copyableRanges=[],n.pasteMode="overwrite",n.rowsLimit=M,A.set(n,{isTriggeredByCopy:!1,isTriggeredByCut:!1,isBeginEditing:!1,isFragmentSelectionEnabled:!1}),n}return a(t,e),u(t,[{key:"isEnabled",value:function(){return !!this.hot.getSettings().copyPaste}},{key:"enablePlugin",value:function(){var e=this;if(!this.enabled){var n=this.hot.getSettings();A.get(this).isFragmentSelectionEnabled=n.fragmentSelection,"object"===l(n.copyPaste)&&(this.pasteMode=n.copyPaste.pasteMode||this.pasteMode,this.rowsLimit=n.copyPaste.rowsLimit||this.rowsLimit,this.columnsLimit=n.copyPaste.columnsLimit||this.columnsLimit),this.addHook("afterContextMenuDefaultOptions",function(t){return e.onAfterContextMenuDefaultOptions(t)}),this.addHook("afterOnCellMouseUp",function(){return e.onAfterOnCellMouseUp()}),this.addHook("afterSelectionEnd",function(){return e.onAfterSelectionEnd()}),this.addHook("beforeKeyDown",function(){return e.onBeforeKeyDown()}),this.focusableElement=(0, k.createElement)(),this.focusableElement.addLocalHook("copy",function(t){return e.onCopy(t)}).addLocalHook("cut",function(t){return e.onCut(t)}).addLocalHook("paste",function(t){return e.onPaste(t)}),c(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this);}}},{key:"updatePlugin",value:function(){this.disablePlugin(),this.enablePlugin(),this.getOrCreateFocusableElement(),c(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updatePlugin",this).call(this);}},{key:"disablePlugin",value:function(){this.focusableElement&&(0, k.destroyElement)(this.focusableElement),c(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"copy",value:function(){A.get(this).isTriggeredByCopy=!0,this.getOrCreateFocusableElement(),this.focusableElement.focus(),document.execCommand("copy");}},{key:"cut",value:function(){A.get(this).isTriggeredByCut=!0,this.getOrCreateFocusableElement(),this.focusableElement.focus(),document.execCommand("cut");}},{key:"getRangedCopyableData",value:function(e){var t=this,n=[],o=[],r=[];return (0, m.arrayEach)(e,function(e){(0, y.rangeEach)(e.startRow,e.endRow,function(e){-1===o.indexOf(e)&&o.push(e);}),(0, y.rangeEach)(e.startCol,e.endCol,function(e){-1===r.indexOf(e)&&r.push(e);});}),(0, m.arrayEach)(o,function(e){var o=[];(0, m.arrayEach)(r,function(n){o.push(t.hot.getCopyableData(e,n));}),n.push(o);}),v.default.stringify(n)}},{key:"getRangedData",value:function(e){var t=this,n=[],o=[],r=[];return (0, m.arrayEach)(e,function(e){(0, y.rangeEach)(e.startRow,e.endRow,function(e){-1===o.indexOf(e)&&o.push(e);}),(0, y.rangeEach)(e.startCol,e.endCol,function(e){-1===r.indexOf(e)&&r.push(e);});}),(0, m.arrayEach)(o,function(e){var o=[];(0, m.arrayEach)(r,function(n){o.push(t.hot.getCopyableData(e,n));}),n.push(o);}),n}},{key:"paste",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;if(e||t){var n=new T.default;e&&n.clipboardData.setData("text/plain",e),t&&n.clipboardData.setData("text/html",t),this.getOrCreateFocusableElement(),this.onPaste(n);}}},{key:"setCopyableText",value:function(){var e=this.hot.getSelectedRangeLast();if(e){var t=e.getTopLeftCorner(),n=e.getBottomRightCorner(),o=t.row,r=t.col,i=n.row,a=n.col,s=Math.min(i,o+this.rowsLimit-1),l=Math.min(a,r+this.columnsLimit-1);this.copyableRanges.length=0,this.copyableRanges.push({startRow:o,startCol:r,endRow:s,endCol:l}),this.copyableRanges=this.hot.runHooks("modifyCopyableRange",this.copyableRanges),i===s&&a===l||this.hot.runHooks("afterCopyLimit",i-o+1,a-r+1,this.rowsLimit,this.columnsLimit);}}},{key:"getOrCreateFocusableElement",value:function(){var e=this.hot.getActiveEditor(),t=e?e.TEXTAREA:void 0;t?this.focusableElement.setFocusableElement(t):this.focusableElement.useSecondaryElement();}},{key:"isEditorOpened",value:function(){var e=this.hot.getActiveEditor();return e&&e.isOpened()}},{key:"populateValues",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.hot.getSelectedLast();if(e.length){for(var n=e.length-1,o=e[0].length-1,r=Math.min(t[0],t[2]),i=Math.max(t[0],t[2],n+r),a=Math.min(t[1],t[3]),s=Math.max(t[1],t[3],o+a),l=[],u=r,c=0;i>=u;u+=1){for(var h=[],f=a,d=0;s>=f;f+=1)h.push(e[c][d]),d=d===o?0:d+=1;l.push(h),c=c===n?0:c+=1;}return this.hot.populateFromArray(r,a,l,void 0,void 0,"CopyPaste.paste",this.pasteMode),[r,a,i,s]}}},{key:"onCopy",value:function(e){var t=A.get(this);if((this.hot.isListening()||t.isTriggeredByCopy)&&!this.isEditorOpened()){this.setCopyableText(),t.isTriggeredByCopy=!1;var n=this.getRangedData(this.copyableRanges);if(!!this.hot.runHooks("beforeCopy",n,this.copyableRanges)){var o=v.default.stringify(n);if(e&&e.clipboardData){var r=(0, R.arrayToTable)(n);e.clipboardData.setData("text/plain",o),e.clipboardData.setData("text/html",r);}else"undefined"==typeof ClipboardEvent&&window.clipboardData.setData("Text",o);this.hot.runHooks("afterCopy",n,this.copyableRanges);}e.preventDefault();}}},{key:"onCut",value:function(e){var t=A.get(this);if((this.hot.isListening()||t.isTriggeredByCut)&&!this.isEditorOpened()){this.setCopyableText(),t.isTriggeredByCut=!1;var n=this.getRangedData(this.copyableRanges);if(!!this.hot.runHooks("beforeCut",n,this.copyableRanges)){var o=v.default.stringify(n);if(e&&e.clipboardData){var r=(0, R.arrayToTable)(n);e.clipboardData.setData("text/plain",o),e.clipboardData.setData("text/html",r);}else"undefined"==typeof ClipboardEvent&&window.clipboardData.setData("Text",o);this.hot.emptySelectedCells(),this.hot.runHooks("afterCut",n,this.copyableRanges);}e.preventDefault();}}},{key:"onPaste",value:function(e){if(this.hot.isListening()&&!this.isEditorOpened()){e&&e.preventDefault&&e.preventDefault();var t=void 0;if(e&&void 0!==e.clipboardData){var n=e.clipboardData.getData("text/html");t=n&&/(<table)|(<TABLE)/.test(n)?(0, R.tableToArray)(n):e.clipboardData.getData("text/plain");}else"undefined"==typeof ClipboardEvent&&void 0!==window.clipboardData&&(t=window.clipboardData.getData("Text"));var o="string"!=typeof t?t:v.default.parse(t);if(0!==o.length&&!1!==this.hot.runHooks("beforePaste",o,this.copyableRanges)){var r=this.populateValues(o),i=s(r,4),a=i[0],l=i[1],u=i[2],c=i[3];this.hot.selectCell(a,l,Math.min(this.hot.countRows()-1,u),Math.min(this.hot.countCols()-1,c)),this.hot.runHooks("afterPaste",o,this.copyableRanges);}}}},{key:"onAfterContextMenuDefaultOptions",value:function(e){e.items.push({name:"---------"},(0, _.default)(this),(0, E.default)(this));}},{key:"onAfterOnCellMouseUp",value:function(){this.hot.isListening()&&!this.isEditorOpened()&&(this.getOrCreateFocusableElement(),this.focusableElement.focus());}},{key:"onAfterSelectionEnd",value:function(){var e=A.get(this),t=e.isFragmentSelectionEnabled;this.isEditorOpened()||(this.getOrCreateFocusableElement(),t&&this.focusableElement.getFocusableElement()!==document.activeElement&&(0, w.getSelectionText)()||(this.setCopyableText(),this.focusableElement.focus()));}},{key:"onBeforeKeyDown",value:function(){if(this.hot.isListening()&&!this.isEditorOpened()){var e=document.activeElement,t=this.hot.getActiveEditor();!t||e!==this.focusableElement.getFocusableElement()&&e!==t.select||(this.getOrCreateFocusableElement(),this.focusableElement.focus());}}},{key:"destroy",value:function(){this.focusableElement&&((0, k.destroyElement)(this.focusableElement),this.focusableElement=null),c(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}}]),t}(f.default);(0, C.registerPlugin)("CopyPaste",N),t.default=N;},function(e,t,n){function o(e){return {key:"copy",name:function(){return this.getTranslatedPhrase(i.CONTEXTMENU_ITEMS_COPY)},callback:function(){e.copy();},disabled:function(){var e=this.getSelected();return !e||e.length>1},hidden:!1}}t.__esModule=!0,t.default=o;var r=n(7),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(r);},function(e,t,n){function o(e){return {key:"cut",name:function(){return this.getTranslatedPhrase(i.CONTEXTMENU_ITEMS_CUT)},callback:function(){e.cut();},disabled:function(){var e=this.getSelected();return !e||e.length>1},hidden:!1}}t.__esModule=!0,t.default=o;var r=n(7),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(r);},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=n(577),i=function(e){return e&&e.__esModule?e:{default:e}}(r);t.default=function e(){o(this,e),this.clipboardData=new i.default;};},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}();t.default=function(){function e(){o(this,e),this.data={};}return r(e,[{key:"setData",value:function(e,t){this.data[e]=t;}},{key:"getData",value:function(e){return this.data[e]||void 0}}]),e}();},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(){var e=new m;return y+=1,e}function a(e){e.eventManager.clear();}function s(e,t,n){e.addEventListener(t,"copy",w("copy",n)),e.addEventListener(t,"cut",w("cut",n)),e.addEventListener(t,"paste",w("paste",n));}function l(){if(C)return C.parentElement||document.body.appendChild(C),C;var e=document.createElement("textarea");return C=e,e.id="HandsontableCopyPaste",e.className="copyPaste",e.tabIndex=-1,e.autocomplete="off",e.wrap="hard",e.value=" ",document.body.appendChild(e),e}function u(e){e instanceof m&&(y>0&&(y-=1),a(e),y>0||(y=0,C&&C.parentNode&&(C.parentNode.removeChild(C),C=null),e.mainElement=null));}t.__esModule=!0,t.destroyElement=t.deactivateElement=t.createElement=void 0;var c=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),h=n(6),f=o(h),d=n(48),p=o(d),g=n(1),v=n(35),m=function(){function e(){r(this,e),this.mainElement=null,this.eventManager=new f.default(this),this.listenersCount=new WeakSet;}return c(e,[{key:"useSecondaryElement",value:function(){var e=l();this.listenersCount.has(e)||(this.listenersCount.add(e),s(this.eventManager,e,this)),this.mainElement=e;}},{key:"setFocusableElement",value:function(e){this.listenersCount.has(e)||(this.listenersCount.add(e),s(this.eventManager,e,this)),this.mainElement=e;}},{key:"getFocusableElement",value:function(){return this.mainElement}},{key:"focus",value:function(){this.mainElement.value=" ",(0, v.isMobileBrowser)()||this.mainElement.select();}}]),e}();(0, g.mixin)(m,p.default);var y=0,w=function(e,t){return function(n){return t.runLocalHooks(e,n)}},C=void 0;t.createElement=i,t.deactivateElement=a,t.destroyElement=u;},function(e,t,n){function o(e){var t=e.length,n=["<table>"],o=document.createElement("div");document.documentElement.appendChild(o);for(var r=0;t>r;r+=1){var i=e[r],s=i.length,l=[];0===r&&n.push("<tbody>");for(var u=0;s>u;u+=1)o.innerText=""+((0, a.isEmpty)(i[u])?"":i[u]),l.push("<td>"+o.innerHTML+"</td>");n.push.apply(n,["<tr>"].concat(l,["</tr>"])),r+1===t&&n.push("</tbody>");}return document.documentElement.removeChild(o),n.push("</table>"),n.join("")}function r(e){return "table"===(e&&e.nodeName||"").toLowerCase()}function i(e){var t=[],n=e;if("string"==typeof n){var o=document.createElement("div");o.innerHTML=n.replace(/\n/g,""),n=o.querySelector("table");}if(n&&r(n)){for(var i=n.rows,a=i&&i.length,s=[],l=0;a>l;l+=1){for(var u=i[l].cells,c=u.length,h=[],f=0;c>f;f+=1){var d=u[f];d.innerHTML=d.innerHTML.trim().replace(/<br(.|)>(\n?)/,"\n");h.push(d.innerText);}s.push(h);}t.push.apply(t,s);}return t}t.__esModule=!0,t.arrayToTable=o,t.tableToArray=i;var a=n(10);},function(e,t){},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),s=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},u=n(11),c=function(e){return e&&e.__esModule?e:{default:e}}(u),h=n(8),f=n(1),d=n(5),p=n(2),g=n(4),v=n(7),m=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(v),y=n(582),w=n(49),C=n(445),b=function(e){function t(e){o(this,t);var n=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.savedBorders=[],n}return i(t,e),s(t,[{key:"isEnabled",value:function(){return !!this.hot.getSettings().customBorders}},{key:"enablePlugin",value:function(){var e=this;this.enabled||(this.addHook("afterContextMenuDefaultOptions",function(t){return e.onAfterContextMenuDefaultOptions(t)}),this.addHook("afterInit",function(){return e.onAfterInit()}),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this));}},{key:"disablePlugin",value:function(){this.hideBorders(),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"updatePlugin",value:function(){this.disablePlugin(),this.enablePlugin(),this.changeBorderSettings(),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updatePlugin",this).call(this);}},{key:"setBorders",value:function(e,t){var n=this,o=["top","right","bottom","left"],r=t?Object.keys(t):o,i=(0, C.detectSelectionType)(e),s=(0, C.normalizeSelectionFactory)(i);(0, p.arrayEach)(e,function(e){for(var o=s(e),i=a(o,4),l=i[0],u=i[1],c=i[2],h=i[3],f=l;c>=f;f+=1)!function(e){for(var o=u;h>=o;o+=1)!function(o){(0, p.arrayEach)(r,function(r){n.prepareBorderFromCustomAdded(e,o,t,r);});}(o);}(f);});}},{key:"getBorders",value:function(e){var t=this;if(!Array.isArray(e))return this.savedBorders;var n=(0, C.detectSelectionType)(e),o=(0, C.normalizeSelectionFactory)(n),r=[];return (0, p.arrayEach)(e,function(e){for(var n=o(e),i=a(n,4),s=i[0],l=i[1],u=i[2],c=i[3],h=s;u>=h;h+=1)!function(e){for(var n=l;c>=n;n+=1)!function(n){(0, p.arrayEach)(t.savedBorders,function(t){t.row===e&&t.col===n&&r.push(t);});}(n);}(h);}),r}},{key:"clearBorders",value:function(e){var t=this;e?this.setBorders(e):((0, p.arrayEach)(this.savedBorders,function(e){t.clearBordersFromSelectionSettings(e.id),t.clearNullCellRange(),t.hot.removeCellMeta(e.row,e.col,"borders");}),this.savedBorders.length=0);}},{key:"insertBorderIntoSettings",value:function(e,t){this.checkSavedBorders(e)||this.savedBorders.push(e);var n={row:e.row,col:e.col},o=new g.CellRange(n,n,n);this.checkCustomSelections(e,o,t)||(this.hot.selection.highlight.addCustomSelection({border:e,cellRange:o}),this.hot.view.wt.draw(!0));}},{key:"prepareBorderFromCustomAdded",value:function(e,t,n,o){var r=(0, w.createEmptyBorders)(e,t);n&&(r=(0, w.extendDefaultBorder)(r,n),(0, p.arrayEach)(this.hot.selection.highlight.customSelections,function(e){if(r.id===e.settings.id)return Object.assign(e.settings,n),r=e.settings,!1})),this.hot.setCellMeta(e,t,"borders",r),this.insertBorderIntoSettings(r,o);}},{key:"prepareBorderFromCustomAddedRange",value:function(e){var t=this,n=e.range;(0, d.rangeEach)(n.from.row,n.to.row,function(o){(0, d.rangeEach)(n.from.col,n.to.col,function(r){var i=(0, w.createEmptyBorders)(o,r),a=0;o===n.from.row&&(a+=1,(0, f.hasOwnProperty)(e,"top")&&(i.top=e.top)),o===n.to.row&&(a+=1,(0, f.hasOwnProperty)(e,"bottom")&&(i.bottom=e.bottom)),r===n.from.col&&(a+=1,(0, f.hasOwnProperty)(e,"left")&&(i.left=e.left)),r===n.to.col&&(a+=1,(0, f.hasOwnProperty)(e,"right")&&(i.right=e.right)),a>0&&(t.hot.setCellMeta(o,r,"borders",i),t.insertBorderIntoSettings(i));});});}},{key:"removeAllBorders",value:function(e,t){var n=(0, w.createId)(e,t);this.spliceBorder(n),this.clearBordersFromSelectionSettings(n),this.clearNullCellRange(),this.hot.removeCellMeta(e,t,"borders");}},{key:"setBorder",value:function(e,t,n,o){var r=this.hot.getCellMeta(e,t).borders;if(r&&void 0!==r.border||(r=(0, w.createEmptyBorders)(e,t)),o){r[n]=(0, w.createSingleEmptyBorder)();if(4===this.countHide(r))this.removeAllBorders(e,t);else{this.checkCustomSelectionsFromContextMenu(r,n,o)||this.insertBorderIntoSettings(r),this.hot.setCellMeta(e,t,"borders",r);}}else{r[n]=(0, w.createDefaultCustomBorder)();this.checkCustomSelectionsFromContextMenu(r,n,o)||this.insertBorderIntoSettings(r),this.hot.setCellMeta(e,t,"borders",r);}}},{key:"prepareBorder",value:function(e,t,n){var o=this;(0, p.arrayEach)(e,function(e){var r=e.start,i=e.end;if(r.row===i.row&&r.col===i.col)"noBorders"===t?o.removeAllBorders(r.row,r.col):o.setBorder(r.row,r.col,t,n);else switch(t){case"noBorders":(0, d.rangeEach)(r.col,i.col,function(e){(0, d.rangeEach)(r.row,i.row,function(t){o.removeAllBorders(t,e);});});break;case"top":(0, d.rangeEach)(r.col,i.col,function(e){o.setBorder(r.row,e,t,n);});break;case"right":(0, d.rangeEach)(r.row,i.row,function(e){o.setBorder(e,i.col,t,n);});break;case"bottom":(0, d.rangeEach)(r.col,i.col,function(e){o.setBorder(i.row,e,t,n);});break;case"left":(0, d.rangeEach)(r.row,i.row,function(e){o.setBorder(e,r.col,t,n);});}});}},{key:"createCustomBorders",value:function(e){var t=this;(0, p.arrayEach)(e,function(e){e.range?t.prepareBorderFromCustomAddedRange(e):t.prepareBorderFromCustomAdded(e.row,e.col,e);});}},{key:"countHide",value:function(e){var t=Object.values(e);return (0, p.arrayReduce)(t,function(e,t){var n=e;return t.hide&&(n+=1),n},0)}},{key:"clearBordersFromSelectionSettings",value:function(e){var t=(0, p.arrayMap)(this.hot.selection.highlight.customSelections,function(e){return e.settings.id}).indexOf(e);t>-1&&this.hot.selection.highlight.customSelections[t].clear(),this.hot.view.wt.draw(!0);}},{key:"clearNullCellRange",value:function(){var e=this;(0, p.arrayEach)(this.hot.selection.highlight.customSelections,function(t,n){if(null===t.cellRange)return e.hot.selection.highlight.customSelections.splice(n,1),!1});}},{key:"hideBorders",value:function(){var e=this;(0, p.arrayEach)(this.savedBorders,function(t){e.clearBordersFromSelectionSettings(t.id);});}},{key:"spliceBorder",value:function(e){var t=(0, p.arrayMap)(this.savedBorders,function(e){return e.id}).indexOf(e);t>-1&&this.savedBorders.splice(t,1);}},{key:"checkSavedBorders",value:function(e){var t=this,n=!1;return 4===this.countHide(e)?(this.spliceBorder(e.id),n=!0):(0, p.arrayEach)(this.savedBorders,function(o,r){if(e.id===o.id)return t.savedBorders[r]=e,n=!0,!1}),n}},{key:"checkCustomSelectionsFromContextMenu",value:function(e,t,n){var o=!1;return (0, p.arrayEach)(this.hot.selection.highlight.customSelections,function(r){if(e.id===r.settings.id)return (0, f.objectEach)(r.instanceBorders,function(e){e.toggleHiddenClass(t,n);}),o=!0,!1}),o}},{key:"checkCustomSelections",value:function(e,t,n){var o=this.countHide(e),r=!1;return 4===o?(this.removeAllBorders(e.row,e.col),this.clearBordersFromSelectionSettings(e.id),this.clearNullCellRange(),r=!0):(0, p.arrayEach)(this.hot.selection.highlight.customSelections,function(o){if(e.id===o.settings.id)return o.cellRange=t,n&&(0, f.objectEach)(o.instanceBorders,function(t){t.changeBorderStyle(n,e);}),r=!0,!1}),r}},{key:"changeBorderSettings",value:function(){var e=this.hot.getSettings().customBorders;Array.isArray(e)?(e.length||(this.savedBorders=e),this.createCustomBorders(e)):void 0!==e&&this.createCustomBorders(this.savedBorders);}},{key:"onAfterContextMenuDefaultOptions",value:function(e){this.hot.getSettings().customBorders&&e.items.push({name:"---------"},{key:"borders",name:function(){return this.getTranslatedPhrase(m.CONTEXTMENU_ITEMS_BORDERS)},disabled:function(){return this.selection.isSelectedByCorner()},submenu:{items:[(0, y.top)(this),(0, y.right)(this),(0, y.bottom)(this),(0, y.left)(this),(0, y.noBorders)(this)]}});}},{key:"onAfterInit",value:function(){this.changeBorderSettings();}},{key:"destroy",value:function(){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}}]),t}(c.default);(0, h.registerPlugin)("customBorders",b),t.default=b;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0,t.top=t.right=t.noBorders=t.left=t.bottom=void 0;var r=n(583),i=o(r),a=n(584),s=o(a),l=n(585),u=o(l),c=n(586),h=o(c),f=n(587),d=o(f);t.bottom=i.default,t.left=s.default,t.noBorders=u.default,t.right=h.default,t.top=d.default;},function(e,t,n){function o(e){return {key:"borders:bottom",name:function(){var e=this.getTranslatedPhrase(i.CONTEXTMENU_ITEMS_BORDERS_BOTTOM);return (0, a.checkSelectionBorders)(this,"bottom")&&(e=(0, a.markSelected)(e)),e},callback:function(t,n){var o=(0, a.checkSelectionBorders)(this,"bottom");e.prepareBorder(n,"bottom",o);}}}t.__esModule=!0,t.default=o;var r=n(7),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(r),a=n(49);},function(e,t,n){function o(e){return {key:"borders:left",name:function(){var e=this.getTranslatedPhrase(i.CONTEXTMENU_ITEMS_BORDERS_LEFT);return (0, a.checkSelectionBorders)(this,"left")&&(e=(0, a.markSelected)(e)),e},callback:function(t,n){var o=(0, a.checkSelectionBorders)(this,"left");e.prepareBorder(n,"left",o);}}}t.__esModule=!0,t.default=o;var r=n(7),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(r),a=n(49);},function(e,t,n){function o(e){return {key:"borders:no_borders",name:function(){return this.getTranslatedPhrase(i.CONTEXTMENU_ITEMS_REMOVE_BORDERS)},callback:function(t,n){e.prepareBorder(n,"noBorders");},disabled:function(){return !(0, a.checkSelectionBorders)(this)}}}t.__esModule=!0,t.default=o;var r=n(7),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(r),a=n(49);},function(e,t,n){function o(e){return {key:"borders:right",name:function(){var e=this.getTranslatedPhrase(i.CONTEXTMENU_ITEMS_BORDERS_RIGHT);return (0, a.checkSelectionBorders)(this,"right")&&(e=(0, a.markSelected)(e)),e},callback:function(t,n){var o=(0, a.checkSelectionBorders)(this,"right");e.prepareBorder(n,"right",o);}}}t.__esModule=!0,t.default=o;var r=n(7),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(r),a=n(49);},function(e,t,n){function o(e){return {key:"borders:top",name:function(){var e=this.getTranslatedPhrase(i.CONTEXTMENU_ITEMS_BORDERS_TOP);return (0, a.checkSelectionBorders)(this,"top")&&(e=(0, a.markSelected)(e)),e},callback:function(t,n){var o=(0, a.checkSelectionBorders)(this,"top");e.prepareBorder(n,"top",o);}}}t.__esModule=!0,t.default=o;var r=n(7),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(r),a=n(49);},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var s=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},u=n(11),c=o(u),h=n(6),f=o(h),d=n(8),p=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.eventManager=new f.default(n),n.boundaries=null,n.callback=null,n.listening=!1,n}return a(t,e),s(t,[{key:"isEnabled",value:function(){return !!this.hot.getSettings().dragToScroll}},{key:"enablePlugin",value:function(){var e=this;this.enabled||(this.addHook("afterOnCellMouseDown",function(){return e.setupListening()}),this.addHook("afterOnCellCornerMouseDown",function(){return e.setupListening()}),this.registerEvents(),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this));}},{key:"updatePlugin",value:function(){this.disablePlugin(),this.enablePlugin(),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updatePlugin",this).call(this);}},{key:"disablePlugin",value:function(){this.unregisterEvents(),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"setBoundaries",value:function(e){this.boundaries=e;}},{key:"setCallback",value:function(e){this.callback=e;}},{key:"check",value:function(e,t){var n=0,o=0;this.boundaries.top>t?o=t-this.boundaries.top:t>this.boundaries.bottom&&(o=t-this.boundaries.bottom),this.boundaries.left>e?n=e-this.boundaries.left:e>this.boundaries.right&&(n=e-this.boundaries.right),this.callback(n,o);}},{key:"registerEvents",value:function(){var e=this;this.eventManager.addEventListener(document,"mouseup",function(){return e.onMouseUp()}),this.eventManager.addEventListener(document,"mousemove",function(t){return e.onMouseMove(t)});}},{key:"unregisterEvents",value:function(){this.eventManager.clear();}},{key:"setupListening",value:function(){var e=this.hot.view.wt.wtTable.holder;e!==window&&(this.setBoundaries(e.getBoundingClientRect()),this.setCallback(function(t,n){0>t?e.scrollLeft-=50:t>0&&(e.scrollLeft+=50),0>n?e.scrollTop-=20:n>0&&(e.scrollTop+=20);}),this.listening=!0);}},{key:"onMouseMove",value:function(e){this.listening&&this.check(e.clientX,e.clientY);}},{key:"onMouseUp",value:function(){this.listening=!1;}},{key:"destroy",value:function(){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}}]),t}(c.default);(0, d.registerPlugin)("dragToScroll",p),t.default=p;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var s=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},u=n(11),c=o(u),h=n(8),f=n(2),d=n(590),p=o(d),g=n(591),v=o(g);n(592);var m=new WeakMap,y=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return m.set(n,{moveByFreeze:!1,afterFirstUse:!1}),n.frozenColumnsBasePositions=[],n.manualColumnMovePlugin=void 0,n}return a(t,e),s(t,[{key:"isEnabled",value:function(){return !!this.hot.getSettings().manualColumnFreeze}},{key:"enablePlugin",value:function(){var e=this;this.enabled||(this.addHook("afterContextMenuDefaultOptions",function(t){return e.addContextMenuEntry(t)}),this.addHook("afterInit",function(){return e.onAfterInit()}),this.addHook("beforeColumnMove",function(t,n){return e.onBeforeColumnMove(t,n)}),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this));}},{key:"disablePlugin",value:function(){var e=m.get(this);e.afterFirstUse=!1,e.moveByFreeze=!1,l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"updatePlugin",value:function(){this.disablePlugin(),this.enablePlugin(),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updatePlugin",this).call(this);}},{key:"freezeColumn",value:function(e){var t=m.get(this),n=this.hot.getSettings();t.afterFirstUse||(t.afterFirstUse=!0),n.fixedColumnsLeft!==this.hot.countCols()&&e>n.fixedColumnsLeft-1&&(t.moveByFreeze=!0,e!==this.getMovePlugin().columnsMapper.getValueByIndex(e)&&(this.frozenColumnsBasePositions[n.fixedColumnsLeft]=e),this.getMovePlugin().moveColumn(e,n.fixedColumnsLeft),n.fixedColumnsLeft+=1);}},{key:"unfreezeColumn",value:function(e){var t=m.get(this),n=this.hot.getSettings();if(t.afterFirstUse||(t.afterFirstUse=!0),n.fixedColumnsLeft>0&&n.fixedColumnsLeft-1>=e){var o=this.getBestColumnReturnPosition(e);t.moveByFreeze=!0,n.fixedColumnsLeft-=1,this.getMovePlugin().moveColumn(e,o+1);}}},{key:"getMovePlugin",value:function(){return this.manualColumnMovePlugin||(this.manualColumnMovePlugin=this.hot.getPlugin("manualColumnMove")),this.manualColumnMovePlugin}},{key:"getBestColumnReturnPosition",value:function(e){var t=this.getMovePlugin(),n=this.hot.getSettings(),o=n.fixedColumnsLeft,r=t.columnsMapper.getValueByIndex(o),i=void 0;if(null===this.frozenColumnsBasePositions[e]||void 0===this.frozenColumnsBasePositions[e])for(i=t.columnsMapper.getValueByIndex(e);null!==r&&i>=r;)o+=1,r=t.columnsMapper.getValueByIndex(o);else{for(i=this.frozenColumnsBasePositions[e],this.frozenColumnsBasePositions[e]=void 0;null!==r&&i>=r;)o+=1,r=t.columnsMapper.getValueByIndex(o);o=r;}return o-1}},{key:"addContextMenuEntry",value:function(e){e.items.push({name:"---------"},(0, p.default)(this),(0, v.default)(this));}},{key:"onAfterInit",value:function(){this.getMovePlugin().isEnabled()||this.getMovePlugin().enablePlugin();}},{key:"onBeforeColumnMove",value:function(e,t){var n=m.get(this);if(n.afterFirstUse&&!n.moveByFreeze){var o=this.hot.getSettings().fixedColumnsLeft,r=o>t;if(r||(0, f.arrayEach)(e,function(e){if(o>e)return r=!0,!1}),r)return !1}n.moveByFreeze&&(n.moveByFreeze=!1);}},{key:"destroy",value:function(){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}}]),t}(c.default);(0, h.registerPlugin)("manualColumnFreeze",y),t.default=y;},function(e,t,n){function o(e){return {key:"freeze_column",name:function(){return this.getTranslatedPhrase(a.CONTEXTMENU_ITEMS_FREEZE_COLUMN)},callback:function(t,n){var o=r(n,1);e.freezeColumn(o[0].start.col),this.render(),this.view.wt.wtOverlays.adjustElementsSize(!0);},hidden:function(){var e=this.getSelectedRange(),t=!1;return void 0===e?t=!0:e.length>1?t=!0:e[0].from.col===e[0].to.col&&e[0].from.col>this.getSettings().fixedColumnsLeft-1||(t=!0),t}}}t.__esModule=!0;var r=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();t.default=o;var i=n(7),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(i);},function(e,t,n){function o(e){return {key:"unfreeze_column",name:function(){return this.getTranslatedPhrase(a.CONTEXTMENU_ITEMS_UNFREEZE_COLUMN)},callback:function(t,n){var o=r(n,1);e.unfreezeColumn(o[0].start.col),this.render(),this.view.wt.wtOverlays.adjustElementsSize(!0);},hidden:function(){var e=this.getSelectedRange(),t=!1;return void 0===e?t=!0:e.length>1?t=!0:e[0].from.col===e[0].to.col&&e[0].from.col<this.getSettings().fixedColumnsLeft||(t=!0),t}}}t.__esModule=!0;var r=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();t.default=o;var i=n(7),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(i);},function(e,t){},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);e.length>t;t++)n[t]=e[t];return n}return Array.from(e)}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function a(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var l=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),u=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},c=n(11),h=o(c),f=n(16),d=o(f),p=n(2),g=n(0),v=n(5),m=n(6),y=o(m),w=n(8),C=n(594),b=o(C),_=n(595),S=o(_),E=n(596),O=o(E);n(597),d.default.getSingleton().register("beforeColumnMove"),d.default.getSingleton().register("afterColumnMove"),d.default.getSingleton().register("unmodifyCol");var T=new WeakMap,k=function(e){function t(e){i(this,t);var n=a(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return T.set(n,{columnsToMove:[],countCols:0,fixedColumns:0,pressed:void 0,disallowMoving:void 0,target:{eventPageX:void 0,coords:void 0,TD:void 0,col:void 0}}),n.removedColumns=[],n.columnsMapper=new b.default(n),n.eventManager=new y.default(n),n.backlight=new S.default(e),n.guideline=new O.default(e),n}return s(t,e),l(t,[{key:"isEnabled",value:function(){return !!this.hot.getSettings().manualColumnMove}},{key:"enablePlugin",value:function(){var e=this;this.enabled||(this.addHook("beforeOnCellMouseDown",function(t,n,o,r){return e.onBeforeOnCellMouseDown(t,n,o,r)}),this.addHook("beforeOnCellMouseOver",function(t,n,o,r){return e.onBeforeOnCellMouseOver(t,n,o,r)}),this.addHook("afterScrollVertically",function(){return e.onAfterScrollVertically()}),this.addHook("modifyCol",function(t,n){return e.onModifyCol(t,n)}),this.addHook("beforeRemoveCol",function(t,n){return e.onBeforeRemoveCol(t,n)}),this.addHook("afterRemoveCol",function(){return e.onAfterRemoveCol()}),this.addHook("afterCreateCol",function(t,n){return e.onAfterCreateCol(t,n)}),this.addHook("afterLoadData",function(){return e.onAfterLoadData()}),this.addHook("unmodifyCol",function(t){return e.onUnmodifyCol(t)}),this.registerEvents(),(0, g.addClass)(this.hot.rootElement,"ht__manualColumnMove"),u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this));}},{key:"updatePlugin",value:function(){this.disablePlugin(),this.enablePlugin(),this.onAfterPluginsInitialized(),u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updatePlugin",this).call(this);}},{key:"disablePlugin",value:function(){var e=this.hot.getSettings().manualColumnMove;Array.isArray(e)&&this.columnsMapper.clearMap(),(0, g.removeClass)(this.hot.rootElement,"ht__manualColumnMove"),this.unregisterEvents(),this.backlight.destroy(),this.guideline.destroy(),u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"moveColumn",value:function(e,t){this.moveColumns([e],t);}},{key:"moveColumns",value:function(e,t){var n=this,o=[].concat(r(e)),i=T.get(this),a=this.hot.runHooks("beforeColumnMove",o,t);i.disallowMoving=!a,!1!==a&&((0, p.arrayEach)(e,function(e,t,o){o[t]=n.columnsMapper.getValueByIndex(e);}),(0, p.arrayEach)(e,function(e,o){var r=n.columnsMapper.getIndexByValue(e);r!==t&&n.columnsMapper.moveColumn(r,t+o);}),this.columnsMapper.clearNull()),this.hot.runHooks("afterColumnMove",o,t);}},{key:"changeSelection",value:function(e,t){this.hot.selectColumns(e,t);}},{key:"getColumnsWidth",value:function(e,t){for(var n=0,o=e;t>o;o++){var r=0;r=0>o?this.hot.view.wt.wtViewport.getRowHeaderWidth()||0:this.hot.view.wt.wtTable.getStretchedColumnWidth(o)||0,n+=r;}return n}},{key:"initialSettings",value:function(){var e=this.hot.getSettings().manualColumnMove;Array.isArray(e)?this.moveColumns(e,0):void 0!==e&&this.persistentStateLoad();}},{key:"isFixedColumnsLeft",value:function(e){return e<this.hot.getSettings().fixedColumnsLeft}},{key:"persistentStateSave",value:function(){this.hot.runHooks("persistentStateSave","manualColumnMove",this.columnsMapper._arrayMap);}},{key:"persistentStateLoad",value:function(){var e={};this.hot.runHooks("persistentStateLoad","manualColumnMove",e),e.value&&(this.columnsMapper._arrayMap=e.value);}},{key:"prepareColumnsToMoving",value:function(e,t){var n=[];return (0, v.rangeEach)(e,t,function(e){n.push(e);}),n}},{key:"refreshPositions",value:function(){var e=T.get(this),t=this.hot.view.wt.wtTable.getFirstVisibleColumn(),n=this.hot.view.wt.wtTable.getLastVisibleColumn(),o=this.hot.view.wt.wtTable,r=this.hot.view.wt.wtOverlays.scrollableElement,i="number"==typeof r.scrollX?r.scrollX:r.scrollLeft,a=this.hot.view.THEAD.offsetLeft+this.getColumnsWidth(0,e.coordsColumn),s=e.target.eventPageX-(e.rootElementOffset-(void 0===r.scrollX?i:0)),l=o.hider.offsetWidth,u=o.TBODY.offsetLeft,c=this.backlight.getOffset().left,h=this.backlight.getSize().width,f=0;if(e.target.eventPageX>e.rootElementOffset+o.holder.offsetWidth+i&&e.countCols>e.coordsColumn&&(e.coordsColumn+=1),e.hasRowHeaders&&(f=this.hot.view.wt.wtOverlays.leftOverlay.clone.wtTable.getColumnHeader(-1).offsetWidth),this.isFixedColumnsLeft(e.coordsColumn)&&(a+=i),a+=f,0>e.coordsColumn)e.target.col=e.fixedColumns>0?0:t>0?t-1:t;else if(s<e.target.TD.offsetWidth/2+a)(e.target.col=e.coordsColumn)>t||e.fixedColumns>e.target.col||0>=t||this.hot.scrollViewportTo(void 0,t-1);else{var d=e.countCols>e.coordsColumn?e.coordsColumn:e.countCols-1;e.target.col=d+1,a+=e.target.TD.offsetWidth,e.target.col>n&&e.countCols>n&&this.hot.scrollViewportTo(void 0,n+1,void 0,!0);}e.target.col>t||e.fixedColumns>e.target.col||0>=t||this.hot.scrollViewportTo(void 0,t-1);var p=s,g=a;l>s+h+c?u+f>s+c&&(p=u+f+Math.abs(c)):p=l-h-c,l-1>a?0===g?g=1:void 0!==r.scrollX&&e.fixedColumns>e.coordsColumn&&(g-=e.rootElementOffset>r.scrollX?0:e.rootElementOffset):g=l-1,this.backlight.setPosition(null,p),this.guideline.setPosition(null,g);}},{key:"updateColumnsMapper",value:function(){var e=this.hot.countSourceCols(),t=this.columnsMapper._arrayMap.length;if(0===t)this.columnsMapper.createMap(e||this.hot.getSettings().startCols);else if(e>t){var n=e-t;this.columnsMapper.insertItems(t,n);}else if(t>e){var o=e-1,r=[];(0, p.arrayEach)(this.columnsMapper._arrayMap,function(e,t){e>o&&r.push(t);}),this.columnsMapper.removeItems(r);}}},{key:"registerEvents",value:function(){var e=this;this.eventManager.addEventListener(document.documentElement,"mousemove",function(t){return e.onMouseMove(t)}),this.eventManager.addEventListener(document.documentElement,"mouseup",function(){return e.onMouseUp()});}},{key:"unregisterEvents",value:function(){this.eventManager.clear();}},{key:"onBeforeOnCellMouseDown",value:function(e,t,n,o){var r=this.hot.view.wt.wtTable,i=this.hot.selection.isSelectedByColumnHeader(),a=this.hot.getSelectedRangeLast(),s=T.get(this),l=e.realTarget.className.indexOf("sortAction")>-1;if(!a||!i||s.pressed||0!==e.button||l)return s.pressed=!1,s.columnsToMove.length=0,void(0, g.removeClass)(this.hot.rootElement,["on-moving--columns","show-ui"]);var u=this.guideline.isBuilt()&&!this.guideline.isAppended(),c=this.backlight.isBuilt()&&!this.backlight.isAppended();u&&c&&(this.guideline.appendTo(r.hider),this.backlight.appendTo(r.hider));var h=a.from,f=a.to,d=Math.min(h.col,f.col),p=Math.max(h.col,f.col);if(0<=t.row||t.col<d||p<t.col)(0, g.removeClass)(this.hot.rootElement,"after-selection--columns"),s.pressed=!1,s.columnsToMove.length=0;else{o.column=!0,s.pressed=!0,s.target.eventPageX=e.pageX,s.coordsColumn=t.col,s.target.TD=n,s.target.col=t.col,s.columnsToMove=this.prepareColumnsToMoving(d,p),s.hasRowHeaders=!!this.hot.getSettings().rowHeaders,s.countCols=this.hot.countCols(),s.fixedColumns=this.hot.getSettings().fixedColumnsLeft,s.rootElementOffset=(0, g.offset)(this.hot.rootElement).left;var v=s.hasRowHeaders?-1:0,m=r.holder.scrollTop+r.getColumnHeaderHeight(0)+1,y=s.fixedColumns>t.col,w=this.hot.view.wt.wtOverlays.scrollableElement,C=w.scrollX?w.scrollX-s.rootElementOffset:0,b=e.layerX-(y?C:0),_=Math.abs(this.getColumnsWidth(d,t.col)+b);this.backlight.setPosition(m,this.getColumnsWidth(v,d)+_),this.backlight.setSize(this.getColumnsWidth(d,p+1),r.hider.offsetHeight-m),this.backlight.setOffset(null,-1*_),(0, g.addClass)(this.hot.rootElement,"on-moving--columns");}}},{key:"onMouseMove",value:function(e){var t=T.get(this);if(t.pressed){if(e.realTarget===this.backlight.element){var n=this.backlight.getSize().width;this.backlight.setSize(0),setTimeout(function(){this.backlight.setPosition(n);});}t.target.eventPageX=e.pageX,this.refreshPositions();}}},{key:"onBeforeOnCellMouseOver",value:function(e,t,n,o){var r=this.hot.getSelectedRangeLast(),i=T.get(this);r&&i.pressed&&(i.columnsToMove.indexOf(t.col)>-1?(0, g.removeClass)(this.hot.rootElement,"show-ui"):(0, g.addClass)(this.hot.rootElement,"show-ui"),o.row=!0,o.column=!0,o.cell=!0,i.coordsColumn=t.col,i.target.TD=n);}},{key:"onMouseUp",value:function(){var e=T.get(this);if(e.coordsColumn=void 0,e.pressed=!1,e.backlightWidth=0,(0, g.removeClass)(this.hot.rootElement,["on-moving--columns","show-ui","after-selection--columns"]),this.hot.selection.isSelectedByColumnHeader()&&(0, g.addClass)(this.hot.rootElement,"after-selection--columns"),e.columnsToMove.length>=1&&void 0!==e.target.col&&-1>=e.columnsToMove.indexOf(e.target.col)){if(this.moveColumns(e.columnsToMove,e.target.col),this.persistentStateSave(),this.hot.render(),this.hot.view.wt.wtOverlays.adjustElementsSize(!0),!e.disallowMoving){this.changeSelection(this.columnsMapper.getIndexByValue(e.columnsToMove[0]),this.columnsMapper.getIndexByValue(e.columnsToMove[e.columnsToMove.length-1]));}e.columnsToMove.length=0;}}},{key:"onAfterScrollVertically",value:function(){var e=this.hot.view.wt.wtTable,t=e.getColumnHeaderHeight(0)+1,n=e.holder.scrollTop,o=t+n;this.backlight.setPosition(o),this.backlight.setSize(null,e.hider.offsetHeight-o);}},{key:"onAfterCreateCol",value:function(e,t){this.columnsMapper.shiftItems(e,t);}},{key:"onBeforeRemoveCol",value:function(e,t){var n=this;this.removedColumns.length=0,!1!==e&&(0, v.rangeEach)(e,e+t-1,function(e){n.removedColumns.push(n.hot.runHooks("modifyCol",e,n.pluginName));});}},{key:"onAfterRemoveCol",value:function(){this.columnsMapper.unshiftItems(this.removedColumns);}},{key:"onAfterLoadData",value:function(){this.updateColumnsMapper();}},{key:"onModifyCol",value:function(e,t){var n=e;if(t!==this.pluginName){var o=this.columnsMapper.getValueByIndex(n);n=null===o?n:o;}return n}},{key:"onUnmodifyCol",value:function(e){var t=this.columnsMapper.getIndexByValue(e);return null===t?e:t}},{key:"onAfterPluginsInitialized",value:function(){this.updateColumnsMapper(),this.initialSettings(),this.backlight.build(),this.guideline.build();}},{key:"destroy",value:function(){this.backlight.destroy(),this.guideline.destroy(),u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}}]),t}(h.default);(0, w.registerPlugin)("ManualColumnMove",k),t.default=k;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(95),a=function(e){return e&&e.__esModule?e:{default:e}}(i),s=n(2),l=n(1),u=n(5),c=function(){function e(t){o(this,e),this.manualColumnMove=t;}return r(e,[{key:"createMap",value:function(e){var t=this,n=void 0===e?this._arrayMap.length:e;this._arrayMap.length=0,(0, u.rangeEach)(n-1,function(e){t._arrayMap[e]=e;});}},{key:"destroy",value:function(){this._arrayMap=null;}},{key:"moveColumn",value:function(e,t){var n=this._arrayMap[e];this._arrayMap[e]=null,this._arrayMap.splice(t,0,n);}},{key:"clearNull",value:function(){this._arrayMap=(0, s.arrayFilter)(this._arrayMap,function(e){return null!==e});}}]),e}();(0, l.mixin)(c,a.default),t.default=c;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},l=n(450),u=function(e){return e&&e.__esModule?e:{default:e}}(l),c=n(0);t.default=function(e){function t(){return o(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return i(t,e),a(t,[{key:"build",value:function(){s(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"build",this).call(this),(0, c.addClass)(this._element,"ht__manualColumnMove--backlight");}}]),t}(u.default);},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},l=n(450),u=function(e){return e&&e.__esModule?e:{default:e}}(l),c=n(0);t.default=function(e){function t(){return o(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return i(t,e),a(t,[{key:"build",value:function(){s(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"build",this).call(this),(0, c.addClass)(this._element,"ht__manualColumnMove--guideline");}}]),t}(u.default);},function(e,t){},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var s=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},u=n(11),c=o(u),h=n(0),f=n(6),d=o(f),p=n(12),g=n(2),v=n(5),m=n(8),y=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.currentTH=null,n.currentCol=null,n.selectedCols=[],n.currentWidth=null,n.newSize=null,n.startY=null,n.startWidth=null,n.startOffset=null,n.handle=document.createElement("DIV"),n.guide=document.createElement("DIV"),n.eventManager=new d.default(n),n.pressed=null,n.dblclick=0,n.autoresizeTimeout=null,n.manualColumnWidths=[],(0, h.addClass)(n.handle,"manualColumnResizer"),(0, h.addClass)(n.guide,"manualColumnResizerGuide"),n}return a(t,e),s(t,[{key:"isEnabled",value:function(){return this.hot.getSettings().manualColumnResize}},{key:"enablePlugin",value:function(){var e=this;if(!this.enabled){this.manualColumnWidths=[];var n=this.hot.getSettings().manualColumnResize,o=this.loadManualColumnWidths();this.addHook("modifyColWidth",function(t,n){return e.onModifyColWidth(t,n)}),this.addHook("beforeStretchingColumnWidth",function(t,n){return e.onBeforeStretchingColumnWidth(t,n)}),this.addHook("beforeColumnResize",function(t,n,o){return e.onBeforeColumnResize(t,n,o)}),this.manualColumnWidths=void 0!==o?o:Array.isArray(n)?n:[],this.bindEvents(),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this);}}},{key:"updatePlugin",value:function(){var e=this.hot.getSettings().manualColumnResize;Array.isArray(e)?this.manualColumnWidths=e:e||(this.manualColumnWidths=[]);}},{key:"disablePlugin",value:function(){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"saveManualColumnWidths",value:function(){this.hot.runHooks("persistentStateSave","manualColumnWidths",this.manualColumnWidths);}},{key:"loadManualColumnWidths",value:function(){var e={};return this.hot.runHooks("persistentStateLoad","manualColumnWidths",e),e.value}},{key:"setupHandlePosition",value:function(e){var t=this;if(!e.parentNode)return !1;this.currentTH=e;var n=this.hot.view.wt.wtTable.getCoords(e).col,o=(0, h.outerHeight)(this.currentTH);if(n>=0){var r=this.currentTH.getBoundingClientRect();if(this.currentCol=n,this.selectedCols=[],this.hot.selection.isSelected()&&this.hot.selection.isSelectedByColumnHeader()){var i=this.hot.getSelectedRangeLast(),a=i.from,s=i.to,l=a.col,u=s.col;u>l||(l=s.col,u=a.col),l>this.currentCol||this.currentCol>u?this.selectedCols.push(this.currentCol):(0, v.rangeEach)(l,u,function(e){return t.selectedCols.push(e)});}else this.selectedCols.push(this.currentCol);this.startOffset=r.left-6,this.startWidth=parseInt(r.width,10),this.handle.style.top=r.top+"px",this.handle.style.left=this.startOffset+this.startWidth+"px",this.handle.style.height=o+"px",this.hot.rootElement.appendChild(this.handle);}}},{key:"refreshHandlePosition",value:function(){this.handle.style.left=this.startOffset+this.currentWidth+"px";}},{key:"setupGuidePosition",value:function(){var e=parseInt((0, h.outerHeight)(this.handle),10),t=parseInt(this.handle.style.top,10)+e,n=parseInt(this.hot.view.maximumVisibleElementHeight(0),10);(0, h.addClass)(this.handle,"active"),(0, h.addClass)(this.guide,"active"),this.guide.style.top=t+"px",this.guide.style.left=this.handle.style.left,this.guide.style.height=n-e+"px",this.hot.rootElement.appendChild(this.guide);}},{key:"refreshGuidePosition",value:function(){this.guide.style.left=this.handle.style.left;}},{key:"hideHandleAndGuide",value:function(){(0, h.removeClass)(this.handle,"active"),(0, h.removeClass)(this.guide,"active");}},{key:"checkIfColumnHeader",value:function(e){if(e!==this.hot.rootElement){var t=e.parentNode;return "THEAD"===t.tagName||this.checkIfColumnHeader(t)}return !1}},{key:"getTHFromTargetElement",value:function(e){return "TABLE"!==e.tagName?"TH"===e.tagName?e:this.getTHFromTargetElement(e.parentNode):null}},{key:"onMouseOver",value:function(e){if(this.checkIfColumnHeader(e.target)){var t=this.getTHFromTargetElement(e.target);if(!t)return;var n=t.getAttribute("colspan");!t||null!==n&&1!==n||this.pressed||this.setupHandlePosition(t);}}},{key:"afterMouseDownTimeout",value:function(){var e=this,t=function(){e.hot.forceFullRender=!0,e.hot.view.render(),e.hot.view.wt.wtOverlays.adjustElementsSize(!0);},n=function(n,o){var r=e.hot.runHooks("beforeColumnResize",n,e.newSize,!0);void 0!==r&&(e.newSize=r),"all"===e.hot.getSettings().stretchH?e.clearManualSize(n):e.setManualSize(n,e.newSize),o&&t(),e.saveManualColumnWidths(),e.hot.runHooks("afterColumnResize",n,e.newSize,!0);};if(this.dblclick>=2){this.selectedCols.length>1?((0, g.arrayEach)(this.selectedCols,function(e){n(e);}),t()):(0, g.arrayEach)(this.selectedCols,function(e){n(e,!0);});}this.dblclick=0,this.autoresizeTimeout=null;}},{key:"onMouseDown",value:function(e){var t=this;(0, h.hasClass)(e.target,"manualColumnResizer")&&(this.setupGuidePosition(),this.pressed=this.hot,null===this.autoresizeTimeout&&(this.autoresizeTimeout=setTimeout(function(){return t.afterMouseDownTimeout()},500),this.hot._registerTimeout(this.autoresizeTimeout)),this.dblclick+=1,this.startX=(0, p.pageX)(e),this.newSize=this.startWidth);}},{key:"onMouseMove",value:function(e){var t=this;this.pressed&&(this.currentWidth=this.startWidth+((0, p.pageX)(e)-this.startX),(0, g.arrayEach)(this.selectedCols,function(e){t.newSize=t.setManualSize(e,t.currentWidth);}),this.refreshHandlePosition(),this.refreshGuidePosition());}},{key:"onMouseUp",value:function(){var e=this,t=function(){e.hot.forceFullRender=!0,e.hot.view.render(),e.hot.view.wt.wtOverlays.adjustElementsSize(!0);},n=function(n,o){e.hot.runHooks("beforeColumnResize",n,e.newSize,!1),o&&t(),e.saveManualColumnWidths(),e.hot.runHooks("afterColumnResize",n,e.newSize);};if(this.pressed){if(this.hideHandleAndGuide(),this.pressed=!1,this.newSize!==this.startWidth){this.selectedCols.length>1?((0, g.arrayEach)(this.selectedCols,function(e){n(e);}),t()):(0, g.arrayEach)(this.selectedCols,function(e){n(e,!0);});}this.setupHandlePosition(this.currentTH);}}},{key:"bindEvents",value:function(){var e=this;this.eventManager.addEventListener(this.hot.rootElement,"mouseover",function(t){return e.onMouseOver(t)}),this.eventManager.addEventListener(this.hot.rootElement,"mousedown",function(t){return e.onMouseDown(t)}),this.eventManager.addEventListener(window,"mousemove",function(t){return e.onMouseMove(t)}),this.eventManager.addEventListener(window,"mouseup",function(){return e.onMouseUp()});}},{key:"setManualSize",value:function(e,t){var n=Math.max(t,20);return this.manualColumnWidths[this.hot.runHooks("modifyCol",e)]=n,n}},{key:"clearManualSize",value:function(e){this.manualColumnWidths[this.hot.runHooks("modifyCol",e)]=void 0;}},{key:"onModifyColWidth",value:function(e,t){var n=e;if(this.enabled){var o=this.hot.runHooks("modifyCol",t),r=this.manualColumnWidths[o];this.hot.getSettings().manualColumnResize&&r&&(n=r);}return n}},{key:"onBeforeStretchingColumnWidth",value:function(e,t){var n=this.manualColumnWidths[t];return void 0===n&&(n=e),n}},{key:"onBeforeColumnResize",value:function(){this.hot.view.wt.wtViewport.hasOversizedColumnHeadersMarked={};}}]),t}(c.default);(0, m.registerPlugin)("manualColumnResize",y),t.default=y;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);e.length>t;t++)n[t]=e[t];return n}return Array.from(e)}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function a(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var l=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),u=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},c=n(11),h=o(c),f=n(16),d=o(f),p=n(2),g=n(0),v=n(5),m=n(6),y=o(m),w=n(8),C=n(600),b=o(C),_=n(601),S=o(_),E=n(602),O=o(E);n(603),d.default.getSingleton().register("beforeRowMove"),d.default.getSingleton().register("afterRowMove"),d.default.getSingleton().register("unmodifyRow");var T=new WeakMap,k=function(e){function t(e){i(this,t);var n=a(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return T.set(n,{rowsToMove:[],pressed:void 0,disallowMoving:void 0,target:{eventPageY:void 0,coords:void 0,TD:void 0,row:void 0}}),n.removedRows=[],n.rowsMapper=new b.default(n),n.eventManager=new y.default(n),n.backlight=new S.default(e),n.guideline=new O.default(e),n}return s(t,e),l(t,[{key:"isEnabled",value:function(){return !!this.hot.getSettings().manualRowMove}},{key:"enablePlugin",value:function(){var e=this;this.enabled||(this.addHook("beforeOnCellMouseDown",function(t,n,o,r){return e.onBeforeOnCellMouseDown(t,n,o,r)}),this.addHook("beforeOnCellMouseOver",function(t,n,o,r){return e.onBeforeOnCellMouseOver(t,n,o,r)}),this.addHook("afterScrollHorizontally",function(){return e.onAfterScrollHorizontally()}),this.addHook("modifyRow",function(t,n){return e.onModifyRow(t,n)}),this.addHook("beforeRemoveRow",function(t,n){return e.onBeforeRemoveRow(t,n)}),this.addHook("afterRemoveRow",function(){return e.onAfterRemoveRow()}),this.addHook("afterCreateRow",function(t,n){return e.onAfterCreateRow(t,n)}),this.addHook("afterLoadData",function(){return e.onAfterLoadData()}),this.addHook("beforeColumnSort",function(t,n){return e.onBeforeColumnSort(t,n)}),this.addHook("unmodifyRow",function(t){return e.onUnmodifyRow(t)}),this.registerEvents(),(0, g.addClass)(this.hot.rootElement,"ht__manualRowMove"),u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this));}},{key:"updatePlugin",value:function(){this.disablePlugin(),this.enablePlugin(),this.onAfterPluginsInitialized(),u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updatePlugin",this).call(this);}},{key:"disablePlugin",value:function(){var e=this.hot.getSettings().manualRowMove;Array.isArray(e)&&this.rowsMapper.clearMap(),(0, g.removeClass)(this.hot.rootElement,"ht__manualRowMove"),this.unregisterEvents(),this.backlight.destroy(),this.guideline.destroy(),u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"moveRow",value:function(e,t){this.moveRows([e],t);}},{key:"moveRows",value:function(e,t){var n=this,o=[].concat(r(e)),i=T.get(this);i.disallowMoving=!1===this.hot.runHooks("beforeRowMove",o,t),i.disallowMoving||((0, p.arrayEach)(e,function(e,t,o){o[t]=n.rowsMapper.getValueByIndex(e);}),(0, p.arrayEach)(e,function(e,o){var r=n.rowsMapper.getIndexByValue(e);r!==t&&n.rowsMapper.moveRow(r,t+o);}),this.rowsMapper.clearNull()),this.hot.runHooks("afterRowMove",o,t);}},{key:"changeSelection",value:function(e,t){this.hot.selectRows(e,t);}},{key:"getRowsHeight",value:function(e,t){for(var n=0,o=e;t>o;o++){n+=this.hot.view.wt.wtTable.getRowHeight(o)||23;}return n}},{key:"initialSettings",value:function(){var e=this.hot.getSettings().manualRowMove;if(Array.isArray(e))this.moveRows(e,0);else if(void 0!==e){var t=this.persistentStateLoad();t.length&&this.moveRows(t,0);}}},{key:"isFixedRowTop",value:function(e){return e<this.hot.getSettings().fixedRowsTop}},{key:"isFixedRowBottom",value:function(e){return e>this.hot.getSettings().fixedRowsBottom}},{key:"persistentStateSave",value:function(){this.hot.runHooks("persistentStateSave","manualRowMove",this.rowsMapper._arrayMap);}},{key:"persistentStateLoad",value:function(){var e={};return this.hot.runHooks("persistentStateLoad","manualRowMove",e),e.value?e.value:[]}},{key:"prepareRowsToMoving",value:function(){var e=this.hot.getSelectedRangeLast(),t=[];if(!e)return t;var n=e.from,o=e.to,r=Math.min(n.row,o.row),i=Math.max(n.row,o.row);return (0, v.rangeEach)(r,i,function(e){t.push(e);}),t}},{key:"refreshPositions",value:function(){var e=T.get(this),t=e.target.coords,n=this.hot.view.wt.wtTable.getFirstVisibleRow(),o=this.hot.view.wt.wtTable.getLastVisibleRow(),r=this.hot.getSettings().fixedRowsTop,i=this.hot.countRows();r>t.row&&n>0&&this.hot.scrollViewportTo(n-1),t.row>=o&&i>o&&this.hot.scrollViewportTo(o+1,void 0,!0);var a=this.hot.view.wt.wtTable,s=e.target.TD,l=(0, g.offset)(this.hot.rootElement),u=this.hot.view.THEAD.offsetHeight+this.getRowsHeight(0,t.row),c=e.target.eventPageY-l.top+a.holder.scrollTop,h=a.hider.offsetHeight,f=a.TBODY.offsetTop,d=this.backlight.getOffset().top,p=this.backlight.getSize().height;this.isFixedRowTop(t.row)&&(u+=a.holder.scrollTop),0>t.row?e.target.row=n>0?n-1:n:s.offsetHeight/2+u>c?e.target.row=t.row:(e.target.row=t.row+1,u+=0===t.row?s.offsetHeight-1:s.offsetHeight);var v=c,m=u;h>c+p+d?f>c+d&&(v=f+Math.abs(d)):v=h-p-d,h-1>u||(m=h-1);var y=0;this.hot.view.wt.wtOverlays.topOverlay&&(y=this.hot.view.wt.wtOverlays.topOverlay.clone.wtTable.TABLE.offsetHeight),t.row>=r&&y>m-a.holder.scrollTop&&this.hot.scrollViewportTo(t.row),this.backlight.setPosition(v),this.guideline.setPosition(m);}},{key:"updateRowsMapper",value:function(){var e=this.hot.countSourceRows(),t=this.rowsMapper._arrayMap.length;if(0===t)this.rowsMapper.createMap(e||this.hot.getSettings().startRows);else if(e>t){var n=e-t;this.rowsMapper.insertItems(t,n);}else if(t>e){var o=e-1,r=[];(0, p.arrayEach)(this.rowsMapper._arrayMap,function(e,t){e>o&&r.push(t);}),this.rowsMapper.removeItems(r);}}},{key:"registerEvents",value:function(){var e=this;this.eventManager.addEventListener(document.documentElement,"mousemove",function(t){return e.onMouseMove(t)}),this.eventManager.addEventListener(document.documentElement,"mouseup",function(){return e.onMouseUp()});}},{key:"unregisterEvents",value:function(){this.eventManager.clear();}},{key:"onBeforeColumnSort",value:function(e,t){T.get(this).disallowMoving=void 0!==t;}},{key:"onBeforeOnCellMouseDown",value:function(e,t,n,o){var r=this.hot.view.wt.wtTable,i=this.hot.selection.isSelectedByRowHeader(),a=this.hot.getSelectedRangeLast(),s=T.get(this);if(!a||!i||s.pressed||0!==e.button)return s.pressed=!1,s.rowsToMove.length=0,void(0, g.removeClass)(this.hot.rootElement,["on-moving--rows","show-ui"]);var l=this.guideline.isBuilt()&&!this.guideline.isAppended(),u=this.backlight.isBuilt()&&!this.backlight.isAppended();l&&u&&(this.guideline.appendTo(r.hider),this.backlight.appendTo(r.hider));var c=a.from,h=a.to,f=Math.min(c.row,h.row),d=Math.max(c.row,h.row);if(0<=t.col||t.row<f||d<t.row)(0, g.removeClass)(this.hot.rootElement,"after-selection--rows"),s.pressed=!1,s.rowsToMove.length=0;else{o.row=!0,s.pressed=!0,s.target.eventPageY=e.pageY,s.target.coords=t,s.target.TD=n,s.rowsToMove=this.prepareRowsToMoving();var p=r.holder.scrollLeft+this.hot.view.wt.wtViewport.getRowHeaderWidth();this.backlight.setPosition(null,p),this.backlight.setSize(r.hider.offsetWidth-p,this.getRowsHeight(f,d+1)),this.backlight.setOffset(-1*(this.getRowsHeight(f,t.row)+e.layerY),null),(0, g.addClass)(this.hot.rootElement,"on-moving--rows"),this.refreshPositions();}}},{key:"onMouseMove",value:function(e){var t=T.get(this);if(t.pressed){if(e.realTarget===this.backlight.element){var n=this.backlight.getSize().height;this.backlight.setSize(null,0),setTimeout(function(){this.backlight.setPosition(null,n);});}t.target.eventPageY=e.pageY,this.refreshPositions();}}},{key:"onBeforeOnCellMouseOver",value:function(e,t,n,o){var r=this.hot.getSelectedRangeLast(),i=T.get(this);r&&i.pressed&&(i.rowsToMove.indexOf(t.row)>-1?(0, g.removeClass)(this.hot.rootElement,"show-ui"):(0, g.addClass)(this.hot.rootElement,"show-ui"),o.row=!0,o.column=!0,o.cell=!0,i.target.coords=t,i.target.TD=n);}},{key:"onMouseUp",value:function(){var e=T.get(this),t=e.target.row,n=e.rowsToMove.length;if(e.pressed=!1,e.backlightHeight=0,(0, g.removeClass)(this.hot.rootElement,["on-moving--rows","show-ui","after-selection--rows"]),this.hot.selection.isSelectedByRowHeader()&&(0, g.addClass)(this.hot.rootElement,"after-selection--rows"),n>=1&&void 0!==t&&-1>=e.rowsToMove.indexOf(t)&&e.rowsToMove[n-1]!==t-1){if(this.moveRows(e.rowsToMove,t),this.persistentStateSave(),this.hot.render(),!e.disallowMoving){this.changeSelection(this.rowsMapper.getIndexByValue(e.rowsToMove[0]),this.rowsMapper.getIndexByValue(e.rowsToMove[n-1]));}e.rowsToMove.length=0;}}},{key:"onAfterScrollHorizontally",value:function(){var e=this.hot.view.wt.wtTable,t=this.hot.view.wt.wtViewport.getRowHeaderWidth(),n=e.holder.scrollLeft,o=t+n;this.backlight.setPosition(null,o),this.backlight.setSize(e.hider.offsetWidth-o);}},{key:"onAfterCreateRow",value:function(e,t){this.rowsMapper.shiftItems(e,t);}},{key:"onBeforeRemoveRow",value:function(e,t){var n=this;this.removedRows.length=0,!1!==e&&(0, v.rangeEach)(e,e+t-1,function(e){n.removedRows.push(n.hot.runHooks("modifyRow",e,n.pluginName));});}},{key:"onAfterRemoveRow",value:function(){this.rowsMapper.unshiftItems(this.removedRows);}},{key:"onAfterLoadData",value:function(){this.updateRowsMapper();}},{key:"onModifyRow",value:function(e,t){var n=e;if(t!==this.pluginName){var o=this.rowsMapper.getValueByIndex(n);n=null===o?n:o;}return n}},{key:"onUnmodifyRow",value:function(e){var t=this.rowsMapper.getIndexByValue(e);return null===t?e:t}},{key:"onAfterPluginsInitialized",value:function(){this.updateRowsMapper(),this.initialSettings(),this.backlight.build(),this.guideline.build();}},{key:"destroy",value:function(){this.backlight.destroy(),this.guideline.destroy(),this.rowsMapper.destroy(),u(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}}]),t}(h.default);(0, w.registerPlugin)("ManualRowMove",k),t.default=k;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=n(95),a=function(e){return e&&e.__esModule?e:{default:e}}(i),s=n(2),l=n(1),u=n(5),c=function(){function e(t){o(this,e),this.manualRowMove=t;}return r(e,[{key:"createMap",value:function(e){var t=this,n=void 0===e?this._arrayMap.length:e;this._arrayMap.length=0,(0, u.rangeEach)(n-1,function(e){t._arrayMap[e]=e;});}},{key:"destroy",value:function(){this._arrayMap=null;}},{key:"moveRow",value:function(e,t){var n=this._arrayMap[e];this._arrayMap[e]=null,this._arrayMap.splice(t,0,n);}},{key:"clearNull",value:function(){this._arrayMap=(0, s.arrayFilter)(this._arrayMap,function(e){return null!==e});}}]),e}();(0, l.mixin)(c,a.default),t.default=c;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},l=n(451),u=function(e){return e&&e.__esModule?e:{default:e}}(l),c=n(0);t.default=function(e){function t(){return o(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return i(t,e),a(t,[{key:"build",value:function(){s(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"build",this).call(this),(0, c.addClass)(this._element,"ht__manualRowMove--backlight");}}]),t}(u.default);},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},l=n(451),u=function(e){return e&&e.__esModule?e:{default:e}}(l),c=n(0);t.default=function(e){function t(){return o(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return i(t,e),a(t,[{key:"build",value:function(){s(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"build",this).call(this),(0, c.addClass)(this._element,"ht__manualRowMove--guideline");}}]),t}(u.default);},function(e,t){},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var s=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},u=n(11),c=o(u),h=n(0),f=n(6),d=o(f),p=n(12),g=n(2),v=n(5),m=n(8),y=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.currentTH=null,n.currentRow=null,n.selectedRows=[],n.currentHeight=null,n.newSize=null,n.startY=null,n.startHeight=null,n.startOffset=null,n.handle=document.createElement("DIV"),n.guide=document.createElement("DIV"),n.eventManager=new d.default(n),n.pressed=null,n.dblclick=0,n.autoresizeTimeout=null,n.manualRowHeights=[],(0, h.addClass)(n.handle,"manualRowResizer"),(0, h.addClass)(n.guide,"manualRowResizerGuide"),n}return a(t,e),s(t,[{key:"isEnabled",value:function(){return this.hot.getSettings().manualRowResize}},{key:"enablePlugin",value:function(){var e=this;if(!this.enabled){this.manualRowHeights=[];var n=this.hot.getSettings().manualRowResize,o=this.loadManualRowHeights();this.manualRowHeights=void 0!==o?o:Array.isArray(n)?n:[],this.addHook("modifyRowHeight",function(t,n){return e.onModifyRowHeight(t,n)}),this.bindEvents(),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this);}}},{key:"updatePlugin",value:function(){var e=this.hot.getSettings().manualRowResize;Array.isArray(e)?this.manualRowHeights=e:e||(this.manualRowHeights=[]);}},{key:"disablePlugin",value:function(){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"saveManualRowHeights",value:function(){this.hot.runHooks("persistentStateSave","manualRowHeights",this.manualRowHeights);}},{key:"loadManualRowHeights",value:function(){var e={};return this.hot.runHooks("persistentStateLoad","manualRowHeights",e),e.value}},{key:"setupHandlePosition",value:function(e){var t=this;this.currentTH=e;var n=this.hot.view.wt.wtTable.getCoords(e).row,o=(0, h.outerWidth)(this.currentTH);if(n>=0){var r=this.currentTH.getBoundingClientRect();if(this.currentRow=n,this.selectedRows=[],this.hot.selection.isSelected()&&this.hot.selection.isSelectedByRowHeader()){var i=this.hot.getSelectedRangeLast(),a=i.from,s=i.to,l=a.row,u=s.row;u>l||(l=s.row,u=a.row),l>this.currentRow||this.currentRow>u?this.selectedRows.push(this.currentRow):(0, v.rangeEach)(l,u,function(e){return t.selectedRows.push(e)});}else this.selectedRows.push(this.currentRow);this.startOffset=r.top-6,this.startHeight=parseInt(r.height,10),this.handle.style.left=r.left+"px",this.handle.style.top=this.startOffset+this.startHeight+"px",this.handle.style.width=o+"px",this.hot.rootElement.appendChild(this.handle);}}},{key:"refreshHandlePosition",value:function(){this.handle.style.top=this.startOffset+this.currentHeight+"px";}},{key:"setupGuidePosition",value:function(){var e=parseInt((0, h.outerWidth)(this.handle),10),t=parseInt(this.handle.style.left,10)+e,n=parseInt(this.hot.view.maximumVisibleElementWidth(0),10);(0, h.addClass)(this.handle,"active"),(0, h.addClass)(this.guide,"active"),this.guide.style.top=this.handle.style.top,this.guide.style.left=t+"px",this.guide.style.width=n-e+"px",this.hot.rootElement.appendChild(this.guide);}},{key:"refreshGuidePosition",value:function(){this.guide.style.top=this.handle.style.top;}},{key:"hideHandleAndGuide",value:function(){(0, h.removeClass)(this.handle,"active"),(0, h.removeClass)(this.guide,"active");}},{key:"checkIfRowHeader",value:function(e){if(e!==this.hot.rootElement){var t=e.parentNode;return "TBODY"===t.tagName||this.checkIfRowHeader(t)}return !1}},{key:"getTHFromTargetElement",value:function(e){return "TABLE"!==e.tagName?"TH"===e.tagName?e:this.getTHFromTargetElement(e.parentNode):null}},{key:"onMouseOver",value:function(e){if(this.checkIfRowHeader(e.target)){var t=this.getTHFromTargetElement(e.target);t&&(this.pressed||this.setupHandlePosition(t));}}},{key:"afterMouseDownTimeout",value:function(){var e=this,t=function(){e.hot.forceFullRender=!0,e.hot.view.render(),e.hot.view.wt.wtOverlays.adjustElementsSize(!0);},n=function(n,o){var r=e.hot.runHooks("beforeRowResize",n,e.newSize,!0);void 0!==r&&(e.newSize=r),e.setManualSize(n,e.newSize),o&&t(),e.hot.runHooks("afterRowResize",n,e.newSize,!0);};if(this.dblclick>=2){this.selectedRows.length>1?((0, g.arrayEach)(this.selectedRows,function(e){n(e);}),t()):(0, g.arrayEach)(this.selectedRows,function(e){n(e,!0);});}this.dblclick=0,this.autoresizeTimeout=null;}},{key:"onMouseDown",value:function(e){var t=this;(0, h.hasClass)(e.target,"manualRowResizer")&&(this.setupGuidePosition(),this.pressed=this.hot,null===this.autoresizeTimeout&&(this.autoresizeTimeout=setTimeout(function(){return t.afterMouseDownTimeout()},500),this.hot._registerTimeout(this.autoresizeTimeout)),this.dblclick+=1,this.startY=(0, p.pageY)(e),this.newSize=this.startHeight);}},{key:"onMouseMove",value:function(e){var t=this;this.pressed&&(this.currentHeight=this.startHeight+((0, p.pageY)(e)-this.startY),(0, g.arrayEach)(this.selectedRows,function(e){t.newSize=t.setManualSize(e,t.currentHeight);}),this.refreshHandlePosition(),this.refreshGuidePosition());}},{key:"onMouseUp",value:function(){var e=this,t=function(){e.hot.forceFullRender=!0,e.hot.view.render(),e.hot.view.wt.wtOverlays.adjustElementsSize(!0);},n=function(n,o){e.hot.runHooks("beforeRowResize",n,e.newSize),o&&t(),e.saveManualRowHeights(),e.hot.runHooks("afterRowResize",n,e.newSize,!1);};if(this.pressed){if(this.hideHandleAndGuide(),this.pressed=!1,this.newSize!==this.startHeight){this.selectedRows.length>1?((0, g.arrayEach)(this.selectedRows,function(e){n(e);}),t()):(0, g.arrayEach)(this.selectedRows,function(e){n(e,!0);});}this.setupHandlePosition(this.currentTH);}}},{key:"bindEvents",value:function(){var e=this;this.eventManager.addEventListener(this.hot.rootElement,"mouseover",function(t){return e.onMouseOver(t)}),this.eventManager.addEventListener(this.hot.rootElement,"mousedown",function(t){return e.onMouseDown(t)}),this.eventManager.addEventListener(window,"mousemove",function(t){return e.onMouseMove(t)}),this.eventManager.addEventListener(window,"mouseup",function(){return e.onMouseUp()});}},{key:"setManualSize",value:function(e,t){return this.manualRowHeights[this.hot.runHooks("modifyRow",e)]=t,t}},{key:"onModifyRowHeight",value:function(e,t){if(this.enabled){var n=this.hot.getPlugin("autoRowSize"),o=n?n.heights[t]:null,r=this.hot.runHooks("modifyRow",t),i=this.manualRowHeights[r];if(void 0!==i&&(i===o||i>(e||0)))return i}return e}}]),t}(c.default);(0, m.registerPlugin)("manualRowResize",y),t.default=y;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);e.length>t;t++)n[t]=e[t];return n}return Array.from(e)}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function a(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var l=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),u=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},h=n(11),f=o(h),d=n(16),p=o(d),g=n(8),v=n(12),m=n(4),y=n(606),w=o(y),C=n(98),b=o(C),_=n(607),S=o(_),E=n(608),O=o(E),T=n(609),k=o(T),R=n(2),M=n(1),D=n(58),A=n(5),N=n(452);n(610),p.default.getSingleton().register("beforeMergeCells"),p.default.getSingleton().register("afterMergeCells"),p.default.getSingleton().register("beforeUnmergeCells"),p.default.getSingleton().register("afterUnmergeCells");var P=new WeakMap,H=function(e){function t(e){i(this,t);var n=a(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return P.set(n,{lastDesiredCoords:null}),n.mergedCellsCollection=null,n.autofillCalculations=null,n.selectionCalculations=null,n}return s(t,e),u(t,[{key:"isEnabled",value:function(){return !!this.hot.getSettings().mergeCells}},{key:"enablePlugin",value:function(){var e=this;this.enabled||(this.mergedCellsCollection=new w.default(this),this.autofillCalculations=new S.default(this),this.selectionCalculations=new O.default(this),this.addHook("afterInit",function(){return e.onAfterInit.apply(e,arguments)}),this.addHook("beforeKeyDown",function(){return e.onBeforeKeyDown.apply(e,arguments)}),this.addHook("modifyTransformStart",function(){return e.onModifyTransformStart.apply(e,arguments)}),this.addHook("afterModifyTransformStart",function(){return e.onAfterModifyTransformStart.apply(e,arguments)}),this.addHook("modifyTransformEnd",function(){return e.onModifyTransformEnd.apply(e,arguments)}),this.addHook("modifyGetCellCoords",function(){return e.onModifyGetCellCoords.apply(e,arguments)}),this.addHook("beforeSetRangeEnd",function(){return e.onBeforeSetRangeEnd.apply(e,arguments)}),this.addHook("afterIsMultipleSelection",function(){return e.onAfterIsMultipleSelection.apply(e,arguments)}),this.addHook("afterRenderer",function(){return e.onAfterRenderer.apply(e,arguments)}),this.addHook("afterContextMenuDefaultOptions",function(){return e.addMergeActionsToContextMenu.apply(e,arguments)}),this.addHook("afterGetCellMeta",function(){return e.onAfterGetCellMeta.apply(e,arguments)}),this.addHook("afterViewportRowCalculatorOverride",function(){return e.onAfterViewportRowCalculatorOverride.apply(e,arguments)}),this.addHook("afterViewportColumnCalculatorOverride",function(){return e.onAfterViewportColumnCalculatorOverride.apply(e,arguments)}),this.addHook("modifyAutofillRange",function(){return e.onModifyAutofillRange.apply(e,arguments)}),this.addHook("afterCreateCol",function(){return e.onAfterCreateCol.apply(e,arguments)}),this.addHook("afterRemoveCol",function(){return e.onAfterRemoveCol.apply(e,arguments)}),this.addHook("afterCreateRow",function(){return e.onAfterCreateRow.apply(e,arguments)}),this.addHook("afterRemoveRow",function(){return e.onAfterRemoveRow.apply(e,arguments)}),this.addHook("afterChange",function(){return e.onAfterChange.apply(e,arguments)}),this.addHook("beforeDrawBorders",function(){return e.onBeforeDrawAreaBorders.apply(e,arguments)}),this.addHook("afterDrawSelection",function(){return e.onAfterDrawSelection.apply(e,arguments)}),this.addHook("beforeRemoveCellClassNames",function(){return e.onBeforeRemoveCellClassNames.apply(e,arguments)}),c(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this));}},{key:"disablePlugin",value:function(){this.clearCollections(),this.hot.render(),c(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"updatePlugin",value:function(){var e=this.hot.getSettings().mergeCells;this.disablePlugin(),this.enablePlugin(),this.generateFromSettings(e),c(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updatePlugin",this).call(this);}},{key:"validateSetting",value:function(e){var t=!0;return !!e&&(b.default.containsNegativeValues(e)?((0, D.warn)(b.default.NEGATIVE_VALUES_WARNING(e)),t=!1):b.default.isOutOfBounds(e,this.hot.countRows(),this.hot.countCols())?((0, D.warn)(b.default.IS_OUT_OF_BOUNDS_WARNING(e)),t=!1):b.default.isSingleCell(e)?((0, D.warn)(b.default.IS_SINGLE_CELL(e)),t=!1):b.default.containsZeroSpan(e)&&((0, D.warn)(b.default.ZERO_SPAN_WARNING(e)),t=!1),t)}},{key:"generateFromSettings",value:function(e){var t=this;if(Array.isArray(e)){var n,o=[];(0, R.arrayEach)(e,function(e){if(t.validateSetting(e)){var n=new m.CellCoords(e.row,e.col),r=new m.CellCoords(e.row+e.rowspan-1,e.col+e.colspan-1),i=new m.CellRange(n,n,r);o.push(t.mergeRange(i,!0,!0));}}),o=o.filter(function(e){return !0!==e});var i=this.getBulkCollectionData(o);(n=this.hot).populateFromArray.apply(n,r(i));}}},{key:"getBulkCollectionData",value:function(e){var t,n=this.getBulkCollectionDataRange(e),o=(t=this.hot).getData.apply(t,r(n)),i=o.splice(0);return (0, R.arrayEach)(e,function(e){var t=l(e,3),o=t[0],r=t[1];(0, R.arrayEach)(t[2],function(e,t){(0, R.arrayEach)(e,function(e,a){i[o-n[0]+t][r-n[1]+a]=e;});});}),[n[0],n[1],i]}},{key:"getBulkCollectionDataRange",value:function(e){var t=[0,0],n=[0,0],o=null,r=null,i=null;return (0, R.arrayEach)(e,function(e){o=e[0],r=e[1],i=e[2],t[0]=Math.min(o,t[0]),t[1]=Math.min(r,t[1]),n[0]=Math.max(o+i.length-1,n[0]),n[1]=Math.max(r+i[0].length-1,n[1]);}),[].concat(t,n)}},{key:"clearCollections",value:function(){this.mergedCellsCollection.clear();}},{key:"canMergeRange",value:function(e){return !(1>=arguments.length||void 0===arguments[1]||!arguments[1])||this.validateSetting(e)}},{key:"toggleMergeOnSelection",value:function(){var e=this.hot.getSelectedRangeLast();if(e){e.setDirection("NW-SE");var t=e.from,n=e.to;this.toggleMerge(e),this.hot.selectCell(t.row,t.col,n.row,n.col,!1);}}},{key:"mergeSelection",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.hot.getSelectedRangeLast();if(e){e.setDirection("NW-SE");var t=e.from,n=e.to;this.unmergeRange(e,!0),this.mergeRange(e),this.hot.selectCell(t.row,t.col,n.row,n.col,!1);}}},{key:"unmergeSelection",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.hot.getSelectedRangeLast();if(e){var t=e.from,n=e.to;this.unmergeRange(e,!0),this.hot.selectCell(t.row,t.col,n.row,n.col,!1);}}},{key:"mergeRange",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=e.getTopLeftCorner(),i=e.getBottomRightCorner(),a={row:r.row,col:r.col,rowspan:i.row-r.row+1,colspan:i.col-r.col+1},s=[],l=null;return !!this.canMergeRange(a,n)&&(this.hot.runHooks("beforeMergeCells",e,n),(0, A.rangeEach)(0,a.rowspan-1,function(e){(0, A.rangeEach)(0,a.colspan-1,function(n){var o=null;s[e]||(s[e]=[]),0===e&&0===n?o=t.hot.getDataAtCell(a.row,a.col):t.hot.setCellMeta(a.row+e,a.col+n,"hidden",!0),s[e][n]=o;});}),this.hot.setCellMeta(a.row,a.col,"spanned",!0),!this.mergedCellsCollection.add(a)||(o?l=[a.row,a.col,s]:this.hot.populateFromArray(a.row,a.col,s,void 0,void 0,this.pluginName),this.hot.runHooks("afterMergeCells",e,a,n),l))}},{key:"unmergeRange",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=this.mergedCellsCollection.getWithinRange(e);o&&(this.hot.runHooks("beforeUnmergeCells",e,n),(0, R.arrayEach)(o,function(e){t.mergedCellsCollection.remove(e.row,e.col),(0, A.rangeEach)(0,e.rowspan-1,function(n){(0, A.rangeEach)(0,e.colspan-1,function(o){t.hot.removeCellMeta(e.row+n,e.col+o,"hidden");});}),t.hot.removeCellMeta(e.row,e.col,"spanned");}),this.hot.render(),this.hot.runHooks("afterUnmergeCells",e,n));}},{key:"toggleMerge",value:function(e){var t=this.mergedCellsCollection.get(e.from.row,e.from.col);t.row===e.from.row&&t.col===e.from.col&&t.row+t.rowspan-1===e.to.row&&t.col+t.colspan-1===e.to.col?this.unmergeRange(e):this.mergeSelection(e);}},{key:"merge",value:function(e,t,n,o){var r=new m.CellCoords(e,t),i=new m.CellCoords(n,o);this.mergeRange(new m.CellRange(r,r,i));}},{key:"unmerge",value:function(e,t,n,o){var r=new m.CellCoords(e,t),i=new m.CellCoords(n,o);this.unmergeRange(new m.CellRange(r,r,i));}},{key:"onAfterInit",value:function(){this.generateFromSettings(this.hot.getSettings().mergeCells),this.hot.render();}},{key:"onBeforeKeyDown",value:function(e){(e.ctrlKey||e.metaKey)&&!e.altKey&&77===e.keyCode&&(this.toggleMerge(this.hot.getSelectedRangeLast()),this.hot.render(),(0, v.stopImmediatePropagation)(e));}},{key:"onAfterIsMultipleSelection",value:function(e){if(e)for(var t=this.mergedCellsCollection.mergedCells,n=this.hot.getSelectedRangeLast(),o=0;t.length>o;o+=1)if(n.highlight.row===t[o].row&&n.highlight.col===t[o].col&&n.to.row===t[o].row+t[o].rowspan-1&&n.to.col===t[o].col+t[o].colspan-1)return !1;return e}},{key:"onModifyTransformStart",value:function(e){var t=P.get(this),n=this.hot.getSelectedRangeLast(),o={row:e.row,col:e.col},r=null,i=new m.CellCoords(n.highlight.row,n.highlight.col),a=this.mergedCellsCollection.get(i.row,i.col);if(t.lastDesiredCoords||(t.lastDesiredCoords=new m.CellCoords(null,null)),a){var s=new m.CellCoords(a.row,a.col),l=new m.CellCoords(a.row+a.rowspan-1,a.col+a.colspan-1);new m.CellRange(s,s,l).includes(t.lastDesiredCoords)||(t.lastDesiredCoords=new m.CellCoords(null,null)),o.row=t.lastDesiredCoords.row?t.lastDesiredCoords.row-i.row:o.row,o.col=t.lastDesiredCoords.col?t.lastDesiredCoords.col-i.col:o.col,e.row>0?o.row=a.row+a.rowspan-1-i.row+e.row:0>e.row&&(o.row=i.row-a.row+e.row),e.col>0?o.col=a.col+a.colspan-1-i.col+e.col:0>e.col&&(o.col=i.col-a.col+e.col);}r=new m.CellCoords(n.highlight.row+o.row,n.highlight.col+o.col);var u=this.mergedCellsCollection.get(r.row,r.col);u&&(t.lastDesiredCoords=r,o={row:u.row-i.row,col:u.col-i.col}),0!==o.row&&(e.row=o.row),0!==o.col&&(e.col=o.col);}},{key:"onModifyTransformEnd",value:function(e){var t=this,n=this.hot.getSelectedRangeLast(),o=(0, M.clone)(e),r=this.selectionCalculations.getUpdatedSelectionRange(n,e),i=(0, M.clone)(o),a=this.mergedCellsCollection.getWithinRange(r,!0);do{i=(0, M.clone)(o),this.selectionCalculations.getUpdatedSelectionRange(n,o),(0, R.arrayEach)(a,function(e){t.selectionCalculations.snapDelta(o,n,e);});}while(o.row!==i.row||o.col!==i.col);e.row=o.row,e.col=o.col;}},{key:"onModifyGetCellCoords",value:function(e,t){var n=this.mergedCellsCollection.get(e,t);return n?[n.row,n.col,n.row+n.rowspan-1,n.col+n.colspan-1]:void 0}},{key:"addMergeActionsToContextMenu",value:function(e){e.items.push({name:"---------"},(0, k.default)(this));}},{key:"onAfterRenderer",value:function(e,t,n){var o=this.mergedCellsCollection.get(t,n);(0, N.applySpanProperties)(e,o,t,n);}},{key:"onBeforeSetRangeEnd",value:function(e){var t=this.hot.getSelectedRangeLast();t.highlight=new m.CellCoords(t.highlight.row,t.highlight.col),t.to=e;var n=!1;if(!(0===t.from.row&&t.to.row===this.hot.countRows()-1||0===t.from.col&&t.to.col===this.hot.countCols()-1))do{n=!1;for(var o=0;this.mergedCellsCollection.mergedCells.length>o;o+=1){var r=this.mergedCellsCollection.mergedCells[o],i=r.getRange();t.expandByRange(i)&&(e.row=t.to.row,e.col=t.to.col,n=!0);}}while(n)}},{key:"onAfterGetCellMeta",value:function(e,t,n){var o=this.mergedCellsCollection.get(e,t);!o||o.row===e&&o.col===t||(n.copyable=!1);}},{key:"onAfterViewportRowCalculatorOverride",value:function(e){var t=this,n=this.hot.countCols(),o=void 0;(0, A.rangeEach)(0,n-1,function(n){if((o=t.mergedCellsCollection.get(e.startRow,n))&&e.startRow>o.row)return e.startRow=o.row,t.onAfterViewportRowCalculatorOverride.call(t,e);if(o=t.mergedCellsCollection.get(e.endRow,n)){var r=o.row+o.rowspan-1;if(r>e.endRow)return e.endRow=r,t.onAfterViewportRowCalculatorOverride.call(t,e)}return !0});}},{key:"onAfterViewportColumnCalculatorOverride",value:function(e){var t=this,n=this.hot.countRows(),o=void 0;(0, A.rangeEach)(0,n-1,function(n){if((o=t.mergedCellsCollection.get(n,e.startColumn))&&e.startColumn>o.col)return e.startColumn=o.col,t.onAfterViewportColumnCalculatorOverride.call(t,e);if(o=t.mergedCellsCollection.get(n,e.endColumn)){var r=o.col+o.colspan-1;if(r>e.endColumn)return e.endColumn=r,t.onAfterViewportColumnCalculatorOverride.call(t,e)}return !0});}},{key:"onModifyAutofillRange",value:function(e,t){this.autofillCalculations.correctSelectionAreaSize(t);var n=this.autofillCalculations.getDirection(t,e),o=e;if(this.autofillCalculations.dragAreaOverlapsCollections(t,o,n))return o=t;var r=this.mergedCellsCollection.getWithinRange({from:{row:t[0],col:t[1]},to:{row:t[2],col:t[3]}});return r?o=this.autofillCalculations.snapDragArea(t,o,n,r):o}},{key:"onAfterCreateCol",value:function(e,t){this.mergedCellsCollection.shiftCollections("right",e,t);}},{key:"onAfterRemoveCol",value:function(e,t){this.mergedCellsCollection.shiftCollections("left",e,t);}},{key:"onAfterCreateRow",value:function(e,t,n){"auto"!==n&&this.mergedCellsCollection.shiftCollections("down",e,t);}},{key:"onAfterRemoveRow",value:function(e,t){this.mergedCellsCollection.shiftCollections("up",e,t);}},{key:"onAfterChange",value:function(e,t){"Autofill.fill"===t&&this.autofillCalculations.recreateAfterDataPopulation(e);}},{key:"onBeforeDrawAreaBorders",value:function(e,t){if(t&&"area"===t){var n=this.hot.getSelectedRangeLast(),o=this.mergedCellsCollection.getWithinRange(n);(0, R.arrayEach)(o,function(t){n.getBottomRightCorner().row===t.getLastRow()&&n.getBottomRightCorner().col===t.getLastColumn()&&(e[2]=t.row,e[3]=t.col);});}}},{key:"onAfterModifyTransformStart",value:function(e,t,n){if(this.enabled){var o=this.mergedCellsCollection.get(e.row,e.col);if(o){var r=t>0,i=0>t,a=0>n,s=n>0,l=o.row+o.rowspan-1==this.hot.countRows()-1,u=0===o.row,c=o.col+o.colspan-1==this.hot.countCols()-1,h=0===o.col;(r&&l||i&&u||s&&c||a&&h)&&(e.row=o.row,e.col=o.col);}}}},{key:"onAfterDrawSelection",value:function(e,t,n,o){return this.selectionCalculations.getSelectedMergedCellClassName(e,t,n,o)}},{key:"onBeforeRemoveCellClassNames",value:function(){return this.selectionCalculations.getSelectedMergedCellClassNameToRemove()}}]),t}(f.default);(0, g.registerPlugin)("mergeCells",H),t.default=H;},function(e,t,n){function o(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);e.length>t;t++)n[t]=e[t];return n}return Array.from(e)}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=function(e,t){return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}(["The merged cell declared at [",", ","], overlaps with the other declared merged \n    cell. The overlapping merged cell was not added to the table, please fix your setup."],["The merged cell declared at [",", ","], overlaps with the other declared merged \n    cell. The overlapping merged cell was not added to the table, please fix your setup."]),s=n(98),l=function(e){return e&&e.__esModule?e:{default:e}}(s),u=n(4),c=n(5),h=n(58),f=n(2),d=n(452),p=n(42);t.default=function(){function e(t){r(this,e),this.plugin=t,this.mergedCells=[],this.hot=t.hot;}return i(e,[{key:"get",value:function(e,t){var n=this.mergedCells,o=!1;return (0, f.arrayEach)(n,function(n){return n.row>e||e>n.row+n.rowspan-1||n.col>t||t>n.col+n.colspan-1||(o=n,!1)}),o}},{key:"getByRange",value:function(e){var t=this.mergedCells,n=!1;return (0, f.arrayEach)(t,function(t){return t.row>e.from.row||e.to.row>t.row+t.rowspan-1||t.col>e.from.col||e.to.col>t.col+t.colspan-1||(n=t)}),n}},{key:"getWithinRange",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=this.mergedCells,o=[],r=e;if(!r.includesRange){var i=new u.CellCoords(r.from.row,r.from.col),a=new u.CellCoords(r.to.row,r.to.col);r=new u.CellRange(i,i,a);}return (0, f.arrayEach)(n,function(e){var n=new u.CellCoords(e.row,e.col),i=new u.CellCoords(e.row+e.rowspan-1,e.col+e.colspan-1),a=new u.CellRange(n,n,i);t?r.overlaps(a)&&o.push(e):r.includesRange(a)&&o.push(e);}),!!o.length&&o}},{key:"add",value:function(t){var n=this.mergedCells,o=t.row,r=t.col,i=t.rowspan,a=t.colspan,s=new l.default(o,r,i,a),u=this.get(o,r),c=this.isOverlapping(s);return u||c?((0, h.warn)(e.IS_OVERLAPPING_WARNING(s)),!1):(this.hot&&s.normalize(this.hot),n.push(s),s)}},{key:"remove",value:function(e,t){var n=this.mergedCells,o=this.get(e,t),r=o?this.mergedCells.indexOf(o):null;return !(!o||!1===r)&&(n.splice(r,1),o)}},{key:"clear",value:function(){var e=this,t=this.mergedCells,n=[],r=[];(0, f.arrayEach)(t,function(t){var o=e.hot.getCell(t.row,t.col);o&&n.push([o,e.get(t.row,t.col),t.row,t.col]);}),this.mergedCells.length=0,(0, f.arrayEach)(n,function(t,o){(0, c.rangeEach)(0,t.rowspan-1,function(n){(0, c.rangeEach)(0,t.colspan-1,function(o){if(0!==o||0!==n){var i=e.hot.getCell(t.row+n,t.col+o);i&&r.push([i,null,null,null]);}});}),n[o][1]=null;}),(0, f.arrayEach)(n,function(e){d.applySpanProperties.apply(void 0,o(e));}),(0, f.arrayEach)(r,function(e){d.applySpanProperties.apply(void 0,o(e));});}},{key:"isOverlapping",value:function(e){var t=new u.CellRange(null,new u.CellCoords(e.row,e.col),new u.CellCoords(e.row+e.rowspan-1,e.col+e.colspan-1)),n=!1;return (0, f.arrayEach)(this.mergedCells,function(e){return !new u.CellRange(null,new u.CellCoords(e.row,e.col),new u.CellCoords(e.row+e.rowspan-1,e.col+e.colspan-1)).overlaps(t)||(n=!0,!1)}),n}},{key:"isMergedParent",value:function(e,t){var n=this.mergedCells,o=!1;return (0, f.arrayEach)(n,function(n){return n.row!==e||n.col!==t||(o=!0,!1)}),o}},{key:"shiftCollections",value:function(e,t,n){var o=this,r=[0,0];switch(e){case"right":r[0]+=n;break;case"left":r[0]-=n;break;case"down":r[1]+=n;break;case"up":r[1]-=n;}(0, f.arrayEach)(this.mergedCells,function(e){e.shift(r,t);}),(0, c.rangeEachReverse)(this.mergedCells.length-1,0,function(e){var t=o.mergedCells[e];t&&t.removed&&o.mergedCells.splice(o.mergedCells.indexOf(t),1);});}}],[{key:"IS_OVERLAPPING_WARNING",value:function(e){return (0, p.toSingleLine)(a,e.row,e.col)}}]),e}();},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(1),s=n(4),l=n(2);t.default=function(){function e(t){o(this,e),this.plugin=t,this.mergedCellsCollection=this.plugin.mergedCellsCollection,this.currentFillData=null;}return i(e,[{key:"correctSelectionAreaSize",value:function(e){if(e[0]===e[2]&&e[1]===e[3]){var t=this.mergedCellsCollection.get(e[0],e[1]);t&&(e[2]=e[0]+t.rowspan-1,e[3]=e[1]+t.colspan-1);}}},{key:"getDirection",value:function(e,t){return t[0]===e[0]&&t[1]===e[1]&&t[3]===e[3]?"down":t[2]===e[2]&&t[1]===e[1]&&t[3]===e[3]?"up":t[1]===e[1]&&t[2]===e[2]?"right":"left"}},{key:"snapDragArea",value:function(e,t,n,o){var i=t.slice(0),a=this.getAutofillSize(e,t,n),s=r(e,4),l=s[0],u=s[1],c=s[2],h=s[3],f=["up","down"].indexOf(n)>-1,d=f?c-l+1:h-u+1,p=Math.floor(a/d)*d,g=a-p,v=this.getFarthestCollection(e,t,n,o);if(v)if("down"===n){var m=v.row+v.rowspan-l-g,y=i[2]+m;y<this.plugin.hot.countRows()?i[2]+=g?m:0:i[2]-=g;}else if("right"===n){var w=v.col+v.colspan-u-g,C=i[3]+w;C<this.plugin.hot.countCols()?i[3]+=g?w:0:i[3]-=g;}else if("up"===n){var b=c-g-v.row+1,_=i[0]+b;0>_?i[0]+=g:i[0]-=g?b:0;}else if("left"===n){var S=h-g-v.col+1,E=i[1]+S;0>E?i[1]+=g:i[1]-=g?S:0;}return this.updateCurrentFillCache({baseArea:e,dragDirection:n,foundMergedCells:o,fillSize:a,dragArea:i,cycleLength:d}),i}},{key:"updateCurrentFillCache",value:function(e){this.currentFillData||(this.currentFillData={}),(0, a.extend)(this.currentFillData,e);}},{key:"getAutofillSize",value:function(e,t,n){var o=r(e,4),i=o[0],a=o[1],s=o[2],l=o[3],u=r(t,4),c=u[0],h=u[1],f=u[2],d=u[3];switch(n){case"up":return i-c;case"down":return f-s;case"left":return a-h;case"right":return d-l;default:return null}}},{key:"getDragArea",value:function(e,t,n){var o=r(e,4),i=o[0],a=o[1],s=o[2],l=o[3],u=r(t,4),c=u[0],h=u[1],f=u[2],d=u[3];switch(n){case"up":return [c,h,i-1,l];case"down":return [s+1,a,f,l];case"left":return [c,h,s,a-1];case"right":return [i,l+1,f,d];default:return null}}},{key:"getFarthestCollection",value:function(e,t,n,o){var i=r(e,4),a=i[0],s=i[1],u=i[2],c=i[3],h=["up","down"].indexOf(n)>-1,f=h?u:c,d=h?a:s,p=this.getAutofillSize(e,t,n),g=h?u-a+1:c-s+1,v=Math.floor(p/g)*g,m=p-v,y=null,w=null,C=null;switch(n){case"up":y="includesVertically",C=f-m+1;break;case"left":y="includesHorizontally",C=f-m+1;break;case"down":y="includesVertically",C=d+m-1;break;case"right":y="includesHorizontally",C=d+m-1;}return (0, l.arrayEach)(o,function(e){e[y](C)&&e.isFarther(w,n)&&(w=e);}),w}},{key:"recreateAfterDataPopulation",value:function(e){if(this.currentFillData){var t=this.getRangeFromChanges(e),n=this.currentFillData.foundMergedCells,o=this.currentFillData.dragDirection,r=function(e,n){switch(o){case"up":return e.row-n>=t.from.row;case"down":return t.to.row>=e.row+e.rowspan-1+n;case"left":return e.col-n>=t.from.column;case"right":return t.to.column>=e.col+e.colspan-1+n;default:return null}},i=0,a=null,s=1;do{for(var l=0;n.length>l;l+=1){if(a=n[l],i=s*this.currentFillData.cycleLength,r(a,i))switch(o){case"up":this.plugin.mergedCellsCollection.add({row:a.row-i,rowspan:a.rowspan,col:a.col,colspan:a.colspan});break;case"down":this.plugin.mergedCellsCollection.add({row:a.row+i,rowspan:a.rowspan,col:a.col,colspan:a.colspan});break;case"left":this.plugin.mergedCellsCollection.add({row:a.row,rowspan:a.rowspan,col:a.col-i,colspan:a.colspan});break;case"right":this.plugin.mergedCellsCollection.add({row:a.row,rowspan:a.rowspan,col:a.col+i,colspan:a.colspan});}l===n.length-1&&(s+=1);}}while(r(a,i));this.currentFillData=null,this.plugin.hot.render();}}},{key:"getRangeFromChanges",value:function(e){var t={min:null,max:null},n={min:null,max:null};return (0, l.arrayEach)(e,function(e){(null===t.min||t.min>e[0])&&(t.min=e[0]),(null===t.max||e[0]>t.max)&&(t.max=e[0]),(null===n.min||n.min>e[1])&&(n.min=e[1]),(null===n.max||e[1]>n.max)&&(n.max=e[1]);}),{from:{row:t.min,column:n.min},to:{row:t.max,column:n.max}}}},{key:"dragAreaOverlapsCollections",value:function(e,t,n){var o=this.getDragArea(e,t,n),i=r(o,4),a=i[0],l=i[1],u=i[2],c=i[3],h=new s.CellCoords(a,l),f=new s.CellCoords(u,c);return !!this.mergedCellsCollection.getWithinRange(new s.CellRange(h,h,f),!0)}}]),e}();},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(4);t.default=function(){function e(t){o(this,e),this.plugin=t,this.fullySelectedMergedCellClassName="fullySelectedMergedCell";}return i(e,[{key:"snapDelta",value:function(e,t,n){var o=t.to,r=o.row+e.row,i=o.col+e.col;e.row?this.jumpOverMergedCell(e,n,r):e.col&&this.jumpOverMergedCell(e,n,i);}},{key:"jumpOverMergedCell",value:function(e,t,n){var o=e.row||e.col,r=null,i=null,a=null;e.row?(r=t.includesVertically(n),i=t.row,a=t.getLastRow()):e.col&&(r=t.includesHorizontally(n),i=t.col,a=t.getLastColumn()),0!==o&&(o>0?r&&n!==i&&(o+=a-n+1):r&&n!==a&&(o-=n-i+1),e.row?e.row=o:e.col&&(e.col=o));}},{key:"getUpdatedSelectionRange",value:function(e,t){return new a.CellRange(e.highlight,e.from,new a.CellCoords(e.to.row+t.row,e.to.col+t.col))}},{key:"getSelectedMergedCellClassName",value:function(e,t,n,o){var i=r(n,4),a=i[0],s=i[1],l=i[2],u=i[3];if(void 0!==o&&!(a>e||e>l||s>t||t>u)){if(!this.plugin.mergedCellsCollection.isMergedParent(e,t))return;var c=this.plugin.mergedCellsCollection.get(e,t);if(!c)return;if(l>=c.row+c.rowspan-1&&u>=c.col+c.colspan-1)return this.fullySelectedMergedCellClassName+"-"+o;if(this.plugin.selectionCalculations.isMergeCellFullySelected(c,this.plugin.hot.getSelectedRange()))return this.fullySelectedMergedCellClassName+"-multiple"}}},{key:"isMergeCellFullySelected",value:function(e,t){var n=[];if(!t||!e)return !1;for(var o=0;e.rowspan>o;o+=1)for(var r=0;e.colspan>r;r+=1)n.push(new a.CellCoords(e.row+o,e.col+r));for(var i=0;n.length>i;i+=1){for(var s=[],l=0;t.length>l;l+=1)s[l]=t[l].includes(n[i]);if(!s.includes(!0))return !1}return !0}},{key:"getSelectedMergedCellClassNameToRemove",value:function(){for(var e=[],t=0;7>=t;t+=1)e.push(this.fullySelectedMergedCellClassName+"-"+t);return e.push(this.fullySelectedMergedCellClassName+"-multiple"),e}}]),e}();},function(e,t,n){function o(e){return {key:"mergeCells",name:function(){var t=this.getSelectedLast();if(t){var n=e.mergedCellsCollection.get(t[0],t[1]);if(n.row===t[0]&&n.col===t[1]&&n.row+n.rowspan-1===t[2]&&n.col+n.colspan-1===t[3])return this.getTranslatedPhrase(i.CONTEXTMENU_ITEMS_UNMERGE_CELLS)}return this.getTranslatedPhrase(i.CONTEXTMENU_ITEMS_MERGE_CELLS)},callback:function(){e.toggleMergeOnSelection();},disabled:function(){var e=this.getSelectedLast();return !e||(s.default.isSingleCell({row:e[0],col:e[1],rowspan:e[2]-e[0]+1,colspan:e[3]-e[1]+1})||this.selection.isSelectedByCorner())},hidden:!1}}t.__esModule=!0,t.default=o;var r=n(7),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(r),a=n(98),s=function(e){return e&&e.__esModule?e:{default:e}}(a);},function(e,t){},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var s=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},u=n(0),c=n(35),h=n(11),f=o(h),d=n(6),p=o(d),g=n(8),v=n(4),m=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.dragged=[],n.eventManager=null,n.lastSetCell=null,n}return a(t,e),s(t,[{key:"isEnabled",value:function(){return (0, c.isMobileBrowser)()}},{key:"enablePlugin",value:function(){this.enabled||(this.eventManager||(this.eventManager=new p.default(this)),this.registerListeners(),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this));}},{key:"registerListeners",value:function(){function e(e){if(1===t.dragged.length)return t.dragged.splice(0,t.dragged.length),!0;var n=t.dragged.indexOf(e);if(-1===n)return !1;0===n?t.dragged=t.dragged.slice(0,1):1===n&&(t.dragged=t.dragged.slice(-1));}var t=this;this.eventManager.addEventListener(this.hot.rootElement,"touchstart",function(e){var n=void 0;return (0, u.hasClass)(e.target,"topLeftSelectionHandle-HitArea")?(n=t.hot.getSelectedRangeLast(),t.dragged.push("topLeft"),t.touchStartRange={width:n.getWidth(),height:n.getHeight(),direction:n.getDirection()},e.preventDefault(),!1):(0, u.hasClass)(e.target,"bottomRightSelectionHandle-HitArea")?(n=t.hot.getSelectedRangeLast(),t.dragged.push("bottomRight"),t.touchStartRange={width:n.getWidth(),height:n.getHeight(),direction:n.getDirection()},e.preventDefault(),!1):void 0}),this.eventManager.addEventListener(this.hot.rootElement,"touchend",function(n){return (0, u.hasClass)(n.target,"topLeftSelectionHandle-HitArea")?(e.call(t,"topLeft"),t.touchStartRange=void 0,n.preventDefault(),!1):(0, u.hasClass)(n.target,"bottomRightSelectionHandle-HitArea")?(e.call(t,"bottomRight"),t.touchStartRange=void 0,n.preventDefault(),!1):void 0}),this.eventManager.addEventListener(this.hot.rootElement,"touchmove",function(e){var n=(0, u.getWindowScrollTop)(),o=(0, u.getWindowScrollLeft)(),r=void 0,i=void 0,a=void 0,s=void 0,l=void 0,c=void 0;if(0!==t.dragged.length){var h=document.elementFromPoint(e.touches[0].screenX-o,e.touches[0].screenY-n);h&&h!==t.lastSetCell&&("TD"!==h.nodeName&&"TH"!==h.nodeName||(r=t.hot.getCoords(h),-1===r.col&&(r.col=0),i=t.hot.getSelectedRangeLast(),a=i.getWidth(),s=i.getHeight(),l=i.getDirection(),1===a&&1===s&&t.hot.selection.setRangeEnd(r),c=t.getCurrentRangeCoords(i,r,t.touchStartRange.direction,l,t.dragged[0]),null!==c.start&&t.hot.selection.setRangeStart(c.start),t.hot.selection.setRangeEnd(c.end),t.lastSetCell=h),e.preventDefault());}});}},{key:"getCurrentRangeCoords",value:function(e,t,n,o,r){var i=e.getTopLeftCorner(),a=e.getBottomRightCorner(),s=e.getBottomLeftCorner(),l=e.getTopRightCorner(),u={start:null,end:null};switch(n){case"NE-SW":switch(o){case"NE-SW":case"NW-SE":u="topLeft"===r?{start:new v.CellCoords(t.row,e.highlight.col),end:new v.CellCoords(s.row,t.col)}:{start:new v.CellCoords(e.highlight.row,t.col),end:new v.CellCoords(t.row,i.col)};break;case"SE-NW":"bottomRight"===r&&(u={start:new v.CellCoords(a.row,t.col),end:new v.CellCoords(t.row,i.col)});}break;case"NW-SE":switch(o){case"NE-SW":"topLeft"===r?u={start:t,end:s}:u.end=t;break;case"NW-SE":"topLeft"===r?u={start:t,end:a}:u.end=t;break;case"SE-NW":"topLeft"===r?u={start:t,end:i}:u.end=t;break;case"SW-NE":"topLeft"===r?u={start:t,end:l}:u.end=t;}break;case"SW-NE":switch(o){case"NW-SE":u="bottomRight"===r?{start:new v.CellCoords(t.row,i.col),end:new v.CellCoords(s.row,t.col)}:{start:new v.CellCoords(i.row,t.col),end:new v.CellCoords(t.row,a.col)};break;case"SW-NE":u="topLeft"===r?{start:new v.CellCoords(e.highlight.row,t.col),end:new v.CellCoords(t.row,a.col)}:{start:new v.CellCoords(t.row,i.col),end:new v.CellCoords(i.row,t.col)};break;case"SE-NW":"bottomRight"===r?u={start:new v.CellCoords(t.row,l.col),end:new v.CellCoords(i.row,t.col)}:"topLeft"===r&&(u={start:s,end:t});}break;case"SE-NW":switch(o){case"NW-SE":case"NE-SW":case"SW-NE":"topLeft"===r&&(u.end=t);break;case"SE-NW":"topLeft"===r?u.end=t:u={start:t,end:i};}}return u}},{key:"isDragged",value:function(){return this.dragged.length>0}}]),t}(f.default);(0, g.registerPlugin)("multipleSelectionHandles",m),t.default=m;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var s=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},u=n(11),c=o(u),h=n(613),f=o(h),d=n(2),p=n(8),g=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.observer=null,n}return a(t,e),s(t,[{key:"isEnabled",value:function(){return this.hot.getSettings().observeChanges}},{key:"enablePlugin",value:function(){var e=this;this.enabled||(this.observer||(this.observer=new f.default(this.hot.getSourceData()),this._exposePublicApi()),this.observer.addLocalHook("change",function(t){return e.onDataChange(t)}),this.addHook("afterCreateRow",function(){return e.onAfterTableAlter()}),this.addHook("afterRemoveRow",function(){return e.onAfterTableAlter()}),this.addHook("afterCreateCol",function(){return e.onAfterTableAlter()}),this.addHook("afterRemoveCol",function(){return e.onAfterTableAlter()}),this.addHook("afterChange",function(t,n){return e.onAfterTableAlter(n)}),this.addHook("afterLoadData",function(t){return e.onAfterLoadData(t)}),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this));}},{key:"disablePlugin",value:function(){this.observer&&(this.observer.destroy(),this.observer=null,this._deletePublicApi()),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"onDataChange",value:function(e){var t=this;if(!this.observer.isPaused()){var n=this.pluginName+".change",o={add:function(e){isNaN(e.col)?t.hot.runHooks("afterCreateRow",e.row,1,n):t.hot.runHooks("afterCreateCol",e.col,1,n);},remove:function(e){isNaN(e.col)?t.hot.runHooks("afterRemoveRow",e.row,1,n):t.hot.runHooks("afterRemoveCol",e.col,1,n);},replace:function(e){t.hot.runHooks("afterChange",[[e.row,e.col,null,e.value]],n);}};(0, d.arrayEach)(e,function(e){o[e.op]&&o[e.op](e);}),this.hot.render();}this.hot.runHooks("afterChangesObserved");}},{key:"onAfterTableAlter",value:function(e){var t=this;"loadData"!==e&&(this.observer.pause(),this.hot.addHookOnce("afterChangesObserved",function(){return t.observer.resume()}));}},{key:"onAfterLoadData",value:function(e){e||this.observer.setObservedData(this.hot.getSourceData());}},{key:"destroy",value:function(){this.observer&&(this.observer.destroy(),this._deletePublicApi()),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}},{key:"_exposePublicApi",value:function(){var e=this,t=this.hot;t.pauseObservingChanges=function(){return e.observer.pause()},t.resumeObservingChanges=function(){return e.observer.resume()},t.isPausedObservingChanges=function(){return e.observer.isPaused()};}},{key:"_deletePublicApi",value:function(){var e=this.hot;delete e.pauseObservingChanges,delete e.resumeObservingChanges,delete e.isPausedObservingChanges;}}]),t}(c.default);t.default=g,(0, p.registerPlugin)("observeChanges",g);},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var i=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(614),s=o(a),l=n(48),u=o(l),c=n(1),h=n(615),f=function(){function e(t){r(this,e),this.observedData=null,this.observer=null,this.paused=!1,this.setObservedData(t);}return i(e,[{key:"setObservedData",value:function(e){var t=this;this.observer&&s.default.unobserve(this.observedData,this.observer),this.observedData=e,this.observer=s.default.observe(this.observedData,function(e){return t.onChange(e)});}},{key:"isPaused",value:function(){return this.paused}},{key:"pause",value:function(){this.paused=!0;}},{key:"resume",value:function(){this.paused=!1;}},{key:"onChange",value:function(e){this.runLocalHooks("change",(0, h.cleanPatches)(e));}},{key:"destroy",value:function(){s.default.unobserve(this.observedData,this.observer),this.observedData=null,this.observer=null;}}]),e}();(0, c.mixin)(f,u.default),t.default=f;},function(e,t,n){var o,r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=function(e,t){function n(){this.constructor=e;}for(var o in t)t.hasOwnProperty(o)&&(e[o]=t[o]);e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n);},a=Error;!function(e){function t(e,n){switch(void 0===e?"undefined":r(e)){case"undefined":case"boolean":case"string":case"number":return e===n;case"object":if(null===e)return null===n;if(k(e)){if(!k(n)||e.length!==n.length)return !1;for(var o=0,i=e.length;i>o;o++)if(!t(e[o],n[o]))return !1;return !0}var a=C(n),s=a.length;if(C(e).length!==s)return !1;for(var o=0;s>o;o++)if(!t(e[o],n[o]))return !1;return !0;default:return !1}}function n(e){return -1===e.indexOf("/")&&-1===e.indexOf("~")?e:e.replace(/~/g,"~0").replace(/\//g,"~1")}function o(e){for(var t=0,n=E.length;n>t;t++)if(E[t].obj===e)return E[t]}function s(e,t){for(var n=0,o=e.observers.length;o>n;n++)if(e.observers[n].callback===t)return e.observers[n].observer}function l(e,t){for(var n=0,o=e.observers.length;o>n;n++)if(e.observers[n].observer===t)return void e.observers.splice(n,1)}function u(e,t){t.unobserve();}function c(e){return "object"===(void 0===e?"undefined":r(e))?JSON.parse(JSON.stringify(e)):e}function h(e,t){var n,r=[],i=o(e);if(i?n=s(i,t):(i=new O(e),E.push(i)),n)return n;if(n={},i.value=c(e),t){n.callback=t,n.next=null;var u=this.intervals||[100,1e3,1e4,6e4];if(void 0===u.push)throw new a("jsonpatch.intervals must be an array");var h=0,d=function(){f(n);},p=function(){clearTimeout(n.next),n.next=setTimeout(function(){d(),h=0,n.next=setTimeout(g,u[h++]);},0);},g=function e(){d(),h==u.length&&(h=u.length-1),n.next=setTimeout(e,u[h++]);};"undefined"!=typeof window&&(window.addEventListener?(window.addEventListener("mousedown",p),window.addEventListener("mouseup",p),window.addEventListener("keydown",p)):(document.documentElement.attachEvent("onmousedown",p),document.documentElement.attachEvent("onmouseup",p),document.documentElement.attachEvent("onkeydown",p))),n.next=setTimeout(g,u[h++]);}return n.patches=r,n.object=e,n.unobserve=function(){f(n),clearTimeout(n.next),l(i,n),"undefined"!=typeof window&&(window.removeEventListener?(window.removeEventListener("mousedown",p),window.removeEventListener("mouseup",p),window.removeEventListener("keydown",p)):(document.documentElement.detachEvent("onmousedown",p),document.documentElement.detachEvent("onmouseup",p),document.documentElement.detachEvent("onkeydown",p)));},i.observers.push(new T(t,n)),n}function f(e){for(var t,n=0,o=E.length;o>n;n++)if(E[n].obj===e.object){t=E[n];break}d(t.value,e.object,e.patches,""),e.patches.length&&g(t.value,e.patches);var r=e.patches;return r.length>0&&(e.patches=[],e.callback&&e.callback(r)),r}function d(e,t,o,i){for(var a=C(t),s=C(e),l=!1,u=s.length-1;u>=0;u--){var h=s[u],f=e[h];if(t.hasOwnProperty(h)){var p=t[h];"object"==(void 0===f?"undefined":r(f))&&null!=f&&"object"==(void 0===p?"undefined":r(p))&&null!=p?d(f,p,o,i+"/"+n(h)):f!=p&&(o.push({op:"replace",path:i+"/"+n(h),value:c(p)}));}else o.push({op:"remove",path:i+"/"+n(h)}),l=!0;}if(l||a.length!=s.length)for(var u=0;a.length>u;u++){var h=a[u];e.hasOwnProperty(h)||o.push({op:"add",path:i+"/"+n(h),value:c(t[h])});}}function p(e){for(var t,n=0,o=e.length;o>n;){t=e.charCodeAt(n);{if(48>t||t>57)return !1;n++;}}return !0}function g(e,t,n){for(var o,r,i=!1,a=0,s=t.length;s>a;){o=t[a],a++;for(var l=o.path||"",u=l.split("/"),c=e,h=1,f=u.length,d=void 0;;){if(r=u[h],n&&void 0===d&&(void 0===c[r]?d=u.slice(0,h).join("/"):h==f-1&&(d=o.path),void 0!==d&&this.validator(o,a-1,e,d)),h++,void 0===r&&h>=f){i=S[o.op].call(o,c,r,e);break}if(k(c)){if("-"===r)r=c.length;else{if(n&&!p(r))throw new R("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index","OPERATION_PATH_ILLEGAL_ARRAY_INDEX",a-1,o.path,o);r=parseInt(r,10);}if(h>=f){if(n&&"add"===o.op&&r>c.length)throw new R("The specified index MUST NOT be greater than the number of elements in the array","OPERATION_VALUE_OUT_OF_BOUNDS",a-1,o.path,o);i=_[o.op].call(o,c,r,e);break}}else if(r&&-1!=r.indexOf("~")&&(r=r.replace(/~1/g,"/").replace(/~0/g,"~")),h>=f){i=b[o.op].call(o,c,r,e);break}c=c[r];}}return i}function v(e,t){var n=[];return d(e,t,n,""),n}function m(e){if(void 0===e)return !0;if("array"==typeof e||"object"==(void 0===e?"undefined":r(e)))for(var t in e)if(m(e[t]))return !0;return !1}function y(t,n,o,i){if("object"!==(void 0===t?"undefined":r(t))||null===t||k(t))throw new R("Operation is not an object","OPERATION_NOT_AN_OBJECT",n,t,o);if(!b[t.op])throw new R("Operation `op` property is not one of operations defined in RFC-6902","OPERATION_OP_INVALID",n,t,o);if("string"!=typeof t.path)throw new R("Operation `path` property is not a string","OPERATION_PATH_INVALID",n,t,o);if(("move"===t.op||"copy"===t.op)&&"string"!=typeof t.from)throw new R("Operation `from` property is not present (applicable in `move` and `copy` operations)","OPERATION_FROM_REQUIRED",n,t,o);if(("add"===t.op||"replace"===t.op||"test"===t.op)&&void 0===t.value)throw new R("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)","OPERATION_VALUE_REQUIRED",n,t,o);if(("add"===t.op||"replace"===t.op||"test"===t.op)&&m(t.value))throw new R("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)","OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED",n,t,o);if(o)if("add"==t.op){var a=t.path.split("/").length,s=i.split("/").length;if(a!==s+1&&a!==s)throw new R("Cannot perform an `add` operation at the desired path","OPERATION_PATH_CANNOT_ADD",n,t,o)}else if("replace"===t.op||"remove"===t.op||"_get"===t.op){if(t.path!==i)throw new R("Cannot perform the operation at a path that does not exist","OPERATION_PATH_UNRESOLVABLE",n,t,o)}else if("move"===t.op||"copy"===t.op){var l={op:"_get",path:t.from,value:void 0},u=e.validate([l],o);if(u&&"OPERATION_PATH_UNRESOLVABLE"===u.name)throw new R("Cannot perform the operation from a path that does not exist","OPERATION_FROM_UNRESOLVABLE",n,t,o)}}function w(e,t){try{if(!k(e))throw new R("Patch sequence must be an array","SEQUENCE_NOT_AN_ARRAY");if(t)t=JSON.parse(JSON.stringify(t)),g.call(this,t,e,!0);else for(var n=0;e.length>n;n++)this.validator(e[n],n);}catch(e){if(e instanceof R)return e;throw e}}var C=function(e){if(k(e)){for(var t=Array(e.length),n=0;t.length>n;n++)t[n]=""+n;return t}if(Object.keys)return Object.keys(e);var t=[];for(var o in e)e.hasOwnProperty(o)&&t.push(o);return t},b={add:function(e,t){return e[t]=this.value,!0},remove:function(e,t){return delete e[t],!0},replace:function(e,t){return e[t]=this.value,!0},move:function(e,t,n){var o={op:"_get",path:this.from};return g(n,[o]),g(n,[{op:"remove",path:this.from}]),g(n,[{op:"add",path:this.path,value:o.value}]),!0},copy:function(e,t,n){var o={op:"_get",path:this.from};return g(n,[o]),g(n,[{op:"add",path:this.path,value:o.value}]),!0},test:function(e,n){return t(e[n],this.value)},_get:function(e,t){this.value=e[t];}},_={add:function(e,t){return e.splice(t,0,this.value),!0},remove:function(e,t){return e.splice(t,1),!0},replace:function(e,t){return e[t]=this.value,!0},move:b.move,copy:b.copy,test:b.test,_get:b._get},S={add:function(e){S.remove.call(this,e);for(var t in this.value)this.value.hasOwnProperty(t)&&(e[t]=this.value[t]);return !0},remove:function(e){for(var t in e)e.hasOwnProperty(t)&&b.remove.call(this,e,t);return !0},replace:function(e){return g(e,[{op:"remove",path:this.path}]),g(e,[{op:"add",path:this.path,value:this.value}]),!0},move:b.move,copy:b.copy,test:function(e){return JSON.stringify(e)===JSON.stringify(this.value)},_get:function(e){this.value=e;}},E=[],O=function(){function e(e){this.observers=[],this.obj=e;}return e}(),T=function(){function e(e,t){this.callback=e,this.observer=t;}return e}();e.unobserve=u,e.observe=h,e.generate=f;var k;k=Array.isArray?Array.isArray:function(e){return e.push&&"number"==typeof e.length},e.apply=g,e.compare=v;var R=function(e){function t(t,n,o,r,i){e.call(this,t),this.message=t,this.name=n,this.index=o,this.operation=r,this.tree=i;}return i(t,e),t}(a);e.JsonPatchError=R,e.Error=R,e.validator=y,e.validate=w;}(o||(o={})),t.apply=o.apply,t.observe=o.observe,t.unobserve=o.unobserve,t.generate=o.generate,t.compare=o.compare,t.validate=o.validate,t.validator=o.validator,t.JsonPatchError=o.JsonPatchError,t.Error=o.Error;},function(e,t,n){function o(e){var t=[],n=(0, a.arrayFilter)(e,function(e){return !/[\/]length/gi.test(e.path)&&!!r(e.path)});return n=(0, a.arrayMap)(n,function(e){var t=r(e.path);return e.row=t.row,e.col=t.col,e}),n=(0, a.arrayFilter)(n,function(e){if(-1!==["add","remove"].indexOf(e.op)&&!isNaN(e.col)){if(-1!==t.indexOf(e.col))return !1;t.push(e.col);}return !0}),t.length=0,n}function r(e){var t=e.match(/^\/(\d+)\/?(.*)?$/);if(!t)return null;var n=i(t,3),o=n[1],r=n[2];return {row:parseInt(o,10),col:/^\d*$/.test(r)?parseInt(r,10):r}}t.__esModule=!0;var i=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();t.cleanPatches=o,t.parsePath=r;var a=n(2);},function(e,t,n){function o(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);e.length>t;t++)n[t]=e[t];return n}return Array.from(e)}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var s=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},u=n(11),c=function(e){return e&&e.__esModule?e:{default:e}}(u),h=n(8),f=n(1),d=n(5),p=n(10),g="htSearchResult",v=function(e,t,n,o,r){e.getCellMeta(t,n).isSearchResult=r;},m=function(e,t){return !((0, p.isUndefined)(e)||null===e||!e.toLowerCase||0===e.length)&&(!(0, p.isUndefined)(t)&&null!==t&&-1!==(""+t).toLowerCase().indexOf(e.toLowerCase()))},y=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.callback=v,n.queryMethod=m,n.searchResultClass=g,n}return a(t,e),s(t,[{key:"isEnabled",value:function(){return this.hot.getSettings().search}},{key:"enablePlugin",value:function(){var e=this;if(!this.enabled){this.updatePluginSettings(this.hot.getSettings().search),this.addHook("beforeRenderer",function(){return e.onBeforeRenderer.apply(e,arguments)}),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this);}}},{key:"disablePlugin",value:function(){var e=this,n=function(){return e.onBeforeRenderer.apply(e,arguments)};this.hot.addHook("beforeRenderer",n),this.hot.addHookOnce("afterRender",function(){e.hot.removeHook("beforeRenderer",n);}),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"updatePlugin",value:function(){this.disablePlugin(),this.enablePlugin(),l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updatePlugin",this).call(this);}},{key:"query",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.getCallback(),o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.getQueryMethod(),r=this.hot.countRows(),i=this.hot.countCols(),a=[],s=this.hot;return (0, d.rangeEach)(0,r-1,function(r){(0, d.rangeEach)(0,i-1,function(i){var l=t.hot.getDataAtCell(r,i),u=t.hot.getCellMeta(r,i),c=u.search.callback||n,h=u.search.queryMethod||o,f=h(e,l);if(f){a.push({row:r,col:i,data:l});}c&&c(s,r,i,l,f);});}),a}},{key:"getCallback",value:function(){return this.callback}},{key:"setCallback",value:function(e){this.callback=e;}},{key:"getQueryMethod",value:function(){return this.queryMethod}},{key:"setQueryMethod",value:function(e){this.queryMethod=e;}},{key:"getSearchResultClass",value:function(){return this.searchResultClass}},{key:"setSearchResultClass",value:function(e){this.searchResultClass=e;}},{key:"updatePluginSettings",value:function(e){(0, f.isObject)(e)&&(e.searchResultClass&&this.setSearchResultClass(e.searchResultClass),e.queryMethod&&this.setQueryMethod(e.queryMethod),e.callback&&this.setCallback(e.callback));}},{key:"onBeforeRenderer",value:function(e,t,n,r,i,a){var s=a.className||[],l=[];if("string"==typeof s)l=s.split(" ");else{var u;(u=l).push.apply(u,o(s));}this.isEnabled()&&a.isSearchResult?l.includes(this.searchResultClass)||l.push(""+this.searchResultClass):l.includes(this.searchResultClass)&&l.splice(l.indexOf(this.searchResultClass),1),a.className=l.join(" ");}},{key:"destroy",value:function(){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"destroy",this).call(this);}}]),t}(c.default);(0, h.registerPlugin)("search",y),t.default=y;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}t.__esModule=!0;var a=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=function e(t,n,o){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,n);if(void 0===r){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,n,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},l=n(0),u=n(2),c=n(11),h=function(e){return e&&e.__esModule?e:{default:e}}(c),f=n(8),d=n(41),p=function(e){function t(e){o(this,t);var n=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.scrollbars=[],n.clones=[],n.lockedCollection=!1,n.freezeOverlays=!1,n}return i(t,e),a(t,[{key:"isEnabled",value:function(){return (0, d.isTouchSupported)()}},{key:"enablePlugin",value:function(){var e=this;this.enabled||(this.addHook("afterRender",function(){return e.onAfterRender()}),this.registerEvents(),s(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"enablePlugin",this).call(this));}},{key:"updatePlugin",value:function(){this.lockedCollection=!1,s(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updatePlugin",this).call(this);}},{key:"disablePlugin",value:function(){s(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"disablePlugin",this).call(this);}},{key:"registerEvents",value:function(){var e=this;this.addHook("beforeTouchScroll",function(){return e.onBeforeTouchScroll()}),this.addHook("afterMomentumScroll",function(){return e.onAfterMomentumScroll()});}},{key:"onAfterRender",value:function(){if(!this.lockedCollection){var e=this.hot.view.wt.wtOverlays,t=e.topOverlay,n=e.bottomOverlay,o=e.leftOverlay,r=e.topLeftCornerOverlay,i=e.bottomLeftCornerOverlay;this.lockedCollection=!0,this.scrollbars.length=0,this.scrollbars.push(t),n.clone&&this.scrollbars.push(n),this.scrollbars.push(o),r&&this.scrollbars.push(r),i&&i.clone&&this.scrollbars.push(i),this.clones.length=0,t.needFullRender&&this.clones.push(t.clone.wtTable.holder.parentNode),n.needFullRender&&this.clones.push(n.clone.wtTable.holder.parentNode),o.needFullRender&&this.clones.push(o.clone.wtTable.holder.parentNode),r&&this.clones.push(r.clone.wtTable.holder.parentNode),i&&i.clone&&this.clones.push(i.clone.wtTable.holder.parentNode);}}},{key:"onBeforeTouchScroll",value:function(){this.freezeOverlays=!0,(0, u.arrayEach)(this.clones,function(e){(0, l.addClass)(e,"hide-tween");});}},{key:"onAfterMomentumScroll",value:function(){var e=this;this.freezeOverlays=!1,(0, u.arrayEach)(this.clones,function(e){(0, l.removeClass)(e,"hide-tween"),(0, l.addClass)(e,"show-tween");}),setTimeout(function(){(0, u.arrayEach)(e.clones,function(e){(0, l.removeClass)(e,"show-tween");});},400),(0, u.arrayEach)(this.scrollbars,function(e){e.refresh(),e.resetFixedPosition();}),this.hot.view.wt.wtOverlays.syncScrollWithMaster();}}]),t}(h.default);(0, f.registerPlugin)("touchScroll",p),t.default=p;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}function a(e){var t=this;this.instance=e,this.doneActions=[],this.undoneActions=[],this.ignoreNewActions=!1,e.addHook("afterChange",function(e,n){e&&"UndoRedo.undo"!==n&&"UndoRedo.redo"!==n&&"MergeCells"!==n&&t.done(new a.ChangeAction(e));}),e.addHook("afterCreateRow",function(e,n,o){if("UndoRedo.undo"!==o&&"UndoRedo.undo"!==o&&"auto"!==o){var r=new a.CreateRowAction(e,n);t.done(r);}}),e.addHook("beforeRemoveRow",function(n,o,r,i){if("UndoRedo.undo"!==i&&"UndoRedo.redo"!==i&&"auto"!==i){var s=t.instance.getSourceDataArray(),l=(s.length+n)%s.length,u=e.toPhysicalRow(l),c=(0, m.deepClone)(s.slice(u,u+o));t.done(new a.RemoveRowAction(l,c));}}),e.addHook("afterCreateCol",function(e,n,o){"UndoRedo.undo"!==o&&"UndoRedo.redo"!==o&&"auto"!==o&&t.done(new a.CreateColumnAction(e,n));}),e.addHook("beforeRemoveCol",function(n,o,r,i){if("UndoRedo.undo"!==i&&"UndoRedo.redo"!==i&&"auto"!==i){var s=t.instance.getSourceDataArray(),l=(t.instance.countCols()+n)%t.instance.countCols(),u=[],c=[],h=[];(0, v.rangeEach)(s.length-1,function(t){var n=[],r=s[t];(0, v.rangeEach)(l,l+(o-1),function(t){n.push(r[e.runHooks("modifyCol",t)]);}),u.push(n);}),(0, v.rangeEach)(o-1,function(t){h.push(e.runHooks("modifyCol",l+t));}),Array.isArray(e.getSettings().colHeaders)&&(0, v.rangeEach)(o-1,function(t){c.push(e.getSettings().colHeaders[e.runHooks("modifyCol",l+t)]||null);});var f=t.instance.getPlugin("manualColumnMove"),d=f.isEnabled()?f.columnsMapper.__arrayMap:[],p=new a.RemoveColumnAction(l,h,u,c,d);t.done(p);}}),e.addHook("beforeCellAlignment",function(e,n,o,r){var i=new a.CellAlignmentAction(e,n,o,r);t.done(i);}),e.addHook("beforeFilter",function(e){t.done(new a.FiltersAction(e));}),e.addHook("beforeRowMove",function(e,n){!1!==e&&t.done(new a.RowMoveAction(e,n));}),e.addHook("beforeMergeCells",function(n,o){o||t.done(new a.MergeCellsAction(e,n));}),e.addHook("afterUnmergeCells",function(n,o){o||t.done(new a.UnmergeCellsAction(e,n));});}function s(){var e=this;void 0===e.getSettings().undo||e.getSettings().undo?e.undoRedo||(e.undoRedo=new a(e),c(e),e.addHook("beforeKeyDown",l),e.addHook("afterChange",u)):e.undoRedo&&(delete e.undoRedo,h(e),e.removeHook("beforeKeyDown",l),e.removeHook("afterChange",u));}function l(e){var t=this;(e.ctrlKey||e.metaKey)&&!e.altKey&&(89===e.keyCode||e.shiftKey&&90===e.keyCode?(t.undoRedo.redo(),(0, y.stopImmediatePropagation)(e)):90===e.keyCode&&(t.undoRedo.undo(),(0, y.stopImmediatePropagation)(e)));}function u(e,t){var n=this;if("loadData"===t)return n.undoRedo.clear()}function c(e){e.undo=function(){return e.undoRedo.undo()},e.redo=function(){return e.undoRedo.redo()},e.isUndoAvailable=function(){return e.undoRedo.isUndoAvailable()},e.isRedoAvailable=function(){return e.undoRedo.isRedoAvailable()},e.clearUndo=function(){return e.undoRedo.clear()};}function h(e){delete e.undo,delete e.redo,delete e.isUndoAvailable,delete e.isRedoAvailable,delete e.clearUndo;}t.__esModule=!0;var f=function(){function e(e,t){for(var n=0;t.length>n;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),d=n(16),p=function(e){return e&&e.__esModule?e:{default:e}}(d),g=n(2),v=n(5),m=n(1),y=n(12),w=n(19);a.prototype.done=function(e){this.ignoreNewActions||(this.doneActions.push(e),this.undoneActions.length=0);},a.prototype.undo=function(){if(this.isUndoAvailable()){var e=this.doneActions.pop(),t=(0, m.deepClone)(e),n=this.instance;if(!1===n.runHooks("beforeUndo",t))return;this.ignoreNewActions=!0;var o=this;e.undo(this.instance,function(){o.ignoreNewActions=!1,o.undoneActions.push(e);}),n.runHooks("afterUndo",t);}},a.prototype.redo=function(){if(this.isRedoAvailable()){var e=this.undoneActions.pop(),t=(0, m.deepClone)(e),n=this.instance;if(!1===n.runHooks("beforeRedo",t))return;this.ignoreNewActions=!0;var o=this;e.redo(this.instance,function(){o.ignoreNewActions=!1,o.doneActions.push(e);}),n.runHooks("afterRedo",t);}},a.prototype.isUndoAvailable=function(){return this.doneActions.length>0},a.prototype.isRedoAvailable=function(){return this.undoneActions.length>0},a.prototype.clear=function(){this.doneActions.length=0,this.undoneActions.length=0;},a.Action=function(){},a.Action.prototype.undo=function(){},a.Action.prototype.redo=function(){},a.ChangeAction=function(e){this.changes=e,this.actionType="change";},(0, m.inherit)(a.ChangeAction,a.Action),a.ChangeAction.prototype.undo=function(e,t){for(var n=(0, m.deepClone)(this.changes),o=e.countEmptyRows(!0),r=e.countEmptyCols(!0),i=0,a=n.length;a>i;i++)n[i].splice(3,1);e.addHookOnce("afterChange",t),e.setDataAtRowProp(n,null,null,"UndoRedo.undo");for(var s=0,l=n.length;l>s;s++)e.getSettings().minSpareRows&&n[s][0]+1+e.getSettings().minSpareRows===e.countRows()&&o===e.getSettings().minSpareRows&&(e.alter("remove_row",parseInt(n[s][0]+1,10),e.getSettings().minSpareRows),e.undoRedo.doneActions.pop()),e.getSettings().minSpareCols&&n[s][1]+1+e.getSettings().minSpareCols===e.countCols()&&r===e.getSettings().minSpareCols&&(e.alter("remove_col",parseInt(n[s][1]+1,10),e.getSettings().minSpareCols),e.undoRedo.doneActions.pop());},a.ChangeAction.prototype.redo=function(e,t){for(var n=(0, m.deepClone)(this.changes),o=0,r=n.length;r>o;o++)n[o].splice(2,1);e.addHookOnce("afterChange",t),e.setDataAtRowProp(n,null,null,"UndoRedo.redo");},a.CreateRowAction=function(e,t){this.index=e,this.amount=t,this.actionType="insert_row";},(0, m.inherit)(a.CreateRowAction,a.Action),a.CreateRowAction.prototype.undo=function(e,t){var n=e.countRows(),o=e.getSettings().minSpareRows;this.index>=n&&n>this.index-o&&(this.index-=o),e.addHookOnce("afterRemoveRow",t),e.alter("remove_row",this.index,this.amount,"UndoRedo.undo");},a.CreateRowAction.prototype.redo=function(e,t){e.addHookOnce("afterCreateRow",t),e.alter("insert_row",this.index,this.amount,"UndoRedo.redo");},a.RemoveRowAction=function(e,t){this.index=e,this.data=t,this.actionType="remove_row";},(0, m.inherit)(a.RemoveRowAction,a.Action),a.RemoveRowAction.prototype.undo=function(e,t){e.alter("insert_row",this.index,this.data.length,"UndoRedo.undo"),e.addHookOnce("afterRender",t),e.populateFromArray(this.index,0,this.data,void 0,void 0,"UndoRedo.undo");},a.RemoveRowAction.prototype.redo=function(e,t){e.addHookOnce("afterRemoveRow",t),e.alter("remove_row",this.index,this.data.length,"UndoRedo.redo");},a.CreateColumnAction=function(e,t){this.index=e,this.amount=t,this.actionType="insert_col";},(0, m.inherit)(a.CreateColumnAction,a.Action),a.CreateColumnAction.prototype.undo=function(e,t){e.addHookOnce("afterRemoveCol",t),e.alter("remove_col",this.index,this.amount,"UndoRedo.undo");},a.CreateColumnAction.prototype.redo=function(e,t){e.addHookOnce("afterCreateCol",t),e.alter("insert_col",this.index,this.amount,"UndoRedo.redo");},a.RemoveColumnAction=function(e,t,n,o,r){this.index=e,this.indexes=t,this.data=n,this.amount=this.data[0].length,this.headers=o,this.columnPositions=r.slice(0),this.actionType="remove_col";},(0, m.inherit)(a.RemoveColumnAction,a.Action),a.RemoveColumnAction.prototype.undo=function(e,t){var n=this,o=void 0,r=this.indexes.slice(0).sort(),i=function(e,t,o){return o[n.indexes.indexOf(r[t])]},a=[];(0, v.rangeEach)(this.data.length-1,function(e){a[e]=(0, g.arrayMap)(n.data[e],i);});var s=[];s=(0, g.arrayMap)(this.headers,i);var l=[];e.runHooks("beforeCreateCol",this.indexes[0],this.indexes.length,"UndoRedo.undo"),(0, v.rangeEach)(this.data.length-1,function(t){o=e.getSourceDataAtRow(t),(0, v.rangeEach)(r.length-1,function(e){o.splice(r[e],0,a[t][e]),l.push([t,r[e],null,a[t][e]]);});}),e.getPlugin("formulas")&&e.getPlugin("formulas").onAfterSetDataAtCell(l),void 0!==this.headers&&(0, v.rangeEach)(s.length-1,function(t){e.getSettings().colHeaders.splice(r[t],0,s[t]);}),e.getPlugin("manualColumnMove")&&(e.getPlugin("manualColumnMove").columnsMapper.__arrayMap=this.columnPositions),e.addHookOnce("afterRender",t),e.runHooks("afterCreateCol",this.indexes[0],this.indexes.length,"UndoRedo.undo"),e.getPlugin("formulas")&&e.getPlugin("formulas").recalculateFull(),e.render();},a.RemoveColumnAction.prototype.redo=function(e,t){e.addHookOnce("afterRemoveCol",t),e.alter("remove_col",this.index,this.amount,"UndoRedo.redo");},a.CellAlignmentAction=function(e,t,n,o){this.stateBefore=e,this.range=t,this.type=n,this.alignment=o;},a.CellAlignmentAction.prototype.undo=function(e,t){var n=this;(0, g.arrayEach)(this.range,function(t){for(var o=t.from,r=t.to,i=o.row;r.row>=i;i+=1)for(var a=o.col;r.col>=a;a+=1)e.setCellMeta(i,a,"className",n.stateBefore[i][a]||" htLeft");}),e.addHookOnce("afterRender",t),e.render();},a.CellAlignmentAction.prototype.redo=function(e,t){(0, w.align)(this.range,this.type,this.alignment,function(t,n){return e.getCellMeta(t,n)},function(t,n,o,r){return e.setCellMeta(t,n,o,r)}),e.addHookOnce("afterRender",t),e.render();},a.FiltersAction=function(e){this.conditionsStack=e,this.actionType="filter";},(0, m.inherit)(a.FiltersAction,a.Action),a.FiltersAction.prototype.undo=function(e,t){var n=e.getPlugin("filters");e.addHookOnce("afterRender",t),n.conditionCollection.importAllConditions(this.conditionsStack.slice(0,this.conditionsStack.length-1)),n.filter();},a.FiltersAction.prototype.redo=function(e,t){var n=e.getPlugin("filters");e.addHookOnce("afterRender",t),n.conditionCollection.importAllConditions(this.conditionsStack),n.filter();},a.MergeCellsAction=function(e){function t(e,n){o(this,t);var i=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return i.cellRange=n,i.rangeData=e.getData(n.from.row,n.from.col,n.to.row,n.to.col),i}return i(t,e),f(t,[{key:"undo",value:function(e,t){var n=e.getPlugin("mergeCells");e.addHookOnce("afterRender",t),n.unmergeRange(this.cellRange,!0),e.populateFromArray(this.cellRange.from.row,this.cellRange.from.col,this.rangeData,void 0,void 0,"MergeCells");}},{key:"redo",value:function(e,t){var n=e.getPlugin("mergeCells");e.addHookOnce("afterRender",t),n.mergeRange(this.cellRange);}}]),t}(a.Action),a.UnmergeCellsAction=function(e){function t(e,n){o(this,t);var i=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return i.cellRange=n,i}return i(t,e),f(t,[{key:"undo",value:function(e,t){var n=e.getPlugin("mergeCells");e.addHookOnce("afterRender",t),n.mergeRange(this.cellRange,!0);}},{key:"redo",value:function(e,t){var n=e.getPlugin("mergeCells");e.addHookOnce("afterRender",t),n.unmergeRange(this.cellRange,!0),e.render();}}]),t}(a.Action),a.RowMoveAction=function(e,t){this.rows=e.slice(),this.target=t;},(0, m.inherit)(a.RowMoveAction,a.Action),a.RowMoveAction.prototype.undo=function(e,t){var n=e.getPlugin("manualRowMove");e.addHookOnce("afterRender",t);for(var o=this.target>this.rows[0]?-1*this.rows.length:0,r=this.rows[0]>this.target?this.rows[0]+this.rows.length:this.rows[0],i=[],a=this.rows.length+o,s=o;a>s;s+=1)i.push(this.target+s);n.moveRows(i.slice(),r),e.render(),e.selectCell(this.rows[0],0,this.rows[this.rows.length-1],e.countCols()-1,!1,!1);},a.RowMoveAction.prototype.redo=function(e,t){var n=e.getPlugin("manualRowMove");e.addHookOnce("afterRender",t),n.moveRows(this.rows.slice(),this.target),e.render();var o=this.target>this.rows[0]?this.target-this.rows.length:this.target;e.selectCell(o,0,o+this.rows.length-1,e.countCols()-1,!1,!1);};var C=p.default.getSingleton();C.add("afterInit",s),C.add("afterUpdateSettings",s),C.register("beforeUndo"),C.register("afterUndo"),C.register("beforeRedo"),C.register("afterRedo"),t.default=a;}]).default});

//=================================
//Additional code to convert to ES6 module
if(exports$2 != module$2.exports) exports$2 = module$2.exports;
//=================================

/** This is a grid editor using hands on table*/
class HandsonGridEditor extends DataDisplay {
    
    constructor(displayContainer,dataSource) {
        super(displayContainer,dataSource);

        this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
        this.savedPixelHeight = DEFAULT_PIXEL_HEIGHT;

        this.gridDiv = uiutil.createElement("div",null,{
            "width": "100%",
            "height":this.savedPixelHeight + "px",
            "overflow":"hidden",
        });

        this.inputData = null;
        this.activeEditOk = undefined;
        this.dataCached = false;

       //we have to make sure the element is loaded before initailizing for handsontable to work properly
       this.loaded = false;

        //grid edited function
        this.gridEdited = (args) => {
            //I am doing this because it tries to save on the initial creation
            //I am sure there is some other way to prevent this.
            if(!this.gridControl) return;
            
            this.save(arguments);
        };

        //on a paste, the event is fired for each row created. We delay it here to haev fewer updates of the rest of the sheet
        this.timerInProcess = false;
        var REFRESH_DELAY = 50;

        this.delayGridEdited = (args) => {

            //if there is no timer waiting, start a timer
            if(!this.timerInProcess) {
                this.timerInProcess = true;
                var callEditEvent = (args) => {
                    this.timerInProcess = false;
                    this.gridEdited(arguments);
                };
                setTimeout(callEditEvent,REFRESH_DELAY);
            }
        };

        //set variables for internal display view sizing
        this.setSupressContainerHorizontalScroll(true);
        this.setUseContainerHeightUi(true);

        //we will use a listener to see when the page is resized
        let app = this.displayContainer.getComponentView().getModelView().getApp();
        this.frameWidthListener = () => this.onFrameWidthResize();
        app.addListener("frameWidthResize",this.frameWidthListener);

    }

//=============================
// "Package" Methods
//=============================

    getContent() {
        return this.gridDiv;
    }
    
    getData() {
        //update "input" data before calling update
        if(this.gridControl) this.inputData = apogeeutil$1.jsonCopy(this.gridControl.getData());
        return this.inputData;
    }
    
    setData(json) {
        if(json == apogeeutil$1.INVALID_VALUE) {
            var errorMsg = "ERROR: Data value is not valid";
            json = [[errorMsg]];
        }

        if((this.inputData === json)&&(this.editOk)) return;
        
        //verify data is the proper format
        if(!this.dataIsValidFormat(json)) {
            var errorMsg = "ERROR: Data value is not an array of arrays";
            json = [[errorMsg]];
        }
//figure out how to handle this error
//I should detect an error if the first array is not as long as all other arrays - handsontable issue
	
        this.inputData = json;
        this.dataCached = true;

        if(this.loaded) {
            this.displayData();
        }
    }

    onLoad() {
        this.loaded = true;
        if(this.dataCached) {
            this.displayData();
        }
    }

    onUnload() {
        this.loaded = false;
    }

    onFrameWidthResize() {
        this.updateWidth();
    }

    destroy() {
        //tear down the grid control
        if(this.gridControl) {
            this.gridControl.destroy();
            this.gridControl = null;
        }
        //remove the frame width listener
        if(this.frameWidthListener) {
            let app = this.displayContainer.getComponentView().getModelView().getApp();
            app.removeListener("frameWidthResize",this.frameWidthListener);
            this.frameWidthListener = null;
        }
    }

    /** This updates the width to the current container width. */
    updateWidth() {
        if(this.gridControl) {
            this.gridControl.render();
        }
    }

    /** This updates the height to the specified pixel height. */
    updateHeight(pixelHeight) {
        if(this.gridControl) {
            this.gridControl.updateSettings({height: pixelHeight});
        }
        else {
            this.gridDiv.style.height = this.savedPixelHeight + "px";
        }
    }

    //---------------------------
    // UI State Management
    //---------------------------
    
    /** This method adds any data display state info to the view state json. 
     * By default there is none. Note that this modifies the json state of the view,
     * rather than providing a data object that will by added to it.. */
    addUiStateData(json) {
        if(this.savedPixelHeight) {
            json.height = this.savedPixelHeight;
        }
    }

    /** This method reads an data display state info from the view state json. */
    readUiStateData(json) {
        if(json.height) {
            let newPixelHeight = json.height;
            if(newPixelHeight >= MAX_PIXEL_HEIGHT) {
                this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
                newPixelHeight = MAX_PIXEL_HEIGHT;
            }
            else {
                this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
                if(newPixelHeight < MIN_PIXEL_HEIGHT) {
                    newPixelHeight = MIN_PIXEL_HEIGHT;
                }
            }

            this.savedPixelHeight = newPixelHeight;
            this.updateHeight(newPixelHeight);
        }
    }

    //----------------------------
    // This is the View resize API
    // The display has controls for the user to resize the display. These use the 
    // following API to interact with the display
    //----------------------------

    /** This method gets the resize mode. Options:
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
     */
    getResizeHeightMode() {
        return this.resizeHeightMode;
    }

    /** This method sets the resize mode. Options:
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
     */
    setResizeHeightMode(resizeHeightMode) {
        let newPixelHeight;
        if(resizeHeightMode == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME) {
            this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME;
            newPixelHeight = this.savedPixelHeight;
        }
        else if(resizeHeightMode == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX) {
            this.resizeHeightMode = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX;
            newPixelHeight = MAX_PIXEL_HEIGHT;
        }
        else {
            //ignore unknown value
            return;
        }

        this.updateHeight(newPixelHeight);
    }

    /** This method adjusts the size when the resize mode is DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME. Options:
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MORE;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_LESS;
    */
    adjustHeight(adjustment) {
        if(this.resizeHeightMode == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME) {
            let newPixelHeight;
            if(adjustment == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_LESS) {
                //decrease up to the min size
                newPixelHeight = this.savedPixelHeight - DELTA_PIXEL_HEIGHT;
                if(newPixelHeight < MIN_PIXEL_HEIGHT) newPixelHeight = MIN_PIXEL_HEIGHT;

            }
            else if(adjustment == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MORE) {
                //decrease up to the min size
                newPixelHeight = this.savedPixelHeight + DELTA_PIXEL_HEIGHT;
                if(newPixelHeight > MAX_PIXEL_HEIGHT) newPixelHeight = MAX_PIXEL_HEIGHT;
            }
            else {
                //ignore an unknown command
                return;
            }
            
            this.savedPixelHeight = newPixelHeight;
            this.updateHeight(newPixelHeight);
        }
    }

    /** This method returns the possible resize options, for use in the mode DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME. Flags:
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_LESS = 1;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MORE = 2;
     * - DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_NONE = 0;
     * These flags should be or'ed togethder to give the allowed options.
    */
    getHeightAdjustFlags() {
        let flags = DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_LESS | DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MORE;
        return flags;
    }

//==============================
// Private Methods
//==============================

    /** This method creates a new grid. 
     * @private */
    createNewGrid(initialData) {
        if(this.gridControl) {
            this.gridControl.destroy();
            this.gridControl = null;
        }

        var gridOptions; 
        if(this.editOk) {
            gridOptions = {
                data: initialData,
                rowHeaders: true,
                colHeaders: true,
                contextMenu: true,
                //edit callbacks - I am using a delay on the grid edited because the table fires too many updates - one for 
                //each row (soemthing like that I forget) on a big paste
                afterChange:this.delayGridEdited,
                afterCreateCol:this.delayGridEdited,
                afterCreateRow:this.delayGridEdited,
                afterRemoveCol:this.delayGridEdited,
                afterRemoveRow:this.delayGridEdited,
                width:"100%",
                height: this.savedPixelHeight + "px"

            };
            this.gridEditable = true;
        }
        else {
            gridOptions = {
                data: initialData,
                readOnly: true,
                rowHeaders: true,
                colHeaders: true,
                width:"100%",
                height: this.savedPixelHeight + "px"
            };
            this.gridEditable = false;
        }

        this.gridControl = new exports$2(this.gridDiv,gridOptions); 

        this.updateWidth();
    }
    
    
    //we must be loaded before creating objects
    displayData() {

        //clear the cached data flag, if it is present
        this.dataCached = false;

        var editData = apogeeutil$1.jsonCopy(this.inputData);
        if(!editData) {
            editData = [[]];
        }

        if((!this.gridControl)||(this.activeEditOk !== this.editOk)) {
            this.createNewGrid(editData);
            this.activeEditOk = this.editOk;
        }
        else {
            this.gridControl.loadData(editData);
        }

        //set the background color
        if(this.editOk) {
            this.gridDiv.style.backgroundColor = "";
        }
        else {
            this.gridDiv.style.backgroundColor = DATA_DISPLAY_CONSTANTS.NO_EDIT_BACKGROUND_COLOR;
        }
    }
    
    //this merifies the data is an array of arrays
    dataIsValidFormat(json) {
        if(Array.isArray(json)) {
            return json.every(Array.isArray);
        }
        else {
            return false;
        }
    }

}

//configuration constants
let MAX_PIXEL_HEIGHT = 1000;
let DEFAULT_PIXEL_HEIGHT = 300;
let MIN_PIXEL_HEIGHT = 30;
let DELTA_PIXEL_HEIGHT = 20;

/** This class is used to provide user-code user interface access to 
 * modifying the model using commands. */
class UiCommandMessenger {
    
    constructor(componentView,fromMemberId) {
        this.componentView = componentView;
        this.fromMemberId = fromMemberId;
        this.app = componentView.getModelView().getApp();
    }
    
    /** This method sents a command to update the given member, as specified by the
     * variable name updateMemberName, with the value data. UpdateMemberName should
     * be the name as it would be specified in a formula from the given member. Data may
     * get a JSON or a Promise (for asynch data), Error (to set an error state) 
     * or apogeeutil.INVALID_VALUE.*/
    dataCommand(updateMemberName,data,optionalCommandDescription,optionalSetsWorkspaceDirty) { 
        let command  = {};
        command.type = "saveMemberData";
        command.memberId = this._getLocalMemberId(updateMemberName);
        command.data = data;
        return this.app.executeCommand(command);
    }
    
    /** This is similar to getDataUpdateCommand but it allows setting multiple values.
     * UpdateInfo is an array with each element being a array of two values with the first
     * being the member name and the second being the value to set. */
    compoundDataCommand(updateInfo,optionalCommandDescription,optionalSetsWorkspaceDirty) {

        let command  = {};
        command.type = "saveMemberCompound";
        command.updateList = updateInfo.map( updateInfo => {
            let updateListEntry = {};
            updateListEntry.memberId = this._getLocalMemberId(updateInfo[0]);
            updateListEntry.data = updateInfo[1];
            return updateListEntry;
        });
        return this.app.executeCommand(command);
    }
    
    //=============================
    // Private Functions
    //=============================

    /** This method returns the member instance for a given local member name,
     * as defined from the source object context. */
    _getLocalMemberId(localMemberName) { 
        let model = this.componentView.getModelView().getModelManager().getModel();
        let fromMember = model.lookupMemberById(this.fromMemberId);
        let contextManager = fromMember.getContextManager();

        var pathArray = localMemberName.split(".");
        var member = contextManager.getMember(model,pathArray);
        return member.getId();
    }

    
}

/** HtmlJsDataDisplay
 * This is the data display for a custom control where the display is generated from
 * HTML and javascript code. The datasrouce for this data display has some additional 
 * fields defined for it: 
 * 
 * - html = dataSource.getHtml(); REQUIRED - This retrieves the HTML for the display
 * - resource = dataSource.getResource(); REQUIRED - This retrieves the "resource" object to run the display
 * - member = dataSource.getContextMember(); REQUIRED - This retrieves a member to use as a context reference
 * - displayData = dataSource.getDisplayData(); OPTIONAL - This returns model data to _construct_ the form
 *              whereas the standard getData() method returns data to _populate_ the form. If the display data is
 *              not valid then the value INVALID_VALUE should be passed.
 * 
 * The resource object can have the following methods. All of these are optional. The areguments include the outputElement
 * whcih is the DOM element for the window and the "admin" object, which is provides some facilities to these methods. The admin
 * is described below.
 * 
 * - init(outputElement,admin) - This is called when the data display is first created.
 * - setData(data,outputElement,admin) - This is called to set model data in the display, whenever the model data
 *                is updated. This will be called _after_ the onLoad method below.
 * - getData(outputElement,admin) - This is called to retrieve data from the display, during a save in edit mode.
 * - isCloseOk(outputElement,admin) - This is called before the data display is closed. Returning false will cancel the close, at
 *                the users option.
 * - destroy(outputElement,admin) - This is called after the display is closed.
 * - onLoad(outputElement,admin) - This is called when the HTML of the data display is loaded.
 * - onUnload(outputElement,admin) - This is called after the HTML for the data display is unloaded from the window.
 * 
 * The admin object includes the following functions on it:
 * getMessenger()
 * startEditMode()
 * endEditMode()
 */

/** This is the display/editor for the custom control output. */
class HtmlJsDataDisplay extends DataDisplay {
    constructor(displayContainer,dataSource) {
        
        super(displayContainer,dataSource);
        
        this.isLoaded = false;
        this.cachedData = undefined;

        this.outputElement = uiutil.createElement("div",null,{
            "position":"relative"
        });

        this._constructDisplay();
    }

    getContent() {
        return this.outputElement;
    }

    /** This method implements the methods needed for the display interface from the data source */
    _constructDisplay() {

        let dataSource = this.getDataSource();
        let html = dataSource.getHtml();
        let resource = dataSource.getResource();
        let componentView = this.getDisplayContainer().getComponentView();
        let member = dataSource.getContextMember();

        let displayData = dataSource.getDisplayData ? dataSource.getDisplayData() : undefined;

        //content
        if(html) {
            this.outputElement.innerHTML = html;
        }
        
        //this gives the ui code access to some data display functions
        var admin = {
            getCommandMessenger: () => new UiCommandMessenger(componentView,member.getId()),
            startEditMode: () => this.startEditMode(),
            endEditMode: () => this.endEditMode()
        };

        if(resource.onLoad) {
            this.onLoad = () => {
                try {
                    resource.onLoad.call(resource,this.outputElement,admin);
                    this.isLoaded = true;

                    //set the display data if we have any
                    if((displayData !== undefined)&&(resource.setDisplayData)) {
                        resource.setDisplayData(displayData);
                        displayData = undefined;
                    }
                    
                    //handle the case the data loaded before the html (which we don't want)
                    if(this.cachedData != undefined) {
                        this.setData(this.cachedData);
                        this.cachedData = undefined;
                    }
                }
                catch(error) {
                    if(error.stack) console.error(error.stack);
                    
                    alert("Error in " + member.getName() + " onLoad function: " + error.message);
                }
            };
        }
        else {
            this.isLoaded = true;
        }

        if(resource.onUnload) {   
            this.onUnload = () => {
                try {
                    
                    this.isLoaded = false;
                    this.cachedData = undefined;
                    
                    resource.onUnload.call(resource,this.outputElement,admin);
                }
                catch(error) {
                    if(error.stack) console.error(error.stack);
                    
                    alert("Error in " + member.getName()+ " onUnload function: " + error.message);
                }
            };
        }

        this.setData = (data) => {
            try {
                if(resource.setData) {
                    if(!this.isLoaded) {
                        this.cachedData = data;
                        return;
                    }
                    
                    resource.setData.call(resource,data,this.outputElement,admin);
                }
                else {
                     //we must include a function here
                     this.setData = () => {};
                }
            }
            catch(error) {
                if(error.stack) console.error(error.stack);
                
                alert("Error in " + member.getName() + " setData function: " + error.message);
            }
        };
        
        if(resource.getData) {
            this.getData = () => {
                try {
                    return resource.getData.call(resource,this.outputElement,admin);
                }
                catch(error) {
                    if(error.stack) console.error(error.stack);
                    
                    alert("Error in " + member.getName() + " getData function: " + error.message);
                }
            };
        }
        else {
            //we must include a function here
            //WHY RETURN A DUMMY OBJECT? WHY NOT NULL? OR INVALID?
            this.getData = () => {};
        }


        if(resource.isCloseOk) {     
            this.isCloseOk = () => {
                try {
                    return resource.isCloseOk.call(resource,this.outputElement,admin);
                }
                catch(error) {
                    if(error.stack) console.error(error.stack);
                    
                    alert("Error in " + member.getName() + " isCloseOk function: " + error.message);
                }
            };
        }

        if(resource.destroy) {
            this.destroy = () => {
                try {
                    resource.destroy.call(resource,this.outputElement,admin);
                }
                catch(error) {
                    if(error.stack) console.error(error.stack);
                    
                    alert("Error in " + member.getName() + " destroy function: " + error.message);
                }
            };
        }

        //-------------------
        //initialization
        //-------------------

        if(resource.init) {
            try {
                resource.init.call(resource,this.outputElement,admin);
            }
            catch(error) {
                if(error.stack) console.error(error.stack);
                
                alert("Error in " + member.getName() + " init function: " + error.message);
            }
        }
    }
}

class JsonTableComponentView extends ComponentView {

    constructor(modelView,jsonTableComponent) {
        super(modelView,jsonTableComponent);
    }

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return JsonTableComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getModelView().getApp();
        
        
        //create the new view element;
        switch(viewType) {
            case JsonTableComponentView.VIEW_DATA:
                var component = this.getComponent();
                let dataView = component.getField("dataView");
                switch(dataView) {
                    case JsonTableComponentView.COLORIZED_DATA_VEW:
                    default:
                        dataDisplaySource = this._wrapSourceForViewChange(dataDisplayHelper.getMemberDataTextDataSource(app,this,"member"));
                        return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/json",AceTextEditor.OPTION_SET_DISPLAY_SOME);
                        
                    case JsonTableComponentView.TEXT_DATA_VEW:
                        dataDisplaySource = this._wrapSourceForViewChange(dataDisplayHelper.getMemberDataJsonDataSource(app,this,"member"));
                        return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/text",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                        
                    case JsonTableComponentView.GRID_DATA_VEW:
                        dataDisplaySource = this._wrapSourceForViewChange(dataDisplayHelper.getMemberDataJsonDataSource(app,this,"member"));
                        return new HandsonGridEditor(displayContainer,dataDisplaySource);
                        
                    // case JsonTableComponentView.PLAIN_DATA_VEW:
                    // default:
                    //     callbacks = dataDisplayHelper.getMemberDataTextCallbacks(app,this.member);
                    //     return new AceTextEditor(displayContainer,callbacks,"ace/mode/text",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                }
                
            case JsonTableComponentView.VIEW_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member",DEFAULT_DATA_VALUE);
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case JsonTableComponentView.VIEW_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member",DEFAULT_DATA_VALUE);
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            default:
    //temporary error handling...
                alert("unrecognized view element!");
                return null;
        }
    }

    /** This method updated the data display source to account for reloading the data display due to 
     * a change in the data view. */
    _wrapSourceForViewChange(dataDisplaySource) {
        let originalDoUpdate = dataDisplaySource.doUpdate;
        dataDisplaySource.doUpdate = () => {
            let returnValue = originalDoUpdate();
            returnValue.reloadDataDisplay = this.getComponent().isFieldUpdated("dataView");
            return returnValue;
        };
        return dataDisplaySource;
    }
}

/** This is used as the default data value if we clear the code. It really should be a function of the data view,
 * since in grid mode this is an invalid value. Support for that shold be added. */
let DEFAULT_DATA_VALUE = "";

//===============================
// Internal Settings
//===============================

JsonTableComponentView.VIEW_DATA = "Data";
JsonTableComponentView.VIEW_CODE = "Formula";
JsonTableComponentView.VIEW_SUPPLEMENTAL_CODE = "Private";

JsonTableComponentView.VIEW_MODES = [
    JsonTableComponentView.VIEW_DATA,
    JsonTableComponentView.VIEW_CODE,
    JsonTableComponentView.VIEW_SUPPLEMENTAL_CODE
];

JsonTableComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": JsonTableComponentView.VIEW_MODES,
    "defaultView": JsonTableComponentView.VIEW_DATA,
    "emptyDataValue": ""
};

JsonTableComponentView.COLORIZED_DATA_VEW = "Colorized";
JsonTableComponentView.TEXT_DATA_VEW = "Text Data";
JsonTableComponentView.GRID_DATA_VEW = "Grid";
JsonTableComponentView.PLAIN_DATA_VEW = "Plain"; 

JsonTableComponentView.DEFAULT_DATA_VIEW = JsonTableComponentView.COLORIZED_DATA_VEW;

//===============================
// External Settings
//===============================

/** This is the component name with which this view is associated. */
JsonTableComponentView.componentName = "apogeeapp.JsonCell";

/** If true, this indicates the component has a tab entry */
JsonTableComponentView.hasTabEntry = false;
/** If true, this indicates the component has an entry appearing on the parent tab */
JsonTableComponentView.hasChildEntry = true;
/** This is the icon url for the component. */
JsonTableComponentView.ICON_RES_PATH = "/componentIcons/dataTable.png";
/** This field gives the default value for the JSON taht should be deserialized to
 * create the member for this object. The field "name" can be omitted. This will 
 * be added when the member is created. */

 /** This is configuration for the properties dialog box, the results of which
 * our code will read in. */
JsonTableComponentView.propertyDialogLines = [
    {
        "type":"dropdown",
        "heading":"Data View: ",
        "entries":[
            "Colorized",
//            "Plain",
            "Text Data",
            "Grid"
        ],
        "resultKey":"dataView"
    }
];

/**
 * Toolbar Plugin
 * - Allows toolbar items, such as buttons.
 * - Each item can have an optional "update" function. This will be called when the selection changes and allows
 * for corresponding changes to the button appearance or function. It is passed "selectionInfo". See below.
 * - Each item can have an optional "getMarkSelectionGenerator" function. This is generates an entry for the selection
 * info for a given mark. (Block selection info is handled automatically.) See below for format.
 * - Each item must have a "registerEditorView" function. This will be called to pass the editor view to the button, so it can
 * act on the view.
 * - Each item must have a "getElement" call, to retrive the DOM element for the item.
 * 
 * SelectionInfo is an object with two entries, "blocks" and "marks". The entry in blocks is automatically generated. The entry
 * for marks is generated by a function from the item itself. The item provides this from the "getMarkSelectionGenerator".
 * 
 * (FOR NOW - see code for examples of how these work)
*/

class ApogeeToolbar {
  constructor(items) {
    this.items = items;
    
    this.dom = document.createElement("div");
    this.dom.className = "atb_toolbar";

    this.markSelectionGenerators = {};

    this.items.forEach(item => this._addToolbarItem(item));
    
  }

  setEditorView(editorView) {
    this.editorView = editorView;

    this.items.forEach(item => {
      item.registerEditorView(editorView);
    });
    this.update();
  }


  update() {
    var selectionInfo = this._getSelectionInfo();
    this.items.forEach(item => {
      item.update(selectionInfo);
    });
  }

  destroy() {
    //this.dom.remove()
  }

  _addToolbarItem(toolbarItem) {

    //this allows mark items to create custom information for themselves in a simple and efficient way
    //blocks are handled in standard way
    if(toolbarItem.getMarkSelectionGenerator) {
      this._registerMarkSelectionGenerator(toolbarItem.getMarkSelectionGenerator());
    }

    this.dom.appendChild(toolbarItem.getElement());
  }

  /** This function allows each mark to create information on selection to decide the item
   * status, such as if the press should turn the mark on or off */
  _registerMarkSelectionGenerator(selectionGenerator) {
    if(selectionGenerator.name) {
      this.markSelectionGenerators[selectionGenerator.name] = selectionGenerator;
    }
  }

  /** This function creates information on each selection event to update the status of the buttons */
  _getSelectionInfo() {

    let { $from, $to } = this.editorView.state.selection;
    let doc = this.editorView.state.doc;
    let schema = this.editorView.state.schema;

    //----------------------------
    //get block info
    //create a list of blocks present
    //-----------------------------
    let blockInfo = {};
    let startBlockIndex = $from.index(0);
    let endBlockIndex = $to.index(0);

    let blockMap = {};
    blockInfo.blockTypes = [];
    for(let index = startBlockIndex; index <= endBlockIndex; index++) {
      let childNode = doc.maybeChild(index);
      if((childNode)&&(!blockMap[childNode.type.name])) {
        blockMap[childNode.type.name] = true;
        blockInfo.blockTypes.push(childNode.type);
      }
    }

    //-------------------
    //get mark info
    //toolbar buttons register a function to create their own mark info entry
    //-------------------
    //initialize mark info
    let markInfo = {};
    for(let markName in this.markSelectionGenerators) {
      let initEntryFunction = this.markSelectionGenerators[markName].getEmptyInfo;
      markInfo[markName] = initEntryFunction ? initEntryFunction() : {};
    }

    //process marks for text nodes.
    let textNodeNumber = 0;
    let setMarkInfo = node => {
      if(node.isText) {
        node.marks.forEach( mark => {
          let markInfoUpdater = this.markSelectionGenerators[mark.type.name].updateInfo;
          if(markInfoUpdater) {
            let markInfoEntry = markInfo[mark.type.name];
            markInfoUpdater(mark,markInfoEntry,textNodeNumber);
          }
        });
        textNodeNumber++;
      }
    };

    doc.nodesBetween($from.pos,$to.pos,setMarkInfo);

    //call final update, if needed
    for(let markName in this.markSelectionGenerators) {
      let onCompleteFunction = this.markSelectionGenerators[markName].onComplete;
      let markInfoEntry = markInfo[markName];
      if(onCompleteFunction) onCompleteFunction(markInfoEntry,textNodeNumber);
    }
    
    //return selection info
    let selectionInfo = {};
    selectionInfo.blocks = blockInfo;
    selectionInfo.marks = markInfo;
    return selectionInfo;
  }

}

const classesById = Object.create(null);

// ::- Superclass for editor selections. Every selection type should
// extend this. Should not be instantiated directly.
class Selection {
  // :: (ResolvedPos, ResolvedPos, ?[SelectionRange])
  // Initialize a selection with the head and anchor and ranges. If no
  // ranges are given, constructs a single range across `$anchor` and
  // `$head`.
  constructor($anchor, $head, ranges) {
    // :: [SelectionRange]
    // The ranges covered by the selection.
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
    // :: ResolvedPos
    // The resolved anchor of the selection (the side that stays in
    // place when the selection is modified).
    this.$anchor = $anchor;
    // :: ResolvedPos
    // The resolved head of the selection (the side that moves when
    // the selection is modified).
    this.$head = $head;
  }

  // :: number
  // The selection's anchor, as an unresolved position.
  get anchor() { return this.$anchor.pos }

  // :: number
  // The selection's head.
  get head() { return this.$head.pos }

  // :: number
  // The lower bound of the selection's main range.
  get from() { return this.$from.pos }

  // :: number
  // The upper bound of the selection's main range.
  get to() { return this.$to.pos }

  // :: ResolvedPos
  // The resolved lower  bound of the selection's main range.
  get $from() {
    return this.ranges[0].$from
  }

  // :: ResolvedPos
  // The resolved upper bound of the selection's main range.
  get $to() {
    return this.ranges[0].$to
  }

  // :: bool
  // Indicates whether the selection contains any content.
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos) return false
    return true
  }

  // eq:: (Selection)  bool
  // Test whether the selection is the same as another selection.

  // map:: (doc: Node, mapping: Mappable)  Selection
  // Map this selection through a [mappable](#transform.Mappable) thing. `doc`
  // should be the new document to which we are mapping.

  // :: ()  Slice
  // Get the content of this selection as a slice.
  content() {
    return this.$from.node(0).slice(this.from, this.to, true)
  }

  // :: (Transaction, ?Slice)
  // Replace the selection with a slice or, if no slice is given,
  // delete the selection. Will append to the given transaction.
  replace(tr, content = Slice.empty) {
    // Put the new selection at the position after the inserted
    // content. When that ended in an inline node, search backwards,
    // to get the position after that node. If not, search forward.
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }

    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }

  // :: (Transaction, Node)
  // Replace the selection with the given node, appending the changes
  // to the given transaction.
  replaceWith(tr, node) {
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom);
      let from = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr.deleteRange(from, to);
      } else {
        tr.replaceRangeWith(from, to, node);
        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }

  // toJSON:: ()  Object
  // Convert the selection to a JSON representation. When implementing
  // this for a custom selection class, make sure to give the object a
  // `type` property whose value matches the ID under which you
  // [registered](#state.Selection^jsonID) your class.

  // :: (ResolvedPos, number, ?bool)  ?Selection
  // Find a valid cursor or leaf node selection starting at the given
  // position and searching back if `dir` is negative, and forward if
  // positive. When `textOnly` is true, only consider cursor
  // selections. Will return null when no valid selection position is
  // found.
  static findFrom($pos, dir, textOnly) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos)
        : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner) return inner

    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found = dir < 0
          ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)
          : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found) return found
    }
  }

  // :: (ResolvedPos, ?number)  Selection
  // Find a valid cursor or leaf node selection near the given
  // position. Searches forward first by default, but if `bias` is
  // negative, it will search backwards first.
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))
  }

  // :: (Node)  Selection
  // Find the cursor or leaf node selection closest to the start of
  // the given document. Will return an
  // [`AllSelection`](#state.AllSelection) if no valid position
  // exists.
  static atStart(doc) {
    return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)
  }

  // :: (Node)  Selection
  // Find the cursor or leaf node selection closest to the end of the
  // given document.
  static atEnd(doc) {
    return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)
  }

  // :: (Node, Object)  Selection
  // Deserialize the JSON representation of a selection. Must be
  // implemented for custom classes (as a static class method).
  static fromJSON(doc, json) {
    if (!json || !json.type) throw new RangeError("Invalid input for Selection.fromJSON")
    let cls = classesById[json.type];
    if (!cls) throw new RangeError(`No selection type ${json.type} defined`)
    return cls.fromJSON(doc, json)
  }

  // :: (string, constructor<Selection>)
  // To be able to deserialize selections from JSON, custom selection
  // classes must register themselves with an ID string, so that they
  // can be disambiguated. Try to pick something that's unlikely to
  // clash with classes from other modules.
  static jsonID(id, selectionClass) {
    if (id in classesById) throw new RangeError("Duplicate use of selection JSON ID " + id)
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass
  }

  // :: ()  SelectionBookmark
  // Get a [bookmark](#state.SelectionBookmark) for this selection,
  // which is a value that can be mapped without having access to a
  // current document, and later resolved to a real selection for a
  // given document again. (This is used mostly by the history to
  // track and restore old selections.) The default implementation of
  // this method just converts the selection to a text selection and
  // returns the bookmark for that.
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark()
  }
}

// :: bool
// Controls whether, when a selection of this type is active in the
// browser, the selected range should be visible to the user. Defaults
// to `true`.
Selection.prototype.visible = true;

// SelectionBookmark:: interface
// A lightweight, document-independent representation of a selection.
// You can define a custom bookmark type for a custom selection class
// to make the history handle it well.
//
//   map:: (mapping: Mapping)  SelectionBookmark
//   Map the bookmark through a set of changes.
//
//   resolve:: (doc: Node)  Selection
//   Resolve the bookmark to a real selection again. This may need to
//   do some error checking and may fall back to a default (usually
//   [`TextSelection.between`](#state.TextSelection^between)) if
//   mapping made the bookmark invalid.

// ::- Represents a selected range in a document.
class SelectionRange {
  // :: (ResolvedPos, ResolvedPos)
  constructor($from, $to) {
    // :: ResolvedPos
    // The lower bound of the range.
    this.$from = $from;
    // :: ResolvedPos
    // The upper bound of the range.
    this.$to = $to;
  }
}

// ::- A text selection represents a classical editor selection, with
// a head (the moving side) and anchor (immobile side), both of which
// point into textblock nodes. It can be empty (a regular cursor
// position).
class TextSelection extends Selection {
  // :: (ResolvedPos, ?ResolvedPos)
  // Construct a text selection between the given points.
  constructor($anchor, $head = $anchor) {
    super($anchor, $head);
  }

  // :: ?ResolvedPos
  // Returns a resolved position if this is a cursor selection (an
  // empty text selection), and null otherwise.
  get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null }

  map(doc, mapping) {
    let $head = doc.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent) return Selection.near($head)
    let $anchor = doc.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)
  }

  replace(tr, content = Slice.empty) {
    super.replace(tr, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks) tr.ensureMarks(marks);
    }
  }

  eq(other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head
  }

  getBookmark() {
    return new TextBookmark(this.anchor, this.head)
  }

  toJSON() {
    return {type: "text", anchor: this.anchor, head: this.head}
  }

  static fromJSON(doc, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON")
    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))
  }

  // :: (Node, number, ?number)  TextSelection
  // Create a text selection from non-resolved positions.
  static create(doc, anchor, head = anchor) {
    let $anchor = doc.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))
  }

  // :: (ResolvedPos, ResolvedPos, ?number)  Selection
  // Return a text selection that spans the given positions or, if
  // they aren't text positions, find a text selection near them.
  // `bias` determines whether the method searches forward (default)
  // or backwards (negative number) first. Will fall back to calling
  // [`Selection.near`](#state.Selection^near) when the document
  // doesn't contain a valid text position.
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos) bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found) $head = found.$head;
      else return Selection.near($head, bias)
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if (($anchor.pos < $head.pos) != (dPos < 0)) $anchor = $head;
      }
    }
    return new TextSelection($anchor, $head)
  }
}

Selection.jsonID("text", TextSelection);

class TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))
  }
  resolve(doc) {
    return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))
  }
}

// ::- A node selection is a selection that points at a single node.
// All nodes marked [selectable](#model.NodeSpec.selectable) can be
// the target of a node selection. In such a selection, `from` and
// `to` point directly before and after the selected node, `anchor`
// equals `from`, and `head` equals `to`..
class NodeSelection extends Selection {
  // :: (ResolvedPos)
  // Create a node selection. Does not verify the validity of its
  // argument.
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    // :: Node The selected node.
    this.node = node;
  }

  map(doc, mapping) {
    let {deleted, pos} = mapping.mapResult(this.anchor);
    let $pos = doc.resolve(pos);
    if (deleted) return Selection.near($pos)
    return new NodeSelection($pos)
  }

  content() {
    return new Slice(Fragment.from(this.node), 0, 0)
  }

  eq(other) {
    return other instanceof NodeSelection && other.anchor == this.anchor
  }

  toJSON() {
    return {type: "node", anchor: this.anchor}
  }

  getBookmark() { return new NodeBookmark(this.anchor) }

  static fromJSON(doc, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON")
    return new NodeSelection(doc.resolve(json.anchor))
  }

  // :: (Node, number)  NodeSelection
  // Create a node selection from non-resolved positions.
  static create(doc, from) {
    return new this(doc.resolve(from))
  }

  // :: (Node)  bool
  // Determines whether the given node may be selected as a node
  // selection.
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false
  }
}

NodeSelection.prototype.visible = false;

Selection.jsonID("node", NodeSelection);

class NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let {deleted, pos} = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)
  }
  resolve(doc) {
    let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos)
    return Selection.near($pos)
  }
}

// ::- A selection type that represents selecting the whole document
// (which can not necessarily be expressed with a text selection, when
// there are for example leaf block nodes at the start or end of the
// document).
class AllSelection extends Selection {
  // :: (Node)
  // Create an all-selection over the given document.
  constructor(doc) {
    super(doc.resolve(0), doc.resolve(doc.content.size));
  }

  toJSON() { return {type: "all"} }

  static fromJSON(doc) { return new AllSelection(doc) }

  map(doc) { return new AllSelection(doc) }

  eq(other) { return other instanceof AllSelection }

  getBookmark() { return AllBookmark }
}

Selection.jsonID("all", AllSelection);

const AllBookmark = {
  map() { return this },
  resolve(doc) { return new AllSelection(doc) }
};

// FIXME we'll need some awareness of text direction when scanning for selections

// Try to find a selection inside the given node. `pos` points at the
// position where the search starts. When `text` is true, only return
// text selections.
function findSelectionIn(doc, node, pos, index, dir, text) {
  if (node.inlineContent) return TextSelection.create(doc, pos)
  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner) return inner
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))
    }
    pos += child.nodeSize * dir;
  }
}

function selectionToInsertionEnd(tr, startLen, bias) {
  let last = tr.steps.length - 1;
  if (last < startLen) return
  let step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) return
  let map = tr.mapping.maps[last], end;
  map.forEach((_from, _to, _newFrom, newTo) => { if (end == null) end = newTo; });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}

const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;

// ::- An editor state transaction, which can be applied to a state to
// create an updated state. Use
// [`EditorState.tr`](#state.EditorState.tr) to create an instance.
//
// Transactions track changes to the document (they are a subclass of
// [`Transform`](#transform.Transform)), but also other state changes,
// like selection updates and adjustments of the set of [stored
// marks](#state.EditorState.storedMarks). In addition, you can store
// metadata properties in a transaction, which are extra pieces of
// information that client code or plugins can use to describe what a
// transacion represents, so that they can update their [own
// state](#state.StateField) accordingly.
//
// The [editor view](#view.EditorView) uses a few metadata properties:
// it will attach a property `"pointer"` with the value `true` to
// selection transactions directly caused by mouse or touch input, and
// a `"uiEvent"` property of that may be `"paste"`, `"cut"`, or `"drop"`.
class Transaction extends Transform {
  constructor(state) {
    super(state.doc);
    // :: number
    // The timestamp associated with this transaction, in the same
    // format as `Date.now()`.
    this.time = Date.now();
    this.curSelection = state.selection;
    // The step count for which the current selection is valid.
    this.curSelectionFor = 0;
    // :: ?[Mark]
    // The stored marks set by this transaction, if any.
    this.storedMarks = state.storedMarks;
    // Bitfield to track which aspects of the state were updated by
    // this transaction.
    this.updated = 0;
    // Object used to store metadata properties for the transaction.
    this.meta = Object.create(null);
  }

  // :: Selection
  // The transaction's current selection. This defaults to the editor
  // selection [mapped](#state.Selection.map) through the steps in the
  // transaction, but can be overwritten with
  // [`setSelection`](#state.Transaction.setSelection).
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection
  }

  // :: (Selection)  Transaction
  // Update the transaction's current selection. Will determine the
  // selection that the editor gets when the transaction is applied.
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document")
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this
  }

  // :: bool
  // Whether the selection was explicitly updated by this transaction.
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0
  }

  // :: (?[Mark])  Transaction
  // Set the current stored marks.
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this
  }

  // :: ([Mark])  Transaction
  // Make sure the current stored marks or, if that is null, the marks
  // at the selection, match the given set of marks. Does nothing if
  // this is already the case.
  ensureMarks(marks) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this
  }

  // :: (Mark)  Transaction
  // Add a mark to the set of stored marks.
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))
  }

  // :: (union<Mark, MarkType>)  Transaction
  // Remove a mark or mark type from the set of stored marks.
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))
  }

  // :: bool
  // Whether the stored marks were explicitly set for this transaction.
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0
  }

  addStep(step, doc) {
    super.addStep(step, doc);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }

  // :: (number)  Transaction
  // Update the timestamp for the transaction.
  setTime(time) {
    this.time = time;
    return this
  }

  // :: (Slice)  Transaction
  // Replace the current selection with the given slice.
  replaceSelection(slice) {
    this.selection.replace(this, slice);
    return this
  }

  // :: (Node, ?bool)  Transaction
  // Replace the selection with the given node. When `inheritMarks` is
  // true and the content is inline, it inherits the marks from the
  // place where it is inserted.
  replaceSelectionWith(node, inheritMarks) {
    let selection = this.selection;
    if (inheritMarks !== false)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none)));
    selection.replaceWith(this, node);
    return this
  }

  // :: ()  Transaction
  // Delete the selection.
  deleteSelection() {
    this.selection.replace(this);
    return this
  }

  // :: (string, from: ?number, to: ?number)  Transaction
  // Replace the given range, or the selection if no range is given,
  // with a text node containing the given string.
  insertText(text, from, to = from) {
    let schema = this.doc.type.schema;
    if (from == null) {
      if (!text) return this.deleteSelection()
      return this.replaceSelectionWith(schema.text(text), true)
    } else {
      if (!text) return this.deleteRange(from, to)
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from);
        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from, to, schema.text(text, marks));
      if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to));
      return this
    }
  }

  // :: (union<string, Plugin, PluginKey>, any)  Transaction
  // Store a metadata property in this transaction, keyed either by
  // name or by plugin.
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this
  }

  // :: (union<string, Plugin, PluginKey>)  any
  // Retrieve a metadata property for a given name or plugin.
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key]
  }

  // :: bool
  // Returns true if this transaction doesn't contain any metadata,
  // and can thus safely be extended.
  get isGeneric() {
    for (let _ in this.meta) return false
    return true
  }

  // :: ()  Transaction
  // Indicate that the editor should scroll the selection into view
  // when updated to the state produced by this transaction.
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this
  }

  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0
  }
}

function bind(f, self) {
  return !self || !f ? f : f.bind(self)
}

class FieldDesc {
  constructor(name, desc, self) {
    this.name = name;
    this.init = bind(desc.init, self);
    this.apply = bind(desc.apply, self);
  }
}

const baseFields = [
  new FieldDesc("doc", {
    init(config) { return config.doc || config.schema.topNodeType.createAndFill() },
    apply(tr) { return tr.doc }
  }),

  new FieldDesc("selection", {
    init(config, instance) { return config.selection || Selection.atStart(instance.doc) },
    apply(tr) { return tr.selection }
  }),

  new FieldDesc("storedMarks", {
    init(config) { return config.storedMarks || null },
    apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }
  }),

  new FieldDesc("scrollToSelection", {
    init() { return 0 },
    apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }
  })
];

// Object wrapping the part of a state object that stays the same
// across transactions. Stored in the state's `config` property.
class Configuration {
  constructor(schema, plugins) {
    this.schema = schema;
    this.fields = baseFields.concat();
    this.plugins = [];
    this.pluginsByKey = Object.create(null);
    if (plugins) plugins.forEach(plugin => {
      if (this.pluginsByKey[plugin.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")")
      this.plugins.push(plugin);
      this.pluginsByKey[plugin.key] = plugin;
      if (plugin.spec.state)
        this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
    });
  }
}

// ::- The state of a ProseMirror editor is represented by an object
// of this type. A state is a persistent data structureit isn't
// updated, but rather a new state value is computed from an old one
// using the [`apply`](#state.EditorState.apply) method.
//
// A state holds a number of built-in fields, and plugins can
// [define](#state.PluginSpec.state) additional fields.
class EditorState {
  constructor(config) {
    this.config = config;
  }

  // doc:: Node
  // The current document.

  // selection:: Selection
  // The selection.

  // storedMarks:: ?[Mark]
  // A set of marks to apply to the next input. Will be null when
  // no explicit marks have been set.

  // :: Schema
  // The schema of the state's document.
  get schema() {
    return this.config.schema
  }

  // :: [Plugin]
  // The plugins that are active in this state.
  get plugins() {
    return this.config.plugins
  }

  // :: (Transaction)  EditorState
  // Apply the given transaction to produce a new state.
  apply(tr) {
    return this.applyTransaction(tr).state
  }

  // : (Transaction)  bool
  filterTransaction(tr, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++) if (i != ignore) {
      let plugin = this.config.plugins[i];
      if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
        return false
    }
    return true
  }

  // :: (Transaction)  {state: EditorState, transactions: [Transaction]}
  // Verbose variant of [`apply`](#state.EditorState.apply) that
  // returns the precise transactions that were applied (which might
  // be influenced by the [transaction
  // hooks](#state.PluginSpec.filterTransaction) of
  // plugins) along with the new state.
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr)) return {state: this, transactions: []}

    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    // This loop repeatedly gives plugins a chance to respond to
    // transactions as new transactions are added, making sure to only
    // pass the transactions the plugin did not see before.
     for (;;) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr = n < trs.length &&
              plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr && newState.filterTransaction(tr, i)) {
            tr.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0});
            }
            trs.push(tr);
            newState = newState.applyInner(tr);
            haveNew = true;
          }
          if (seen) seen[i] = {state: newState, n: trs.length};
        }
      }
      if (!haveNew) return {state: newState, transactions: trs}
    }
  }

  // : (Transaction)  EditorState
  applyInner(tr) {
    if (!tr.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction")
    let newInstance = new EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
    }
    for (let i = 0; i < applyListeners.length; i++) applyListeners[i](this, tr, newInstance);
    return newInstance
  }

  // :: Transaction
  // Start a [transaction](#state.Transaction) from this state.
  get tr() { return new Transaction(this) }

  // :: (Object)  EditorState
  // Create a new state.
  //
  //   config::- Configuration options. Must contain `schema` or `doc` (or both).
  //
  //      schema:: ?Schema
  //      The schema to use.
  //
  //      doc:: ?Node
  //      The starting document.
  //
  //      selection:: ?Selection
  //      A valid selection in the document.
  //
  //      storedMarks:: ?[Mark]
  //      The initial set of [stored marks](#state.EditorState.storedMarks).
  //
  //      plugins:: ?[Plugin]
  //      The plugins that should be active in this state.
  static create(config) {
    let $config = new Configuration(config.schema || config.doc.type.schema, config.plugins);
    let instance = new EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    return instance
  }

  // :: (Object)  EditorState
  // Create a new state based on this one, but with an adjusted set of
  // active plugins. State fields that exist in both sets of plugins
  // are kept unchanged. Those that no longer exist are dropped, and
  // those that are new are initialized using their
  // [`init`](#state.StateField.init) method, passing in the new
  // configuration object..
  //
  //   config::- configuration options
  //
  //     schema:: ?Schema
  //     New schema to use.
  //
  //     plugins:: ?[Plugin]
  //     New set of active plugins.
  reconfigure(config) {
    let $config = new Configuration(config.schema || this.schema, config.plugins);
    let fields = $config.fields, instance = new EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance
  }

  // :: (?union<Object<Plugin>, string, number>)  Object
  // Serialize this state to JSON. If you want to serialize the state
  // of plugins, pass an object mapping property names to use in the
  // resulting JSON object to plugin objects. The argument may also be
  // a string or number, in which case it is ignored, to support the
  // way `JSON.stringify` calls `toString` methods.
  toJSON(pluginFields) {
    let result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()};
    if (this.storedMarks) result.storedMarks = this.storedMarks.map(m => m.toJSON());
    if (pluginFields && typeof pluginFields == 'object') for (let prop in pluginFields) {
      if (prop == "doc" || prop == "selection")
        throw new RangeError("The JSON fields `doc` and `selection` are reserved")
      let plugin = pluginFields[prop], state = plugin.spec.state;
      if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key]);
    }
    return result
  }

  // :: (Object, Object, ?Object<Plugin>)  EditorState
  // Deserialize a JSON representation of a state. `config` should
  // have at least a `schema` field, and should contain array of
  // plugins to initialize the state with. `pluginFields` can be used
  // to deserialize the state of plugins, by associating plugin
  // instances with the property names they use in the JSON object.
  //
  //   config::- configuration options
  //
  //     schema:: Schema
  //     The schema to use.
  //
  //     plugins:: ?[Plugin]
  //     The set of active plugins.
  static fromJSON(config, json, pluginFields) {
    if (!json) throw new RangeError("Invalid input for EditorState.fromJSON")
    if (!config.schema) throw new RangeError("Required config field 'schema' missing")
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new EditorState($config);
    $config.fields.forEach(field => {
      if (field.name == "doc") {
        instance.doc = Node$1.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields) for (let prop in pluginFields) {
          let plugin = pluginFields[prop], state = plugin.spec.state;
          if (plugin.key == field.name && state && state.fromJSON &&
              Object.prototype.hasOwnProperty.call(json, prop)) {
            // This field belongs to a plugin mapped to a JSON field, read it from there.
            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
            return
          }
        }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance
  }

  // Kludge to allow the view to track mappings between different
  // instances of a state.
  //
  // FIXME this is no longer needed as of prosemirror-view 1.9.0,
  // though due to backwards-compat we should probably keep it around
  // for a while (if only as a no-op)
  static addApplyListener(f) {
    applyListeners.push(f);
  }
  static removeApplyListener(f) {
    let found = applyListeners.indexOf(f);
    if (found > -1) applyListeners.splice(found, 1);
  }
}

const applyListeners = [];

// PluginSpec:: interface
//
// This is the type passed to the [`Plugin`](#state.Plugin)
// constructor. It provides a definition for a plugin.
//
//   props:: ?EditorProps
//   The [view props](#view.EditorProps) added by this plugin. Props
//   that are functions will be bound to have the plugin instance as
//   their `this` binding.
//
//   state:: ?StateField<any>
//   Allows a plugin to define a [state field](#state.StateField), an
//   extra slot in the state object in which it can keep its own data.
//
//   key:: ?PluginKey
//   Can be used to make this a keyed plugin. You can have only one
//   plugin with a given key in a given state, but it is possible to
//   access the plugin's configuration and state through the key,
//   without having access to the plugin instance object.
//
//   view:: ?(EditorView)  Object
//   When the plugin needs to interact with the editor view, or
//   set something up in the DOM, use this field. The function
//   will be called when the plugin's state is associated with an
//   editor view.
//
//     return::-
//     Should return an object with the following optional
//     properties:
//
//       update:: ?(view: EditorView, prevState: EditorState)
//       Called whenever the view's state is updated.
//
//       destroy:: ?()
//       Called when the view is destroyed or receives a state
//       with different plugins.
//
//   filterTransaction:: ?(Transaction, EditorState)  bool
//   When present, this will be called before a transaction is
//   applied by the state, allowing the plugin to cancel it (by
//   returning false).
//
//   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState)  ?Transaction
//   Allows the plugin to append another transaction to be applied
//   after the given array of transactions. When another plugin
//   appends a transaction after this was called, it is called again
//   with the new state and new transactionsbut only the new
//   transactions, i.e. it won't be passed transactions that it
//   already saw.

function bindProps(obj, self, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function) val = val.bind(self);
    else if (prop == "handleDOMEvents") val = bindProps(val, self, {});
    target[prop] = val;
  }
  return target
}

// ::- Plugins bundle functionality that can be added to an editor.
// They are part of the [editor state](#state.EditorState) and
// may influence that state and the view that contains it.
class Plugin {
  // :: (PluginSpec)
  // Create a plugin.
  constructor(spec) {
    // :: EditorProps
    // The [props](#view.EditorProps) exported by this plugin.
    this.props = {};
    if (spec.props) bindProps(spec.props, this, this.props);
    // :: Object
    // The plugin's [spec object](#state.PluginSpec).
    this.spec = spec;
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }

  // :: (EditorState)  any
  // Extract the plugin's state field from an editor state.
  getState(state) { return state[this.key] }
}

// StateField:: interface<T>
// A plugin spec may provide a state field (under its
// [`state`](#state.PluginSpec.state) property) of this type, which
// describes the state it wants to keep. Functions provided here are
// always called with the plugin instance as their `this` binding.
//
//   init:: (config: Object, instance: EditorState)  T
//   Initialize the value of the field. `config` will be the object
//   passed to [`EditorState.create`](#state.EditorState^create). Note
//   that `instance` is a half-initialized state instance, and will
//   not have values for plugin fields initialized after this one.
//
//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState)  T
//   Apply the given transaction to this state field, producing a new
//   field value. Note that the `newState` argument is again a partially
//   constructed state does not yet contain the state from plugins
//   coming after this one.
//
//   toJSON:: ?(value: T)  *
//   Convert this field to JSON. Optional, can be left off to disable
//   JSON serialization for the field.
//
//   fromJSON:: ?(config: Object, value: *, state: EditorState)  T
//   Deserialize the JSON representation of this field. Note that the
//   `state` argument is again a half-initialized state.

const keys = Object.create(null);

function createKey(name) {
  if (name in keys) return name + "$" + ++keys[name]
  keys[name] = 0;
  return name + "$"
}

// :: (EditorState, ?(tr: Transaction))  bool
// Delete the selection, if there is one.
function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false
  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView());
  return true
}

// :: (EditorState, ?(tr: Transaction), ?EditorView)  bool
// If the selection is empty and at the start of a textblock, try to
// reduce the distance between that block and the one before itif
// there's a block directly before it that can be joined, join them.
// If not, try to move the selected block closer to the next one in
// the document structure by lifting it out of its parent or moving it
// into a parent of the previous block. Will use the view for accurate
// (bidi-aware) start-of-textblock detection if given.
function joinBackward(state, dispatch, view) {
  let {$cursor} = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state)
                        : $cursor.parentOffset > 0))
    return false

  let $cut = findCutBefore($cursor);

  // If there is no node before this, try to lift
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null) return false
    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
    return true
  }

  let before = $cut.nodeBefore;
  // Apply the joining algorithm
  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
    return true

  // If the node below has no content and the node above is
  // selectable, delete the node below and select the one above.
  if ($cursor.parent.content.size == 0 &&
      (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    if (dispatch) {
      let tr = state.tr.deleteRange($cursor.before(), $cursor.after());
      tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)
                      : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
      dispatch(tr.scrollIntoView());
    }
    return true
  }

  // If the node before is an atom, delete it
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true
  }

  return false
}

function textblockAt(node, side) {
  for (; node; node = (side == "start" ? node.firstChild : node.lastChild))
    if (node.isTextblock) return true
  return false
}

// :: (EditorState, ?(tr: Transaction), ?EditorView)  bool
// When the selection is empty and at the start of a textblock, select
// the node before that textblock, if possible. This is intended to be
// bound to keys like backspace, after
// [`joinBackward`](#commands.joinBackward) or other deleting
// commands, as a fall-back behavior when the schema doesn't allow
// deletion at the selected point.
function selectNodeBackward(state, dispatch, view) {
  let {$cursor} = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state)
                        : $cursor.parentOffset > 0))
    return false

  let $cut = findCutBefore($cursor), node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node)) return false
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true
}

function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {
    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1))
    if ($pos.node(i).type.spec.isolating) break
  }
  return null
}

// :: (EditorState, ?(tr: Transaction), ?EditorView)  bool
// If the selection is empty and the cursor is at the end of a
// textblock, try to reduce or remove the boundary between that block
// and the one after it, either by joining them or by moving the other
// block closer to this one in the tree structure. Will use the view
// for accurate start-of-textblock detection if given.
function joinForward(state, dispatch, view) {
  let {$cursor} = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state)
                        : $cursor.parentOffset < $cursor.parent.content.size))
    return false

  let $cut = findCutAfter($cursor);

  // If there is no node after this, there's nothing to do
  if (!$cut) return false

  let after = $cut.nodeAfter;
  // Try the joining algorithm
  if (deleteBarrier(state, $cut, dispatch)) return true

  // If the node above has no content and the node below is
  // selectable, delete the node above and select the one below.
  if ($cursor.parent.content.size == 0 &&
      (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    if (dispatch) {
      let tr = state.tr.deleteRange($cursor.before(), $cursor.after());
      tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)
                      : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
      dispatch(tr.scrollIntoView());
    }
    return true
  }

  // If the next node is an atom, delete it
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true
  }

  return false
}

// :: (EditorState, ?(tr: Transaction), ?EditorView)  bool
// When the selection is empty and at the end of a textblock, select
// the node coming after that textblock, if possible. This is intended
// to be bound to keys like delete, after
// [`joinForward`](#commands.joinForward) and similar deleting
// commands, to provide a fall-back behavior when the schema doesn't
// allow deletion at the selected point.
function selectNodeForward(state, dispatch, view) {
  let {$cursor} = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state)
                        : $cursor.parentOffset < $cursor.parent.content.size))
    return false

  let $cut = findCutAfter($cursor), node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node)) return false
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true
}

function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {
    let parent = $pos.node(i);
    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1))
    if (parent.type.spec.isolating) break
  }
  return null
}

// :: (EditorState, ?(tr: Transaction))  bool
// If a block node is selected, create an empty paragraph before (if
// it is its parent's first child) or after it.
function createParagraphNear(state, dispatch) {
  let {$from, $to} = state.selection;
  if ($from.parent.inlineContent || $to.parent.inlineContent) return false
  let type = $from.parent.contentMatchAt($to.indexAfter()).defaultType;
  if (!type || !type.isTextblock) return false
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }
  return true
}

// :: (EditorState, ?(tr: Transaction))  bool
// Split the parent block of the selection. If the selection is a text
// selection, also delete its content.
function splitBlock(state, dispatch) {
  let {$from, $to} = state.selection;
  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) return false
    if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView());
    return true
  }

  if (!$from.parent.isBlock) return false

  if (dispatch) {
    let atEnd = $to.parentOffset == $to.parent.content.size;
    let tr = state.tr;
    if (state.selection instanceof TextSelection) tr.deleteSelection();
    let deflt = $from.depth == 0 ? null : $from.node(-1).contentMatchAt($from.indexAfter(-1)).defaultType;
    let types = atEnd && deflt ? [{type: deflt}] : null;
    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {
      types = [{type: deflt}];
      can = true;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt &&
          $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), Fragment.from(deflt.create(), $from.parent)))
        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
    }
    dispatch(tr.scrollIntoView());
  }
  return true
}

// :: (EditorState, ?(tr: Transaction))  bool
// Select the whole document.
function selectAll(state, dispatch) {
  if (dispatch) dispatch(state.tr.setSelection(new AllSelection(state.doc)));
  return true
}

function joinMaybeClear(state, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type)) return false
  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true
  }
  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false
  if (dispatch)
    dispatch(state.tr
             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))
             .join($pos.pos)
             .scrollIntoView());
  return true
}

function deleteBarrier(state, $cut, dispatch) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  if (before.type.spec.isolating || after.type.spec.isolating) return false
  if (joinMaybeClear(state, $cut, dispatch)) return true

  if ($cut.parent.canReplace($cut.index(), $cut.index() + 1) &&
      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&
      match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end = $cut.pos + after.nodeSize, wrap = Fragment.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap = Fragment.from(conn[i].create(null, wrap));
      wrap = Fragment.from(before.copy(wrap));
      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true));
      let joinAt = end + 2 * conn.length;
      if (canJoin(tr.doc, joinAt)) tr.join(joinAt);
      dispatch(tr.scrollIntoView());
    }
    return true
  }

  let selAfter = Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
    return true
  }

  return false
}

// :: (...[(EditorState, ?(tr: Transaction), ?EditorView)  bool])  (EditorState, ?(tr: Transaction), ?EditorView)  bool
// Combine a number of command functions into a single function (which
// calls them one by one until one returns true).
function chainCommands(...commands) {
  return function(state, dispatch, view) {
    for (let i = 0; i < commands.length; i++)
      if (commands[i](state, dispatch, view)) return true
    return false
  }
}

// declare global: os, navigator
const mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform)
          : typeof os != "undefined" ? os.platform() == "darwin" : false;

//PROBLEMS

//--------------------------------------------------------
// Commands
//--------------------------------------------------------

// :: (EditorState, ?(tr: Transaction))  bool
// When the selection is an empty list item in a top level list (not a child list)
// this creates a default block after the list
function exitList(state, dispatch) {
    let { $head } = state.selection;
    let schema = state.schema;
    //make sure this is an empty list item in the root of a list
    if (($head.parent.type != schema.nodes.listItem) || ($head.depth != 2) || ($head.parent.content.size != 0)) return false;

    //only apply this for the last list item
    if( $head.node(1).childCount-1 > $head.index(1) ) return false;

    let above = $head.node(-2), after = $head.indexAfter(-2), type = above.contentMatchAt(after).defaultType;
    if (!above.canReplaceWith(after, after, type)) return false
    if (dispatch) {
        let transform = state.tr;

        transform = transform.delete($head.pos - 1, $head.pos + 1);

        let inListAtEndPos = transform.mapping.map($head.pos);
        let afterListPos = inListAtEndPos + 1;

        transform = transform.replaceWith(afterListPos, afterListPos, type.createAndFill());

        let newTextBlockPos = afterListPos;

        transform.setSelection(Selection.near(transform.doc.resolve(newTextBlockPos), 1));
        dispatch(transform.scrollIntoView());
    }
    return true;
}

function liftEmptyChildList(state, dispatch) {
    let { $head } = state.selection;
    let listItemDepth = $head.depth;
    let schema = state.schema;
    //make sure this is an empty list item in the root of a list
    if (($head.parent.type != schema.nodes.listItem) || (listItemDepth < 3) || ($head.parent.content.size != 0)) return false;

    //only apply this for the last list item
    if( $head.node(-1).childCount-1 > $head.index(-1) ) return false;

    if(dispatch) {
        //lift the list item
        let listDepth = listItemDepth-1;
        let transform = state.tr;
        transform = liftContent($head, $head, listDepth, transform);

        dispatch(transform.scrollIntoView());
    }

    return true;
}


function setMark(markType, attrs, state, dispatch) {
    let { empty, $cursor, ranges } = state.selection;
    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) return false
    if (dispatch) {
        if ($cursor) {
            dispatch(state.tr.addStoredMark(markType.create(attrs)));
        }
        else {
            let tr = state.tr;
            for (let i = 0; i < ranges.length; i++) {
                let { $from, $to } = ranges[i];
                tr.addMark($from.pos, $to.pos, markType.create(attrs));
            }
            dispatch(tr.scrollIntoView());
        }
    }
    return true
}


function clearMark(markType, state, dispatch) {
    let { empty, $cursor, ranges } = state.selection;
    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) return false
    if (dispatch) {
        if ($cursor) {
            dispatch(state.tr.removeStoredMark(markType));
        }
        else {
            let tr = state.tr;
            for (let i = 0; i < ranges.length; i++) {
                let { $from, $to } = ranges[i];
                tr.removeMark($from.pos, $to.pos, markType);
            }
            dispatch(tr.scrollIntoView());
        }
    }
    return true
}

function markApplies(doc, ranges, type) {
    for (let i = 0; i < ranges.length; i++) {
        let { $from, $to } = ranges[i];
        let can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;
        doc.nodesBetween($from.pos, $to.pos, node => {
            if (can) return false
            can = node.inlineContent && node.type.allowsMarkType(type);
        });
        if (can) return true
    }
    return false
}


//--
//to non-list block type commands
//--

/** This function converts a selection to a new non-list block type. */
function convertToNonListBlockType(nodeType, state, dispatch) {

    //some input checking
    if(nodeType.spec.group == "list") return false;

    //this will be our transform
    let transform = state.tr;    
    let schema = state.schema;
    let selection = state.selection;

    //------------------------------
    //if there are start and end lists, split them from the selection to update
    //------------------------------
    transform = splitStartAndEndLists(transform,selection);

    //---------------------------
    // -traverse the top level nodes (the ones in the doc) and process each
    //----------------------------

    transform = convertSelectedBlocksToNonList(transform,nodeType,selection,schema);
    
    //------------------------------
    // execute the transform
    //------------------------------

    if ((dispatch) && (transform.docChanged)) {
        dispatch(transform);
    }

    return true;

}

/** This traverses the list of nodes in the selection and converts them to the 
 * specified non-list type. Before this is called, any lists at the start and end
 * of the selection that go oustide the selection should be split, on list item boundaries.
 */
function convertSelectedBlocksToNonList(transform,nodeType,selection,schema) {

    //set the baseline for the document and the reference step for position mapping 
    let refDoc = transform.doc;
    let refStep = transform.steps.length;

    //this is our range to convert
    let { $from, $to } = selection;

    //update if we have done any transform
    if (transform.docChanged) {
        let newFrom = transform.mapping.map($from.pos);
        let newTo = transform.mapping.map($to.pos);
        $from = refDoc.resolve(newFrom);
        $to = refDoc.resolve(newTo);
    }

    //get start and end index in top level
    let firstIndex = $from.index(0);
    let lastIndex = $to.index(0);

    //traverse nodes, converting them to node type
    refDoc.forEach( (node,offset,index) => {
        if((index >= firstIndex)&&(index <= lastIndex)) {
            
            if(node.type.spec.group == "list") {
                //convert list entry to non list
                convertListToNonList(nodeType,null,node,offset,transform,refStep,schema);
            }
            else if(node.isTextblock) {
                //convert block type
                if(node.type != nodeType) {
                    convertBlockType(nodeType,null,node,offset,transform,refStep);
                }
            }
            else if(node.nodeType === schema.nodes.apogeeComponent) ;
            else {
                //this shouldn't happen
                throw new Error("Unexpected editor node type: " + node.nodeType.name);
            }
        }
    });

    return transform;
}


/** This converts the list to a parent worker, and then traverses the child nodes -
 * It updates child list items to the proper target node type. It lifts content out of any child list
 */
function convertListToNonList(targetNodeType,attrs,node,nodeRefStart,transform,refStep,schema) {
    //convert outer type to worker parent
    //traverse child
    //- list item - change to target type
    //- list - (1) recursively lift content (2) convet to target node type

    //convert top level list to worker parent
    convertBlockType(schema.nodes.workerParent,attrs,node,nodeRefStart,transform,refStep);

    //insert leading tabs on indented line (no leading tab on lowest level of list = "")
    insertLeadingStringOnIndentedLines(node,"",nodeRefStart,transform,refStep,schema);
    
    //flatten the lists inside
    flattenList(node,nodeRefStart,transform,refStep,true);

    //convert worker children to target link and remove worker 
    convertBlocksToProperTypes(targetNodeType,attrs,transform,schema);

}

/** This lifts children of the given node out of that node. */
function insertLeadingStringOnIndentedLines(node,linePrefix,nodeRefStart,transform,refStep,schema) {
    //traverse the child nodes
    
    node.forEach( (childNode,offset,index) => {
        let childNodeRefStart = nodeRefStart + 1 + offset;
        if((childNode.type == schema.nodes.listItem)&&(linePrefix.length > 0)) {     
            //get the updated mapping and text location
            let mapping = transform.mapping.slice(refStep);
            let childNodeStart = mapping.map(childNodeRefStart);
            let textStart = childNodeStart + 1;
            transform.insertText(linePrefix,textStart,textStart);
        }
        else if(childNode.type.spec.group == "list") {
            //recursive call to insert tabs
            insertLeadingStringOnIndentedLines(childNode,linePrefix + "\t",childNodeRefStart,transform,refStep,schema);
        }
    });

    return transform;
}

/** This function is used in converting to a non-list block type. That start point should be 
 * a worker parent node with text blocks inside - either list items or non-list text blocks.
 * The doc should _only_ contain worker parents in this format. All will be converted. 
 * This converts the inside blocks to the target node format and unwraps the contents from the 
 * worker parent node. */
function convertBlocksToProperTypes(targetNodeType,attrs,transform,schema) {
    //convert worker children to target link and remove worker 
    //get the updated doc
    let doc = transform.doc;
    let refStep = transform.steps.length;

    doc.forEach( (childNode,offset,index) => {
        if(childNode.type == schema.nodes.workerParent) {
            let childPosition = offset;

            childNode.forEach( (grandchildNode,childOffset,childIndex) => {
                let grandchildPosition = childPosition + 1 + childOffset;
                convertBlockType(targetNodeType,attrs,grandchildNode,grandchildPosition,transform,refStep);
            });

            unwrapChildren(childNode,childPosition,transform,refStep);
        }
    });
}

//--
//to non-list block type commands
//--

/** This function converts a selection to a new list block type. */
function convertToListBlockType(nodeType, state, dispatch) {

    //some input checking
    if(nodeType.spec.group != "list") return false;

    //this will be our transform
    let transform = state.tr;
    let schema = state.schema;
    
    //------------------------------
    //if there are start and end lists, split them from the selection to update
    //------------------------------
    transform = splitStartAndEndLists(transform,state.selection);

    //-------------------------------
    // Wrap continueous ranges of non-apogee component nodes in a worker parent, which will be our end list(s). 
    //-------------------------------

    transform = wrapSelectionInWorkerParent(transform,state.selection,schema);

    //---------------------------
    // process each future list node
    //----------------------------

    transform = processWorkerContentsToListContents(transform,nodeType,schema);

    //------------------------------
    // Convert worker parents to target list and add indent for leading tabs
    //------------------------------
    let refDoc = transform.doc;
    let refStep = transform.steps.length;
    let attrs = null;

    refDoc.forEach( (childNode,offset,index) => {
        if(childNode.type == schema.nodes.workerParent) {
            let childPosition = offset;
            
            //convert worker to target list type
            convertBlockType(nodeType,attrs,childNode,childPosition,transform,refStep);

            //add indent for top level list items with leading tabs
            addIndentForTab(nodeType,attrs,childNode,childPosition,transform,refStep,schema);

        }
    });

    //------------------------------
    // execute the transform
    //------------------------------

    if ((dispatch) && (transform.docChanged)) {
        dispatch(transform);
    }

    return true;

}


/** This function wraps the given selection in one or more worker parent nodes, with any apogee
 * component nodes excluded.
 */
function wrapSelectionInWorkerParent(transform,selection,schema) {

    let refDoc = transform.doc;
    let refStep = transform.steps.length;

    //this is our range to convert
    let { $from, $to } = selection;

    //update if we have done any transform
    if (transform.docChanged) {
        let newFrom = transform.mapping.map($from.pos);
        let newTo = transform.mapping.map($to.pos);
        $from = refDoc.resolve(newFrom);
        $to = refDoc.resolve(newTo);
    }

    //get start and end index in top level
    let firstIndex = $from.index(0);
    let lastIndex = $to.index(0);

    let startPosition;
    let endPosition;
    let inFutureList = false;
    let insertDepth = 0;
    refDoc.forEach( (node,offset,index) => {
        if((index >= firstIndex)&&(index <= lastIndex)) {

            if(node.type === schema.nodes.apogeeComponent) {
                if(inFutureList) {
                    inFutureList = false;
                    endPosition = offset;
                    //wrap in a worker parent
                    insertDepth = 0;
                    wrapSelectionInNode(startPosition,endPosition,insertDepth,schema.nodes.workerParent,transform,refStep);
                }
            }
            else {
                if(!inFutureList) {
                    inFutureList = true;
                    //set the start position
                    startPosition = offset;
                }
                //update the end position
                endPosition = offset + node.nodeSize;
            }
    
        }
    });

    //create the final list/worker segment
    if(inFutureList) {
        wrapSelectionInNode(startPosition,endPosition,insertDepth,schema.nodes.workerParent,transform,refStep);
    }

    return transform;
}

/** This method updates the top level nodes to match the desired list type. */
function processWorkerContentsToListContents(transform,nodeType,schema) {
    
    let refDoc = transform.doc;
    let refStep = transform.steps.length;

    refDoc.forEach( (node,offset,index) => {
        if(node.type == schema.nodes.workerParent) {
            let workerPosition = offset;

            node.forEach( (childNode,childOffset,index) => {
                let childPosition = workerPosition + 1 + childOffset;
            
                if(childNode.type.spec.group == "list") {
                    //lift children from al top level lists (the worker parent will be the list)
                    unwrapChildren(childNode,childPosition,transform,refStep);
                }
                else if(childNode.isTextblock) {
                    //convert all text block entries into list items
                    if(childNode.type != schema.nodes.listItem) {
                        convertBlockType(schema.nodes.listItem,null,childNode,childPosition,transform,refStep);
                    }
                }
                else if(childNode.type === schema.nodes.apogeeComponent) ;
                else {
                    //this shouldn't happen
                    throw new Error("Unexpected editor node type: " + childNode.type.name);
                }
            });
        }
    });

    return transform;
}

//add indent for top level list items with leading tabs
function addIndentForTab(nodeType,attrs,listNode,baseListPosition,transform,refStep,schema) {

    //traverse child nodes
    //for top level list items, record the number of leading tabs
    //store a "indent summary": indent count for each node, along with position of start
    //insert list nodes based on changes in indent 
    let mapping = transform.mapping.slice(refStep);
    let listPosition = mapping.map(baseListPosition);

    //--------------------
    //create a list with the tab indent level for each non-list block
    //---------------------
    let indentInfo = [];

    //add a dummy entry at start with 0 indent
    let initialIndentEntry = {};
    initialIndentEntry.nodeStart = listPosition + 1;
    initialIndentEntry.indent = 0;
    indentInfo.push(initialIndentEntry);

    listNode.forEach( (childNode,childOffset,index) => {
        let indentEntry = {};
        indentEntry.nodeStart = listPosition + 1 + childOffset;
        indentInfo.push(indentEntry);

        if(childNode.type == schema.nodes.listItem) {
            indentEntry.indent = countLeadingTabs(childNode);
        }
        else {
            indentEntry.indent = 0;
        }
    });

    //add a dummy entry at end with 0 indent
    let listEndPosition = baseListPosition + 1 + listNode.content.size;

    //----------------------
    // delete leading tabs
    //----------------------
    indentInfo.forEach( indentEntry => {
        if(indentEntry.indent > 0) {
            let tabRefStart = indentEntry.nodeStart + 1; //start pos is the start of the list item
            let tabRefEnd = tabRefStart + indentEntry.indent;
            let mapping = transform.mapping.slice(refStep);
            let tabStart = mapping.map(tabRefStart, 1);
            let tabEnd = mapping.map(tabRefEnd, 1);
            transform.delete(tabStart,tabEnd);
        }
    });

    //----------------------
    // insert the list nodes for indenting
    //----------------------
    addListIndent(nodeType,indentInfo,listEndPosition,transform,refStep); 
    
}

/** This function counts the nubmer of tabs in a text block node. */
function countLeadingTabs(textblockNode) {
    if(!textblockNode.isTextblock) throw new Error("Text block expected");

    let tabCount = 0;
    for(let nodeIndex = 0; nodeIndex < textblockNode.content.content.length; nodeIndex++) {
        let textNode = textblockNode.content.content[nodeIndex];
        for(let charIndex = 0; charIndex < textNode.text.length; charIndex++) {
            let textChar = textNode.text.charAt(charIndex);
            if(textChar == "\t") tabCount++;
            else return tabCount;
        }
    }
    //we will get here if the list item has only tabs
    return tabCount;

}

function indentSelection(state, dispatch) {
    return doIndentChange(1, state, dispatch);
}

function unindentSelection(state, dispatch) {
    return doIndentChange(-1, state, dispatch);
}

function doIndentChange(indentDelta, state, dispatch) {
    //this will be our transform
    let transform = state.tr;
    let schema = state.schema;

    //set the baseline for the document and the reference step for position mapping 
    let refDoc = transform.doc;
    let refStep = transform.steps.length;

    //this is our range to convert
    let { $from, $to } = state.selection;

    //get top level node
    let startTopNode = $from.node(1);
    let endTopNode = $to.node(1);
    let mainInsidePos = $from.start(1);
    let mainOutsidePos = mainInsidePos - 1;
    let mainInsideEndPos = mainInsidePos + startTopNode.content.size;
    let mainIndex = $from.index(0);

    //require we are in a single list item
    if((startTopNode.type.spec.group != "list")||(startTopNode != endTopNode)) return false;
    let listNode = startTopNode;

    //--------------------
    //traverse descendants
    //--------------------

    //indent info
    let currentIndent = 0;
    let indentInfo = [];

    //list range info
    let activeParentStack = [];
    activeParentStack.push(listNode);
    let activeParent;

    //construction function
    let constructIndentInfo = (node,offset,parent) => {
        let outsideNodeStart = mainInsidePos + offset;

        //get the proper parent entry
        while(true) {
            activeParent = activeParentStack[activeParentStack.length-1];
            if(activeParent != parent) {
                if(activeParentStack.length > 0) {
                    activeParentStack.pop();
                    currentIndent--;
                }
                else {
                    throw new Error("Unknown error indenting!");
                }
            }
            else {
                break;
            }
        } 

        //record the indent, by line
        if(node.type == schema.nodes.listItem) {
            let indentEntry = {};
            indentEntry.indent = currentIndent;
            
            //see if we are in the selection - we start befroe the end of the node inside
            //and end after the start of the node inside
            if(($from.pos <= outsideNodeStart + 1 + node.nodeSize)&&($to.pos >= outsideNodeStart + 1)) {
                let maybeNewIndent = indentEntry.indent + indentDelta;
                //don't unindent from indent = 0
                if(maybeNewIndent >= 0) {
                    indentEntry.indent = maybeNewIndent;
                }
            }

            indentInfo.push(indentEntry);
            return false;
        }
        else if(node.type.spec.group == "list") {
            activeParentStack.push(node);
            currentIndent++;
            return true;
        }
    };

    //execute function on list node descendants
    listNode.descendants(constructIndentInfo);

    //--------------------------
    // Flatten the list
    //--------------------------
    flattenList(listNode,mainOutsidePos,transform,refStep,true);

    //--------------------------
    // Set element locations on indent info (now that we flattened the list)
    //--------------------------
    let mapping = transform.mapping.slice(refStep);
    let newListPos = mapping.map(mainOutsidePos);
    let newListInsideEndPos = mapping.map(mainInsideEndPos);
    
    let newRefDoc = transform.doc;
    let newRefStep = transform.steps.length;
    let newListNode = newRefDoc.child(mainIndex);

    newListNode.forEach( (childNode,offset,index) => {
        let indentInfoEntry = indentInfo[index];
        indentInfoEntry.nodeStart = newListPos + 1 + offset;
    });

    //--------------------------
    // Add the proper indent
    //--------------------------
    addListIndent(newListNode.type,indentInfo,newListInsideEndPos,transform,newRefStep);

    //------------------------------
    // execute the transform
    //------------------------------

    if ((dispatch) && (transform.docChanged)) {
        dispatch(transform);
    }

    return true;

}

//==========================
// Common utilities
//==========================

/** Split any lists so there is not a list that spans outside the current selection */
function splitStartAndEndLists(transform,selection,schema) {
    //this is our range to convert
    let { $from, $to } = selection;
    transform = splitSpannedListAfterPos($to, transform);
    transform = splitSpannedListBeforePos($from, transform);
    return transform;
}

/** This method converts the given block into the targetnode type. */
function convertBlockType(targetNodeType,attrs,node,nodeRefStart,transform,refStep) {
    //get the mapping to remap the node position
    let mapping = transform.mapping.slice(refStep);
    let start = mapping.map(nodeRefStart, 1);
    let end = mapping.map(nodeRefStart + node.nodeSize, 1);
    return transform.step(new ReplaceAroundStep(start, end, start + 1, end - 1,
            new Slice(Fragment.from(targetNodeType.create(attrs, null, node.marks)), 0, 0), 1, true))
}

/** This lifts children of the given node out of that node. */
function unwrapChildren(node,nodeRefStart,transform,refStep) {
    //get the mapping to remap the node position
    let mapping = transform.mapping.slice(refStep);
    let start = mapping.map(nodeRefStart, 1);
    let end = mapping.map(nodeRefStart + node.nodeSize, 1);

    //return transform.step(new ReplaceStep(start, end, new Slice(node.content, 0, 0), false))

    return transform.step(new ReplaceAroundStep(start, end, start + 1, end - 1,
        new Slice(Fragment.empty, 0, 0), 0, false))
}

/** This function cuts the document so there is not a list spanned before the text block at the given position. */
function splitSpannedListAfterPos($pos, transform, schema) {

    let modPath = pathToModPath($pos.path);

    //traverse backwards to look for the deepest entry that cuts a list (last element is doc, we can ignore it)
    for (let i = modPath.length - 1; i > 0; i--) {
        let entry = modPath[i];
        if ((entry.node.type.spec.group == "list") && (entry.index < entry.node.childCount - 1)) {
            //split here!
            //cut at the end of the child block
            let childBlockDepth = i + 1;
            let cutDepth = i;
            let cutPosition = $pos.end(childBlockDepth) + 1;
            transform = transform.split(cutPosition, cutDepth);
            break;
        }
    }

    return transform;
}

/** This function cuts the document so there is not a list spanned after the text block at the given position. */
function splitSpannedListBeforePos($pos, transform, schema) {
    let modPath = pathToModPath($pos.path);

    //traverse backwards to look for the deepest entry that cuts list (last element is doc, we can ignore it)
    for (let i = modPath.length - 1; i > 0; i--) {
        let entry = modPath[i];
        if ((entry.node.type.spec.group == "list") && (entry.index > 0)) {
            //split here!
            //cut at start of the child block
            let childBlockDepth = i + 1;
            let cutDepth = i;
            let cutPosition = $pos.start(childBlockDepth) - 1;
            transform = transform.split(cutPosition, cutDepth); //cut position off by 1 when at the start of a child list, but need to cut is parent
            break;
        }
    }

    return transform;
}

/** This load the path data into an alternat struct */
//helper
function pathToModPath(path) {
    let modPath = [];
    for (let i = 0; i < path.length - 2; i += 3) {
        let entry = {};
        entry.node = path[i];
        entry.index = path[i + 1];
        entry.startPos = path[i + 2];
        modPath.push(entry);
    }
    return modPath;
}

/** This is a recursive function to flatten a list. The argument flattenOnlyChildren can
 * be set so the current passed list object is not flattened
 */
function flattenList(node,nodeRefStart,transform,refStep,flattenOnlyChildren) {
    //unwrap the children
    node.forEach( (childNode,offset,index) => {
        let refPosition = nodeRefStart + 1 + offset;
        if(childNode.type.spec.group == "list") {
            flattenList(childNode,refPosition,transform,refStep,false);
        }
    });

    //unwrap this list, including adding a tab for any indents
    if(!flattenOnlyChildren) {
        unwrapChildren(node,nodeRefStart,transform,refStep);
    }
}

//depth is set to 0
function wrapSelectionInNode(baseFrom, baseTo, parentDepth, nodeType, transform, refStep) {
    let mapping = transform.mapping.slice(refStep);
    let from = mapping.map(baseFrom, 1);
    let to = mapping.map(baseTo, -1);
    let $from = transform.doc.resolve(from);
    let $to = transform.doc.resolve(to);
    let range = new NodeRange($from, $to, parentDepth);
    let wrapping = range && findWrapping(range, nodeType);
    if (!wrapping) throw new Error("Wrapping not found!"); //need to work out error handling
    //return the updated transform
    return transform.wrap(range, wrapping);
}

/** This function takes a indentInfo structure to tell where to indent a given list. The
 * list should be a flat list (no existing indent). The indent info should contain the nodeStart postiion, relative to the document at
 * the refStep, and the amount of indent for that line. */
function addListIndent(nodeType,indentInfo,listInsideEndPos,transform,refStep) {

    //calculate the desired list ranges from the indent info
    let listRanges = [];
    let activeListRanges = [];
    let previousIndentEntry;
    indentInfo.forEach( currentIndentEntry => {
        if(previousIndentEntry) {
            if(currentIndentEntry.indent > previousIndentEntry.indent) {
                //add a list, or multiple (indent)
                for(let indent = previousIndentEntry.indent + 1; indent <= currentIndentEntry.indent; indent++) {
                    let listRangeEntry = {};
                    listRangeEntry.startPos = currentIndentEntry.nodeStart;
                    listRangeEntry.indent = indent;
                    listRanges.push(listRangeEntry);
                    activeListRanges.push(listRangeEntry);
                }
            }
            else if(currentIndentEntry.indent < previousIndentEntry.indent) {
                //remove a list,or multiple (unindent)
                for(let indent = previousIndentEntry.indent - 1; indent >= currentIndentEntry.indent; indent--) {
                    if(activeListRanges.length === 0) throw new Error("Unknown error constructing indented lists");
                    let closeRangeEntry = activeListRanges.pop();
                    closeRangeEntry.endPos = currentIndentEntry.nodeStart;
                }
            }
        }
        previousIndentEntry = currentIndentEntry;
    });

    //finishe the list
    while(activeListRanges.length > 0) {
        let listRangeEntry = activeListRanges.pop();
        listRangeEntry.endPos = listInsideEndPos;
    }

    // insert the list nodes for indenting
    listRanges.forEach( listRangeEntry => {
        let listParentDepth = listRangeEntry.indent;
        wrapSelectionInNode(listRangeEntry.startPos, listRangeEntry.endPos, listParentDepth, nodeType, transform, refStep);
    });
    
}

let enter = chainCommands(exitList, createParagraphNear, liftEmptyChildList, splitBlock);
let backspace = chainCommands(exitList,deleteSelection, joinBackward, selectNodeBackward);
let del = chainCommands(deleteSelection, joinForward, selectNodeForward);

// :: Object
// A keymap for the apogee schema
let pcBaseKeymap = {
  "Enter": enter,
  //"Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};

// :: Object
// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,
// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and
// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like
// Ctrl-Delete.
let macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"]
};
for (let key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key];

// declare global: os, navigator
const mac$1 = typeof navigator != "undefined" ? /Mac/.test(navigator.platform)
          : typeof os != "undefined" ? os.platform() == "darwin" : false;

// :: Object
// Depending on the detected platform, this will hold
// [`pcBasekeymap`](#commands.pcBaseKeymap) or
// [`macBaseKeymap`](#commands.macBaseKeymap).
let baseKeymap = mac$1 ? macBaseKeymap : pcBaseKeymap;

/** This is a toolbar button for marks. It is inteded for marks with either no attrbiutes or with 
 * fixed attributes. Arguments:
 * - markType - this is the schema mark type object.
 * - attr - these are the attributes for the marks. It should be fixed of empty.
 * - labelText - This is the text that appears on the label. 
 * - textStyleClass - This is the CSS class name for the text. Note that the background and text color are controlled
 * by the button to show enabled,disabled and highlighted.
 * - toolTip - This is the tooltip text for the button.
 */
class MarkToggleItem {
    constructor(markType, attr, labelText, styleClass, tooltip) {
        this.markType = markType;
        this.attr = attr;
        this.labelText = labelText;
        this.styleClass = styleClass;

        this.selectionGenerator = createSelectionGenerator(markType);

        this.element = document.createElement("span");
        this.element.title = tooltip;
        this.element.textContent = labelText;

        this.element.onclick = () => {
            this.editorView.focus();
            if (this.elementIsSelected) {
                clearMark(this.markType, this.editorView.state, this.editorView.dispatch);
            }
            else {
                setMark(this.markType, this.attr, this.editorView.state, this.editorView.dispatch);
            }
        };

        this._setElementIsSelected(false);
    }

    registerEditorView(editorView) {
        this.editorView = editorView;
    }

    getElement() {
        return this.element;
    }

    getMarkSelectionGenerator() {
        return this.selectionGenerator;
    }

    /** This gets the selection info and sets whether the toggle should be on or off. 
     * Mark is considered "on" if it is present on all text nodes in the selection.
    */
    update(selectionInfo) {
        let markInfo = selectionInfo.marks[this.markType.name];
        let isSelected = (markInfo)&&(markInfo.present === true)&&(markInfo.missing === false);
        this._setElementIsSelected(isSelected);
    }

    //=========================
    // internal
    //=========================

    /** This sets the toggle state and the display class. */
    _setElementIsSelected(isSelected) {
        if (this.elementIsSelected != isSelected) {
            this.elementIsSelected = isSelected;
            if (isSelected) {
                this.element.className = "atb_toggleButton atb_toggleOnClass " + this.styleClass;
            }
            else {
                this.element.className = "atb_toggleButton atb_toggleOffClass " + this.styleClass;
            }
        }
    }

}

function createSelectionGenerator(markType) {
    let selectionGenerator = {};
    selectionGenerator.name = markType.name;
    selectionGenerator.getEmptyInfo = () => { return { last: -1, missing: false}; };
    selectionGenerator.updateInfo = (mark,markInfoEntry,textNodeNumber) => {
        //record if there are any text nodes with this mark missing
        if(textNodeNumber - markInfoEntry.last > 1) {
            markInfoEntry.missing = true;
        }
        markInfoEntry.last = textNodeNumber;

        //record that this mark is present
        markInfoEntry.present = true;
    };
    selectionGenerator.onComplete = (markInfoEntry,nodeCount) => {
        if(nodeCount - markInfoEntry.last > 1) {
            markInfoEntry.missing = true;
        }
    };

    return selectionGenerator;
}

/** This is a toolbar element for marks which have a single attribute key and multple attribute values. Arguments:
 * - markType - this is the schema mark type object.
 * - attrName - this is the name or the single attribute for the marks. 
 * - attrValueList - This is a list of values for the attribute. Each value should have a two element array, the first 
 * being the display label and the second beint the internal value represented.
 * - defaultValue - This is the value for the list which corresponds to no mark present. For example in the font
 * case, this should be the font that is showing when no mark is present.
 */
//This is a menu element for a mark with multiple attribute values, for a single attribute name
//the default value should be the selection option for no mark present.
class MarkDropdownItem {
    constructor(markType, attrName, attrValueList, defaultValue) {
        this.markType = markType;
        this.attrValueList = attrValueList;
        this.defaultValue = defaultValue;

        this.selectionGenerator = createSelectionGenerator$1(markType, attrName);

        this.element = document.createElement("select");
        attrValueList.forEach(attrValueEntry => {
            let option = document.createElement("option");
            option.value = attrValueEntry[1];
            option.text = attrValueEntry[0];
            this.element.add(option);
        });

        this.element.value = this.defaultValue;

        this.element.onchange = () => {
            this.editorView.focus();
            //allow string or boolean value (I think it turns to string even if boolean is set)
            if(this.element.value == defaultValue) {
                //remove mark
                clearMark(this.markType, this.editorView.state, this.editorView.dispatch);
            }
            else {
                //set the mark with the current value
                var attr = {};
                attr[attrName] = this.element.value;
                setMark(this.markType, attr, this.editorView.state, this.editorView.dispatch);
            }
        };
    }

    registerEditorView(editorView) {
        this.editorView = editorView;
    }

    getElement() {
        return this.element;
    }

    getMarkSelectionGenerator() {
        return this.selectionGenerator;
    }

    /** This gets the selection info and sets whether the toggle should be on or off. */
    update(selectionInfo) {
        let markInfo = selectionInfo.marks[this.markType.name];

        if((markInfo.values.length === 1)&&(!markInfo.missing)) {
            //mark present on all text nodes - display this as the current value
            this._setElementValue(markInfo.values[0]);
        }
        else if(markInfo.values.length === 0) {
            //mark not present. This is the default.
            this._setElementValue(this.defaultValue);
        }
        else {
            //multiple values present - display no current value
            this._setElementValue(null);
        }

        return;
    }

    
    //=========================
    // internal
    //=========================

    
    /** This sets the toggle state and the display class. */
    _setElementValue(value) {
        if (this.element.value !== value) {
            this.element.value = value;
        }
    }

}

function createSelectionGenerator$1(markType,attrName) {
    let selectionGenerator = {};
    selectionGenerator.name = markType.name;
    selectionGenerator.getEmptyInfo = () => { return { last: -1, missing: false, values: [] }; };
    selectionGenerator.updateInfo = (mark,markInfoEntry,textNodeNumber) => {
        //record if there are any text nodes with this mark missing
        if(textNodeNumber - markInfoEntry.last > 1) {
            markInfoEntry.missing = true;
        }
        markInfoEntry.last = textNodeNumber;

        //recorc that this mark is present
        let attrValue = mark.attrs[attrName];
        if(markInfoEntry.values.indexOf(attrValue) < 0) markInfoEntry.values.push(attrValue);
    };
    selectionGenerator.onComplete = (markInfoEntry,nodeCount) => {
        if(nodeCount - markInfoEntry.last > 1) {
            markInfoEntry.missing = true;
        }
    };

    return selectionGenerator;
}

/** This is a toolbar item button. Arguments:
 * - commandFunction - this is the action taken when the button is pressed when enabled.
 * - isHighlightedFunction - This function is called with selectionInfo on selection change to determine if the 
 * button should be in the highlighted state. This does not change the action. If the function is not provided
 * the button is never highlighted.
 * - isEnabled - This function is called with the selectionInfo on selection change to determine if the
 * button shoudl be enabled. The button only acts when enabled. If this function is not provided, the button is
 * always enabled.
 * - labelText - This is the text that appears on the label. 
 * - textStyleClass - This is the CSS class name for the text. Note that the background and text color are controlled
 * by the button to show enabled,disabled and highlighted.
 * - toolTip - This is the tooltip text for the button.
 */
class ActionButton {
    constructor(commandFunction, isHighlightedFunction, isEnabledFunction, labelText, textStyleClass, tooltip) {
        this.commandFunction = commandFunction;
        this.labelText = labelText;
        this.textStyleClass = textStyleClass;

        this.element = document.createElement("span");
        this.element.title = tooltip;
        this.element.textContent = labelText;

        this.element.onclick = () => {
            this.editorView.focus();
            if(this.isEnabled) {
                this.commandFunction(this.editorView.state, this.editorView.dispatch);
            }
        };

        this.isHighlightedFunction = isHighlightedFunction;
        this.isEnabledFunction = isEnabledFunction;

        this.isEnabled;
        this._setState(true,false);
    }

    registerEditorView(editorView) {
        this.editorView = editorView;
    }

    getElement() {
        return this.element;
    }

    /** This gets the selection info and sets whether the toggle should be on or off. */
    update(selectionInfo) {

        //call function to decide if button is enabled if function defined. Otherwise just keep it on. 
        var isHighlighted = this.isHighlightedFunction ? this.isHighlightedFunction(selectionInfo) : false;
        var isEnabled = this.isEnabledFunction ? this.isEnabledFunction(selectionInfo) : true;

        this._setState(isEnabled,isHighlighted);
    }

    //=========================
    // internal
    //=========================

    /** This sets the toggle state and the display class. */
    _setState(isEnabled,isHighlighted) {
        let className = "atb_actionButton " + this.textStyleClass;

        if (isEnabled) {
            if (isHighlighted) {
                className += " atb_actionHighlightedClass";
            }
            else {
                className += " atb_actionEnabledClass";
            }
        }
        else {
            className += " atb_actionDisabledClass";
        }

        if(className != this.element.classname) {
            this.element.className = className;
        }

        this.isEnabled = isEnabled;
        
    }

}

//============================
// StateCheck plugin
//============================

//This is a test to measure the state of the editor. I want to use this to 
//configure my menu bar (as to what is active)
class StateCheck {
    constructor(editorView) {
      this.editorView = editorView;
    }
  
    update() {
      this._showSelectionInfo();
    }
  
  
    _showSelectionInfo() {
  
      var { empty, $cursor, ranges } = this.editorView.state.selection;
      var doc = this.editorView.state.doc;
      /////////////////////////////////////////////
      //temp printout to examine selection
      console.log("================");
      if(empty) console.log(empty);
      if($cursor) {
        this._printResolvedPosition("$cursor",$cursor);
      }
      else {
        this._printResolvedPosition("$from",ranges[0].$from);
        this._printResolvedPosition("$to",ranges[0].$to);
      }
      console.log("================");
      return;
    }

    _getNodePathString(path) {
      let simplifiedPath = path.map( element => {
        if(typeof element == "object") {
          return element.type.name;
        }
        else {
          return element;
        }
      });

      return JSON.stringify(simplifiedPath);
    }

    _printResolvedPosition(name,$pos) {
      console.log(name);
      console.log("pos: " + $pos.pos);
      console.log("parentDepth: " + $pos.depth);
      console.log("parentType: " + $pos.parent.type.name);
      console.log("parentOffset: " + $pos.parentOffset);
    }
  }

var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ";",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\"",
  229: "Q"
};

var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac$2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var brokenModifierNames = chrome && (mac$2 || +chrome[1] < 57) || gecko && mac$2;

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];

function keyName(event) {
  // Don't trust event.key in Chrome when there are modifiers until
  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||
    safari && event.shiftKey && event.key && event.key.length == 1;
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified";
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name
}

keyName.base = base;
keyName.shift = shift;

// declare global: navigator

const mac$3 = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;

function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space") result = " ";
  let alt, ctrl, shift, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) meta = true;
    else if (/^a(lt)?$/i.test(mod)) alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
    else if (/^s(hift)?$/i.test(mod)) shift = true;
    else if (/^mod$/i.test(mod)) { if (mac$3) meta = true; else ctrl = true; }
    else throw new Error("Unrecognized modifier name: " + mod)
  }
  if (alt) result = "Alt-" + result;
  if (ctrl) result = "Ctrl-" + result;
  if (meta) result = "Meta-" + result;
  if (shift) result = "Shift-" + result;
  return result
}

function normalize(map) {
  let copy = Object.create(null);
  for (let prop in map) copy[normalizeKeyName(prop)] = map[prop];
  return copy
}

function modifiers(name, event, shift) {
  if (event.altKey) name = "Alt-" + name;
  if (event.ctrlKey) name = "Ctrl-" + name;
  if (event.metaKey) name = "Meta-" + name;
  if (shift !== false && event.shiftKey) name = "Shift-" + name;
  return name
}

// :: (Object)  Plugin
// Create a keymap plugin for the given set of bindings.
//
// Bindings should map key names to [command](#commands)-style
// functions, which will be called with `(EditorState, dispatch,
// EditorView)` arguments, and should return true when they've handled
// the key. Note that the view argument isn't part of the command
// protocol, but can be used as an escape hatch if a binding needs to
// directly interact with the UI.
//
// Key names may be strings like `"Shift-Ctrl-Enter"`a key
// identifier prefixed with zero or more modifiers. Key identifiers
// are based on the strings that can appear in
// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).
// Use lowercase letters to refer to letter keys (or uppercase letters
// if you want shift to be held). You may use `"Space"` as an alias
// for the `" "` name.
//
// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or
// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or
// `Meta-`) are recognized. For characters that are created by holding
// shift, the `Shift-` prefix is implied, and should not be added
// explicitly.
//
// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on
// other platforms.
//
// You can add multiple keymap plugins to an editor. The order in
// which they appear determines their precedence (the ones early in
// the array get to dispatch first).
function keymap(bindings) {
  return new Plugin({props: {handleKeyDown: keydownHandler(bindings)}})
}

// :: (Object)  (view: EditorView, event: dom.Event)  bool
// Given a set of bindings (using the same format as
// [`keymap`](#keymap.keymap), return a [keydown
// handler](#view.EditorProps.handleKeyDown) handles them.
function keydownHandler(bindings) {
  let map = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), isChar = name.length == 1 && name != " ", baseName;
    let direct = map[modifiers(name, event, !isChar)];
    if (direct && direct(view.state, view.dispatch, view)) return true
    if (isChar && (event.shiftKey || event.altKey || event.metaKey) &&
        (baseName = keyName.base[event.keyCode]) && baseName != name) {
      let fromCode = map[modifiers(baseName, event, true)];
      if (fromCode && fromCode(view.state, view.dispatch, view)) return true
    }
    return false
  }
}

const dummyFunction = () => true;

const PASSTHROUGH_KEYMAP = {
    "Enter": dummyFunction,
    "Delete": dummyFunction,
    "Mod-a": dummyFunction,
    "ArrowLeft": dummyFunction,
    "ArrowRight": dummyFunction,
    "ArrowUp": dummyFunction,
    "ArrowDown": dummyFunction
};

//key handler args: state, dispatch, view

let inverseKeydownHandler = keydownHandler(PASSTHROUGH_KEYMAP);

function interactiveNodeKeydownHandler(view,event) {

    if((view.state.selection instanceof NodeSelection)&&(view.state.selection.node.type.spec.hasInteractiveSelection)) {
        //interactive node selected
        let passThrough = inverseKeydownHandler(view,event);

        if(passThrough) return false;
        else {
            //pass these events along
            console.log("Event captured for selecte interactive node: " + event.key);

            return true;
        }
    }
    else {
        //interactive node is not selected
        return false;
    }
}


/** This creates a plugin to filter out keydown events and to forward when
/* thee is an interactive node selected. */ 
const getInteractiveNodePlugin = function() {
    return new Plugin({
        props: {
            handleKeyDown: interactiveNodeKeydownHandler
        }
    })
};

const result = {};

if (typeof navigator != "undefined" && typeof document != "undefined") {
  const ie_edge = /Edge\/(\d+)/.exec(navigator.userAgent);
  const ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);

  result.mac = /Mac/.test(navigator.platform);
  let ie = result.ie = !!(ie_upto10 || ie_11up || ie_edge);
  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;
  result.gecko = !ie && /gecko\/(\d+)/i.test(navigator.userAgent);
  result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
  let chrome = !ie && /Chrome\/(\d+)/.exec(navigator.userAgent);
  result.chrome = !!chrome;
  result.chrome_version = chrome && +chrome[1];
  result.ios = !ie && /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  result.android = /Android \d/.test(navigator.userAgent);
  result.webkit = !ie && 'WebkitAppearance' in document.documentElement.style;
  result.safari = /Apple Computer/.test(navigator.vendor);
  result.webkit_version = result.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
}

const domIndex = function(node) {
  for (var index = 0;; index++) {
    node = node.previousSibling;
    if (!node) return index
  }
};

const parentNode = function(node) {
  let parent = node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent
};

const textRange = function(node, from, to) {
  let range = document.createRange();
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from || 0);
  return range
};

// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
const isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||
                        scanFor(node, off, targetNode, targetOff, 1))
};

const atomElements = /^(img|br|input|textarea|hr)$/i;

function scanFor(node, off, targetNode, targetOff, dir) {
  for (;;) {
    if (node == targetNode && off == targetOff) return true
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false
    }
  }
}

function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length
}

function hasBlockDesc(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock
}

// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523
// (isCollapsed inappropriately returns true in shadow dom)
const selectionCollapsed = function(domSel) {
  let collapsed = domSel.isCollapsed;
  if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)
    collapsed = false;
  return collapsed
};

function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event
}

function windowRect(win) {
  return {left: 0, right: win.innerWidth,
          top: 0, bottom: win.innerHeight}
}

function getSide(value, side) {
  return typeof value == "number" ? value : value[side]
}

function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc = view.dom.ownerDocument, win = doc.defaultView;
  for (let parent = startDOM || view.dom;; parent = parentNode(parent)) {
    if (!parent) break
    if (parent.nodeType != 1) continue
    let atTop = parent == doc.body || parent.nodeType != 1;
    let bounding = atTop ? windowRect(win) : parent.getBoundingClientRect();
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        win.scrollBy(moveX, moveY);
      } else {
        if (moveY) parent.scrollTop += moveY;
        if (moveX) parent.scrollLeft += moveX;
      }
    }
    if (atTop) break
  }
}

// Store the scroll position of the editor's parent nodes, along with
// the top position of an element near the top of the editor, which
// will be used to make sure the visible viewport remains stable even
// when the size of the content above changes.
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let doc = view.dom.ownerDocument;
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1;
       y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (dom == view.dom || !view.dom.contains(dom)) continue
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break
    }
  }
  let stack = [];
  for (let dom = view.dom; dom; dom = parentNode(dom)) {
    stack.push({dom, top: dom.scrollTop, left: dom.scrollLeft});
    if (dom == doc.body) break
  }
  return {refDOM, refTop, stack}
}

// Reset the scroll position of the editor's parent nodes to that what
// it was before, when storeScrollPos was called.
function resetScrollPos({refDOM, refTop, stack}) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  let dTop = newRefTop == 0 ? 0 : newRefTop - refTop;
  for (let i = 0; i < stack.length; i++) {
    let {dom, top, left} = stack[i];
    if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left) dom.scrollLeft = left;
  }
}

function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset = 0;
  let rowBot = coords.top, rowTop = coords.top;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1) rects = child.getClientRects();
    else if (child.nodeType == 3) rects = textRange(child).getClientRects();
    else continue

    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left
            : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {left: rect.right < coords.left ? rect.right : rect.left, top: coords.top} : coords;
          if (child.nodeType == 1 && dx)
            offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue
        }
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||
                       coords.left >= rect.left && coords.top >= rect.bottom))
        offset = childIndex + 1;
    }
  }
  if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest)
  if (!closest || (dxClosest && closest.nodeType == 1)) return {node, offset}
  return findOffsetInNode(closest, coordsClosest)
}

function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom) continue
    if (inRect(coords, rect))
      return {node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)}
  }
  return {node, offset: 0}
}

function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1&&
    coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1
}

function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent
  return dom
}

function posFromElement(view, elt, coords) {
  let {node, offset} = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset, bias)
}

function posFromCaret(view, node, offset, coords) {
  // Browser (in caretPosition/RangeFromPoint) will agressively
  // normalize towards nearby inline nodes. Since we are interested in
  // positions between block nodes too, we first walk up the hierarchy
  // of nodes to see if there are block nodes that the coordinates
  // fall outside of. If so, we take the position before/after that
  // block. If not, we call `posFromDOM` on the raw node/offset.
  let outside = -1;
  for (let cur = node;;) {
    if (cur == view.dom) break
    let desc = view.docView.nearestDesc(cur, true);
    if (!desc) return null
    if (desc.node.isBlock && desc.parent) {
      let rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top) outside = desc.posBefore;
      else if (rect.right < coords.left || rect.bottom < coords.top) outside = desc.posAfter;
      else break
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view.docView.posFromDOM(node, offset)
}

function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2), i = startI;;) {
      let child = element.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect)) return elementFromPoint(child, coords, rect)
        }
      }
      if ((i = (i + 1) % len) == startI) break
    }
  }
  return element
}

// Given an x,y position on the editor, get the position in the document.
function posAtCoords(view, coords) {
  let root = view.root, node, offset;
  if (root.caretPositionFromPoint) {
    let pos = root.caretPositionFromPoint(coords.left, coords.top);
    if (pos) ({offsetNode: node, offset} = pos);
  }
  if (!node && root.caretRangeFromPoint) {
    let range = root.caretRangeFromPoint(coords.left, coords.top);
    if (range) ({startContainer: node, startOffset: offset} = range);
  }

  let elt = root.elementFromPoint(coords.left, coords.top + 1), pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box)) return null
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt) return null
  }
  elt = targetKludge(elt, coords);
  if (node) {
    // Firefox will sometimes return offsets into <input> nodes, which
    // have no actual children, from caretPositionFromPoint (#953)
    if (node.nodeType == 1) offset = Math.min(offset, node.childNodes.length);
    // Suspiciously specific kludge to work around caret*FromPoint
    // never returning a position at the end of the document
    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&
        coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    // Ignore positions directly after a BR, since caret*FromPoint
    // 'round up' positions that would be more accurately placed
    // before the BR node.
    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset, coords);
  }
  if (pos == null) pos = posFromElement(view, elt, coords);

  let desc = view.docView.nearestDesc(elt, true);
  return {pos, inside: desc ? desc.posAtStart - desc.border : -1}
}

function singleRect(object, bias) {
  let rects = object.getClientRects();
  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1]
}

// : (EditorView, number)  {left: number, top: number, right: number, bottom: number}
// Given a position in the document model, get a bounding box of the
// character at that position, relative to the window.
function coordsAtPos(view, pos) {
  let {node, offset} = view.docView.domFromPos(pos);

  // These browsers support querying empty text ranges
  if (node.nodeType == 3 && (result.chrome || result.gecko)) {
    let rect = singleRect(textRange(node, offset, offset), 0);
    // Firefox returns bad results (the position before the space)
    // when querying a position directly after line-broken
    // whitespace. Detect this situation and and kludge around it
    if (result.gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
      let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
      if (Math.abs(rectBefore.left - rect.left) < 1 && rectBefore.top == rect.top) {
        let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
        return flattenV(rectAfter, rectAfter.left < rectBefore.left)
      }
    }
    return rect
  }

  if (node.nodeType == 1 && !view.state.doc.resolve(pos).parent.inlineContent) {
    // Return a horizontal line in block context
    let top = true, rect;
    if (offset < node.childNodes.length) {
      let after = node.childNodes[offset];
      if (after.nodeType == 1) rect = after.getBoundingClientRect();
    }
    if (!rect && offset) {
      let before = node.childNodes[offset - 1];
      if (before.nodeType == 1) { rect = before.getBoundingClientRect(); top = false; }
    }
    return flattenH(rect || node.getBoundingClientRect(), top)
  }

  // Not Firefox/Chrome, or not in a text node, so we have to use
  // actual element/character rectangles to get a solution (this part
  // is not very bidi-safe)
  //
  // Try the left side first, fall back to the right one if that
  // doesn't work.
  for (let dir = -1; dir < 2; dir += 2) {
    if (dir < 0 && offset) {
      let prev, target = node.nodeType == 3 ? textRange(node, offset - 1, offset)
          : (prev = node.childNodes[offset - 1]).nodeType == 3 ? textRange(prev)
          : prev.nodeType == 1 && prev.nodeName != "BR" ? prev : null; // BR nodes tend to only return the rectangle before them
      if (target) {
        let rect = singleRect(target, 1);
        if (rect.top < rect.bottom) return flattenV(rect, false)
      }
    } else if (dir > 0 && offset < nodeSize(node)) {
      let next, target = node.nodeType == 3 ? textRange(node, offset, offset + 1)
          : (next = node.childNodes[offset]).nodeType == 3 ? textRange(next)
          : next.nodeType == 1 ? next : null;
      if (target) {
        let rect = singleRect(target, -1);
        if (rect.top < rect.bottom) return flattenV(rect, true)
      }
    }
  }
  // All else failed, just try to get a rectangle for the target node
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, 0), false)
}

function flattenV(rect, left) {
  if (rect.width == 0) return rect
  let x = left ? rect.left : rect.right;
  return {top: rect.top, bottom: rect.bottom, left: x, right: x}
}

function flattenH(rect, top) {
  if (rect.height == 0) return rect
  let y = top ? rect.top : rect.bottom;
  return {top: y, bottom: y, left: rect.left, right: rect.right}
}

function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state) view.updateState(state);
  if (active != view.dom) view.focus();
  try {
    return f()
  } finally {
    if (viewState != state) view.updateState(viewState);
    if (active != view.dom) active.focus();
  }
}

// : (EditorView, number, number)
// Whether vertical position motion in a given direction
// from a position would leave a text block.
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$anchor.min(sel.$head) : sel.$anchor.max(sel.$head);
  return withFlushedState(view, state, () => {
    let {node: dom} = view.docView.domFromPos($pos.pos);
    for (;;) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) break
      if (nearest.node.isBlock) { dom = nearest.dom; break }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1) boxes = child.getClientRects();
      else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else continue
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top && (dir == "up" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1))
          return false
      }
    }
    return true
  })
}

const maybeRTL = /[\u0590-\u08ac]/;

function endOfTextblockHorizontal(view, state, dir) {
  let {$head} = state.selection;
  if (!$head.parent.isTextblock) return false
  let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
  let sel = getSelection();
  // If the textblock is all LTR, or the browser doesn't support
  // Selection.modify (Edge), fall back to a primitive approach
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd

  return withFlushedState(view, state, () => {
    // This is a huge hack, but appears to be the best we can
    // currently do: use `Selection.modify` to move the selection by
    // one character, and see if that moves the cursor out of the
    // textblock (or doesn't move it at all, when at the start/end of
    // the document).
    let oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    let oldBidiLevel = sel.caretBidiLevel; // Only for Firefox
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) ||
        (oldNode == sel.focusNode && oldOff == sel.focusOffset);
    // Restore the previous selection
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel;
    return result
  })
}

let cachedState = null, cachedDir = null, cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir) return cachedResult
  cachedState = state; cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down"
    ? endOfTextblockVertical(view, state, dir)
    : endOfTextblockHorizontal(view, state, dir)
}

// NodeView:: interface
//
// By default, document nodes are rendered using the result of the
// [`toDOM`](#model.NodeSpec.toDOM) method of their spec, and managed
// entirely by the editor. For some use cases, such as embedded
// node-specific editing interfaces, you want more control over
// the behavior of a node's in-editor representation, and need to
// [define](#view.EditorProps.nodeViews) a custom node view.
//
// Objects returned as node views must conform to this interface.
//
//   dom:: ?dom.Node
//   The outer DOM node that represents the document node. When not
//   given, the default strategy is used to create a DOM node.
//
//   contentDOM:: ?dom.Node
//   The DOM node that should hold the node's content. Only meaningful
//   if the node view also defines a `dom` property and if its node
//   type is not a leaf node type. When this is present, ProseMirror
//   will take care of rendering the node's children into it. When it
//   is not present, the node view itself is responsible for rendering
//   (or deciding not to render) its child nodes.
//
//   update:: ?(node: Node, decorations: [Decoration])  bool
//   When given, this will be called when the view is updating itself.
//   It will be given a node (possibly of a different type), and an
//   array of active decorations (which are automatically drawn, and
//   the node view may ignore if it isn't interested in them), and
//   should return true if it was able to update to that node, and
//   false otherwise. If the node view has a `contentDOM` property (or
//   no `dom` property), updating its child nodes will be handled by
//   ProseMirror.
//
//   selectNode:: ?()
//   Can be used to override the way the node's selected status (as a
//   node selection) is displayed.
//
//   deselectNode:: ?()
//   When defining a `selectNode` method, you should also provide a
//   `deselectNode` method to remove the effect again.
//
//   setSelection:: ?(anchor: number, head: number, root: dom.Document)
//   This will be called to handle setting the selection inside the
//   node. The `anchor` and `head` positions are relative to the start
//   of the node. By default, a DOM selection will be created between
//   the DOM positions corresponding to those positions, but if you
//   override it you can do something else.
//
//   stopEvent:: ?(event: dom.Event)  bool
//   Can be used to prevent the editor view from trying to handle some
//   or all DOM events that bubble up from the node view. Events for
//   which this returns true are not handled by the editor.
//
//   ignoreMutation:: ?(dom.MutationRecord)  bool
//   Called when a DOM
//   [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)
//   or a selection change happens within the view. When the change is
//   a selection change, the record will have a `type` property of
//   `"selection"` (which doesn't occur for native mutation records).
//   Return false if the editor should re-read the selection or
//   re-parse the range around the mutation, true if it can safely be
//   ignored.
//
//   destroy:: ?()
//   Called when the node view is removed from the editor or the whole
//   editor is destroyed.

// View descriptions are data structures that describe the DOM that is
// used to represent the editor's content. They are used for:
//
// - Incremental redrawing when the document changes
//
// - Figuring out what part of the document a given DOM position
//   corresponds to
//
// - Wiring in custom implementations of the editing interface for a
//   given node
//
// They form a doubly-linked mutable tree, starting at `view.docView`.

const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;

// Superclass for the various kinds of descriptions. Defines their
// basic structure and shared methods.
class ViewDesc {
  // : (?ViewDesc, [ViewDesc], dom.Node, ?dom.Node)
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    // An expando property on the DOM node provides a link back to its
    // description.
    dom.pmViewDesc = this;
    // This is the node that holds the child views. It may be null for
    // descs that don't have children.
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
  }

  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget() { return false }
  matchesMark() { return false }
  matchesNode() { return false }
  matchesHack() { return false }

  get beforePosition() { return false }

  // : ()  ?ParseRule
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() { return null }

  // : (dom.Event)  bool
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent() { return false }

  // The size of the content represented by this desc.
  get size() {
    let size = 0;
    for (let i = 0; i < this.children.length; i++) size += this.children[i].size;
    return size
  }

  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() { return 0 }

  destroy() {
    this.parent = null;
    if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = null;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }

  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; i < this.children.length; i++) {
      let cur = this.children[i];
      if (cur == child) return pos
      pos += cur.size;
    }
  }

  get posBefore() {
    return this.parent.posBeforeChild(this)
  }

  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
  }

  get posAfter() {
    return this.posBefore + this.size
  }

  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border
  }

  // : (dom.Node, number, ?number)  number
  localPosFromDOM(dom, offset, bias) {
    // If the DOM position is in the content, use the child desc after
    // it to figure out a position.
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset - 1];
        } else {
          while (dom.parentNode != this.contentDOM) dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset];
        } else {
          while (dom.parentNode != this.contentDOM) dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this)) domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd
      }
    }
    // Otherwise, use various heuristics, falling back on the bias
    // parameter, to determine whether to return the position at the
    // start or at the end of this view desc.
    let atEnd;
    if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset == 0) for (let search = dom;; search = search.parentNode) {
        if (search == this.dom) { atEnd = false; break }
        if (search.parentNode.firstChild != search) break
      }
      if (atEnd == null && offset == dom.childNodes.length) for (let search = dom;; search = search.parentNode) {
        if (search == this.dom) { atEnd = true; break }
        if (search.parentNode.lastChild != search) break
      }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart
  }

  // Scan up the dom finding the first desc that is a descendant of
  // this one.
  nearestDesc(dom, onlyNodes) {
    for (let first = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur);
      if (desc && (!onlyNodes || desc.node)) {
        // If dom is outside of this desc's nodeDOM, don't count it.
        if (first && desc.nodeDOM && !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom) : desc.nodeDOM == dom)) first = false;
        else return desc
      }
    }
  }

  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent) if (cur == this) return desc
  }

  posFromDOM(dom, offset, bias) {
    for (let scan = dom;; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc) return desc.localPosFromDOM(dom, offset, bias)
    }
  }

  // : (number)  ?NodeViewDesc
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset + child.size;
      if (offset == pos && end != offset) {
        while (!child.border && child.children.length) child = child.children[0];
        return child
      }
      if (pos < end) return child.descAt(pos - offset - child.border)
      offset = end;
    }
  }

  // : (number)  {node: dom.Node, offset: number}
  domFromPos(pos) {
    if (!this.contentDOM) return {node: this.dom, offset: 0}
    for (let offset = 0, i = 0;; i++) {
      if (offset == pos) {
        while (i < this.children.length && (this.children[i].beforePosition || this.children[i].dom.parentNode != this.contentDOM)) i++;
        return {node: this.contentDOM,
                offset: i == this.children.length ? this.contentDOM.childNodes.length : domIndex(this.children[i].dom)}
      }
      if (i == this.children.length) throw new Error("Invalid position " + pos)
      let child = this.children[i], end = offset + child.size;
      if (pos < end) return child.domFromPos(pos - offset - child.border)
      offset = end;
    }
  }

  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from, to, base = 0) {
    if (this.children.length == 0)
      return {node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length}

    let fromOffset = -1, toOffset = -1;
    for (let offset = base, i = 0;; i++) {
      let child = this.children[i], end = offset + child.size;
      if (fromOffset == -1 && from <= end) {
        let childBase = offset + child.border;
        // FIXME maybe descend mark views to parse a narrower range?
        if (from >= childBase && to <= end - child.border && child.node &&
            child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from, to, childBase)

        from = offset;
        for (let j = i; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break
          }
          from -= prev.size;
        }
        if (fromOffset == -1) fromOffset = 0;
      }
      if (fromOffset > -1 && to <= end) {
        to = end;
        for (let j = i + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break
          }
          to += next.size;
        }
        if (toOffset == -1) toOffset = this.contentDOM.childNodes.length;
        break
      }
      offset = end;
    }
    return {node: this.contentDOM, from, to, fromOffset, toOffset}
  }

  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length) return false
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side)
  }

  // : (number)  dom.Node
  domAfterPos(pos) {
    let {node, offset} = this.domFromPos(pos);
    if (node.nodeType != 1 || offset == node.childNodes.length)
      throw new RangeError("No node after pos " + pos)
    return node.childNodes[offset]
  }

  // : (number, number, dom.Document)
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, root, force) {
    // If the selection falls entirely in a child, give it to that child
    let from = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset + child.size;
      if (from > offset && to < end)
        return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force)
      offset = end;
    }

    let anchorDOM = this.domFromPos(anchor), headDOM = this.domFromPos(head);
    let domSel = root.getSelection(), range = document.createRange();
    if (!force &&
        isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) &&
        isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
      return

    // Selection.extend can be used to create an 'inverted' selection
    // (one where the focus is before the anchor), but not all
    // browsers support it yet.
    if (domSel.extend) {
      range.setEnd(anchorDOM.node, anchorDOM.offset);
      range.collapse(false);
    } else {
      if (anchor > head) { let tmp = anchorDOM; anchorDOM = headDOM; headDOM = tmp; }
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
    }
    domSel.removeAllRanges();
    domSel.addRange(range);
    if (domSel.extend)
      domSel.extend(headDOM.node, headDOM.offset);
  }

  // : (dom.MutationRecord)  bool
  ignoreMutation(_mutation) {
    return !this.contentDOM
  }

  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)
  }

  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from, to) {
    for (let offset = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset + child.size;
      if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
        let startInside = offset + child.border, endInside = end - child.border;
        if (from >= startInside && to <= endInside) {
          this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from == startInside && to == endInside && child.contentLost) child.dirty = NODE_DIRTY;
          else child.markDirty(from - startInside, to - startInside);
          return
        } else {
          child.dirty = NODE_DIRTY;
        }
      }
      offset = end;
    }
    this.dirty = CONTENT_DIRTY;
  }

  markParentsDirty() {
    for (let node = this.parent; node; node = node.parent) {
      let dirty =  CONTENT_DIRTY ;
      if (node.dirty < dirty) node.dirty = dirty;
    }
  }
}

// Reused array to avoid allocating fresh arrays for things that will
// stay empty anyway.
const nothing = [];

// A widget desc represents a widget decoration, which is a DOM node
// drawn between the document nodes.
class WidgetViewDesc extends ViewDesc {
  // : (ViewDesc, Decoration)
  constructor(parent, widget, view, pos) {
    let self, dom = widget.type.toDOM;
    if (typeof dom == "function") dom = dom(view, () => {
      if (!self) return pos
      if (self.parent) return self.parent.posBeforeChild(self)
    });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap = document.createElement("span");
        wrap.appendChild(dom);
        dom = wrap;
      }
      dom.contentEditable = false;
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, nothing, dom, null);
    this.widget = widget;
    self = this;
  }

  get beforePosition() {
    return this.widget.type.side < 0
  }

  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type)
  }

  parseRule() { return {ignore: true} }

  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false
  }
}

class CompositionViewDesc extends ViewDesc {
  constructor(parent, dom, textDOM, text) {
    super(parent, nothing, dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }

  get size() { return this.text.length }

  localPosFromDOM(dom, offset) {
    if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0)
    return this.posAtStart + offset
  }

  domFromPos(pos) {
    return {node: this.textDOM, offset: pos}
  }

  ignoreMutation(mut) {
    return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue
   }
}

// A mark desc represents a mark. May have multiple children,
// depending on how the mark is split. Note that marks are drawn using
// a fixed nesting order, for simplicity and predictability, so in
// some cases they will be split more often than would appear
// necessary.
class MarkViewDesc extends ViewDesc {
  // : (ViewDesc, Mark, dom.Node)
  constructor(parent, mark, dom, contentDOM) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
  }

  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom)
  }

  parseRule() { return {mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM} }

  matchesMark(mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark) }

  markDirty(from, to) {
    super.markDirty(from, to);
    // Move dirty info to nearest node view
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node) parent = parent.parent;
      if (parent.dirty < this.dirty) parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }

  slice(from, to, view) {
    let copy = MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size = this.size;
    if (to < size) nodes = replaceNodes(nodes, to, size, view);
    if (from > 0) nodes = replaceNodes(nodes, 0, from, view);
    for (let i = 0; i < nodes.length; i++) nodes[i].parent = copy;
    copy.children = nodes;
    return copy
  }
}

// Node view descs are the main, most common type of view desc, and
// correspond to an actual node in the document. Unlike mark descs,
// they populate their child array themselves.
class NodeViewDesc extends ViewDesc {
  // : (?ViewDesc, Node, [Decoration], DecorationSet, dom.Node, ?dom.Node, EditorView)
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, node.isLeaf ? nothing : [], dom, contentDOM);
    this.nodeDOM = nodeDOM;
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    if (contentDOM) this.updateChildren(view, pos);
  }

  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finnicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      // (This is a function that allows the custom view to find its
      // own position)
      if (!descObj) return pos
      if (descObj.parent) return descObj.parent.posBeforeChild(descObj)
    }, outerDeco);

    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom) dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3) throw new RangeError("Text must be rendered as a DOM text node")
    } else if (!dom) {
({dom, contentDOM} = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)));
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") { // Chrome gets confused by <br contenteditable=false>
      if (!dom.hasAttribute("contenteditable")) dom.contentEditable = false;
      if (node.type.spec.draggable) dom.draggable = true;
    }

    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);

    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM,
                                              spec, view, pos + 1)
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view)
    else
      return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos + 1)
  }

  parseRule() {
    // Experimental kludge to allow opt-in re-parsing of nodes
    if (this.node.type.spec.reparseInView) return null
    // FIXME the assumption that this can always return the current
    // attrs means that if the user somehow manages to change the
    // attrs in the dom, that won't be picked up. Not entirely sure
    // whether this is a problem
    let rule = {node: this.node.type.name, attrs: this.node.attrs};
    if (this.node.type.spec.code) rule.preserveWhitespace = "full";
    if (this.contentDOM && !this.contentLost) rule.contentElement = this.contentDOM;
    else rule.getContent = () => this.contentDOM ? Fragment.empty : this.node.content;
    return rule
  }

  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) &&
      sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco)
  }

  get size() { return this.node.nodeSize }

  get border() { return this.node.isLeaf ? 0 : 1 }

  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off = pos;
    let composition = inline && view.composing && this.localCompositionNode(view, pos);
    let updater = new ViewTreeUpdater(this, composition && composition.node);
    iterDeco(this.node, this.innerDeco, (widget, i) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0)
        updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view);
      // If the next node is a desc matching this widget, reuse it,
      // otherwise insert the widget as a new view desc.
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i) => {
      // Make sure the wrapping mark descs match the node's marks.
      updater.syncToMarks(child.marks, inline, view);
      // Either find an existing desc that exactly matches this node,
      // and drop the descs before it.
      updater.findNodeMatch(child, outerDeco, innerDeco, i) ||
        // Or try updating the next desc to reflect this node.
        updater.updateNextNode(child, outerDeco, innerDeco, view, i) ||
        // Or just add it as a new desc.
        updater.addNode(child, outerDeco, innerDeco, view, off);
      off += child.nodeSize;
    });
    // Drop all remaining descs after the current position.
    updater.syncToMarks(nothing, inline, view);
    if (this.node.isTextblock) updater.addTextblockHacks();
    updater.destroyRest();

    // Sync the DOM if anything changed
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      // May have to protect focused DOM from being changed if a composition is active
      if (composition) this.protectLocalComposition(view, composition);
      this.renderChildren();
    }
  }

  renderChildren() {
    renderDescs(this.contentDOM, this.children);
    if (result.ios) iosHacks(this.dom);
  }

  localCompositionNode(view, pos) {
    // Only do something if both the selection and a focused text node
    // are inside of this node, and the node isn't already part of a
    // view that's a child of this view
    let {from, to} = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from < pos || to > pos + this.node.content.size) return
    let sel = view.root.getSelection();
    let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode)) return

    // Find the text in the focused node in the node, stop if it's not
    // there (may have been modified through other means, in which
    // case it should overwritten)
    let text = textNode.nodeValue;
    let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);

    return textPos < 0 ? null : {node: textNode, pos: textPos, text}
  }

  protectLocalComposition(view, {node, pos, text}) {
    // The node is already part of a local view desc, leave it there
    if (this.getDesc(node)) return

    // Create a composition view for the orphaned nodes
    let topNode = node;
    for (;; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM) break
      while (topNode.previousSibling) topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling) topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc) topNode.pmViewDesc = null;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text);
    view.compositionNodes.push(desc);

    // Patch up this.children to contain the composition view
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }

  // : (Node, [Decoration], DecorationSet, EditorView)  bool
  // If this desc be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY ||
        !node.sameMarkup(this.node)) return false
    this.updateInner(node, outerDeco, innerDeco, view);
    return true
  }

  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM) this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }

  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco)) return
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM,
                              computeOuterDeco(this.outerDeco, this.node, needsWrap),
                              computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = null;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }

  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) this.dom.draggable = true;
  }

  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) this.dom.draggable = false;
  }
}

// Create a view desc for the top-level document node, to be exported
// and used by the view class.
function docViewDesc(doc, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc);
  return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view, 0)
}

class TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view);
  }

  parseRule() {
    let parent = this.nodeDOM.parentNode;
    return parent ? {skip: parent} : {ignore: true}
  }

  update(node, outerDeco) {
    if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||
        !node.sameMarkup(this.node)) return false
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue)
      this.nodeDOM.nodeValue = node.text;
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true
  }

  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode) if (n == parentDOM) return true
    return false
  }

  domFromPos(pos) {
    return {node: this.nodeDOM, offset: pos}
  }

  localPosFromDOM(dom, offset, bias) {
    if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length)
    return super.localPosFromDOM(dom, offset, bias)
  }

  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection"
  }

  slice(from, to, view) {
    let node = this.node.cut(from, to), dom = document.createTextNode(node.text);
    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view)
  }
}

// A dummy desc used to tag trailing BR or span nodes created to work
// around contentEditable terribleness.
class BRHackViewDesc extends ViewDesc {
  parseRule() { return {ignore: true} }
  matchesHack() { return this.dirty == NOT_DIRTY }
}

// A separate subclass is used for customized node views, so that the
// extra checks only have to be made for nodes that are actually
// customized.
class CustomNodeViewDesc extends NodeViewDesc {
  // : (?ViewDesc, Node, [Decoration], DecorationSet, dom.Node, ?dom.Node, NodeView, EditorView)
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }

  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY) return false
    if (this.spec.update) {
      let result = this.spec.update(node, outerDeco);
      if (result) this.updateInner(node, outerDeco, innerDeco, view);
      return result
    } else if (!this.contentDOM && !node.isLeaf) {
      return false
    } else {
      return super.update(node, outerDeco, innerDeco, view)
    }
  }

  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }

  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }

  setSelection(anchor, head, root, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root)
      : super.setSelection(anchor, head, root, force);
  }

  destroy() {
    if (this.spec.destroy) this.spec.destroy();
    super.destroy();
  }

  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false
  }

  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation)
  }
}

// : (dom.Node, [ViewDesc])
// Sync the content of the given DOM node with the nodes associated
// with the given array of view descs, recursing into mark descs
// because this should sync the subtree for a whole node at a time.
function renderDescs(parentDOM, descs) {
  let dom = parentDOM.firstChild;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) dom = rm(dom);
      dom = dom.nextSibling;
    } else {
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) dom = rm(dom);
}

function OuterDecoLevel(nodeName) {
  if (nodeName) this.nodeName = nodeName;
}
OuterDecoLevel.prototype = Object.create(null);

const noDeco = [new OuterDecoLevel];

function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0) return noDeco

  let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top];

  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs, cur = top;
    if (!attrs) continue
    if (attrs.nodeName)
      result.push(cur = new OuterDecoLevel(attrs.nodeName));

    for (let name in attrs) {
      let val = attrs[name];
      if (val == null) continue
      if (needsWrap && result.length == 1)
        result.push(cur = top = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class") cur.class = (cur.class ? cur.class + " " : "") + val;
      else if (name == "style") cur.style = (cur.style ? cur.style + ";" : "") + val;
      else if (name != "nodeName") cur[name] = val;
    }
  }

  return result
}

function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  // Shortcut for trivial case
  if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM

  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&
          (parent = nodeDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.appendChild(curDOM);
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM
}

function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ") : nothing;
    let curList = cur.class ? cur.class.split(" ") : nothing;
    for (let i = 0; i < prevList.length; i++) if (curList.indexOf(prevList[i]) == -1)
      dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++) if (prevList.indexOf(curList[i]) == -1)
      dom.classList.add(curList[i]);
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style[m[1].toLowerCase()] = "";
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}

function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1))
}

// : ([Decoration], [Decoration])  bool
function sameOuterDeco(a, b) {
  if (a.length != b.length) return false
  for (let i = 0; i < a.length; i++) if (!a[i].type.eq(b[i].type)) return false
  return true
}

// Remove a DOM node and return its next sibling.
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next
}

// Helper class for incrementally updating a tree of mark descs and
// the widget and node descs inside of them.
class ViewTreeUpdater {
  // : (NodeViewDesc)
  constructor(top, lockedNode) {
    this.top = top;
    this.lock = lockedNode;
    // Index into `this.top`'s child array, represents the current
    // update position.
    this.index = 0;
    // When entering a mark, the current top and index are pushed
    // onto this.
    this.stack = [];
    // Tracks whether anything was changed
    this.changed = false;

    let pre = preMatch(top.node.content, top.children);
    this.preMatched = pre.nodes;
    this.preMatchOffset = pre.offset;
  }

  getPreMatch(index) {
    return index >= this.preMatchOffset ? this.preMatched[index - this.preMatchOffset] : null
  }

  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start, end) {
    if (start == end) return
    for (let i = start; i < end; i++) this.top.children[i].destroy();
    this.top.children.splice(start, end - start);
    this.changed = true;
  }

  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }

  // : ([Mark], EditorView)
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep &&
           (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;

    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        if (this.top.children[i].matchesMark(marks[depth])) { found = i; break }
      }
      if (found > -1) {
        if (found > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }

  // : (Node, [Decoration], DecorationSet)  bool
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index) {
    let found = -1, preMatch = index < 0 ? undefined : this.getPreMatch(index), children = this.top.children;
    if (preMatch && preMatch.matchesNode(node, outerDeco, innerDeco)) {
      found = children.indexOf(preMatch);
    } else {
      for (let i = this.index, e = Math.min(children.length, i + 5); i < e; i++) {
        let child = children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && this.preMatched.indexOf(child) < 0) {
          found = i;
          break
        }
      }
    }
    if (found < 0) return false
    this.destroyBetween(this.index, found);
    this.index++;
    return true
  }

  // : (Node, [Decoration], DecorationSet, EditorView, Fragment, number)  bool
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index) {
    if (this.index == this.top.children.length) return false
    let next = this.top.children[this.index];
    if (next instanceof NodeViewDesc) {
      let preMatch = this.preMatched.indexOf(next);
      if (preMatch > -1 && preMatch + this.preMatchOffset != index) return false
      let nextDOM = next.dom;

      // Can't update if nextDOM is or contains this.lock, except if
      // it's a text node whose content already matches the new text
      // and whose decorations match the new ones.
      let locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) &&
          !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&
            next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
      if (!locked && next.update(node, outerDeco, innerDeco, view)) {
        if (next.dom != nextDOM) this.changed = true;
        this.index++;
        return true
      }
    }
    return false
  }

  // : (Node, [Decoration], DecorationSet, EditorView)
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));
    this.changed = true;
  }

  placeWidget(widget, view, pos) {
    if (this.index < this.top.children.length && this.top.children[this.index].matchesWidget(widget)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }

  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1];
    while (lastChild instanceof MarkViewDesc) lastChild = lastChild.children[lastChild.children.length - 1];

    if (!lastChild || // Empty textblock
        !(lastChild instanceof TextViewDesc) ||
        /\n$/.test(lastChild.node.text)) {
      if (this.index < this.top.children.length && this.top.children[this.index].matchesHack()) {
        this.index++;
      } else {
        let dom = document.createElement("br");
        this.top.children.splice(this.index++, 0, new BRHackViewDesc(this.top, nothing, dom, null));
        this.changed = true;
      }
    }
  }
}

// : (Fragment, [ViewDesc])  [ViewDesc]
// Iterate from the end of the fragment and array of descs to find
// directly matching ones, in order to avoid overeagerly reusing
// those for other nodes. Returns an array whose positions correspond
// to node positions in the fragment, and whose elements are either
// descs matched to the child at that index, or empty.
function preMatch(frag, descs) {
  let result = [], end = frag.childCount;
  for (let i = descs.length - 1; end > 0 && i >= 0; i--) {
    let desc = descs[i], node = desc.node;
    if (!node) continue
    if (node != frag.child(end - 1)) break
    result.push(desc);
    --end;
  }
  return {nodes: result.reverse(), offset: end}
}

function compareSide(a, b) { return a.type.side - b.type.side }

// : (ViewDesc, DecorationSet, (Decoration, number), (Node, [Decoration], DecorationSet, number))
// This function abstracts iterating over the nodes and decorations in
// a fragment. Calls `onNode` for each node, with its local and child
// decorations. Splits text nodes when there is a decoration starting
// or ending inside of them. Calls `onWidget` for each widget.
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset = 0;
  // Simple, cheap variant for when there are no local decorations
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset, child), i);
      offset += child.nodeSize;
    }
    return
  }

  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0;;) {
    if (decoIndex < locals.length && locals[decoIndex].to == offset) {
      let widget = locals[decoIndex++], widgets;
      while (decoIndex < locals.length && locals[decoIndex].to == offset)
        (widgets || (widgets = [widget])).push(locals[decoIndex++]);
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++) onWidget(widgets[i], parentIndex);
      } else {
        onWidget(widget, parentIndex);
      }
    }

    let child, index;
    if (restNode) {
      index = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break
    }

    for (let i = 0; i < active.length; i++) if (active[i].to <= offset) active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from == offset) active.push(locals[decoIndex++]);

    let end = offset + child.nodeSize;
    if (child.isText) {
      let cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++) if (active[i].to < cutAt) cutAt = active[i].to;
      if (cutAt < end) {
        restNode = child.cut(cutAt - offset);
        child = child.cut(0, cutAt - offset);
        end = cutAt;
        index = -1;
      }
    }

    onNode(child, active.length ? active.slice() : nothing, deco.forChild(offset, child), index);
    offset = end;
  }
}

// List markers in Mobile Safari will mysteriously disappear
// sometimes. This works around that.
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}

function nearbyTextNode(node, offset) {
  for (;;) {
    if (node.nodeType == 3) return node
    if (node.nodeType == 1 && offset > 0) {
      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)
        return node.childNodes[offset]
      node = node.childNodes[offset - 1];
      offset = nodeSize(node);
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      node = node.childNodes[offset];
      offset = 0;
    } else {
      return null
    }
  }
}

// Find a piece of text in an inline fragment, overlapping from-to
function findTextInFragment(frag, text, from, to) {
  for (let str = "", i = 0, childPos = 0; i < frag.childCount; i++) {
    let child = frag.child(i), end = childPos + child.nodeSize;
    if (child.isText) {
      str += child.text;
      if (end >= to) {
        let strStart = end - str.length, found = str.lastIndexOf(text);
        while (found > -1 && strStart + found > from) found = str.lastIndexOf(text, found - 1);
        if (found > -1 && strStart + found + text.length >= to) {
          return strStart + found
        } else if (end > to) {
          break
        }
      }
    } else {
      str = "";
    }
    childPos = end;
  }
  return -1
}

// Replace range from-to in an array of view descs with replacement
// (may be null to just delete). This goes very much against the grain
// of the rest of this code, which tends to create nodes with the
// right shape in one go, rather than messing with them after
// creation, but is necessary in the composition hack.
function replaceNodes(nodes, from, to, view, replacement) {
  let result = [];
  for (let i = 0, off = 0; i < nodes.length; i++) {
    let child = nodes[i], start = off, end = off += child.size;
    if (start >= to || end <= from) {
      result.push(child);
    } else {
      if (start < from) result.push(child.slice(0, from - start, view));
      if (replacement) {
        result.push(replacement);
        replacement = null;
      }
      if (end > to) result.push(child.slice(to - start, child.size, view));
    }
  }
  return result
}

function moveSelectionBlock(state, dir) {
  let {$anchor, $head} = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir)
}

function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true
}

function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && (next instanceof NodeSelection)) return apply(view, next)
      return false
    } else {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText) return false
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head))
      } else if (result.webkit) {
        // Chrome and Safari will introduce extra pointless cursor
        // positions around inline uneditable nodes, so we have to
        // take over and move the cursor past them (#937)
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)))
      } else {
        return false
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from))
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next) return apply(view, next)
    return false
  }
}

function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length
}

function isIgnorable(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR")
}

// Make sure the cursor isn't directly after one or more ignored
// nodes, which will confuse the browser's cursor motion logic.
function skipIgnoredNodesLeft(view) {
  let sel = view.root.getSelection();
  let node = sel.focusNode, offset = sel.focusOffset;
  if (!node) return
  let moveNode, moveOffset, force = false;
  // Gecko will do odd things when the selection is directly in front
  // of a non-editable node, so in that case, move it into the next
  // node if possible. Issue prosemirror/prosemirror#832.
  if (result.gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) force = true;
  for (;;) {
    if (offset > 0) {
      if (node.nodeType != 1) {
        break
      } else {
        let before = node.childNodes[offset - 1];
        if (isIgnorable(before)) {
          moveNode = node;
          moveOffset = --offset;
        } else if (before.nodeType == 3) {
          node = before;
          offset = node.nodeValue.length;
        } else break
      }
    } else if (isBlockNode(node)) {
      break
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom) break
        offset = 0;
      } else {
        node = prev;
        offset = nodeLen(node);
      }
    }
  }
  if (force) setSelFocus(view, sel, node, offset);
  else if (moveNode) setSelFocus(view, sel, moveNode, moveOffset);
}

// Make sure the cursor isn't directly before one or more ignored
// nodes.
function skipIgnoredNodesRight(view) {
  let sel = view.root.getSelection();
  let node = sel.focusNode, offset = sel.focusOffset;
  if (!node) return
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (;;) {
    if (offset < len) {
      if (node.nodeType != 1) break
      let after = node.childNodes[offset];
      if (isIgnorable(after)) {
        moveNode = node;
        moveOffset = ++offset;
      }
      else break
    } else if (isBlockNode(node)) {
      break
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom) break
        offset = len = 0;
      } else {
        node = next;
        offset = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode) setSelFocus(view, sel, moveNode, moveOffset);
}

function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock
}

function setSelFocus(view, sel, node, offset) {
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset);
    range.setStart(node, offset);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset);
  }
  view.domObserver.setCurSelection();
}

// : (EditorState, number)
// Check whether vertical selection motion would involve node
// selections. If so, apply it (if not, the result is left to the
// browser)
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1) return false
  let {$from, $to} = sel;

  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && (next instanceof NodeSelection))
      return apply(view, next)
  }
  if (!$from.parent.inlineContent) {
    let beyond = Selection.findFrom(dir < 0 ? $from : $to, dir);
    return beyond ? apply(view, beyond) : true
  }
  return false
}

function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection)) return true
  let {$head, $anchor, empty} = view.state.selection;
  if (!$head.sameParent($anchor)) return true
  if (!empty) return false
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) return true
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr = view.state.tr;
    if (dir < 0) tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    else tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true
  }
  return false
}

function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}

// Issue #867 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821
// In which Chrome does really wrong things when the down arrow is
// pressed when the cursor is directly at the start of a textblock and
// has an uneditable node after it
function chromeDownArrowBug(view) {
  if (!result.chrome || view.state.selection.$head.parentOffset > 0) return
  let {focusNode, focusOffset} = view.root.getSelection();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&
      focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, true);
    setTimeout(() => switchEditable(view, child, false), 20);
  }
}

// A backdrop key mapping used to make sure we always suppress keys
// that have a dangerous default effect, even if the commands they are
// bound to return false, and to make sure that cursor-motion keys
// find a cursor (as opposed to a node selection) when pressed. For
// cursor-motion keys, the code in the handlers also takes care of
// block selections.

function getMods(event) {
  let result = "";
  if (event.ctrlKey) result += "c";
  if (event.metaKey) result += "m";
  if (event.altKey) result += "a";
  if (event.shiftKey) result += "s";
  return result
}

function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || (result.mac && code == 72 && mods == "c")) { // Backspace, Ctrl-h on Mac
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view)
  } else if (code == 46 || (result.mac && code == 68 && mods == "c")) { // Delete, Ctrl-d on Mac
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)
  } else if (code == 13 || code == 27) { // Enter, Esc
    return true
  } else if (code == 37) { // Left arrow
    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view)
  } else if (code == 39) { // Right arrow
    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view)
  } else if (code == 38) { // Up arrow
    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view)
  } else if (code == 40) { // Down arrow
    return chromeDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view)
  } else if (mods == (result.mac ? "m" : "c") &&
             (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]
    return true
  }
  return false
}

function selectionFromDOM(view, origin) {
  let domSel = view.root.getSelection(), doc = view.state.doc;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
  let $head = doc.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc && !nearestDesc.node) nearestDesc = nearestDesc.parent;
    if (nearestDesc && nearestDesc.node.isAtom && NodeSelection.isSelectable(nearestDesc.node) && nearestDesc.parent) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc.resolve(pos));
    }
  } else {
    $anchor = doc.resolve(view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset));
  }

  if (!selection) {
    let bias = origin == "pointer" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection
}

function selectionToDOM(view, takeFocus, force) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);

  if (view.editable && !view.hasFocus()) {
    if (!takeFocus) return
    // See https://bugzilla.mozilla.org/show_bug.cgi?id=921444
    if (result.gecko && result.gecko_version <= 55) {
      view.domObserver.disconnectSelection();
      view.dom.focus();
      view.domObserver.connectSelection();
    }
  } else if (!view.editable && !(hasSelection(view) && document.activeElement.contains(view.dom)) && !takeFocus) {
    return
  }

  view.domObserver.disconnectSelection();

  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let {anchor, head} = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom) resetEditableFrom.contentEditable = "false";
      if (resetEditableTo) resetEditableTo.contentEditable = "false";
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else if (anchor != head) {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) removeClassOnSelectionChange(view);
    }
  }

  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}

// Kludge to work around Webkit not allowing a selection to start/end
// between non-editable block nodes. We briefly make something
// editable, set the selection, then set it uneditable again.

const brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;

function temporarilyEditableNear(view, pos) {
  let {node, offset} = view.docView.domFromPos(pos);
  let after = offset < node.childNodes.length ? node.childNodes[offset] : null;
  let before = offset ? node.childNodes[offset - 1] : null;
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after) {
      after.contentEditable = "true";
      return after
    } else if (before) {
      before.contentEditable = "true";
      return before
    }
  }
}

function removeClassOnSelectionChange(view) {
  let doc = view.dom.ownerDocument;
  doc.removeEventListener("selectionchange", view.hideSelectionGuard);
  let domSel = view.root.getSelection();
  let node = domSel.anchorNode, offset = domSel.anchorOffset;
  doc.addEventListener("selectionchange", view.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
      doc.removeEventListener("selectionchange", view.hideSelectionGuard);
      view.dom.classList.remove("ProseMirror-hideselection");
    }
  });
}

function selectCursorWrapper(view) {
  let domSel = view.root.getSelection(), range = document.createRange();
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img) range.setEnd(node.parentNode, domIndex(node) + 1);
  else range.setEnd(node, 0);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  // Kludge to kill 'control selection' in IE11 when selecting an
  // invisible cursor wrapper, since that would result in those weird
  // resize handles and a selection that considers the absolutely
  // positioned wrapper, rather than the root editable node, the
  // focused element.
  if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}

function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc) desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}

// Clear all DOM statefulness of the last node selection.
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = null;
  }
}

function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", f => f(view, $anchor, $head))
    || TextSelection.between($anchor, $head, bias)
}

function hasFocusAndSelection(view) {
  if (view.editable && view.root.activeElement != view.dom) return false
  return hasSelection(view)
}

function hasSelection(view) {
  let sel = view.root.getSelection();
  if (!sel.anchorNode) return false
  try {
    // Firefox will raise 'permission denied' errors when accessing
    // properties of `sel.anchorNode` when it's in a generated CSS
    // element.
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&
      (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode))
  } catch(_) {
    return false
  }
}

function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor);
  let domSel = view.root.getSelection();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset)
}

// Note that all referencing and parsing is done with the
// start-of-operation selection and document, since that's the one
// that the DOM represents. If any changes came in in the meantime,
// the modification is mapped over those before it is applied, in
// readDOMChange.

function parseBetween(view, from_, to_) {
  let {node: parent, fromOffset, toOffset, from, to} = view.docView.parseRange(from_, to_);

  let domSel = view.root.getSelection(), find = null, anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find = [{node: anchor, offset: domSel.anchorOffset}];
    if (!selectionCollapsed(domSel))
      find.push({node: domSel.focusNode, offset: domSel.focusOffset});
  }
  // Work around issue in Chrome where backspacing sometimes replaces
  // the deleted content with a random BR node (issues #799, #831)
  if (result.chrome && view.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeType == "BR" && !desc) { toOffset = off; break }
      if (!desc || desc.size) break
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from);
  let sel = null, doc = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.spec.code ? "full" : true,
    editableContent: true,
    findPositions: find,
    ruleFromNode: ruleFromNode(parser, $from),
    context: $from
  });
  if (find && find[0].pos != null) {
    let anchor = find[0].pos, head = find[1] && find[1].pos;
    if (head == null) head = anchor;
    sel = {anchor: anchor + from, head: head + from};
  }
  return {doc, sel, from, to}
}

function ruleFromNode(parser, context) {
  return dom => {
    let desc = dom.pmViewDesc;
    if (desc) {
      return desc.parseRule()
    } else if (dom.nodeName == "BR" && dom.parentNode) {
      // Safari replaces the list item or table cell with a BR
      // directly in the list node (?!) if you delete the last
      // character in a list item or table cell (#708, #862)
      if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName))
        return parser.matchTag(document.createElement("li"), context)
      else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName))
        return {ignore: true}
    } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
      return {ignore: true}
    }
  }
}

function readDOMChange(view, from, to, typeOver) {
  if (from < 0) {
    let origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (!view.state.selection.eq(newSel)) {
      let tr = view.state.tr.setSelection(newSel);
      if (origin == "pointer") tr.setMeta("pointer", true);
      else if (origin == "key") tr.scrollIntoView();
      view.dispatch(tr);
    }
    return
  }

  let $before = view.state.doc.resolve(from);
  let shared = $before.sharedDepth(to);
  from = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);

  let sel = view.state.selection;
  let parse = parseBetween(view, from, to);

  let doc = view.state.doc, compare = doc.slice(parse.from, parse.to);
  let preferredPos, preferredSide;
  // Prefer anchoring to end when Backspace is pressed
  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.lastKeyCode = null;

  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&
        !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      let state = view.state, sel = state.selection;
      view.dispatch(state.tr.replaceSelectionWith(state.schema.text(state.doc.textBetween(sel.from, sel.to)), true).scrollIntoView());
    } else if (parse.sel) {
      let sel = resolveSelection(view, view.state.doc, parse.sel);
      if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel));
    }
    return
  }
  view.domChangeCount++;
  // Handle the case where overwriting a selection by typing matches
  // the start or end of the selected content, creating a change
  // that's smaller than what was actually overwritten.
  if (view.state.selection.from < view.state.selection.to &&
      change.start == change.endB &&
      view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {
      change.endB += (view.state.selection.to - change.endA);
      change.endA = view.state.selection.to;
    }
  }

  let $from = parse.doc.resolveNoCache(change.start - parse.from);
  let $to = parse.doc.resolveNoCache(change.endB - parse.from);
  let nextSel;
  // If this looks like the effect of pressing Enter, just dispatch an
  // Enter key instead.
  if (!$from.sameParent($to) && $from.pos < parse.doc.content.size &&
      (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&
      nextSel.head == $to.pos &&
      view.someProp("handleKeyDown", f => f(view, keyEvent(13, "Enter"))))
    return
  // Same for backspace
  if (view.state.selection.anchor > change.start &&
      looksLikeJoin(doc, change.start, change.endA, $from, $to) &&
      view.someProp("handleKeyDown", f => f(view, keyEvent(8, "Backspace")))) {
    if (result.android && result.chrome) view.domObserver.suppressSelectionUpdates(); // #820
    return
  }

  let chFrom = change.start, chTo = change.endA;

  let tr, storedMarks, markChange, $from1;
  if ($from.sameParent($to) && $from.parent.inlineContent) {
    if ($from.pos == $to.pos) { // Deletion
      // IE11 sometimes weirdly moves the DOM selection around after
      // backspacing out the first element in a textblock
      if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));
    } else if ( // Adding or removing a mark
      change.endA == change.endB && ($from1 = doc.resolve(change.start)) &&
      (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset),
                                 $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))
    ) {
      tr = view.state.tr;
      if (markChange.type == "add") tr.addMark(chFrom, chTo, markChange.mark);
      else tr.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      // Both positions in the same text node -- simply insert text
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", f => f(view, chFrom, chTo, text))) return
      tr = view.state.tr.insertText(text, chFrom, chTo);
    }
  }

  if (!tr)
    tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
  if (parse.sel) {
    let sel = resolveSelection(view, tr.doc, parse.sel);
    if (sel) tr.setSelection(sel);
  }
  if (storedMarks) tr.ensureMarks(storedMarks);
  view.dispatch(tr.scrollIntoView());
}

function resolveSelection(view, doc, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) return null
  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head))
}

// : (Fragment, Fragment)  ?{mark: Mark, type: string}
// Given two same-length, non-empty fragments of inline content,
// determine whether the first could be created from the second by
// removing or adding a single mark type.
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i = 0; i < prevMarks.length; i++) added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++) removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = node => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = node => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++) updated.push(update(prev.child(i)));
  if (Fragment.from(updated).eq(cur)) return {mark, type}
}

function looksLikeJoin(old, start, end, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock ||
      // The content must have shrunk
      end - start <= $newEnd.pos - $newStart.pos ||
      // newEnd must point directly at or after the end of the block that newStart points into
      skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
    return false

  let $start = old.resolve(start);
  // Start must be at the end of a block
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  // The next textblock must start before end and end near it
  if (!$next.parent.isTextblock || $next.pos > end ||
      skipClosingAndOpening($next, true, false) < end)
    return false

  // The fragments after the join point must match
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content)
}

function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end
}

function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start = a.findDiffStart(b, pos);
  if (start == null) return null
  let {a: endA, b: endB} = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }
  if (endA < start && a.size < b.size) {
    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
    start -= move;
    endA = start + (endA - endB);
    endB = start;
  }
  return {start, endA, endB}
}

function serializeForClipboard(view, slice) {
  let context = [], {content, openStart, openEnd} = slice;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.type.hasRequiredAttrs() ? node.attrs : null);
    content = node.content;
  }

  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc = detachedDoc(), wrap = doc.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content, {document: doc}));

  let firstChild = wrap.firstChild, needsWrap;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc.createElement(needsWrap[i]);
      while (wrap.firstChild) wrapper.appendChild(wrap.firstChild);
      wrap.appendChild(wrapper);
    }
    firstChild = wrap.firstChild;
  }

  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd} ${JSON.stringify(context)}`);

  let text = view.someProp("clipboardTextSerializer", f => f(slice)) ||
      slice.content.textBetween(0, slice.content.size, "\n\n");

  return {dom: wrap, text}
}

// : (EditorView, string, string, ?bool, ResolvedPos)  ?Slice
// Read a slice of content from the clipboard (or drop data).
function parseFromClipboard(view, text, html, plainText, $context) {
  let dom, inCode = $context.parent.type.spec.code, slice;
  if (!html && !text) return null
  let asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", f => { text = f(text); });
    if (inCode) return new Slice(Fragment.from(view.state.schema.text(text)), 0, 0)
    let parsed = view.someProp("clipboardTextParser", f => f(text, $context));
    if (parsed) {
      slice = parsed;
    } else {
      dom = document.createElement("div");
      text.trim().split(/(?:\r\n?|\n)+/).forEach(block => {
        dom.appendChild(document.createElement("p")).textContent = block;
      });
    }
  } else {
    view.someProp("transformPastedHTML", f => { html = f(html); });
    dom = readHTML(html);
  }

  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
  if (!slice) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice = parser.parseSlice(dom, {preserveWhitespace: !!(asText || sliceData), context: $context});
  }
  if (sliceData)
    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[3]);
  else // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent
    slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), false);

  view.someProp("transformPasted", f => { slice = f(slice); });
  return slice
}

// Takes a slice parsed with parseSlice, which means there hasn't been
// any content-expression checking done on the top nodes, tries to
// find a parent node in the current context that might fit the nodes,
// and if successful, rebuilds the slice so that it fits into that parent.
//
// This addresses the problem that Transform.replace expects a
// coherent slice, and will fail to place a set of siblings that don't
// fit anywhere in the schema.
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2) return fragment
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach(node => {
      if (!result) return
      let wrap = match.findWrapping(node.type), inLast;
      if (!wrap) return result = null
      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap);
        result.push(wrapped);
        match = match.matchType(wrapped.type, wrapped.attrs);
        lastWrap = wrap;
      }
    });
    if (result) return Fragment.from(result)
  }
  return fragment
}

function withWrappers(node, wrap, from = 0) {
  for (let i = wrap.length - 1; i >= from; i--)
    node = wrap[i].create(null, Fragment.from(node));
  return node
}

// Used to group adjacent nodes wrapped in similar parents by
// normalizeSiblings into the same parent node
function addToSibling(wrap, lastWrap, node, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner))
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap, depth + 1))))
  }
}

function closeRight(node, depth) {
  if (depth == 0) return node
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill))
}

function closeRange(fragment, side, from, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd);
  if (depth >= from)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner)
      : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner))
}

function closeSlice(slice, openStart, openEnd) {
  if (openStart < slice.openStart)
    slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
  if (openEnd < slice.openEnd)
    slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
  return slice
}

// Trick from jQuery -- some elements must be wrapped in other
// elements for innerHTML to work. I.e. if you do `div.innerHTML =
// "<td>..</td>"` the table cells are ignored.
const wrapMap = {thead: ["table"], colgroup: ["table"], col: ["table", "colgroup"],
                 tr: ["table", "tbody"], td: ["table", "tbody", "tr"], th: ["table", "tbody", "tr"]};

let _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"))
}

function readHTML(html) {
  let metas = /(\s*<meta [^>]*>)*/.exec(html);
  if (metas) html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /(?:<meta [^>]*>)*<([a-z][^>\s]+)/i.exec(html), wrap, depth = 0;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) {
    html = wrap.map(n => "<" + n + ">").join("") + html + wrap.map(n => "</" + n + ">").reverse().join("");
    depth = wrap.length;
  }
  elt.innerHTML = html;
  for (let i = 0; i < depth; i++) elt = elt.firstChild;
  return elt
}

function addContext(slice, context) {
  if (!slice.size) return slice
  let schema = slice.content.firstChild.type.schema, array;
  try { array = JSON.parse(context); }
  catch(e) { return slice }
  let {content, openStart, openEnd} = slice;
  for (let i = array.length - 2; i >= 0; i -= 2) {
    let type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs()) break
    content = Fragment.from(type.create(array[i + 1], content));
    openStart++; openEnd++;
  }
  return new Slice(content, openStart, openEnd)
}

const observeOptions = {childList: true, characterData: true, attributes: true, subtree: true, characterDataOldValue: true};
// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified
const useCharData = result.ie && result.ie_version <= 11;

class SelectionState {
  constructor() {
    this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
  }

  set(sel) {
    this.anchorNode = sel.anchorNode; this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode; this.focusOffset = sel.focusOffset;
  }

  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&
      sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset
  }
}

class DOMObserver {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.observer = window.MutationObserver &&
      new window.MutationObserver(mutations => {
        // IE11 will sometimes (on backspacing out a single character
        // text node after a BR node) call the observer callback
        // before actually updating the DOM, which will cause
        // ProseMirror to miss the change (see #930)
        if (result.ie && result.ie_version <= 11 && mutations.some(
          m => m.type == "childList" && m.removedNodes.length == 1 && m.removedNodes[0].parentNode == m.target))
          setTimeout(() => this.flush(mutations), 10);
        else
          this.flush(mutations);
      });
    this.currentSelection = new SelectionState;
    this.queue = [];
    if (useCharData) {
      this.onCharData = e => {
        this.queue.push({target: e.target, type: "characterData", oldValue: e.prevValue});
        window.setTimeout(() => this.flush(), 20);
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.suppressingSelectionUpdates = false;
  }

  start() {
    if (this.observer)
      this.observer.observe(this.view.dom, observeOptions);
    if (useCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }

  stop() {
    let take = this.observer.takeRecords();
    if (take.length) {
      for (let i = 0; i < take.length; i++) this.queue.push(take[i]);
      window.setTimeout(() => this.flush(), 20);
    }
    if (this.observer) this.observer.disconnect();
    if (useCharData) this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }

  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }

  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }

  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }

  onSelectionChange() {
    if (!hasFocusAndSelection(this.view)) return
    if (this.suppressingSelectionUpdates) return selectionToDOM(this.view)
    this.flush();
  }

  setCurSelection() {
    this.currentSelection.set(this.view.root.getSelection());
  }

  ignoreSelectionChange(sel) {
    if (sel.rangeCount == 0) return true
    let container = sel.getRangeAt(0).commonAncestorContainer;
    let desc = this.view.docView.nearestDesc(container);
    return desc && desc.ignoreMutation({type: "selection", target: container.nodeType == 3 ? container.parentNode : container})
  }

  flush(mutations) {
    if (!this.view.docView) return
    if (!mutations) mutations = this.observer.takeRecords();
    if (this.queue.length) {
      mutations = this.queue.concat(mutations);
      this.queue.length = 0;
    }

    let sel = this.view.root.getSelection();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel);

    let from = -1, to = -1, typeOver = false;
    if (this.view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i]);
        if (result) {
          from = from < 0 ? result.from : Math.min(result.from, from);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver && !this.view.composing) typeOver = true;
        }
      }
    }
    if (from > -1 || newSel) {
      if (from > -1) this.view.docView.markDirty(from, to);
      this.handleDOMChange(from, to, typeOver);
      if (this.view.docView.dirty) this.view.updateState(this.view.state);
      else if (!this.currentSelection.eq(sel)) selectionToDOM(this.view);
    }
  }

  registerMutation(mut) {
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" &&
        (desc == this.view.docView || mut.attributeName == "contenteditable" ||
         // Firefox sometimes fires spurious events for null/empty styles
         (mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))))
      return null
    if (!desc || desc.ignoreMutation(mut)) return null

    if (mut.type == "childList") {
      let fromOffset = mut.previousSibling && mut.previousSibling.parentNode == mut.target
          ? domIndex(mut.previousSibling) + 1 : 0;
      let from = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = mut.nextSibling && mut.nextSibling.parentNode == mut.target
          ? domIndex(mut.nextSibling) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return {from, to}
    } else if (mut.type == "attributes") {
      return {from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border}
    } else { // "characterData"
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      }
    }
  }
}

// A collection of DOM events that occur within the editor, and callback functions
// to invoke when the event fires.
const handlers = {}, editHandlers = {};

function initInput(view) {
  view.shiftKey = false;
  view.mouseDown = null;
  view.lastKeyCode = null;
  view.lastKeyCodeTime = 0;
  view.lastClick = {time: 0, x: 0, y: 0, type: ""};
  view.lastSelectionOrigin = null;
  view.lastSelectionTime = 0;

  view.composing = false;
  view.composingTimeout = null;
  view.compositionNodes = [];
  view.compositionEndedAt = -2e8;

  view.domObserver = new DOMObserver(view, (from, to, typeOver) => readDOMChange(view, from, to, typeOver));
  view.domObserver.start();
  // Used by hacks like the beforeinput handler to check whether anything happened in the DOM
  view.domChangeCount = 0;

  view.eventHandlers = Object.create(null);
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.eventHandlers[event] = event => {
      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&
          (view.editable || !(event.type in editHandlers)))
        handler(view, event);
    });
  }
  // On Safari, for reasons beyond my understanding, adding an input
  // event handler makes an issue where the composition vanishes when
  // you press enter go away.
  if (result.safari) view.dom.addEventListener("input", () => null);

  ensureListeners(view);
}

function setSelectionOrigin(view, origin) {
  view.lastSelectionOrigin = origin;
  view.lastSelectionTime = Date.now();
}

function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.eventHandlers)
    view.dom.removeEventListener(type, view.eventHandlers[type]);
  clearTimeout(view.composingTimeout);
}

function ensureListeners(view) {
  view.someProp("handleDOMEvents", currentHandlers => {
    for (let type in currentHandlers) if (!view.eventHandlers[type])
      view.dom.addEventListener(type, view.eventHandlers[type] = event => runCustomHandler(view, event));
  });
}

function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", handlers => {
    let handler = handlers[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false
  })
}

function eventBelongsToView(view, event) {
  if (!event.bubbles) return true
  if (event.defaultPrevented) return false
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 ||
        (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))
      return false
  return true
}

function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] &&
      (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}

editHandlers.keydown = (view, event) => {
  view.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event)) return
  view.lastKeyCode = event.keyCode;
  view.lastKeyCodeTime = Date.now();
  if (view.someProp("handleKeyDown", f => f(view, event)) || captureKeyDown(view, event))
    event.preventDefault();
  else
    setSelectionOrigin(view, "key");
};

editHandlers.keyup = (view, e) => {
  if (e.keyCode == 16) view.shiftKey = false;
};

editHandlers.keypress = (view, event) => {
  if (inOrNearComposition(view, event) || !event.charCode ||
      event.ctrlKey && !event.altKey || result.mac && event.metaKey) return

  if (view.someProp("handleKeyPress", f => f(view, event))) {
    event.preventDefault();
    return
  }

  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    if (!view.someProp("handleTextInput", f => f(view, sel.$from.pos, sel.$to.pos, text)))
      view.dispatch(view.state.tr.insertText(text).scrollIntoView());
    event.preventDefault();
  }
};

function eventCoords(event) { return {left: event.clientX, top: event.clientY} }

function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100
}

function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1) return false
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, f => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)
                                                    : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true
  }
  return false
}

function updateSelection(view, selection, origin) {
  if (!view.focused) view.focus();
  let tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") tr.setMeta("pointer", true);
  view.dispatch(tr);
}

function selectClickedLeaf(view, inside) {
  if (inside == -1) return false
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true
  }
  return false
}

function selectClickedNode(view, inside) {
  if (inside == -1) return false
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection) selectedNode = sel.node;

  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 &&
          i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break
    }
  }

  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true
  } else {
    return false
  }
}

function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) ||
    view.someProp("handleClick", f => f(view, pos, event)) ||
    (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside))
}

function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) ||
    view.someProp("handleDoubleClick", f => f(view, pos, event))
}

function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) ||
    view.someProp("handleTripleClick", f => f(view, pos, event)) ||
    defaultTripleClick(view, inside)
}

function defaultTripleClick(view, inside) {
  let doc = view.state.doc;
  if (inside == -1) {
    if (doc.inlineContent) {
      updateSelection(view, TextSelection.create(doc, 0, doc.content.size), "pointer");
      return true
    }
    return false
  }

  let $pos = doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc, nodePos), "pointer");
    else
      continue
    return true
  }
}

function forceDOMFlush(view) {
  return endComposition(view)
}

const selectNodeModifier = result.mac ? "metaKey" : "ctrlKey";

handlers.mousedown = (view, event) => {
  view.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now = Date.now(), type = "singleClick";
  if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {
    if (view.lastClick.type == "singleClick") type = "doubleClick";
    else if (view.lastClick.type == "doubleClick") type = "tripleClick";
  }
  view.lastClick = {time: now, x: event.clientX, y: event.clientY, type};

  let pos = view.posAtCoords(eventCoords(event));
  if (!pos) return

  if (type == "singleClick")
    view.mouseDown = new MouseDown(view, pos, event, flushed);
  else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event))
    event.preventDefault();
  else
    setSelectionOrigin(view, "pointer");
};

class MouseDown {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.startDoc = view.state.doc;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.selectNode = event[selectNodeModifier];
    this.allowDefault = event.shiftKey;

    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }

    this.mightDrag = null;

    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;

    if (targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||
        view.state.selection instanceof NodeSelection && targetPos == view.state.selection.from)
      this.mightDrag = {node: targetNode,
                        pos: targetPos,
                        addAttr: this.target && !this.target.draggable,
                        setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable")};

    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr) this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => this.target.setAttribute("contentEditable", "false"), 20);
      this.view.domObserver.start();
    }

    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }

  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr) this.target.draggable = false;
      if (this.mightDrag.setUneditable) this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    this.view.mouseDown = null;
  }

  up(event) {
    this.done();

    if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target))
      return

    let pos = this.pos;
    if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event));

    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (this.flushed ||
               // Chrome will sometimes treat a node selection as a
               // cursor, but still report that the node is selected
               // when asked through getSelection. You'll then get a
               // situation where clicking at the point where that
               // (hidden) cursor is doesn't change the selection, and
               // thus doesn't get a reaction from ProseMirror. This
               // works around that.
               (result.chrome && !(this.view.state.selection instanceof TextSelection) &&
                (pos.pos == this.view.state.selection.from || pos.pos == this.view.state.selection.to))) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }

  move(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||
                               Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
    setSelectionOrigin(this.view, "pointer");
  }
}

handlers.touchdown = view => {
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};

handlers.contextmenu = view => forceDOMFlush(view);

function inOrNearComposition(view, event) {
  if (view.composing) return true
  // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
  // On Japanese input method editors (IMEs), the Enter key is used to confirm character
  // selection. On Safari, when Enter is pressed, compositionend and keydown events are
  // emitted. The keydown event triggers newline insertion, which we don't want.
  // This method returns true if the keydown event should be ignored.
  // We only ignore it once, as pressing Enter a second time *should* insert a newline.
  // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.
  // This guards against the case where compositionend is triggered without the keyboard
  // (e.g. character confirmation may be done with the mouse), and keydown is triggered
  // afterwards- we wouldn't want to ignore the keydown event in this case.
  if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {
    view.compositionEndedAt = -2e8;
    return true
  }
  return false
}

// Drop active composition after 5 seconds of inactivity on Android
const timeoutComposition = result.android ? 5000 : -1;

editHandlers.compositionstart = editHandlers.compositionupdate = view => {
  if (!view.composing) {
    view.domObserver.flush();
    let {state} = view, $pos = state.selection.$from;
    if (state.selection.empty &&
        (state.storedMarks || (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(m => m.type.spec.inclusive === false)))) {
      // Need to wrap the cursor in mark nodes different from the ones in the DOM context
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      // In firefox, if the cursor is after but outside a marked node,
      // the inserted text won't inherit the marks. So this moves it
      // inside if necessary.
      if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.root.getSelection();
        for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {
          let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
          if (before.nodeType == 3) {
            sel.collapse(before, before.nodeValue.length);
            break
          } else {
            node = before;
            offset = -1;
          }
        }
      }
    }
    view.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};

editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd(view, 20);
  }
};

function scheduleComposeEnd(view, delay) {
  clearTimeout(view.composingTimeout);
  if (delay > -1) view.composingTimeout = setTimeout(() => endComposition(view), delay);
}

function endComposition(view, forceUpdate) {
  view.composing = false;
  while (view.compositionNodes.length > 0) view.compositionNodes.pop().markParentsDirty();
  if (forceUpdate || view.docView.dirty) {
    view.updateState(view.state);
    return true
  }
  return false
}

function captureCopy(view, dom) {
  // The extra wrapper is somehow necessary on IE/Edge to prevent the
  // content from being mangled when it is put onto the clipboard
  let doc = dom.ownerDocument;
  let wrap = doc.body.appendChild(doc.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = doc.createRange();
  range.selectNodeContents(dom);
  // Done because IE will fire a selectionchange moving the selection
  // to its start when removeAllRanges is called and the editor still
  // has focus (which will mess up the editor's selection state).
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    doc.body.removeChild(wrap);
    view.focus();
  }, 50);
}

// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard APIall the objects and methods are
// there, they just don't work, and they are hard to test.
const brokenClipboardAPI = (result.ie && result.ie_version < 15) ||
      (result.ios && result.webkit_version < 604);

handlers.copy = editHandlers.cut = (view, e) => {
  let sel = view.state.selection, cut = e.type == "cut";
  if (sel.empty) return

  // IE and Edge's clipboard interface is completely broken
  let data = brokenClipboardAPI ? null : e.clipboardData;
  let slice = sel.content(), {dom, text} = serializeForClipboard(view, slice);
  if (data) {
    e.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};

function sliceSingleNode(slice) {
  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null
}

function capturePaste(view, e) {
  let doc = view.dom.ownerDocument;
  let plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = doc.body.appendChild(doc.createElement(plainText ? "textarea" : "div"));
  if (!plainText) target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    doc.body.removeChild(target);
    if (plainText) doPaste(view, target.value, null, e);
    else doPaste(view, target.textContent, target.innerHTML, e);
  }, 50);
}

function doPaste(view, text, html, e) {
  let slice = parseFromClipboard(view, text, html, view.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", f => f(view, e, slice || Slice.empty)) || !slice) return true

  let singleNode = sliceSingleNode(slice);
  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true
}

editHandlers.paste = (view, e) => {
  let data = brokenClipboardAPI ? null : e.clipboardData;
  if (data && (doPaste(view, data.getData("text/plain"), data.getData("text/html"), e) || data.files.length > 0))
    e.preventDefault();
  else
    capturePaste(view, e);
};

class Dragging {
  constructor(slice, move) {
    this.slice = slice;
    this.move = move;
  }
}

const dragCopyModifier = result.mac ? "altKey" : "ctrlKey";

handlers.dragstart = (view, e) => {
  let mouseDown = view.mouseDown;
  if (mouseDown) mouseDown.done();
  if (!e.dataTransfer) return

  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(e));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1: sel.to)) ; else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (e.target && e.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(e.target, true);
    if (!desc || !desc.node.type.spec.draggable || desc == view.docView) return
    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)));
  }
  let slice = view.state.selection.content(), {dom, text} = serializeForClipboard(view, slice);
  e.dataTransfer.clearData();
  e.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  if (!brokenClipboardAPI) e.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice, !e[dragCopyModifier]);
};

handlers.dragend = view => {
  window.setTimeout(() => view.dragging = null, 50);
};

editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();

editHandlers.drop = (view, e) => {
  let dragging = view.dragging;
  view.dragging = null;

  if (!e.dataTransfer) return

  let eventPos = view.posAtCoords(eventCoords(e));
  if (!eventPos) return
  let $mouse = view.state.doc.resolve(eventPos.pos);
  if (!$mouse) return
  let slice = dragging && dragging.slice ||
      parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"),
                         brokenClipboardAPI ? null : e.dataTransfer.getData("text/html"), false, $mouse);
  if (!slice) return

  e.preventDefault();
  if (view.someProp("handleDrop", f => f(view, e, slice, dragging && dragging.move))) return
  let insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
  if (insertPos == null) insertPos = $mouse.pos;

  let tr = view.state.tr;
  if (dragging && dragging.move) tr.deleteSelection();

  let pos = tr.mapping.map(insertPos);
  let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
  let beforeInsert = tr.doc;
  if (isNode)
    tr.replaceRangeWith(pos, pos, slice.content.firstChild);
  else
    tr.replaceRange(pos, pos, slice);
  if (tr.doc.eq(beforeInsert)) return

  let $pos = tr.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice.content.firstChild) &&
      $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild))
    tr.setSelection(new NodeSelection($pos));
  else
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(tr.mapping.map(insertPos))));
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};

handlers.focus = view => {
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
  }
};

handlers.blur = view => {
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    view.focused = false;
  }
};

handlers.beforeinput = (view, event) => {
  // We should probably do more with beforeinput events, but support
  // is so spotty that I'm still waiting to see where they are going.

  // Very specific hack to deal with backspace sometimes failing on
  // Chrome Android when after an uneditable node.
  if (result.chrome && result.android && event.inputType == "deleteContentBackward") {
    let {domChangeCount} = view;
    setTimeout(() => {
      if (view.domChangeCount != domChangeCount) return // Event already had some effect
      // This bug tends to close the virtual keyboard, so we refocus
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", f => f(view, keyEvent(8, "Backspace")))) return
      let {$cursor} = view.state.selection;
      // Crude approximation of backspace behavior when no command handled it
      if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};

// Make sure all handlers get registered
for (let prop in editHandlers) handlers[prop] = editHandlers[prop];

function compareObjs(a, b) {
  if (a == b) return true
  for (let p in a) if (a[p] !== b[p]) return false
  for (let p in b) if (!(p in a)) return false
  return true
}

class WidgetType {
  constructor(toDOM, spec) {
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
    this.toDOM = toDOM;
  }

  map(mapping, span, offset, oldOffset) {
    let {pos, deleted} = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset, pos - offset, this)
  }

  valid() { return true }

  eq(other) {
    return this == other ||
      (other instanceof WidgetType &&
       (this.spec.key && this.spec.key == other.spec.key ||
        this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)))
  }
}

class InlineType {
  constructor(attrs, spec) {
    this.spec = spec || noSpec;
    this.attrs = attrs;
  }

  map(mapping, span, offset, oldOffset) {
    let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
    return from >= to ? null : new Decoration(from, to, this)
  }

  valid(_, span) { return span.from < span.to }

  eq(other) {
    return this == other ||
      (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&
       compareObjs(this.spec, other.spec))
  }

  static is(span) { return span.type instanceof InlineType }
}

class NodeType$1 {
  constructor(attrs, spec) {
    this.spec = spec || noSpec;
    this.attrs = attrs;
  }

  map(mapping, span, offset, oldOffset) {
    let from = mapping.mapResult(span.from + oldOffset, 1);
    if (from.deleted) return null
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from.pos) return null
    return new Decoration(from.pos - offset, to.pos - offset, this)
  }

  valid(node, span) {
    let {index, offset} = node.content.findIndex(span.from);
    return offset == span.from && offset + node.child(index).nodeSize == span.to
  }

  eq(other) {
    return this == other ||
      (other instanceof NodeType$1 && compareObjs(this.attrs, other.attrs) &&
       compareObjs(this.spec, other.spec))
  }
}

// ::- Decoration objects can be provided to the view through the
// [`decorations` prop](#view.EditorProps.decorations). They come in
// several variantssee the static members of this class for details.
class Decoration {
  constructor(from, to, type) {
    // :: number
    // The start position of the decoration.
    this.from = from;
    // :: number
    // The end position. Will be the same as `from` for [widget
    // decorations](#view.Decoration^widget).
    this.to = to;
    this.type = type;
  }

  copy(from, to) {
    return new Decoration(from, to, this.type)
  }

  eq(other) {
    return this.type.eq(other.type) && this.from == other.from && this.to == other.to
  }

  map(mapping, offset, oldOffset) {
    return this.type.map(mapping, this, offset, oldOffset)
  }

  // :: (number, union<(view: EditorView, getPos: ()  number)  dom.Node, dom.Node>, ?Object)  Decoration
  // Creates a widget decoration, which is a DOM node that's shown in
  // the document at the given position. It is recommended that you
  // delay rendering the widget by passing a function that will be
  // called when the widget is actually drawn in a view, but you can
  // also directly pass a DOM node. `getPos` can be used to find the
  // widget's current document position.
  //
  //   spec::- These options are supported:
  //
  //     side:: ?number
  //     Controls which side of the document position this widget is
  //     associated with. When negative, it is drawn before a cursor
  //     at its position, and content inserted at that position ends
  //     up after the widget. When zero (the default) or positive, the
  //     widget is drawn after the cursor and content inserted there
  //     ends up before the widget.
  //
  //     When there are multiple widgets at a given position, their
  //     `side` values determine the order in which they appear. Those
  //     with lower values appear first. The ordering of widgets with
  //     the same `side` value is unspecified.
  //
  //     When `marks` is null, `side` also determines the marks that
  //     the widget is wrapped inthose of the node before when
  //     negative, those of the node after when positive.
  //
  //     marks:: ?[Mark]
  //     The precise set of marks to draw around the widget.
  //
  //     stopEvent:: ?(event: dom.Event)  bool
  //     Can be used to control which DOM events, when they bubble out
  //     of this widget, the editor view should ignore.
  //
  //     key:: ?string
  //     When comparing decorations of this type (in order to decide
  //     whether it needs to be redrawn), ProseMirror will by default
  //     compare the widget DOM node by identity. If you pass a key,
  //     that key will be compared instead, which can be useful when
  //     you generate decorations on the fly and don't want to store
  //     and reuse DOM nodes. Make sure that any widgets with the same
  //     key are interchangeableif widgets differ in, for example,
  //     the behavior of some event handler, they should get
  //     different keys.
  static widget(pos, toDOM, spec) {
    return new Decoration(pos, pos, new WidgetType(toDOM, spec))
  }

  // :: (number, number, DecorationAttrs, ?Object)  Decoration
  // Creates an inline decoration, which adds the given attributes to
  // each inline node between `from` and `to`.
  //
  //   spec::- These options are recognized:
  //
  //     inclusiveStart:: ?bool
  //     Determines how the left side of the decoration is
  //     [mapped](#transform.Position_Mapping) when content is
  //     inserted directly at that position. By default, the decoration
  //     won't include the new content, but you can set this to `true`
  //     to make it inclusive.
  //
  //     inclusiveEnd:: ?bool
  //     Determines how the right side of the decoration is mapped.
  //     See
  //     [`inclusiveStart`](#view.Decoration^inline^spec.inclusiveStart).
  static inline(from, to, attrs, spec) {
    return new Decoration(from, to, new InlineType(attrs, spec))
  }

  // :: (number, number, DecorationAttrs, ?Object)  Decoration
  // Creates a node decoration. `from` and `to` should point precisely
  // before and after a node in the document. That node, and only that
  // node, will receive the given attributes.
  static node(from, to, attrs, spec) {
    return new Decoration(from, to, new NodeType$1(attrs, spec))
  }

  // :: Object
  // The spec provided when creating this decoration. Can be useful
  // if you've stored extra information in that object.
  get spec() { return this.type.spec }
}

// DecorationAttrs:: interface
// A set of attributes to add to a decorated node. Most properties
// simply directly correspond to DOM attributes of the same name,
// which will be set to the property's value. These are exceptions:
//
//   class:: ?string
//   A CSS class name or a space-separated set of class names to be
//   _added_ to the classes that the node already had.
//
//   style:: ?string
//   A string of CSS to be _added_ to the node's existing `style` property.
//
//   nodeName:: ?string
//   When non-null, the target node is wrapped in a DOM element of
//   this type (and the other attributes are applied to this element).

const none = [], noSpec = {};

// ::- A collection of [decorations](#view.Decoration), organized in
// such a way that the drawing algorithm can efficiently use and
// compare them. This is a persistent data structureit is not
// modified, updates create a new value.
class DecorationSet {
  constructor(local, children) {
    this.local = local && local.length ? local : none;
    this.children = children && children.length ? children : none;
  }

  // :: (Node, [Decoration])  DecorationSet
  // Create a set of decorations, using the structure of the given
  // document.
  static create(doc, decorations) {
    return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty
  }

  // :: (?number, ?number, ?(spec: Object)  bool)  [Decoration]
  // Find all decorations in this set which touch the given range
  // (including decorations that start or end directly at the
  // boundaries) and match the given predicate on their spec. When
  // `start` and `end` are omitted, all decorations in the set are
  // considered. When `predicate` isn't given, all decorations are
  // asssumed to match.
  find(start, end, predicate) {
    let result = [];
    this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
    return result
  }

  findInner(start, end, result, offset, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset, span.to + offset));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end && this.children[i + 1] > start) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
      }
    }
  }

  // :: (Mapping, Node, ?Object)  DecorationSet
  // Map the set of decorations in response to a change in the
  // document.
  //
  //   options::- An optional set of options.
  //
  //     onRemove:: ?(decorationSpec: Object)
  //     When given, this function will be called for each decoration
  //     that gets dropped as a result of the mapping, passing the
  //     spec of that decoration.
  map(mapping, doc, options) {
    if (this == empty || mapping.maps.length == 0) return this
    return this.mapInner(mapping, doc, 0, 0, options || noSpec)
  }

  mapInner(mapping, node, offset, oldOffset, options) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset, oldOffset);
      if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove) options.onRemove(this.local[i].spec);
    }

    if (this.children.length)
      return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options)
    else
      return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty
  }

  // :: (Node, [Decoration])  DecorationSet
  // Add the given array of decorations to the ones in the set,
  // producing a new set. Needs access to the current document to
  // create the appropriate tree structure.
  add(doc, decorations) {
    if (!decorations.length) return this
    if (this == empty) return DecorationSet.create(doc, decorations)
    return this.addInner(doc, decorations, 0)
  }

  addInner(doc, decorations, offset) {
    let children, childIndex = 0;
    doc.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset, found;
      if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return

      if (!children) children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset) childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });

    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local,
                             children || this.children)
  }

  // :: ([Decoration])  DecorationSet
  // Create a new set that contains the decorations in this set, minus
  // the ones in the given array.
  remove(decorations) {
    if (decorations.length == 0 || this == empty) return this
    return this.removeInner(decorations, 0)
  }

  removeInner(decorations, offset) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found, from = children[i] + offset, to = children[i + 1] + offset;
      for (let j = 0, span; j < decorations.length; j++) if (span = decorations[j]) {
        if (span.from > from && span.to < to) {
          decorations[j] = null
          ;(found || (found = [])).push(span);
        }
      }
      if (!found) continue
      if (children == this.children) children = this.children.slice();
      let removed = children[i + 2].removeInner(found, from + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) for (let i = 0, span; i < decorations.length; i++) if (span = decorations[i]) {
      for (let j = 0; j < local.length; j++) if (local[j].type.eq(span.type)) {
        if (local == this.local) local = this.local.slice();
        local.splice(j--, 1);
      }
    }
    if (children == this.children && local == this.local) return this
    return local.length || children.length ? new DecorationSet(local, children) : empty
  }

  forChild(offset, node) {
    if (this == empty) return this
    if (node.isLeaf) return DecorationSet.empty

    let child, local;
    for (let i = 0; i < this.children.length; i += 3) if (this.children[i] >= offset) {
      if (this.children[i] == offset) child = this.children[i + 2];
      break
    }
    let start = offset + 1, end = start + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {
        let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
        if (from < to) (local || (local = [])).push(dec.copy(from, to));
      }
    }
    if (local) {
      let localSet = new DecorationSet(local.sort(byPos));
      return child ? new DecorationGroup([localSet, child]) : localSet
    }
    return child || empty
  }

  eq(other) {
    if (this == other) return true
    if (!(other instanceof DecorationSet) ||
        this.local.length != other.local.length ||
        this.children.length != other.children.length) return false
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i])) return false
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] ||
          this.children[i + 1] != other.children[i + 1] ||
          !this.children[i + 2].eq(other.children[i + 2])) return false
    return true
  }

  locals(node) {
    return removeOverlap(this.localsInner(node))
  }

  localsInner(node) {
    if (this == empty) return none
    if (node.inlineContent || !this.local.some(InlineType.is)) return this.local
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result
  }
}

const empty = new DecorationSet();

// :: DecorationSet
// The empty set of decorations.
DecorationSet.empty = empty;

DecorationSet.removeOverlap = removeOverlap;

// :- An abstraction that allows the code dealing with decorations to
// treat multiple DecorationSet objects as if it were a single object
// with (a subset of) the same interface.
class DecorationGroup {
  constructor(members) {
    this.members = members;
  }

  forChild(offset, child) {
    if (child.isLeaf) return DecorationSet.empty
    let found = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset, child);
      if (result == empty) continue
      if (result instanceof DecorationGroup) found = found.concat(result.members);
      else found.push(result);
    }
    return DecorationGroup.from(found)
  }

  eq(other) {
    if (!(other instanceof DecorationGroup) ||
        other.members.length != this.members.length) return false
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i])) return false
    return true
  }

  locals(node) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length) continue
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++) result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none
  }

  // : ([DecorationSet])  union<DecorationSet, DecorationGroup>
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0: return empty
      case 1: return members[0]
      default: return new DecorationGroup(members)
    }
  }
}

function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
  let children = oldChildren.slice();

  // Mark the children that are directly touched by changes, and
  // move those that are after the changes.
  let shift = (oldStart, oldEnd, newStart, newEnd) => {
    for (let i = 0; i < children.length; i += 3) {
      let end = children[i + 1], dSize;
      if (end == -1 || oldStart > end + oldOffset) continue
      if (oldEnd >= children[i] + oldOffset) {
        children[i + 1] = -1;
      } else if (dSize = (newEnd - newStart) - (oldEnd - oldStart) + (oldOffset - offset)) {
        children[i] += dSize;
        children[i + 1] += dSize;
      }
    }
  };
  for (let i = 0; i < mapping.maps.length; i++) mapping.maps[i].forEach(shift);

  // Find the child nodes that still correspond to a single node,
  // recursively call mapInner on them and update their positions.
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3) if (children[i + 1] == -1) { // Touched nodes
    let from = mapping.map(children[i] + oldOffset), fromLocal = from - offset;
    if (fromLocal < 0 || fromLocal >= node.content.size) {
      mustRebuild = true;
      continue
    }
    // Must read oldChildren because children was tagged with -1
    let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;
    let {index, offset: childOffset} = node.content.findIndex(fromLocal);
    let childNode = node.maybeChild(index);
    if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
      let mapped = children[i + 2].mapInner(mapping, childNode, from + 1, children[i] + oldOffset + 1, options);
      if (mapped != empty) {
        children[i] = fromLocal;
        children[i + 1] = toLocal;
        children[i + 2] = mapped;
      } else {
        children[i + 1] = -2;
        mustRebuild = true;
      }
    } else {
      mustRebuild = true;
    }
  }

  // Remaining children must be collected and rebuilt into the appropriate structure
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping,
                                                       offset, oldOffset, options);
    let built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3) if (children[i + 1] < 0) {
      children.splice(i, 3);
      i -= 3;
    }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from = built.children[i];
      while (j < children.length && children[j] < from) j += 3;
      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }

  return new DecorationSet(newLocal && newLocal.sort(byPos), children)
}

function moveSpans(spans, offset) {
  if (!offset || !spans.length) return spans
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset, span.to + offset, span.type));
  }
  return result
}

function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
  // Gather all decorations from the remaining marked children
  function gather(set, oldOffset) {
    for (let i = 0; i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset, oldOffset);
      if (mapped) decorations.push(mapped);
      else if (options.onRemove) options.onRemove(set.local[i].spec);
    }
    for (let i = 0; i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset + 1);
  }
  for (let i = 0; i < children.length; i += 3) if (children[i + 1] == -1)
    gather(children[i + 2], oldChildren[i] + oldOffset + 1);

  return decorations
}

function takeSpansForNode(spans, node, offset) {
  if (node.isLeaf) return null
  let end = offset + node.nodeSize, found = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset && span.to < end) {
(found || (found = [])).push(span);
      spans[i] = null;
    }
  }
  return found
}

function withoutNulls(array) {
  let result = [];
  for (let i = 0; i < array.length; i++)
    if (array[i] != null) result.push(array[i]);
  return result
}

// : ([Decoration], Node, number)  DecorationSet
// Build up a tree that corresponds to a set of decorations. `offset`
// is a base offset that should be subtractet from the `from` and `to`
// positions in the spans (so that we don't have to allocate new spans
// for recursive calls).
function buildTree(spans, node, offset, options) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found = takeSpansForNode(spans, childNode, localStart + offset);
    if (found) {
      hasNulls = true;
      let subtree = buildTree(found, childNode, offset + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
  for (let i = 0; i < locals.length; i++) if (!locals[i].type.valid(node, locals[i])) {
    if (options.onRemove) options.onRemove(locals[i].spec);
    locals.splice(i--, 1);
  }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty
}

// : (Decoration, Decoration)  number
// Used to sort decorations so that ones with a low start position
// come first, and within a set with the same start position, those
// with an smaller end position come first.
function byPos(a, b) {
  return a.from - b.from || a.to - b.to
}

// : ([Decoration])  [Decoration]
// Scan a sorted array of decorations for partially overlapping spans,
// and split those so that only fully overlapping spans are left (to
// make subsequent rendering easier). Will return the input array if
// no partially overlapping spans are found (the common case).
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to) for (let j = i + 1; j < working.length; j++) {
      let next = working[j];
      if (next.from == span.from) {
        if (next.to != span.to) {
          if (working == spans) working = spans.slice();
          // Followed by a partially overlapping larger span. Split that
          // span.
          working[j] = next.copy(next.from, span.to);
          insertAhead(working, j + 1, next.copy(span.to, next.to));
        }
        continue
      } else {
        if (next.from < span.to) {
          if (working == spans) working = spans.slice();
          // The end of this one overlaps with a subsequent span. Split
          // this one.
          working[i] = span.copy(span.from, next.from);
          insertAhead(working, j, span.copy(next.from, span.to));
        }
        break
      }
    }
  }
  return working
}

function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0) i++;
  array.splice(i, 0, deco);
}

// : (EditorView)  union<DecorationSet, DecorationGroup>
// Get the decorations associated with the current props of a view.
function viewDecorations(view) {
  let found = [];
  view.someProp("decorations", f => {
    let result = f(view.state);
    if (result && result != empty) found.push(result);
  });
  if (view.cursorWrapper)
    found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found)
}

// ::- An editor view manages the DOM structure that represents an
// editable document. Its state and behavior are determined by its
// [props](#view.DirectEditorProps).
class EditorView {
  // :: (?union<dom.Node, (dom.Node), {mount: dom.Node}>, DirectEditorProps)
  // Create a view. `place` may be a DOM node that the editor should
  // be appended to, a function that will place it into the document,
  // or an object whose `mount` property holds the node to use as the
  // document container. If it is `null`, the editor will not be added
  // to the document.
  constructor(place, props) {
    this._props = props;
    // :: EditorState
    // The view's current [state](#state.EditorState).
    this.state = props.state;

    this.dispatch = this.dispatch.bind(this);

    this._root = null;
    this.focused = false;

    // :: dom.Element
    // An editable DOM node containing the document. (You probably
    // should not directly interfere with its content.)
    this.dom = (place && place.mount) || document.createElement("div");
    if (place) {
      if (place.appendChild) place.appendChild(this.dom);
      else if (place.apply) place(this.dom);
      else if (place.mount) this.mounted = true;
    }

    this.editable = getEditable(this);
    this.markCursor = null;
    this.cursorWrapper = null;
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);

    this.lastSelectedViewDesc = null;
    // :: ?{slice: Slice, move: bool}
    // When editor content is being dragged, this object contains
    // information about the dragged slice and whether it is being
    // copied or moved. At any other time, it is null.
    this.dragging = null;

    initInput(this);

    this.pluginViews = [];
    this.updatePluginViews();
  }

  // composing:: boolean
  // Holds `true` when a
  // [composition](https://developer.mozilla.org/en-US/docs/Mozilla/IME_handling_guide)
  // is active.

  // :: DirectEditorProps
  // The view's current [props](#view.EditorProps).
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev) this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props
  }

  // :: (DirectEditorProps)
  // Update the view's props. Will immediately cause an update to
  // the DOM.
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this);
    this._props = props;
    this.updateStateInner(props.state, true);
  }

  // :: (DirectEditorProps)
  // Update the view by updating existing props object with the object
  // given as argument. Equivalent to `view.update(Object.assign({},
  // view.props, props))`.
  setProps(props) {
    let updated = {};
    for (let name in this._props) updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props) updated[name] = props[name];
    this.update(updated);
  }

  // :: (EditorState)
  // Update the editor's `state` prop, without touching any of the
  // other props.
  updateState(state) {
    this.updateStateInner(state, this.state.plugins != state.plugins);
  }

  updateStateInner(state, reconfigured) {
    let prev = this.state, redraw = false;
    this.state = state;
    if (reconfigured) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
      ensureListeners(this);
    }

    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);

    let scroll = reconfigured ? "reset"
        : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    let updateSel = updateDoc || !state.selection.eq(prev.selection);
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);

    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = false;
      if (updateDoc) {
        // Work around an issue in Chrome where changing the DOM
        // around the active selection puts it into a broken state
        // where the thing the user sees differs from the selection
        // reported by the Selection object (#710)
        let startSelContext = result.chrome && selectionContext(this.root);
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (startSelContext)
          forceSelUpdate = !this.composing && needChromeSelectionForce(startSelContext, this.root);
      }
      // Work around for an issue where an update arriving right between
      // a DOM selection change and the "selectionchange" event for it
      // can cause a spurious DOM selection update, disrupting mouse
      // drag selection.
      if (forceSelUpdate ||
          !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {
        selectionToDOM(this, false, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }

    this.updatePluginViews(prev);

    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      let startDOM = this.root.getSelection().focusNode;
      if (this.someProp("handleScrollToSelection", f => f(this)))
        ; // Handled
      else if (state.selection instanceof NodeSelection)
        scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM);
      else
        scrollRectIntoView(this, this.coordsAtPos(state.selection.head), startDOM);
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }

  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop()) if (view.destroy) view.destroy();
  }

  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins) {
      this.destroyPluginViews();
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update) pluginView.update(this, prevState);
      }
    }
  }

  // :: (string, ?(prop: *)  *)  *
  // Goes over the values of a prop, first those provided directly,
  // then those from plugins (in order), and calls `f` every time a
  // non-undefined value is found. When `f` returns a truthy value,
  // that is immediately returned. When `f` isn't provided, it is
  // treated as the identity function (the prop value is returned
  // directly).
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop)) return value
    let plugins = this.state.plugins;
    if (plugins) for (let i = 0; i < plugins.length; i++) {
      let prop = plugins[i].props[propName];
      if (prop != null && (value = f ? f(prop) : prop)) return value
    }
  }

  // :: ()  bool
  // Query whether the view has focus.
  hasFocus() {
    return this.root.activeElement == this.dom
  }

  // :: ()
  // Focus the editor.
  focus() {
    this.domObserver.stop();
    selectionToDOM(this, true);
    if (this.editable) {
      if (this.dom.setActive) this.dom.setActive(); // for IE
      else this.dom.focus({preventScroll: true});
    }
    this.domObserver.start();
  }

  // :: union<dom.Document, dom.DocumentFragment>
  // Get the document root in which the editor exists. This will
  // usually be the top-level `document`, but might be a [shadow
  // DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  // root if the editor is inside one.
  get root() {
    let cached = this._root;
    if (cached == null) for (let search = this.dom.parentNode; search; search = search.parentNode) {
      if (search.nodeType == 9 || (search.nodeType == 11 && search.host))
        return this._root = search
    }
    return cached || document
  }

  // :: ({left: number, top: number})  ?{pos: number, inside: number}
  // Given a pair of viewport coordinates, return the document
  // position that corresponds to them. May return null if the given
  // coordinates aren't inside of the editor. When an object is
  // returned, its `pos` property is the position nearest to the
  // coordinates, and its `inside` property holds the position of the
  // inner node that the position falls inside of, or -1 if it is at
  // the top level, not in any node.
  posAtCoords(coords) {
    return posAtCoords(this, coords)
  }

  // :: (number)  {left: number, right: number, top: number, bottom: number}
  // Returns the viewport rectangle at a given document position. `left`
  // and `right` will be the same number, as this returns a flat
  // cursor-ish rectangle.
  coordsAtPos(pos) {
    return coordsAtPos(this, pos)
  }

  // :: (number)  {node: dom.Node, offset: number}
  // Find the DOM position that corresponds to the given document
  // position. Note that you should **not** mutate the editor's
  // internal DOM, only inspect it (and even that is usually not
  // necessary).
  domAtPos(pos) {
    return this.docView.domFromPos(pos)
  }

  // :: (number)  ?dom.Node
  // Find the DOM node that represents the document node after the
  // given position. May return `null` when the position doesn't point
  // in front of a node or if the node is inside an opaque node view.
  //
  // This is intended to be able to call things like
  // `getBoundingClientRect` on that DOM node. Do **not** mutate the
  // editor DOM directly, or add styling this way, since that will be
  // immediately overriden by the editor as it redraws the node.
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null
  }

  // :: (dom.Node, number, ?number)  number
  // Find the document position that corresponds to a given DOM
  // position. (Whenever possible, it is preferable to inspect the
  // document structure directly, rather than poking around in the
  // DOM, but sometimesfor example when interpreting an event
  // targetyou don't have a choice.)
  //
  // The `bias` parameter can be used to influence which side of a DOM
  // node to use when the position is inside a leaf node.
  posAtDOM(node, offset, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset, bias);
    if (pos == null) throw new RangeError("DOM position not inside the editor")
    return pos
  }

  // :: (union<"up", "down", "left", "right", "forward", "backward">, ?EditorState)  bool
  // Find out whether the selection is at the end of a textblock when
  // moving in a given direction. When, for example, given `"left"`,
  // it will return true if moving left from the current cursor
  // position would leave that position's parent textblock. Will apply
  // to the view's current state by default, but it is possible to
  // pass a different state.
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir)
  }

  // :: ()
  // Removes the editor from the DOM and destroys all [node
  // views](#view.NodeView).
  destroy() {
    if (!this.docView) return
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
  }

  // Used for testing.
  dispatchEvent(event) {
    return dispatchEvent(this, event)
  }

  // :: (Transaction)
  // Dispatch a transaction. Will call
  // [`dispatchTransaction`](#view.DirectEditorProps.dispatchTransaction)
  // when given, and otherwise defaults to applying the transaction to
  // the current state and calling
  // [`updateState`](#view.EditorView.updateState) with the result.
  // This method is bound to the view instance, so that it can be
  // easily passed around.
  dispatch(tr) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction) dispatchTransaction.call(this, tr);
    else this.updateState(this.state.apply(tr));
  }
}

function computeDocDeco(view) {
  let attrs = Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);

  view.someProp("attributes", value => {
    if (typeof value == "function") value = value(view.state);
    if (value) for (let attr in value) {
      if (attr == "class")
        attrs.class += " " + value[attr];
      else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
        attrs[attr] = String(value[attr]);
    }
  });

  return [Decoration.node(0, view.state.doc.content.size, attrs)]
}

function updateCursorWrapper(view) {
  let {$head, $anchor, visible} = view.state.selection;
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.setAttribute("mark-placeholder", "true");
    view.cursorWrapper = {dom, deco: Decoration.widget($head.pos, dom, {raw: true, marks: view.markCursor})};
  } else if (visible || $head.pos != $anchor.pos) {
    view.cursorWrapper = null;
  } else {
    let dom;
    if (!view.cursorWrapper || view.cursorWrapper.dom.childNodes.length) {
      dom = document.createElement("div");
      dom.style.position = "absolute";
      dom.style.left = "-100000px";
    } else if (view.cursorWrapper.deco.pos != $head.pos) {
      dom = view.cursorWrapper.dom;
    }
    if (dom)
      view.cursorWrapper = {dom, deco: Decoration.widget($head.pos, dom, {raw: true})};
  }
}

function getEditable(view) {
  return !view.someProp("editable", value => value(view.state) === false)
}

function selectionContext(root) {
  let {focusOffset: offset, focusNode: node} = root.getSelection();
  if (!node || node.nodeType == 3) return null
  return [node, offset,
          node.nodeType == 1 ? node.childNodes[offset - 1] : null,
          node.nodeType == 1 ? node.childNodes[offset] : null]
}

function needChromeSelectionForce(context, root) {
  let newContext = selectionContext(root);
  if (!newContext || newContext[0].nodeType == 3) return false
  for (let i = 0; i < context.length; i++) if (newContext[i] != context[i]) return true
  return false
}

function buildNodeViews(view) {
  let result = {};
  view.someProp("nodeViews", obj => {
    for (let prop in obj) if (!Object.prototype.hasOwnProperty.call(result, prop))
      result[prop] = obj[prop];
  });
  return result
}

function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop]) return true
    nA++;
  }
  for (let _ in b) nB++;
  return nA != nB
}

// EditorProps:: interface
//
// Props are configuration values that can be passed to an editor view
// or included in a plugin. This interface lists the supported props.
//
// The various event-handling functions may all return `true` to
// indicate that they handled the given event. The view will then take
// care to call `preventDefault` on the event, except with
// `handleDOMEvents`, where the handler itself is responsible for that.
//
// How a prop is resolved depends on the prop. Handler functions are
// called one at a time, starting with the base props and then
// searching through the plugins (in order of appearance) until one of
// them returns true. For some props, the first plugin that yields a
// value gets precedence.
//
//   handleDOMEvents:: ?Object<(view: EditorView, event: dom.Event)  bool>
//   Can be an object mapping DOM event type names to functions that
//   handle them. Such functions will be called before any handling
//   ProseMirror does of events fired on the editable DOM element.
//   Contrary to the other event handling props, when returning true
//   from such a function, you are responsible for calling
//   `preventDefault` yourself (or not, if you want to allow the
//   default behavior).
//
//   handleKeyDown:: ?(view: EditorView, event: dom.KeyboardEvent)  bool
//   Called when the editor receives a `keydown` event.
//
//   handleKeyPress:: ?(view: EditorView, event: dom.KeyboardEvent)  bool
//   Handler for `keypress` events.
//
//   handleTextInput:: ?(view: EditorView, from: number, to: number, text: string)  bool
//   Whenever the user directly input text, this handler is called
//   before the input is applied. If it returns `true`, the default
//   behavior of actually inserting the text is suppressed.
//
//   handleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool)  bool
//   Called for each node around a click, from the inside out. The
//   `direct` flag will be true for the inner node.
//
//   handleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent)  bool
//   Called when the editor is clicked, after `handleClickOn` handlers
//   have been called.
//
//   handleDoubleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool)  bool
//   Called for each node around a double click.
//
//   handleDoubleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent)  bool
//   Called when the editor is double-clicked, after `handleDoubleClickOn`.
//
//   handleTripleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool)  bool
//   Called for each node around a triple click.
//
//   handleTripleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent)  bool
//   Called when the editor is triple-clicked, after `handleTripleClickOn`.
//
//   handlePaste:: ?(view: EditorView, event: dom.Event, slice: Slice)  bool
//   Can be used to override the behavior of pasting. `slice` is the
//   pasted content parsed by the editor, but you can directly access
//   the event to get at the raw content.
//
//   handleDrop:: ?(view: EditorView, event: dom.Event, slice: Slice, moved: bool)  bool
//   Called when something is dropped on the editor. `moved` will be
//   true if this drop moves from the current selection (which should
//   thus be deleted).
//
//   handleScrollToSelection:: ?(view: EditorView)  bool
//   Called when the view, after updating its state, tries to scroll
//   the selection into view. A handler function may return false to
//   indicate that it did not handle the scrolling and further
//   handlers or the default behavior should be tried.
//
//   createSelectionBetween:: ?(view: EditorView, anchor: ResolvedPos, head: ResolvedPos)  ?Selection
//   Can be used to override the way a selection is created when
//   reading a DOM selection between the given anchor and head.
//
//   domParser:: ?DOMParser
//   The [parser](#model.DOMParser) to use when reading editor changes
//   from the DOM. Defaults to calling
//   [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) on the
//   editor's schema.
//
//   transformPastedHTML:: ?(html: string)  string
//   Can be used to transform pasted HTML text, _before_ it is parsed,
//   for example to clean it up.
//
//   clipboardParser:: ?DOMParser
//   The [parser](#model.DOMParser) to use when reading content from
//   the clipboard. When not given, the value of the
//   [`domParser`](#view.EditorProps.domParser) prop is used.
//
//   transformPastedText:: ?(text: string)  string
//   Transform pasted plain text.
//
//   clipboardTextParser:: ?(text: string, $context: ResolvedPos)  Slice
//   A function to parse text from the clipboard into a document
//   slice. Called after
//   [`transformPastedText`](#view.EditorProps.transformPastedText).
//   The default behavior is to split the text into lines, wrap them
//   in `<p>` tags, and call
//   [`clipboardParser`](#view.EditorProps.clipboardParser) on it.
//
//   transformPasted:: ?(Slice)  Slice
//   Can be used to transform pasted content before it is applied to
//   the document.
//
//   nodeViews:: ?Object<(node: Node, view: EditorView, getPos: ()  number, decorations: [Decoration])  NodeView>
//   Allows you to pass custom rendering and behavior logic for nodes
//   and marks. Should map node and mark names to constructor
//   functions that produce a [`NodeView`](#view.NodeView) object
//   implementing the node's display behavior. For nodes, the third
//   argument `getPos` is a function that can be called to get the
//   node's current position, which can be useful when creating
//   transactions to update it. For marks, the third argument is a
//   boolean that indicates whether the mark's content is inline.
//
//   `decorations` is an array of node or inline decorations that are
//   active around the node. They are automatically drawn in the
//   normal way, and you will usually just want to ignore this, but
//   they can also be used as a way to provide context information to
//   the node view without adding it to the document itself.
//
//   clipboardSerializer:: ?DOMSerializer
//   The DOM serializer to use when putting content onto the
//   clipboard. If not given, the result of
//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)
//   will be used.
//
//   clipboardTextSerializer:: ?(Slice)  string
//   A function that will be called to get the text for the current
//   selection when copying text to the clipboard. By default, the
//   editor will use [`textBetween`](#model.Node.textBetween) on the
//   selected range.
//
//   decorations:: ?(state: EditorState)  ?DecorationSet
//   A set of [document decorations](#view.Decoration) to show in the
//   view.
//
//   editable:: ?(state: EditorState)  bool
//   When this returns false, the content of the view is not directly
//   editable.
//
//   attributes:: ?union<Object<string>, (EditorState)  ?Object<string>>
//   Control the DOM attributes of the editable element. May be either
//   an object or a function going from an editor state to an object.
//   By default, the element will get a class `"ProseMirror"`, and
//   will have its `contentEditable` attribute determined by the
//   [`editable` prop](#view.EditorProps.editable). Additional classes
//   provided here will be added to the class. For other attributes,
//   the value provided first (as in
//   [`someProp`](#view.EditorView.someProp)) will be used.
//
//   scrollThreshold:: ?union<number, {top: number, right: number, bottom: number, left: number}>
//   Determines the distance (in pixels) between the cursor and the
//   end of the visible viewport at which point, when scrolling the
//   cursor into view, scrolling takes place. Defaults to 0.
//
//   scrollMargin:: ?union<number, {top: number, right: number, bottom: number, left: number}>
//   Determines the extra space (in pixels) that is left above or
//   below the cursor when it is scrolled into view. Defaults to 5.

// DirectEditorProps:: interface extends EditorProps
//
// The props object given directly to the editor view supports two
// fields that can't be used in plugins:
//
//   state:: EditorState
//   The current state of the editor.
//
//   dispatchTransaction:: ?(tr: Transaction)
//   The callback over which to send transactions (state updates)
//   produced by the view. If you specify this, you probably want to
//   make sure this ends up calling the view's
//   [`updateState`](#view.EditorView.updateState) method with a new
//   state that has the transaction
//   [applied](#state.EditorState.apply). The callback will be bound to have
//   the view instance as its `this` binding.

// ::- Gap cursor selections are represented using this class. Its
// `$anchor` and `$head` properties both point at the cursor position.
class GapCursor extends Selection {
  // : (ResolvedPos)
  constructor($pos) {
    super($pos, $pos);
  }

  map(doc, mapping) {
    let $pos = doc.resolve(mapping.map(this.head));
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos)
  }

  content() { return Slice.empty }

  eq(other) {
    return other instanceof GapCursor && other.head == this.head
  }

  toJSON() {
    return {type: "gapcursor", pos: this.head}
  }

  static fromJSON(doc, json) {
    if (typeof json.pos != "number") throw new RangeError("Invalid input for GapCursor.fromJSON")
    return new GapCursor(doc.resolve(json.pos))
  }

  getBookmark() { return new GapBookmark(this.anchor) }

  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false
    let override = parent.type.spec.allowGapCursor;
    if (override != null) return override
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock
  }

  static findFrom($pos, dir, mustMove) {
    if (!mustMove && GapCursor.valid($pos)) return $pos

    let pos = $pos.pos, next = null;
    // Scan up from this position
    for (let d = $pos.depth;; d--) {
      let parent = $pos.node(d);
      if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
        next = parent.maybeChild(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
        break
      } else if (d == 0) {
        return null
      }
      pos += dir;
      let $cur = $pos.doc.resolve(pos);
      if (GapCursor.valid($cur)) return $cur
    }

    // And then down into the next node
    for (;;) {
      next = dir > 0 ? next.firstChild : next.lastChild;
      if (!next) break
      pos += dir;
      let $cur = $pos.doc.resolve(pos);
      if (GapCursor.valid($cur)) return $cur
    }

    return null
  }
}

GapCursor.prototype.visible = false;

Selection.jsonID("gapcursor", GapCursor);

class GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new GapBookmark(mapping.map(this.pos))
  }
  resolve(doc) {
    let $pos = doc.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos)
  }
}

function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.index(d);
    // At the start of this parent, look at next one
    if (index == 0) continue
    // See if the node before (or its first ancestor) is closed
    for (let before = $pos.node(d).child(index - 1);; before = before.lastChild) {
      if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating) return true
      if (before.inlineContent) return false
    }
  }
  // Hit start of document
  return true
}

function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.indexAfter(d), parent = $pos.node(d);
    if (index == parent.childCount) continue
    for (let after = parent.child(index);; after = after.firstChild) {
      if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating) return true
      if (after.inlineContent) return false
    }
  }
  return true
}

// :: ()  Plugin
// Create a gap cursor plugin. When enabled, this will capture clicks
// near and arrow-key-motion past places that don't have a normally
// selectable position nearby, and create a gap cursor selection for
// them. The cursor is drawn as an element with class
// `ProseMirror-gapcursor`. You can either include
// `style/gapcursor.css` from the package's directory or add your own
// styles to make it visible.
const gapCursor = function() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,

      createSelectionBetween(_view, $anchor, $head) {
        if ($anchor.pos == $head.pos && GapCursor.valid($head)) return new GapCursor($head)
      },

      handleClick,
      handleKeyDown
    }
  })
};

const handleKeyDown = keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});

function arrow(axis, dir) {
  let dirStr = axis == "vert" ? (dir > 0 ? "down" : "up") : (dir > 0 ? "right" : "left");
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr)) return false
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findFrom($start, dir, mustMove);
    if (!$found) return false
    if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)));
    return true
  }
}

function handleClick(view, pos, event) {
  if (view.someProp("editable", editable => editable(view.state) === false)) return false
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos)) return false
  let {inside} = view.posAtCoords({left: event.clientX, top: event.clientY});
  if (inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(inside))) return false
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true
}

function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor)) return null
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, {key: "gapcursor"})])
}

//================================================================================
// Apogee component
//================================================================================

class ApogeeComponentView {
  constructor(node, view, getPos, pageDisplay) {
    // We'll need these later
    this.node = node;
    this.view = view;
    this.getPos = getPos;
    this.pageDisplay = pageDisplay;

    // The node's representation in the editor
    this.dom = document.createElement("div");
    this.dom.className = "page-apogee-comp";

    this.contentDiv = document.createElement("div");
    this.contentDiv.className = "page-apogee-comp-container";
    this.dom.appendChild(this.contentDiv);

    this.setViewDataFromNode();

  }

  selectNode() {
    this.dom.classList.add("ProseMirror-selectednode");
    //if (!this.innerView) this.open()
  }

  deselectNode() {
    this.dom.classList.remove("ProseMirror-selectednode");
    //if (this.innerView) this.close()
  }

  setViewDataFromNode() {
    let name = this.node.attrs["name"];
    let memberId = this.node.attrs["memberId"];

    //temporary solution to a problem: we will hold an ID during a name
    //change so we don't lose track of an object.
    //we will not display data in this time.
    let childComponentDisplay;
    if (name) {
      childComponentDisplay = this.pageDisplay.getChildComponentDisplay(name);

    }

    if (childComponentDisplay) {
      var displayElement = childComponentDisplay.getElement();
      this.contentDiv.appendChild(displayElement);
    }
    else {
      this.contentDiv.innerHTML = "Component not found: " + name;
    }

  }

  //===========================================================
  //figrue out what I want here
  getJsonData() {
    //get the attribute!!!! - this is just a string
    var name = this.node.attrs["name"];
    if (name) stateJson = { name };
    else stateJson = {};
    return stateJson;
  }

  getTextData() {
    //get the json data and make to text
    var data = this.getJsonData();
    var textData;
    if (data == null) textData = "";
    else textData = JSON.stringify(data);
    return textData;
  }
  //end simplified
  //============================================================

  update(node) {
    if (!node.sameMarkup(this.node)) return false
    this.node = node;
    this.setViewDataFromNode();
    return true
  }

  destroy() {
    //    if (this.innerView) this.close()
  }

  stopEvent(event) {
    return true;
  }

  ignoreMutation() { return true }
}

//===========================

function createProseMirrorManager(app,schema) {

  //this is the function return object - the editor manager
  let proseMirror = {};

  //===========================
  //create the toolbar
  //===========================
  let convertToParagraphCommand = (state,dispatch) => convertToNonListBlockType(schema.nodes.paragraph, state, dispatch);
  let convertToH1Command = (state,dispatch) => convertToNonListBlockType(schema.nodes.heading1, state, dispatch);
  let convertToH2Command = (state,dispatch) => convertToNonListBlockType(schema.nodes.heading2, state, dispatch);
  let convertToH3Command = (state,dispatch) => convertToNonListBlockType(schema.nodes.heading3, state, dispatch);
  let convertToH4Command = (state,dispatch) => convertToNonListBlockType(schema.nodes.heading4, state, dispatch);
  let convertToBulletCommand = (state,dispatch) => convertToListBlockType(schema.nodes.bulletList, state, dispatch);
  let convertToNumberedCommand = (state,dispatch) => convertToListBlockType(schema.nodes.numberedList, state, dispatch);
  let indentCommand = (state,dispatch) => indentSelection(state, dispatch);
  let unindentCommand = (state,dispatch) => unindentSelection(state, dispatch);

  //this function determines if the block button is highlighted
  let getBlockIsHighlightedFunction = (nodeType) => {
    return (selectionInfo) => {
      let blockTypes = selectionInfo.blocks.blockTypes;
      return ((blockTypes.length === 1)&&(blockTypes[0] == nodeType));
    }
  };

  //this determines if the list indent buttons are active
  let listIndentIsActive = (selectionInfo) => {
    let blockTypes = selectionInfo.blocks.blockTypes;
    return ((blockTypes.length === 1)&&(blockTypes[0].spec.group == "list"));
  };

  let toolbarItems = [
    new ActionButton(convertToParagraphCommand,getBlockIsHighlightedFunction(schema.nodes.paragraph),null,"Normal","atb_normal_style","Paragraph"),
    new ActionButton(convertToH1Command,getBlockIsHighlightedFunction(schema.nodes.heading1),null,"H1","atb_h1_style","Heading 1"),
    new ActionButton(convertToH2Command,getBlockIsHighlightedFunction(schema.nodes.heading2),null,"H2","atb_h2_style","Heading 2"),
    new ActionButton(convertToH3Command,getBlockIsHighlightedFunction(schema.nodes.heading3),null,"H3","atb_h3_style","Heading 3"),
    new ActionButton(convertToH4Command,getBlockIsHighlightedFunction(schema.nodes.heading4),null,"H4","atb_h4_style","Heading 4"),
    new ActionButton(convertToBulletCommand,getBlockIsHighlightedFunction(schema.nodes.bulletList),null,'\u2022',"atb_ul_style","Bullet List"),
    new ActionButton(convertToNumberedCommand,getBlockIsHighlightedFunction(schema.nodes.numberedList),null,"1.","atb_ol_style","Nubmered List"),
    new ActionButton(indentCommand, null, listIndentIsActive, ">>", "atb_lindent_style", "Indent List"),
    new ActionButton(unindentCommand, null, listIndentIsActive, "<<", "atb_lunindent_style", "Unindent List"),
    new MarkToggleItem(schema.marks.bold, null, "B", "atb_bold_style", "Bold"),
    new MarkToggleItem(schema.marks.italic, null, "I", "atb_italic_style", "Italic"),
    new MarkDropdownItem(schema.marks.fontfamily, "fontfamily", [["Sans-serif","Sans-serif"], ["Serif","Serif"], ["Monospace","Monospace"]],"Sans-serif"),
    new MarkDropdownItem(schema.marks.fontsize, "fontsize", [["75%",".75em"], ["100%","1em"], ["150%","1.5em"], ["200%","2em"]],"1em"),
    new MarkDropdownItem(schema.marks.textcolor, "color", [["Black","black"],["Blue","blue"],["Red","red"],["Green","green"],["Yellow","yellow"],["Dark Gray","#202020"],
      ["Gray","#505050"],["light gray","#808080"]],"black"),
    new MarkDropdownItem(schema.marks.highlight, "color", [["None","none"], ["Yellow","yellow"], ["Cyan","cyan"], ["Pink","pink"], ["Green","green"],
      ['Orange',"orange"], ["Red","red"], ["Gray","#a0a0a0"]],"none"),

  ];

  //create the toolbar instance
  let toolbarView = new ApogeeToolbar(toolbarItems);
  proseMirror.editorToolbarElement = toolbarView.dom;

  //create the toolbar plugin - we will reuse the toolbar element here
  let toolbarPlugin = new Plugin({
    view(editorView) {
      toolbarView.setEditorView(editorView);
      return toolbarView;
    }
  });


  //===========================
  //state debug plugin
  //===========================

  let stateCheckPlugin = new Plugin({
    view(editorView) {
      let stateCheck = new StateCheck(editorView);
      return stateCheck;
    }
  });

  //==============================
  // Create the editor
  //==============================

  // function saveState() {
  //   var stateJson = window.view.state.toJSON();
  //   console.log(JSON.stringify(stateJson));
  // }

  // function openState() {
  //   var stateText = prompt("Enter the state json:");
  //   var stateJson = JSON.parse(stateText);
  //   var doc = ProseMirrorNode.fromJSON(schema, stateJson.doc);
  //   var state = createEditorState(doc);
  //   window.view.updateState(state);
  // }

  // function showSelection() {
  //   var selection = window.view.state.selection;
  //   console.log(JSON.stringify(selection));
  // }

  function undo() {
    let commandManager = app.getCommandManager();
    let commandHistory = commandManager.getCommandHistory();
    commandHistory.undo();
  }

  function redo() {
    let commandManager = app.getCommandManager();
    let commandHistory = commandManager.getCommandHistory();
    commandHistory.redo();
  }

  //===============================
  //set up the export functions
  //===============================

  proseMirror.createEditorState = function(document,optionalSelection,optionalStoredMarks) {
    var state = EditorState.create({
      doc: document,
      selection: optionalSelection,
      storedMarks: optionalStoredMarks,
      plugins: [
        getInteractiveNodePlugin(),
        keymap({ "Mod-z": undo, "Mod-y": redo }),
        keymap(baseKeymap),
        gapCursor(),
        toolbarPlugin,
        stateCheckPlugin
      ]
    });
    return state;
  };

  proseMirror.createEditorView = function (containerElement, pageDisplay, editorData) {

    var nodeViews = {};
    nodeViews.apogeeComponent = (node, view, getPos) => new ApogeeComponentView(node, view, getPos, pageDisplay);

    let pageComponentView = pageDisplay.getComponentView();

    var dispatchTransaction = transaction => pageComponentView.applyTransaction(transaction);

    var editorView = new EditorView(containerElement, {
      state: editorData,
      dispatchTransaction: dispatchTransaction,
      nodeViews: nodeViews
    });

    return editorView;

  };



  return proseMirror;

}

//this constant is used (or hopefully not) in correctCreateInfoforRepeatedNames
const MAX_SUFFIX_INDEX = 99999;

/** This is the base class for a parent component (an object that has children),
 * It extends the component class. */
class ParentComponentView extends ComponentView {

    constructor(modelView,component) {
        //base constructor
        super(modelView,component);

        //ccreate the editor manager
        this.editorManager = createProseMirrorManager(modelView.getApp(),component.getSchema());

        this.editorData = null;
        this._loadEditorData(component);
    }

    createTreeDisplay() {
        var treeDisplay = super.createTreeDisplay();
        
        //add any existing children to the tree entry
        var treeEntry = treeDisplay.getTreeEntry();
        var parentFolder = this.component.getParentFolderForChildren();
        var modelView = this.getModelView();
        var modelManager = modelView.getModelManager();

        var childIdMap = parentFolder.getChildIdMap();
        for(var childKey in childIdMap) {
            var childMemberId = childIdMap[childKey];
            var childComponentId = modelManager.getComponentIdByMemberId(childMemberId);
            var childComponentView = modelView.getComponentViewByComponentId(childComponentId);
            if(childComponentView) {
                var childTreeEntry = childComponentView.getTreeEntry();
                treeEntry.addChild(childTreeEntry);
            }
        }
        
        return treeDisplay;
    }
    
    //----------------------
    // Parent Methods
    //----------------------

    /** This brings the child component to the front and takes any other actions
     * to show the child in the open parent. */
    showChild(childComponentView) {
        if(childComponentView.getParentComponentView() != this) return;
        this.selectApogeeNode(childComponentView.getName());
    }

    /** This function adds a fhile componeent to the displays for this parent component. */
    removeChild(childComponent) {
        //remove from tree entry
        var treeEntry = this.getTreeEntry();
        if(treeEntry) {
            var childTreeEntry = childComponent.getTreeEntry();
            if(childTreeEntry) {
                treeEntry.removeChild(childTreeEntry);
            }
        }
        
        //remove child windows - just hide them. They will be deleted in the component
        childComponent.closeComponentDisplay();
    }

    /** This function adds a fhile componeent to the displays for this parent component. */
    addChild(childComponentView) {
        //add the child to the tree entry
        var treeEntry = this.getTreeEntry();
        if(treeEntry) {
            var childTreeEntry = childComponentView.getTreeEntry();
            treeEntry.addChild(childTreeEntry);
        }

        //add child entry for tab
        if(this.tabDisplay) {
            this.tabDisplay.addChild(childComponentView); 
        }
    }

    //==============================
    // TEMP
    //==============================

    /** This overides the super method to first intercept the new document and save the editor data */
    componentUpdated(component) {
        //set the document data
        if(component.isFieldUpdated("document")) {
            this._loadEditorData(component);
        }

        //update the component and its ui elements
        super.componentUpdated(component);
    }

    _loadEditorData(component) {
        let document = component.getDocument();
        let editorStateInfo = component.getEditorStateInfo(true);
        let schema = component.getSchema();

        let selection;
        let storedMarks;
        if(editorStateInfo) {
            //load the saved selection
            let selectionJson = editorStateInfo.selection;
            if(selectionJson) {
                selection = Selection.fromJSON(document,selectionJson);
            }

            //load the saved marks
            let storedMarksJson = editorStateInfo.storedMarks;
            if(storedMarksJson) {
                storedMarks = storedMarksJson.map(markJson => Mark.fromJson(schema,markJson));
            }
        }

        this.editorData = this.editorManager.createEditorState(document,selection,storedMarks);
    }

    //###########################################################################################################
    //start page code
    
    getEditorData() {
        return this.editorData;
    }

    // setEditorData(editorData) {
    //     this.editorData = editorData;
        
    //     //this should be in an event for the change
    //     var tabDisplay = this.getTabDisplay();
    //     if(tabDisplay) {
    //         tabDisplay.updateDocumentData(this.editorData);
    //     }
    // }

    getEditorManager() {
        return this.editorManager;
    }

    //----------------------------------------
    // Editor Command Processing
    //----------------------------------------
    
    /** This method is called to respond to transactions created in the editor. */
    applyTransaction(transaction) {
        
        //console.log("New Transaction:");
        //console.log("Doc changed: " + transaction.docChanged);

        if(transaction.docChanged) {

            //this will hold the resulting command
            let apogeeCommand;

            let initialSelection = this.editorData.selection;
            let initialMarks = this.editorData.marks;

            if(this.transactionUpdatesModel(transaction)) {

                let commandList = [];
                let allDeletedNames = [];

                //record if the transaction sets the selection or markSet
                let finalSelection = transaction.selectionSet ? transaction.selection : null;
                let finalStoredMarks = transaction.storedMarksSet ? transaction.storedMarks : null;

                let workingInitialSelection = initialSelection;
                let workingInitialMarks = initialMarks;

                //process each step, mapping to new steps
                let activeNameMap = this.createActiveNameMap();
                let modifiedTransaction = this.editorData.tr;
                let transactionModified = false;
                transaction.steps.forEach( (oldStep, index) => {

                    let oldStepDoc = transaction.docs[index];
                    let oldStepJson = oldStep.toJSON();

                    //--------------------------------------
                    //process the step for deleted components
                    //--------------------------------------
                    let deleteComponentCommands;
                    let deletedComponentShortNames = this.getStepDeletedComponentShortNames(oldStep,oldStepDoc);
                    if(deletedComponentShortNames.length > 0) {
                        //update active name map
                        this.updateActiveNameMapForDelete(activeNameMap,deletedComponentShortNames);

                        //get delete commands
                        deleteComponentCommands = this.createDeleteComponentCommands(deletedComponentShortNames);

                        //save the deleted names so we can warn the user about the delete
                        allDeletedNames = allDeletedNames.concat(deletedComponentShortNames);
                    }

                    //--------------------------------------
                    //process the step for any added components including potentially modifying the slice
                    //--------------------------------------
                    let createComponentCommands;
                    let { newSliceContentJson, createdComponentInfos } = this.processForStepComponentCreateCommands(oldStep,oldStepJson,activeNameMap);
                    if(createdComponentInfos.length > 0) {
                        //get the create commands
                        createComponentCommands = this.createCreateComponentCommands(createdComponentInfos);

                        //perhaps confusingly, the activeNameMap is updated in place in the above function so we don't have to 
                        //do it here.
                    }

                    //--------------------------------------
                    // Update the new transaction and commands
                    //--------------------------------------
                    if((deleteComponentCommands)||(createComponentCommands)) {
                        //we want to modify the step and insert the delete and/or create component commands

                        //----------------------------------
                        //create the remove step (if needed)
                        //-----------------------------------
                        let removeStep = this.createRemoveStep(oldStepJson);
                        if(removeStep) {
                            modifiedTransaction.step(removeStep);
                            transactionModified = true;
                        }

                        //close out the old transaction if needed, starting a new one
                        if(transactionModified) {
                            //save the transaction as a command (so we can add the model commands now)
                            let editorCommand = this.createEditorCommand(modifiedTransaction,workingInitialSelection,workingInitialMarks);
                            commandList.push(editorCommand);

                            //create a new transaction
                            let config = {};
                            config.doc = modifiedTransaction.doc;
                            config.selection = modifiedTransaction.selection;
                            config.storedMarks = modifiedTransaction.storedMarks;
                            let intermediateState = EditorState.create(config);

                            modifiedTransaction = intermediateState.tr;
                            workingInitialSelection = config.selection;
                            workingInitialMarks = config.storedMarks;
                            transactionModified = false;
                        }

                        //----------------------------
                        //insert any model commands
                        //----------------------------
                        if(deleteComponentCommands) commandList.push(...deleteComponentCommands);
                        if(createComponentCommands) commandList.push(...createComponentCommands);

                        //----------------------------
                        //create the editor insert step (if needed)
                        //----------------------------
                        let insertStep = this.createInsertStep(oldStepJson,newSliceContentJson);
                        if(insertStep) {
                            modifiedTransaction.step(insertStep);
                            transactionModified = true;
                        }    
                    }
                    else {
                        //add the old step to the current modified transaction
                        modifiedTransaction.step(oldStep);
                    }

                });

                //if the selection or stored marks was explicitly set in the transaction, add these back to the final new transaction
                if(finalSelection) {
                    let fixedSelection = this.convertSelectionToNewDoc(finalSelection,modifiedTransaction.doc);
                    modifiedTransaction.setSelection(fixedSelection);
                    transactionModified = true;
                }
                if(finalStoredMarks) {
                    modifiedTransaction.setStoredMarks(finalStoredMarks);
                    transactionModified = true;
                }

                //close out the final transaction, if needed
                if(transactionModified) {
                    //make sure we scroll into view
                    modifiedTransaction.scrollIntoView();

                    //save the transaction as a command (so we can add the model commands now)
                    let editorCommand = this.createEditorCommand(modifiedTransaction,workingInitialSelection,workingInitialMarks);
                    commandList.push(editorCommand);
                }

                //-------------------
                // Get verificaion if we are deleting anything
                //-------------------
                if(allDeletedNames.length > 0) {
                    let doDelete = confirm("Are you sure you want to delete these apogee nodes: " + allDeletedNames);
                    if(!doDelete) return;
                }

                //-------------------------
                //create the apogee command for the input transaction
                //-------------------------
                apogeeCommand = {};
                apogeeCommand.type = "compoundCommand";
                apogeeCommand.childCommands = commandList;
            }
            else {
                //--------------------------
                //There is no change to the model. Convert the transaction directly to an editor command
                //--------------------------
                apogeeCommand = this.createEditorCommand(transaction,initialSelection,initialMarks);
            }

            //-------------------
            //execute the command
            //-------------------
            if(apogeeCommand) {
                this.getModelView().getApp().executeCommand(apogeeCommand);
            }
        }
        else {
            //------------------------------
            //this is a editor state change that doesn't change the saved data
            //------------------------------
            this.editorData = this.editorData.apply(transaction);
            
            //##############################################
            //DOH! this is bad. I need to update the split between view and app for the editor
            //-I  shouldn't update the view editor data without updating the component editor data. But I have to as is.
            if(this.tabDisplay) {
                this.tabDisplay.nonComponentDocumentUpdate();
            }
        }
    }

    //---------------------------------------
    // Transaction Processing to extract model commands
    //---------------------------------------

    /** This function checks if the editor transaction creates or deletes any apogee components. */
    transactionUpdatesModel(transaction) {
        let modelUpdated = false;

        //check for deleted components
        let deleteNodeComponentCheck = node => {
            if(node.type.name == "apogeeComponent") modelUpdated = true;

            //apogee nodes are top level. Return false so we do no dive into child nodes.
            //if we change this rule, we need to change this code.
            return false;
        };

        //check steps to see if model is updated
        transaction.steps.forEach( (step,index) => {

            //look for deleted components in removed nodes 
            let doc = transaction.docs[index];
            if(step.jsonID == "replace") {
                doc.nodesBetween(step.from,step.to,deleteNodeComponentCheck);
            }
            else if(step.jsonID == "replaceAround") {
                doc.nodesBetween(step.from,step.gapFrom,deleteNodeComponentCheck);
                doc.nodesBetween(step.gapTo,step.to,deleteNodeComponentCheck);
            }

            //look for created components in added nodes
            if(this.stepHasCreateComponentNode(step)) modelUpdated = true;
        });

        return modelUpdated;
    }

    /** This function creates a map of the component names currently in this parent component. */
    createActiveNameMap() {
        //retrieve the existing names
        let activeNameMap = {};
        let member = this.getComponent().getMember();
        for(let name in member.getChildIdMap()) {
            activeNameMap[name] = true;
        }

        return activeNameMap;
    }
    
    /** This function updates the active name map for the list of deleted components. If updates the map in place, but also returns it. */
    updateActiveNameMapForDelete(activeNameMap,deletedComponentShortNames) {
        deletedComponentShortNames.forEach( name => {
            if(activeNameMap[name]) delete activeNameMap[name];
        });
    }

    /** This function gets the shorts names for the components deleted in this step. */
    getStepDeletedComponentShortNames(step,stepDoc) {
        let deletedComponentShortNames = [];

        //this will store the name if this is a component node
        let getApogeeNodeNames = node => {
            if(node.type.name == "apogeeComponent") {
                deletedComponentShortNames.push(node.attrs.name);
            }
        };

        //read the deleted nodes, saving the apogee component node names
        if(step.jsonID == "replace") {
            stepDoc.nodesBetween(step.from,step.to,getApogeeNodeNames);
        }
        else if(step.jsonID == "replaceAround") {
            stepDoc.nodesBetween(step.from,step.gapFrom,getApogeeNodeNames);
            stepDoc.nodesBetween(step.gapTo,step.to,getApogeeNodeNames);
        }

        return deletedComponentShortNames;
    }
    
    /** This method process the step, modifying it as needed:
     * -it pulls out the "state" that we include in the pasted data, but we don't track this value in the working node
     * - it checks if the name is available. If not, it modifying the name.
     * The passed in variable "activeNameMap" is modified in place as new names are added
     */
    processForStepComponentCreateCommands(oldStep,oldStepJson,activeNameMap) {
        let newSliceContentJson;
        let createdComponentInfos = [];

        if(!this.stepHasCreateComponentNode(oldStep)) {
            //no modified step or create component commands needed
            if(oldStepJson.slice) newSliceContentJson = oldStepJson.slice.content;
            createdComponentInfos = [];
        }
        else {
            newSliceContentJson = [];
            if((oldStepJson.stepType == "replace")||(oldStepJson.stepType == "replaceAround")) {
                oldStepJson.slice.content.forEach( oldNodeJson => {

                    if(oldNodeJson.type == "apogeeComponent") {
                        let newNodeJson = apogeeutil$1.jsonCopy(oldNodeJson);

                        //remove the state from the json, but save it separately
                        let state = newNodeJson.attrs.state;
                        delete newNodeJson.attrs.state;

                        //get the name and do any needed name processing
                        let requestedName = newNodeJson.attrs.name;

                        let nameToUse = this.createComponentReplacementNameProcessing(requestedName,activeNameMap);
                        if(nameToUse != requestedName) {
                            newNodeJson.attrs.name = nameToUse;

                            //we need to change the name in the state too
                           if(state) {
                                state.memberJson.name = nameToUse;                                
                            }
                        }

                        //store the create info
                        let createdComponentInfo = {};
                        createdComponentInfo.name = nameToUse;
                        createdComponentInfo.state = state;
                        createdComponentInfos.push(createdComponentInfo);

                        //store the modified json
                        newSliceContentJson.push(newNodeJson);
                        
                    }
                    else {
                        //not a component, store the original node
                        newSliceContentJson.push(oldNodeJson);
                    }
                });
            }
        }

        //return the new step
        return { newSliceContentJson, createdComponentInfos };
    }

    /** This method checks the name of a created component and returns the proper name to 
     * use to create the component. It will be modified if the name already exists. This function modifies the active name map 
     * in place. */
    createComponentReplacementNameProcessing(name,activeNameMap) {
        if(activeNameMap[name]) {
            //repeat name! - modify it with a suffix
            for(let suffixIndex = 1; true; suffixIndex++) {
                let testName = name + "_" + suffixIndex;
                if(!activeNameMap[testName]) {
                    let newName = testName;
                    //mark this name as used
                    activeNameMap[newName] = true;
                    return newName;
                }
                
                //I assume this will never happen, but just in case we will provide an end to this loop
                if(suffixIndex > MAX_SUFFIX_INDEX) {
                    throw new Error("Too many repeat names in create new component!");
                }
            }
        }
        else {
            //old name was good, mark it as used
            activeNameMap[name] = true;
            return name
        }
    }

    /** This method returns true if the given step has any create component node command. */
    stepHasCreateComponentNode(step) {
        if((step.jsonID == "replace")||(step.jsonID == "replaceAround")) {
            return step.slice.content.content.some( node => (node.type.name == "apogeeComponent") );
        }
    }

    /** This method takes a selection pointing at one document and makes a new one pointing at the given
     * document. The positions in the documents must match.
     */
    convertSelectionToNewDoc(selection,newDoc) {
        let $newAnchor = newDoc.resolve(selection.$anchor.pos);
        let $newHead = newDoc.resolve(selection.$head.pos);
        if(selection instanceof TextSelection) {
            return new TextSelection($newAnchor,$newHead);
        }
        else if(selection instanceof NodeSelection) {
            return new TextSelection($newAnchor);
        }
        else {
            throw new Exception("Unknown selection type: " + selection.constructor.name);
        }
        
    }

    /** This method takes an input step that includes a delete and/or create and makes the associated remove step. 
     * The insert step is made in createInsertStep. This method returns null if there is no remove step.
     * The new step will keep the same bounds for the replace but it will remove the slice that is inserted.
     */
    createRemoveStep(oldStepJson) {
        let newStepJson;
        if(oldStepJson.stepType == "replace") {
            if(oldStepJson.from != oldStepJson.to) {
                newStepJson = {};
                newStepJson.stepType = "replace";
                newStepJson.from = oldStepJson.from;
                newStepJson.to = oldStepJson.to;
            }
            else {
                newStepJson = null;
            }
        }
        else if(oldStepJson.stepType == "replaceAround") {
            if((oldStepJson.from != oldStepJson.gapFrom)&&(oldStepJson.gapTo != oldStepJson.to)) {
                newStepJson = {};
                newStepJson.stepType = "replaceAround";
                newStepJson.from = oldStepJson.from;
                newStepJson.gapFrom = oldStepJson.gapFrom;
                newStepJson.gapTo = oldStepJson.gapTo;
                newStepJson.to = oldStepJson.to;
            }
            else {
                newStepJson = null;
            }
        }
        else {
            throw new Error("Unknown editor step type: " + oldStepJson.stepType);
        }

        return newStepJson ? Step.fromJSON(this.editorData.schema, newStepJson) : null;
    }
    
    /** This method takes an input step that includes a delete and/or create and makes the associated insert step. 
     * The remove step is made in createRemoveStep. This method returns null if there is no insert step.
     * The new step will keep the same slice for the insert but it will remove no content.
     */
    createInsertStep(oldStepJson,newSliceContentJson) {
        if(newSliceContentJson) {
            //make a copy to keep the old slice info - but we will insert the potentiall modified content
            let newStepJson = apogeeutil$1.jsonCopy(oldStepJson);
            newStepJson.slice.content = newSliceContentJson;
            //update the locations
            if(oldStepJson.stepType == "replace") {
                newStepJson.from = oldStepJson.from;
                newStepJson.to = oldStepJson.from;
            }
            else if(oldStepJson.stepType == "replaceAround") {
                newStepJson.from = oldStepJson.from;
                newStepJson.gapFrom = newStepJson.from;
                let gapSize = oldStepJson.gapTo - oldStepJson.gapFrom;
                newStepJson.gapTo = newStepJson.gapFrom + gapSize;
                newStepJson.to = newStepJson.gapTo;
            }
            else {
                throw new Error("Unknown editor step type: " + oldStepJson.stepType);
            }

            return  Step.fromJSON(this.editorData.schema, newStepJson);
        }
        else {
            //no insert done
            return null;
        }
    }

    /** This method maps the list of component names to a list of delete commands. */
    createDeleteComponentCommands(deletedComponentShortNames) {
        return deletedComponentShortNames.map(shortName => {

            let parentMember = this.getComponent().getParentFolderForChildren();
            let memberId = parentMember.lookupChildId(shortName);
            
            let commandData = {};
            commandData.type = "deleteComponent";
            commandData.memberId = memberId;
            return commandData;
        });
    }
    
    /** This method maps the list of component craete infos to a list of create commands. */
    createCreateComponentCommands(createdComponentInfos) {
        return createdComponentInfos.map( createInfo => {
            let state = createInfo.state;

            let parentMember = this.getComponent().getParentFolderForChildren();

            let commandData = {};
            commandData.type = "addComponent";
            commandData.parentId = parentMember.getId();
            commandData.memberJson = state.memberJson;
            commandData.componentJson = state.componentJson;
            return commandData;
        })
    }

    //------------------------------------------
    // Editor command processing from commands created outside the editor
    //------------------------------------------

    /** This function turns a transaction into an application command. This is used
     * for the command path for commands generated outside the editor. */
    createEditorCommand(transaction,optionalInitialSelection,optionalInitialMarks) {
        var stepsJson = [];
        var inverseStepsJson = [];

        for(var i = 0; i < transaction.steps.length; i++) {
            var step = transaction.steps[i];
            stepsJson.push(step.toJSON());
            var stepDoc = transaction.docs[i];
            var inverseStep = step.invert(stepDoc);
            //this is in the wrong order - we will reverse it below
            inverseStepsJson.push(inverseStep.toJSON()); 
        }

        //fix the order of inverse commands
        inverseStepsJson.reverse();

        var commandData = {};
        commandData.type = "literatePageTransaction";
        commandData.memberId = this.getComponent().getMemberId();
        commandData.steps = stepsJson;
        commandData.undoSteps = inverseStepsJson;

        if(optionalInitialSelection) commandData.startSelection = optionalInitialSelection.toJSON();
        if(optionalInitialMarks) commandData.startMarks = optionalInitialMarks.map(mark => mark.toJSON());
        if(transaction.selection) commandData.endSelection = transaction.selection.toJSON();
        if(transaction.marks) commandData.endMarks = transaction.marks.map(mark => mark.toJSON());
        
        return commandData;
    }

    /** This method removes the node of the given name frmo the folder. If no
     * transaction argument is included, a new transaction will be created. If the
     * transaction object is included, the remove action will be added to it. 
     */
    selectApogeeNode(childShortName) {
        var state = this.getEditorData();
      
        let {found,from,to} = this.getComponentRange(state,childShortName);
        //end test

        if(found) {
            let $from = state.doc.resolve(from);
            let selection = new NodeSelection($from);
            let transaction = state.tr.setSelection(selection).scrollIntoView();
            this.applyTransaction(transaction);
        }
    }

    
    getComponentRange(editorData,componentShortName) {
        let doc = editorData.doc;
        let schema = editorData.schema;
        let result = {};
        doc.forEach((node, offset) => {
            if (node.type == schema.nodes.apogeeComponent) {
                if (node.attrs.name == componentShortName) {

                    if (result.found) {
                        //this shouldn't happen
                        throw new Error("Multiple nodes found with the given name");
                    }

                    result.found = true;
                    result.from = offset;
                    result.to = result.from + node.nodeSize;
                }
            }
        });
        return result;
    }

    /** This method give focus to the editor for this componennt, if the component is showing. */
    giveEditorFocusIfShowing() {
        let display = this.getTabDisplay();
        if((display)&&(display.getIsShowing())) {
            let editorView = display.getEditorView(); 
            if(editorView.dom) {
                editorView.focus();
            }
        }
    }
      
    /** This method adds an apogee component node of the given name to the folder.
     * It will be placed in the current selection, unless the "insertAtEnd" argument is true. 
     * If no transaction argument is included, a new transaction will be created. If the
     * transaction object is included, the remove action will be added to it. 
     */
    getInsertApogeeNodeOnPageCommands(shortName,insertAtEnd) {
        let state = this.getEditorData();
        let schema = state.schema;
        let setupTransaction;
        let commandInfo = {};
        
        if(!insertAtEnd) {
            let { empty } = state.selection;
            if(!empty) {

                setupTransaction = state.tr.deleteSelection(); 

                //see if we need to delete any apogee nodes
                var deletedComponentShortNames = this.getDeletedApogeeComponentShortNames(setupTransaction);
                commandInfo.deletedComponentShortNames = deletedComponentShortNames;

                if(deletedComponentShortNames.length > 0) {
                    //create delete commands
                    commandInfo.deletedComponentCommands = this.createDeleteComponentCommands(deletedComponentShortNames); 
                }
            }
        }
        else {
            //insert at end
            //move selection to end
            let docLength = state.doc.content.size;
            let $pos = state.doc.resolve(docLength);
            let selection = new TextSelection($pos,$pos);
            setupTransaction = state.tr.setSelection(selection);
        }

        if(setupTransaction) {
            let initial1Selection = state.selection;
            let initial1Marks = state.marks;
            commandInfo.editorSetupCommand = this.createEditorCommand(setupTransaction,initial1Selection,initial1Marks);
        }

        //create a second transaction
        let addTransaction;
        let initial2Selection;
        let initial2Marks;
        if(setupTransaction) {
            let config = {};
            config.doc = setupTransaction.doc;
            config.selection = setupTransaction.selection;
            config.storedMarks = setupTransaction.storedMarks;
            let intermediateState = EditorState.create(config);

            addTransaction = intermediateState.tr;
            initial2Selection = config.selection;
            initial2Marks = config.storedMarks;
        }
        else {
            addTransaction = state.tr;
            initial2Selection = state.selection;
            initial2Marks = state.marks;
        }

        //finish the document transaction
        addTransaction = addTransaction.replaceSelectionWith(schema.nodes.apogeeComponent.create({ "name": shortName }));
        addTransaction.scrollIntoView();
        commandInfo.editorAddCommand = this.createEditorCommand(addTransaction,initial2Selection,initial2Marks);

        return commandInfo;
        
    }

    
    /** This function returns the names of any apogee components nodes which are deleted in the
     * given transaction. */
    getDeletedApogeeComponentShortNames(transaction) {
        //prepare to get apogee nodes
        let transactionShortNames = [];
    
        //get all the replcaed apogee components
        transaction.steps.forEach( (step,index) => {
            let stepDoc = transaction.docs[index];
            let stepShortNames = this.getStepDeletedComponentShortNames(step,stepDoc);
            transactionShortNames.push(...stepShortNames);
        });
    
        return transactionShortNames;
    
    }

    /** This method removes the node of the given name frmo the folder. If no
     * transaction argument is included, a new transaction will be created. If the
     * transaction object is included, the remove action will be added to it. 
     */
    getRemoveApogeeNodeFromPageCommand(childShortName) {
        var state = this.getEditorData();
      
        let {found,from,to} = this.getComponentRange(state,childShortName);
        //end test

        if(found) {
            let transaction = state.tr.delete(from, to).scrollIntoView();
            var commandData = this.createEditorCommand(transaction,state.selection,state.marks);
            return commandData;
        }
        else {
            return null;
        }
    }

    /** This method updates the name attribute of the given node. If no 
     * transaction argument is included, a new transaction will be created. If the
     * transaction object is included, the remove action will be added to it. 
     */
    getRenameApogeeNodeCommands(memberId,oldShortName,newShortName) {
        var state = this.getEditorData();
        let {found,from,to} = this.getComponentRange(state,oldShortName);

        let commands = {};

        if(found) {
            //clear the component state (by recording member id)
            let setupTransaction = state.tr.replaceWith(from, to,state.schema.nodes.apogeeComponent.create({"memberId": memberId }));
            commands.setupCommand = this.createEditorCommand(setupTransaction,state.selection,state.marks);

            //later set the new name
            let config = {};
            config.doc = setupTransaction.doc;
            config.selection = setupTransaction.selection;
            config.storedMarks = setupTransaction.storedMarks;
            let intermediateState = EditorState.create(config);
            let setNameTransaction = intermediateState.tr.replaceWith(from, to,state.schema.nodes.apogeeComponent.create({"name": newShortName}));
            commands.setNameCommand = this.createEditorCommand(setNameTransaction,config.selection,config.storedMarks);

            return commands;
        }
        else {
            return null;
        }
    }
        
    //end page code
    //############################################################################################################

}

/** This is used to flag this as an edit component. */
ParentComponentView.isParentComponentView = true;

/** This is a standin for the display conatiner for the literate page
 * 
 * @class 
 */
class PageDisplayContainer {

    constructor(componentView, viewType, isMainView) {
        
        //variables
        this.isMainView = isMainView;
        
        this.mainElement = null;
        this.viewLabelHeaderElement = null;
        this.viewLabelElement = null;
        this.headerContainer = null;
        this.viewContainer = null;

        this.viewSelectorContainer = null;
        this.viewActiveElement = null;
        this.viewNameElement = null;

        this.uiCompleted = false;
        
        this.isComponentShowing = false;
        this.isViewActive = isMainView;
        this.isContentLoaded = false;
        
        this.destroyViewOnInactive = true;
        
        this.inEditMode = false;
        
        this.content = null;
        
        this.componentView = componentView;
        this.viewType = viewType;
        this.dataDisplay = null;

        this.heightUiActive = false;
        this.showLessButton = null;
        this.showMoreButton = null;
        this.showMaxButton = null;

        this.savedUiState = {};
        
        //initialize
        this.initUI();
    }

    getComponentView() {
        return this.componentView;
    }

    //-------------------
    // state management
    //-------------------

    /** This method should be called whent the frame parent is loaded or unloaded from the DOM. */
    setIsComponentShowing(isComponentShowing) {
        this.isComponentShowing = isComponentShowing;
        this.updateDataDisplayLoadedState();
    }

    /** This returns the isComponentShowing status of the display. */
    getIsComponentShowing() {
        return this.isComponentShowing;
    }

    /** This method closes the window. If the argument forceClose is not
     * set to true the "request_close" handler is called to check if
     * it is ok to close the window. */
    close(forceClose) {

        if(!forceClose) {
            //make a close request
            var requestResponse = this.callHandler(uiutil.REQUEST_CLOSE,this);
            if(requestResponse == uiutil.DENY_CLOSE) {
                //do not close the window
                return;
            }
        }

        this.dispatchEvent(uiutil.CLOSE_EVENT,this);
    }

    getStateJson() {
        //update the saved state json
        this.savedUiState.isViewActive = this.isViewActive;
        if(this.dataDisplay) {
            this.dataDisplay.addUiStateData(this.savedUiState);
        }
        return this.savedUiState;
    }

    setStateJson(json) {
        if(json) {
            this.savedUiState = json;
        }
        else {
            this.savedUiState = {};
        }

        //update any relevent fields
        if(this.savedUiState.isViewActive !== undefined) {
            this.setIsViewActive(this.savedUiState.isViewActive);
        }

        if(this.dataDisplay) {
            this.dataDisplay.readUiStateData(this.savedUiState);
        }
    }

    //---------------------------
    // GUI ELEMENT
    //---------------------------

    /** This method returns the view label element to be used in the component title bar. */
    getViewSelectorContainer() {
        return this.viewSelectorContainer;
    }

    /** This method returns the main dom element for the window frame. */
    getDisplayElement() {
        return this.mainElement;
    }

    //====================================
    // Private Methods
    //====================================

    /** This method should be called whent the frame parent is loaded or unloaded from the DOM. */
    setIsViewActive(isViewActive) {
        this.isViewActive = isViewActive;
        this.updateViewSelectorState();
        this.updateDataDisplayLoadedState();
    }

    //---------------------------
    // Initialization
    //---------------------------

    /** @private */
    initUI() {
        
        //make the container
        this.mainElement = uiutil.createElementWithClass("div","visiui_displayContainer_mainClass",null);

        //make the selector for the view, in the component title bar
        this.viewSelectorContainer = uiutil.createElementWithClass("div","visiui_displayContainer_viewSelectorContainerClass",null);

        this.viewActiveElement = uiutil.createElementWithClass("div","visiui_displayContainer_viewActiveElementClass",this.viewSelectorContainer);
        this.viewNameElement = uiutil.createElementWithClass("div","visiui_displayContainer_viewSelectorClass",this.viewSelectorContainer);
        
        this.viewNameElement.innerHTML = this.viewType;

        this.expandImage = uiutil.createElementWithClass("img","visiui_displayContainer_expandContractClass",this.viewActiveElement);
        this.expandImage.src = uiutil.getResourcePath(PageDisplayContainer.COMPONENT_LABEL_EXPAND_BUTTON_PATH);
    
        this.contractImage = uiutil.createElementWithClass("img","visiui_displayContainer_expandContractClass",this.viewActiveElement);
        this.contractImage.src = uiutil.getResourcePath(PageDisplayContainer.VIEW_TITLE_CONTRACT_BUTTON_PATH);

        this.viewSelectorContainer.onclick = () => this.setIsViewActive(!this.isViewActive);
        
        this.updateViewSelectorState();
    }

    /** This completes the UI. It should only be called when the data display has been created. */
    completeUI() {

        if(!this.dataDisplay) return;
        
        //make the label for the view
        this.viewLabelHeaderElement = uiutil.createElementWithClass("div","visiui_displayContainer_viewLabelHeaderClass",this.mainElement);

        this.viewLabelElement = uiutil.createElementWithClass("div","visiui_displayContainer_viewLabelClass",this.viewLabelHeaderElement);
        this.viewLabelElement.innerHTML = this.viewType;

        this.viewToolbarElement = uiutil.createElementWithClass("div","visiui_displayContainer_viewToolbarClass",this.viewLabelHeaderElement);

        //add the view toolbar controls
        this.populateViewToolbar();
        
        //add the header elment (for the save bar)
        this.headerContainer = uiutil.createElementWithClass("div","visiui_displayContainer_headerContainerClass",this.mainElement);
        
        //add the view container
        let viewContainerClass = this.dataDisplay.getSupressContainerHorizontalScroll() ? 
            "visiui_displayContainer_viewContainerClass_noHScroll" : "visiui_displayContainer_viewContainerClass";
        this.viewContainer = uiutil.createElementWithClass("div",viewContainerClass,this.mainElement);

        this.uiCompleted = true;
    }

    /** This undoes the data display specific parts of the container ui */
    uncompleteUI() {
        uiutil.removeAllChildren(this.mainElement);
        this.heightUiActive = false;
        this.uiCompleted = false;
    }

    updateViewSelectorState() {
        //show/hide ui elements
        if(this.isViewActive) {
            this.mainElement.style.display = ""; 
            this.expandImage.style.display = "none";
            this.contractImage.style.display = "";
        }
        else {
            this.mainElement.style.display = "none";
            this.expandImage.style.display = "";
            this.contractImage.style.display = "none";
        }
    }

    /** This method configures the toolbar for the view display. */
    populateViewToolbar() {
        if(this.dataDisplay.getUseContainerHeightUi()) {
            this.showLessButton = uiutil.createElementWithClass("div","visiui_displayContainer_viewDisplaySizeButtonClass",this.viewToolbarElement);
            this.showLessButton.innerHTML = "less";
            this.showLessButton.onclick = () => this.showLess();
            this.showMoreButton = uiutil.createElementWithClass("div","visiui_displayContainer_viewDisplaySizeButtonClass",this.viewToolbarElement);
            this.showMoreButton.innerHTML = "more";
            this.showMoreButton.onclick = () => this.showMore();
            this.showMaxButton = uiutil.createElementWithClass("div","visiui_displayContainer_viewDisplaySizeButtonClass",this.viewToolbarElement);
            this.showMaxButton.innerHTML = "max";
            this.showMaxButton.onclick = () => this.showMax();
            this.heightUiActive = true;
            this.updateViewSizeButtons();
        }
    }

    showLess() {
        if((this.dataDisplay)&&(this.heightUiActive)) {
            if(this.dataDisplay.getResizeHeightMode() == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX) {
                //if we are in display max mode, change to display some mode
                this.dataDisplay.setResizeHeightMode(DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME);
            }
            else if(this.dataDisplay.getResizeHeightMode() == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME) {
                //if we are in "some" mode, adjust size smaller if allowed
                if((this.dataDisplay.getHeightAdjustFlags() | DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_LESS) !== 0) {                  
                    this.dataDisplay.adjustHeight(DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_LESS);
                }
            }
            else {
                //unknown mode
                return;
            }
            this.updateViewSizeButtons();
        }
    }

    showMore() {
        if((this.dataDisplay)&&(this.heightUiActive)) {
            if(this.dataDisplay.getResizeHeightMode() == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME) {
                //if we are in "some" mode, adjust size smaller if allowed
                if((this.dataDisplay.getHeightAdjustFlags() | DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MORE) !== 0) {
                    this.dataDisplay.adjustHeight(DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MORE);
                }
            }
            else {
                //no action is not in some mode
                return;
            }
            this.updateViewSizeButtons();
        }
    }

    showMax() {
        if((this.dataDisplay)&&(this.heightUiActive)) {
            if(this.dataDisplay.getResizeHeightMode() == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME) {
                //if we are in display max mode, change to display some mode
                this.dataDisplay.setResizeHeightMode(DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX);
            }
            else {
                //no action is not in some mode
                return;
            }
            this.updateViewSizeButtons();
        }
    }

    updateViewSizeButtons() {
        if(this.heightUiActive) {
            let showLessVisible = false, showMoreVisible = false, showMaxVisible = false;
            if(this.dataDisplay) {
                if(this.dataDisplay.getResizeHeightMode() == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_SOME) {
                    showLessVisible = true;
                    showMoreVisible = true;
                    showMaxVisible = true;
                }
                else if(this.dataDisplay.getResizeHeightMode() == DATA_DISPLAY_CONSTANTS.RESIZE_HEIGHT_MODE_MAX){
                    showLessVisible = true;
                }
            }

            this.showLessButton.style.display = (showLessVisible) ? "" : "none";
            this.showMoreButton.style.display = (showMoreVisible) ? "" : "none";
            this.showMaxButton.style.display = (showMaxVisible) ? "" : "none";
        }
        
    }

    /** This method shold be called when the content loaded or frame visible state 
     * changes to manage the data display.
     * private */
    updateDataDisplayLoadedState() {
        
        if((this.isComponentShowing)&&(this.isViewActive)) {
            if(!this.dataDisplayLoaded) {
                if(!this.dataDisplay) {
                    //the display should be created only when it is made visible
                    this.dataDisplay =  this.componentView.getDataDisplay(this,this.viewType);
                    this.dataDisplay.readUiStateData(this.savedUiState);
                    if(!this.uiCompleted) this.completeUI();
                    this.setContent(this.dataDisplay.getContent());
                    this.dataDisplay.showData();
                }
            
                if(this.dataDisplay.onLoad) this.dataDisplay.onLoad();
                this.dataDisplayLoaded = true;
            }
        }
        else {
            if(this.dataDisplay) {
                if(this.dataDisplayLoaded) {
                    this.dataDisplayLoaded = false;
                    if(this.dataDisplay.onUnload) this.dataDisplay.onUnload();
                }
                
                //we will destroy the display is the destroyViewOnInactive flag is set, and we are inactive
                if((this.destroyViewOnInactive)&&(!this.isViewActive)) {
                    //update the saved UI state
                    this.dataDisplay.addUiStateData(this.savedUiState);

                    //remove content
                    this.safeRemoveContent();
                    //destroy the display
                    if(this.dataDisplay.destroy) this.dataDisplay.destroy();
                    this.dataDisplay = null;
                }
            }  
        }
        
            
        //fyi - this is remove code, when we need to add it
        //[]
    }

    //------------------------------
    // standard methods
    //------------------------------

    /** The displayDestroyFlags indicate when the display for this view mode will be destroyed,
     * refering to times it is not visible to the user. See further notes in the constructor
     * description. */
    setDestroyViewOnInactive(destroyViewOnInactive) {
        this.destroyViewOnInactive = destroyViewOnInactive;
    }   

    /** This method cleasr the data display. It should only be called when the data display is not showing. 
     * maybe allow this when the display is showing - unload and reload it*/
    reloadDisplay() {

        //update the stored UI state json
        this.savedUiState = this.getStateJson();

        //this destrpys the data display, not the container - bad name
        this.destroy();

        //this gets rid of the data display specific parts of the ui
        this.uncompleteUI();

        //reload display
        this.updateDataDisplayLoadedState();
    }

    /** This method destroys the data display. */
    destroy() {
        if(this.dataDisplay) {
            if(this.dataDisplay.destroy) {
                this.dataDisplay.destroy();
            }
            this.dataDisplay = null;
            this.dataDisplayLoaded = false;
        }
    }

    /** This method should be called called before the view mode is closed. It should
     * return true or false. NO - IT RETURNS SOMETHING ELSE! FIX THIS! */
    isCloseOk() {
        if(this.dataDisplay) {
            if(this.dataDisplay.isCloseOk) {
                return this.dataDisplay.isCloseOk();
            }
            
            if(this.inEditMode) {
                return DisplayContainer.UNSAVED_DATA;
            }
        }
        
        return DisplayContainer.CLOSE_OK;
    }
        
    /** This method is called when the member is updated, to make sure the 
    * data display is up to date. */
    componentUpdated(component) {
        //update the data display
        if((this.dataDisplay)&&(!this.inEditMode)) {
            let {reloadData,reloadDataDisplay} = this.dataDisplay.doUpdate();
            if(reloadDataDisplay) {
                this.reloadDisplay();
            }
            else if(reloadData) {
                this.dataDisplay.showData();
                this.updateViewSizeButtons();
            }
        }
    }
        
    //------------------------------
    // Accessed by the Editor, if applicable
    //------------------------------

    onCancel() {
        //reload old data
        this.dataDisplay.showData();
        
        return true;
    }

    startEditMode(onSave,onCancel) {
        if(!this.inEditMode) {
            this.inEditMode = true;
            var saveBar = getSaveBar(onSave,onCancel);
            this.setHeaderContent(saveBar);
        }
    }

    endEditMode() {
        //exit edit mode
        if(this.inEditMode) {
            this.inEditMode = false;
            this.setHeaderContent(null);
        }
        //select the associated node in the document.
        let parentComponentView = this.componentView.getParentComponentView();
        if(parentComponentView) {
            let name = this.componentView.getComponent().getName();
            parentComponentView.selectApogeeNode(name);
        }
        //give the editor focus
        parentComponentView.giveEditorFocusIfShowing();

    }

    isInEditMode() {
        return this.inEditMode;
    }


    //====================================
    // Internal Methods
    //====================================

    /** This sets the content for the window. If null (or otherwise false) is passed
     * the content will be set to empty.*/
    setHeaderContent(contentElement) {
        uiutil.removeAllChildren(this.headerContainer);
        if(contentElement) {
            this.headerContainer.appendChild(contentElement);
        }
    }

    /** This sets the content for the window. */
    setContent(contentElement) {
        
        uiutil.removeAllChildren(this.viewContainer);
        
        //set the content
        this.viewContainer.appendChild(contentElement);
        this.content = contentElement;
    }

    /** This method removes the given element from the content display. If the element
     * is not in the content display, no action is taken. */
    safeRemoveContent() {
        for(var i = 0; i < this.viewContainer.childNodes.length; i++) {
            var node = this.viewContainer.childNodes[i];
            if(node === this.content) {
                this.viewContainer.removeChild(this.content);
                this.content = null;
            }
        }
    }

}

/** This method returns the main dom element for the window frame. */
PageDisplayContainer.COMPONENT_LABEL_EXPAND_BUTTON_PATH = "/closed_gray.png";
PageDisplayContainer.VIEW_TITLE_CONTRACT_BUTTON_PATH = "/opened_gray.png";

/** This component represents a json table object. */
class PageChildComponentDisplay {

    constructor(componentView, parentComponentDisplay) {
        this.componentView = componentView;
        this.parentComponentDisplay = parentComponentDisplay;
        
        //these are the header elements
        this.iconOverlayElement;
        this.mainElement = null;
        this.bannerContainer = null;

        this.titleBarNameElement = null;
        
        this.displayContainerMap = null;
        
        this.isPageShowing = false;

        //make the container
        this.mainElement = uiutil.createElementWithClass("div","visiui_pageChild_mainClass",null);
    
        //this is the window in which the component is displayed
        if(componentView) this.loadComponentDisplay();
        
        //connect to parent
        this.setIsPageShowing(this.parentComponentDisplay.getIsShowing());
        this.parentComponentDisplay.addListener(uiutil.SHOWN_EVENT,() => this.setIsPageShowing(true));
        this.parentComponentDisplay.addListener(uiutil.HIDDEN_EVENT,() => this.setIsPageShowing(false));
    }

    getElement() {
        return this.mainElement;
    }

    setComponentView(componentView) {
        this.componentView = componentView;
        this.loadComponentDisplay();
        this.updateChildDisplayStates();
    }

    getComponentView() {
        return this.componentView;
    }

    // getMember() {
    //     return this.member;
    // }

    componentUpdated(component) {

        if(component.isDisplayNameUpdated()) {
            this._setTitle();
        }

        if(component.isMemberFieldUpdated("member","state")) {
            this._setBannerState();
        }

        //update the content in instantiated view mode elements
        for(var viewType in this.displayContainerMap) {
            var displayContainer = this.displayContainerMap[viewType];
            displayContainer.componentUpdated(component);
        }
    }

    /** This gets the current window state, to reconstruct the view. */
    getStateJson() {
        let json = {};
        let dataPresent = false;
        
        //view state
        json.views = {};
        for(var viewType in this.displayContainerMap) {
            let displayContainer = this.displayContainerMap[viewType];
            let viewStateJson = displayContainer.getStateJson();
            if(viewStateJson) {
                json.views[viewType] = viewStateJson;
                dataPresent = true;
            }
        }
        
        if(dataPresent) return json;
        else return undefined;
    }

    /** This gets the current window state, to reconstruct the view. */
    setStateJson(json) {
        if(json) {

            //set view state
            if(json.views) {
                for(let viewType in json.views) {
                    let viewStateJson = json.views[viewType];
                    if(viewStateJson) {
                        let displayContainer = this.displayContainerMap[viewType];
                        if(displayContainer) {
                            displayContainer.setStateJson(viewStateJson);
                        }
                    }
                }
            }
        }
    }

    /** This will reload the given data display. */
    reloadDisplay(viewType) {
        if(this.displayContainerMap) {
            let displayContainer = this.displayContainerMap[viewType];
            if(displayContainer) {
                displayContainer.reloadDisplay();
            }
        }
    }

    /** This should be called by the component when it discards this display. */
    deleteDisplay() {
        //dispose any view elements
        for(var viewType in this.displayContainerMap) {
            var displayContainer = this.displayContainerMap[viewType];
            if(displayContainer) {
                displayContainer.destroy();
                delete this.displayContainerMap[viewType];
            }
        }
    }


    //===============================
    // Private Functions
    //===============================


    /** This is the standard window for the component.  
     * @private */
    loadComponentDisplay() {
        if(!this.componentView) return;

        //add the click handler, to select this node if it is clicked
        this.mainElement.onclick = () => {
            let name = this.componentView.getName();
            let parentComponentView = this.componentView.getParentComponentView();
            parentComponentView.selectApogeeNode(name);
        };
        
        //add title bar
        this.addTitleBar();
        
        //add banner container
        this.bannerContainer = uiutil.createElementWithClass("div","visiui_pageChild_bannerContainerClass",this.mainElement);
        
        //add the view container
        this.viewContainer = uiutil.createElementWithClass("div","visiui_pageChild_viewContainerClass",this.mainElement);
        
        //add the view elements
        var settings = this.componentView.getTableEditSettings();
        var viewTypes = settings.viewModes;
        
        this.displayContainerMap = {};  
        if(viewTypes.length > 0) {
            for(var i = 0; i < viewTypes.length; i++) {
                var viewType = viewTypes[i];
                
                var isMainView = (i == 0);

                var displayContainer = new PageDisplayContainer(this.componentView, viewType, isMainView);
                
                //add the view title element to the title bar
                this.titleBarViewsElement.appendChild(displayContainer.getViewSelectorContainer());
                
                //add the view display
                this.viewContainer.appendChild(displayContainer.getDisplayElement());
                
                //store the display container object
                this.displayContainerMap[viewType] = displayContainer;
            }
        }

        this._setTitle();
        this._setBannerState();
    }

    /** This makes the title bar, and installs it inline */
    addTitleBar() {
        
        this.titleBarContainer = uiutil.createElementWithClass("div","visiui_pageChild_titleBarClass",this.mainElement);
        this.titleBarMenuElement = uiutil.createElementWithClass("div","visiui_pageChild_titleBarMenuClass",this.titleBarContainer);
        this.titleBarNameElement = uiutil.createElementWithClass("div","visiui_pageChild_titleBarNameClass",this.titleBarContainer);
        this.titleBarViewsElement = uiutil.createElementWithClass("div","visiui_pageChild_titleBarViewsClass",this.titleBarContainer);
        
        //------------------
        // menu
        //------------------
        
        var iconUrl = this.componentView.getIconUrl();
        if(!iconUrl) iconUrl = uiutil.getResourcePath(uiutil.MENU_IMAGE);
        
        this.menu = Menu.createMenuFromImage(iconUrl);
        var menuItemCallback = () => {
            return this.componentView.getMenuItems();
        };
        this.menu.setAsOnTheFlyMenu(menuItemCallback);
    
        this.titleBarMenuElement.appendChild(this.menu.getElement());
        
        //create the icon (menu) overlay
        this.iconOverlayElement = uiutil.createElementWithClass("div","visiui_pageChild_icon_overlay_style",this.titleBarMenuElement);

    }

    setIsPageShowing(isPageShowing) {
        if(this.isPageShowing != isPageShowing) {
            this.isPageShowing = isPageShowing;
            this.updateChildDisplayStates();
        }
    }

    updateChildDisplayStates() {
        var componentBodyShowing = this.isPageShowing;
        for(var viewType in this.displayContainerMap) {
            var displayContainer = this.displayContainerMap[viewType];
            if(displayContainer) {
                //notify display container if component display body is loaded
                if(displayContainer.getIsComponentShowing() != componentBodyShowing) {
                    displayContainer.setIsComponentShowing(componentBodyShowing);
                }
            }
        }
    }

    /** This sets the given element as the icon overlay. If null or other [false} is passed
     * this will just clear the icon overlay. */
    setIconOverlay(element) {
        if(this.iconOverlayElement) {
            this.clearIconOverlay();
            if(element) {
                this.iconOverlayElement.appendChild(element);
            }
        }
    }

    clearIconOverlay() {
        if(this.iconOverlayElement) {
            uiutil.removeAllChildren(this.iconOverlayElement);
        }
    }

    _setTitle() {
        if(!this.componentView) return;

        let title = this.componentView.getDisplayName();
        this.titleBarNameElement.innerHTML = title;
    }

    _setBannerState() {
        if(!this.componentView) return;

        let bannerState = this.componentView.getBannerState();
        let bannerMessage = this.componentView.getBannerMessage();

        //update the banner
        var bannerDiv;
        if(bannerState == bannerConstants.BANNER_TYPE_NONE) {
            bannerDiv = null;
        }
        else {
            bannerDiv = getBanner(bannerMessage,bannerState);
        }
        uiutil.removeAllChildren(this.bannerContainer);
        if(bannerDiv) {
            this.bannerContainer.appendChild(bannerDiv);
        }
        
        //update the icon overlay
        var iconOverlay = getIconOverlay(bannerState);
        if(iconOverlay) {
            this.setIconOverlay(iconOverlay);
        }
        else {
            this.clearIconOverlay();
        }
    }

}

/** This method returns the main dom element for the window frame. */
PageChildComponentDisplay.EXPAND_BUTTON_PATH = "/closed_gray.png";
PageChildComponentDisplay.CONTRACT_BUTTON_PATH = "/opened_gray.png";

/** This component represents a json table object. */
class LiteratePageComponentDisplay$1 {
    
    constructor(componentView) {
        //mixin initialization
        this.eventManagerMixinInit();

        this.componentView = componentView;

        this.isShowing = false;

        this.editorManager = this.componentView.getEditorManager();

        //this is used if we have to prepopolate and child component displays
        this.standInChildComponentDisplays = {};

        this.loadTabEntry();
    };

    getComponentView() {
        return this.componentView;
    }


    getTab() {
        return this.tab;
    }

    getEditorView() {
        return this.editorView;
    }

    closeTab() {
        if(this.tab) {
            this.tab.close();
            this.tab = null;
        }
    }

    getIsShowing() {
        return this.isShowing;
    }

    componentUpdated(component) {

        if(component.isMemberFieldUpdated("member","name")) {
            this.tab.setTitle(this.componentView.getName());
        }

        if(component.isFieldUpdated("document")) {
            let editorData = this.componentView.getEditorData();
            this.editorView.updateState(editorData);
        }

        if(component.isMemberFieldUpdated("member","state")) {
            this._setBannerState();
        }
    }

    //#############################################################################
    //Argh! See ntoes and fix this
    nonComponentDocumentUpdate() {
        let editorData = this.componentView.getEditorData();
        this.editorView.updateState(editorData);
    }
    //##############################################################################

    getChildComponentDisplay(name) {
        let folderComponent = this.componentView.getComponent();
        let folderMember = folderComponent.getParentFolderForChildren();

        //lookup component
        var memberId = folderMember.lookupChildId(name);
        if (memberId) {
            var modelView = this.componentView.getModelView();
            var modelManager = modelView.getModelManager();
            var childComponentId = modelManager.getComponentIdByMemberId(memberId);
            var childComponentView = modelView.getComponentViewByComponentId(childComponentId);
            let childComponentDisplay;
            if (childComponentView) {
                childComponentDisplay = childComponentView.getComponentDisplay();
                //   //CLUDGE ALERT - fix this when I reorganize the code
                //   var tabDisplay = this.folderComponentView.getTabDisplay();
                //   tabDisplay.addChild(componentView);
                //   componentDisplay = componentView.getComponentDisplay();
            }
            else {
                //this component view has not been created yet. Make a standing
                childComponentDisplay = new PageChildComponentDisplay(null, this);
                this.standInChildComponentDisplays[name] = childComponentDisplay;
            }

            return childComponentDisplay
        }
        else {
            return null;
        }
    }

    /** This creates and adds a display for the child component to the parent container. */
    addChild(childComponentView) {

        //-----------------
        // Get component display
        //-----------------
        let childComponentDisplay;

        //create a new component display for this child
        if(childComponentView.constructor.hasChildEntry) {
            //check if there is a component display already waiting
            childComponentDisplay = this.standInChildComponentDisplays[childComponentView.getName()];
            if(childComponentDisplay) {
                //set up the standin component display
                childComponentDisplay.setComponentView(childComponentView);
                delete this.standInChildComponentDisplays[childComponentView.getName()];
            }
            else {
                childComponentDisplay = new PageChildComponentDisplay(childComponentView,this);
            }
        }

        //set this on the child
        if(childComponentDisplay) {
            //set the component display
            childComponentView.setComponentDisplay(childComponentDisplay);
        }
    }

    /** This will move the selection to the start of the document. */
    selectStartOfDocument() {
        let state = this.componentView.getEditorData();
        let $startPos = state.doc.resolve(0);
        let selection = selectionBetween(this.editorView, $startPos, $startPos);
        let transaction = state.tr.setSelection(selection).scrollIntoView();
        this.componentView.applyTransaction(transaction);

        this.componentView.giveEditorFocusIfShowing();
    }

    /** This will move the selection to the end of the document. */
    selectEndOfDocument() {
        let state = this.componentView.getEditorData();
        let endPos = state.doc.content.size;
        let $endPos = state.doc.resolve(endPos);
        let selection = selectionBetween(this.editorView, $endPos, $endPos);
        let transaction = state.tr.setSelection(selection).scrollIntoView();
        this.componentView.applyTransaction(transaction);

        this.componentView.giveEditorFocusIfShowing();
    }

////////////////////////////////////////////////////////////////////////////////////////////////

    /** This is to record any state in the tab object. */
    getStateJson() {
        return null;
    }

    /** This is to restore any state in the tab object. */
    setStateJson(json) {
    }

    //===============================
    // Private Functions
    //===============================

    /** @private */
    loadTabEntry() {
        let component = this.componentView.getComponent();
        this.tab = new Tab(component.getId());    

        //-----------------------
        //set the content
        //-----------------------
        this.createDisplayContent();

        if(this.tab.getIsShowing()) {
            this.tabShown();
        }
        else {
            this.tabHidden();
        }
        this.tab.addListener(uiutil.SHOWN_EVENT,() => this.tabShown());
        this.tab.addListener(uiutil.HIDDEN_EVENT,() => this.tabHidden());
        this.tab.addListener(uiutil.CLOSE_EVENT,() => this.tabClosed());

        //------------------
        // set menu
        //------------------
        var menu = this.tab.createMenu(this.componentView.getIconUrl());
        var createMenuItemsCallback = () => {
            return this.componentView.getMenuItems();
        };
        menu.setAsOnTheFlyMenu(createMenuItemsCallback);

        //-----------------
        //set the tab title
        //-----------------
        this.tab.setTitle(this.componentView.getName());

        //-----------------
        // apply the banner state
        //-----------------
        this._setBannerState();

        //-----------------------------
        //add the handlers for the tab
        //-----------------------------
        var onClose = () => {
            this.componentView.closeTabDisplay();
            this.destroy();
        };
        this.tab.addListener(uiutil.CLOSE_EVENT,onClose);
    }

    _setBannerState() {
        let bannerState = this.componentView.getBannerState();
        let bannerMessage = this.componentView.getBannerMessage();

        uiutil.removeAllChildren(this.bannerContainer);
        if(bannerState == bannerConstants.BANNER_TYPE_NONE) ;
        else {
            var banner = getBanner(bannerMessage,bannerState);
            this.bannerContainer.appendChild(banner);
        }

        if(this.tab) {
            var iconOverlay = getIconOverlay(bannerState);
            if(iconOverlay) {
                this.tab.setIconOverlay(iconOverlay);
            }
            else {
                this.tab.clearIconOverlay();
            }
        }
    }

     /** @private */
    createDisplayContent() {

        //-----------
        //page header
        //------------
        this.headerElement = uiutil.createElementWithClass("div","visiui_litPage_header",null);
        this.tab.setHeaderContent(this.headerElement);

        this.editorToolbarContainer = uiutil.createElementWithClass("div","visiui_litPage_editorToolbar",this.headerElement);
        this.componentToolbarContainer = uiutil.createElementWithClass("div","visiui_litPage_componentToolbar",this.headerElement);
        this.bannerContainer = uiutil.createElementWithClass("div","visiui_litPage_banner",this.headerElement);

        this.initComponentToolbar();

        //-------------------
        //page body
        //-------------------
        this.contentElement = uiutil.createElementWithClass("div","visiui_litPage_body",null);
        this.tab.setContent(this.contentElement);

        let pageComponent = this.componentView.getComponent();
        let folder = pageComponent.getParentFolderForChildren();

        //show all children
        var modelView = this.componentView.getModelView();
        var modelManager = modelView.getModelManager();
        var childrenIds = folder.getChildIdMap();
        for(var childName in childrenIds) {
            var childMemberId = childrenIds[childName];
            var childComponentId = modelManager.getComponentIdByMemberId(childMemberId);
            var childComponentView = modelView.getComponentViewByComponentId(childComponentId);
            if(childComponentView) {
                this.addChild(childComponentView);
            }
        }
        
        // var editorData = this.componentView.getEditorData();
        // this.editorView.updateState(editorData);
        this.initEditor();

        //set the selection to the start of the view
        this.selectStartOfDocument();
    }

    initComponentToolbar() {

        //THIS IS BAD - IT IS ONLY TO GET THIS WORKING AS A TRIAL
        //MAKE A WAY TO GET COMPONENT GENERATORS FOR BUTTONS RATHER THAN READING A PRIVATE VARIABLE FROM APP
        let pageComponent = this.componentView.getComponent();
        var appView = this.componentView.getModelView().getWorkspaceView().getAppView();
        var app = appView.getApp();

        let standardComponentNames = componentInfo.getStandardComponentNames();
        for(var i = 0; i < standardComponentNames.length; i++) {
            let componentName = standardComponentNames[i];

            let componentClass = componentInfo.getComponentClass(componentName);
            let componentViewClass = getComponentViewClass(componentClass.uniqueName);
            if(componentViewClass.hasChildEntry) {

                var buttonElement = uiutil.createElementWithClass("div","visiui_litPage_componentButton",this.componentToolbarContainer);
                //make the idon
                var imageElement = document.createElement("img");
                imageElement.src = uiutil.getResourcePath(componentViewClass.ICON_RES_PATH);
                var iconElement = uiutil.createElementWithClass("div","visiui_litPage_componentButtonIcon",buttonElement);
                iconElement.appendChild(imageElement);
                //label
                var textElement = uiutil.createElementWithClass("div","visiui_litPage_componentButtonText",buttonElement);
                textElement.innerHTML = componentClass.displayName;
                //add handler
                buttonElement.onclick = () => {

                    this.editorView.dom.focus();

                    var initialValues = {};
                    var parentMember = pageComponent.getParentFolderForChildren();
                    initialValues.parentId = parentMember.getId();

                    addComponent(appView,app,componentClass,initialValues,null,null);
                };
            }
        }

        //add the additional component item
        var buttonElement = uiutil.createElementWithClass("div","visiui_litPage_componentButton",this.componentToolbarContainer);
        var textElement = uiutil.createElementWithClass("div","visiui_litPage_componentButtonText",buttonElement);
        textElement.innerHTML = "Additional Components...";
        buttonElement.onclick = () => {

            this.editorView.dom.focus();

            var initialValues = {};
            var parentMember = pageComponent.getParentFolderForChildren();
            initialValues.parentId = parentMember.getId();

            let appView = this.componentView.getModelView().getWorkspaceView().getAppView();

            //I tacked on a piggyback for testing!!!
            addAdditionalComponent(appView,app,initialValues,null,null);
        };
        this.componentToolbarContainer.appendChild(buttonElement);
    }


    initEditor() {
        
        //start with an empty component display
        var initialEditorState = this.componentView.getEditorData();
        
        this.editorView = this.editorManager.createEditorView(this.contentElement,this,initialEditorState);

        this.contentElement.addEventListener("click",event => this.onClickContentElement(event));

        //add the editor toolbar
        this.editorToolbarContainer.appendChild(this.editorManager.editorToolbarElement);
        
    }

    /** This is used to select the end of the document if the page is clicked below the document end. */
    onClickContentElement(event) {
        if(event.target == this.contentElement) {
            this.selectEndOfDocument();    
        }    
    }

    /** This should be called by the parent component when it is discarding the 
     * page display.  
     * @protected */
    destroy() {
        //we should probably have a less cumbesome way of doing this
        let pageComponent = this.componentView.getComponent();
        let folder = pageComponent.getParentFolderForChildren();
        var childIdMap = folder.getChildIdMap();
        var modelView = this.componentView.getModelView();
        var modelManager = modelView.getModelManager();

        for(var childName in childIdMap) {
            var childMemberId = childIdMap[childName];
            var childComponentId = modelManager.getComponentIdByMemberId(childMemberId);
            var childComponentView = modelView.getComponentViewByComponentId(childComponentId);
            if(childComponentView) {
                childComponentView.closeComponentDisplay();
            }
        }

        if(this.tab) this.closeTab();
    }

    /** @protected */
    tabShown() {
        this.isShowing = true;
        this.dispatchEvent(uiutil.SHOWN_EVENT,this);
    }

    /** @protected */
    tabHidden() {
        this.isShowing = false;
        this.dispatchEvent(uiutil.HIDDEN_EVENT,this);
    }

    tabClosed() {
        //delete the page
        this.componentView.closeTabDisplay();
        this.dispatchEvent(uiutil.CLOSE_EVENT,this);
    }
    
}

//add mixins to this class
apogeeutil$1.mixin(LiteratePageComponentDisplay$1,EventManager);

/** This is the data to load an empty page. */
LiteratePageComponentDisplay$1.EMPTY_PAGE_BODY = [];

/** This component represents a table object. */
class FolderComponentView extends ParentComponentView {

    constructor(modelView,folderComponent) {
        super(modelView,folderComponent);
    }

    instantiateTabDisplay() {
        return new LiteratePageComponentDisplay$1(this); 
    }

}

//======================================
// This is the component generator, to register the component
//======================================

FolderComponentView.componentName = "apogeeapp.PageComponent";
FolderComponentView.hasTabEntry = true;
FolderComponentView.hasChildEntry = false;
FolderComponentView.ICON_RES_PATH = "/componentIcons/formControl.png";
FolderComponentView.TREE_ENTRY_SORT_ORDER = ParentComponentView.FOLDER_COMPONENT_TYPE_SORT_ORDER;

/** This component represents a table object. */
class FunctionComponentView extends ComponentView {

    constructor(modelView,functionComponent) {
        //extend edit component
        super(modelView,functionComponent);
    };

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return FunctionComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getModelView().getApp();
        
        //create the new view element;
        switch(viewType) {
                
            case FunctionComponentView.VIEW_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case FunctionComponentView.VIEW_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            default:
    //temporary error handling...
                alert("unrecognized view element!");
                return null;
        }
    }

}


FunctionComponentView.VIEW_CODE = "Code";
FunctionComponentView.VIEW_SUPPLEMENTAL_CODE = "Private";

FunctionComponentView.VIEW_MODES = [
    FunctionComponentView.VIEW_CODE,
    FunctionComponentView.VIEW_SUPPLEMENTAL_CODE
];

FunctionComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": FunctionComponentView.VIEW_MODES,
    "defaultView": FunctionComponentView.VIEW_CODE
};


//======================================
// This is the component generator, to register the component
//======================================

FunctionComponentView.componentName = "apogeeapp.FunctionCell";
FunctionComponentView.hasTabEntry = false;
FunctionComponentView.hasChildEntry = true;
FunctionComponentView.ICON_RES_PATH = "/componentIcons/functionTable.png";

FunctionComponentView.propertyDialogLines = [
    {
        "type":"inputElement",
        "heading":"Arg List: ",
        "resultKey":"argListString"
    }
];

/** This component represents a folderFunction, which is a function that is programmed using
 *apogee tables rather than writing code. */
class FolderFunctionComponentView extends ParentComponentView {
        
    constructor(modelView,component) {
        //extend parent component
        super(modelView,component);
    }

    instantiateTabDisplay() {
        return new LiteratePageComponentDisplay$1(this); 
    }

    //==============================
    // Child Display
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return FolderFunctionComponentView.TABLE_EDIT_SETTINGS;
    }

}

//=======================
// Child View SEttings
//=======================

FolderFunctionComponentView.VIEW_MODES = [
];

FolderFunctionComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": FolderFunctionComponentView.VIEW_MODES,
};


//======================================
// This is the component generator, to register the component
//======================================

FolderFunctionComponentView.componentName = "apogeeapp.PageFunctionComponent";
FolderFunctionComponentView.hasTabEntry = true;
FolderFunctionComponentView.hasChildEntry = true;
FolderFunctionComponentView.ICON_RES_PATH = "/componentIcons/folderFunction.png";
FolderFunctionComponentView.TREE_ENTRY_SORT_ORDER = ParentComponentView.FOLDER_COMPONENT_TYPE_SORT_ORDER;


FolderFunctionComponentView.propertyDialogLines = [
    {
        "type":"inputElement",
        "heading":"Arg List: ",
        "resultKey":"argListString"
    },
    {
        "type":"inputElement",
        "heading":"Return Val: ",
        "resultKey":"returnValueString"
    }
];

/** This component represents a table object. */
class DynamicFormView extends ComponentView {
        
    constructor(modelView,component) {
        //extend edit component
        super(modelView,component);
    };

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return DynamicFormView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getModelView().getApp();
        
        //create the new view element;
        switch(viewType) {
            
            case DynamicFormView.VIEW_FORM:
                dataDisplaySource = this.getFormCallbacks();
                return new ConfigurableFormEditor(displayContainer,dataDisplaySource);
                
            case DynamicFormView.VIEW_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case DynamicFormView.VIEW_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            default:
    //temporary error handling...
                alert("unrecognized view element!");
                return null;
        }
    }

    getFormCallbacks() { 
        var dataDisplaySource = {
            doUpdate: () => {
                //we have no data here, just the form layout
                let reloadData = false;
                let reloadDataDisplay = this.getComponent().isMemberDataUpdated("member");
                return {reloadData,reloadDataDisplay};
            },

            getDisplayData: () => {             
                let functionMember = this.getComponent().getField("member"); 
                let layoutFunction = functionMember.getData();

                //make sure this is a function (could be invalid value, or a user code error)
                if(layoutFunction instanceof Function) {
                    let admin = {
                        getCommandMessenger: () => new UiCommandMessenger(this,functionMember.getId())
                    };
                    try {
                        return layoutFunction(admin);
                    }
                    catch(error) {
                        console.error("Error reading form layout: " + this.getName());
                        if(error.stack) console.error(error.stack);
                    }
                }
                //if we get here there was a problem with the layout
                return apogeeutil.INVALID_VALUE;
            },

            getData: () => {              
                return null;
            }
        };

        return dataDisplaySource;
    }
        
    //======================================
    // Static methods
    //======================================


}

DynamicFormView.VIEW_FORM = "Form";
DynamicFormView.VIEW_CODE = "Code";
DynamicFormView.VIEW_SUPPLEMENTAL_CODE = "Private";

DynamicFormView.VIEW_MODES = [
    DynamicFormView.VIEW_FORM,
    DynamicFormView.VIEW_CODE,
    DynamicFormView.VIEW_SUPPLEMENTAL_CODE
];

DynamicFormView.TABLE_EDIT_SETTINGS = {
    "viewModes": DynamicFormView.VIEW_MODES,
    "defaultView": DynamicFormView.VIEW_FORM
};

//======================================
// This is the component generator, to register the component
//======================================

DynamicFormView.componentName = "apogeeapp.ActionFormCell";
DynamicFormView.hasTabEntry = false;
DynamicFormView.hasChildEntry = true;
DynamicFormView.ICON_RES_PATH = "/componentIcons/formControl.png";

/** This ccomponent represents a data value, with input being from a configurable form.
 * This is an example of componound component. The data associated with the form
 * can be accessed from the variables (componentName).data. There are also subtables
 * "layout" which contains the form layout and "isInputValid" which is a function
 * to validate form input.
 * If you want a form to take an action on submit rather than create and edit a 
 * data value, you can use the dynmaic form. */
class FormDataComponentView extends ComponentView {

    constructor(modelView,folderComponent) {
        //extend edit component
        super(modelView,folderComponent);
    };

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return FormDataComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getModelView().getApp();
        
        //create the new view element;
        switch(viewType) {
                
            case FormDataComponentView.VIEW_FORM:
                dataDisplaySource = this.getFormEditorCallbacks();
                return new ConfigurableFormEditor(displayContainer,dataDisplaySource);
                
            case FormDataComponentView.VIEW_LAYOUT_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member.layout");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case FormDataComponentView.VIEW_LAYOUT_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member.layout");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
            
            case FormDataComponentView.VIEW_FORM_VALUE:
                dataDisplaySource = dataDisplayHelper.getMemberDataTextDataSource(app,this,"member.data");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/json",AceTextEditor.OPTION_SET_DISPLAY_SOME);
                
            case FormDataComponentView.VIEW_INPUT_INVALID_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member.isInputValid");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case FormDataComponentView.VIEW_INPUT_INVALID_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member.isInputValid");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            default:
    //temporary error handling...
                alert("unrecognized view element!");
                return null;
        }
    }

    getFormEditorCallbacks() {

        var dataDisplaySource = {};
        dataDisplaySource.doUpdate = () => {
            //update depends on multiplefields
            let component = this.getComponent();
            let reloadData = component.isMemberDataUpdated("member.data");
            let reloadDataDisplay = ( (component.isMemberDataUpdated("member.layout")) ||
                (component.isMemberDataUpdated("member.isInputValid")) );
            return {reloadData,reloadDataDisplay};
        },

        //return form layout
        dataDisplaySource.getDisplayData = () => { 
            let layoutFunctionMember = this.getComponent().getField("member.layout");
            if(layoutFunctionMember.getState() == apogeeutil$1.STATE_NORMAL) {
                let layoutFunction = layoutFunctionMember.getData();   
                if(layoutFunction instanceof Function) {
                    try { 
                        return layoutFunction();
                    }
                    catch(error) {
                        console.error("Error reading form layout: " + this.getName());
                        if(error.stack) console.error(error.stack);
                    }
                }
            }
            //if we get here there was a problem with the return value
            return  apogeeutil$1.INVALID_VALUE;
            
        };
        
        //return desired form value
        dataDisplaySource.getData = () => {
            let dataTable = this.getComponent().getField("member.data");
            return dataTable.getData();
        }; 
        
        //edit ok - always true
        dataDisplaySource.getEditOk = () => {
            return true;
        };
        
        //save data - just form value here
        
        dataDisplaySource.saveData = (formValue) => {
            let layoutFunctionMember = this.getComponent().getField("member.layout");
            let isInputValidFunctionMember = this.getComponent().getField("member.isInputValid");
            //validate input
            var isInputValid = isInputValidFunctionMember.getData();
            let validateResult;
            if(isInputValid instanceof Function) {
                try {
                    validateResult = isInputValid(formValue);
                }
                catch(error) {
                    validateResult = "Error running input validation function.";
                    console.error("Error reading form layout: " + this.getName());
                }
            }
            else {
                validateResult = "Input validate function not valid";
            }

            if(validateResult !== true) {
                if(typeof validateResult != 'string') {
                    validateResult = "Improper format for isInputValid function. It should return true or an error message";
                }
                alert(validateResult);
                return false;
            }

            //save the data - send via messenger to the variable named "data" in code, which is the field 
            //named "member.data", NOT the field named "data"
            let commandMessenger = new UiCommandMessenger(this,layoutFunctionMember.getId());
            commandMessenger.dataCommand("data",formValue);
            return true;
        };
        
        return dataDisplaySource;
    }

    //======================================
    // Static methods
    //======================================

}


FormDataComponentView.VIEW_FORM = "Form";
FormDataComponentView.VIEW_LAYOUT_CODE = "Layout Code";
FormDataComponentView.VIEW_LAYOUT_SUPPLEMENTAL_CODE = "Layout Private";
FormDataComponentView.VIEW_FORM_VALUE = "Form Value";
FormDataComponentView.VIEW_INPUT_INVALID_CODE = "isInputValid(formValue)";
FormDataComponentView.VIEW_INPUT_INVALID_SUPPLEMENTAL_CODE = "isInputValid Private";

FormDataComponentView.VIEW_MODES = [
    FormDataComponentView.VIEW_FORM,
    FormDataComponentView.VIEW_LAYOUT_CODE,
    FormDataComponentView.VIEW_LAYOUT_SUPPLEMENTAL_CODE,
    FormDataComponentView.VIEW_INPUT_INVALID_CODE,
    FormDataComponentView.VIEW_INPUT_INVALID_SUPPLEMENTAL_CODE,
    FormDataComponentView.VIEW_FORM_VALUE
];

FormDataComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": FormDataComponentView.VIEW_MODES,
    "defaultView": FormDataComponentView.VIEW_FORM,
};

//======================================
// This is the component generator, to register the component
//======================================


FormDataComponentView.componentName = "apogeeapp.DataFormCell";
FormDataComponentView.hasTabEntry = false;
FormDataComponentView.hasChildEntry = true;
FormDataComponentView.ICON_RES_PATH = "/componentIcons/formControl.png";

/** This is a custom resource component. 
 * To implement it, the resource script must have the methods "run()" which will
 * be called when the component is updated. It also must have any methods that are
 * confugred with initialization data from the model. */
class CustomComponentView extends ComponentView {

    constructor(modelView,component) {
        super(modelView,component);

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        //add css to page! I think this should go in a separate on create event, but until I 
        //make this, I iwll put this here.
        let css = component.getField("css");
        if((css)&&(css != "")) {
            uiutil.setObjectCssData(component.getId(),css);
        }
        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    };

    /** This component overrides the componentupdated to process the css data, which is managed directly in the view. */
    componentUpdated(component) {
        super.componentUpdated(component);

        //if this is the css field, set it immediately
        if(component.isFieldUpdated("css")) {
            uiutil.setObjectCssData(component.getId(),component.getField("css"));
        }
    }

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /** This component extends the on delete method to get rid of any css data for this component. */
    onDelete() {
        //remove the css data for this component
        uiutil.setObjectCssData(this.component.getId(),"");
        
        super.onDelete();
    }

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return CustomComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getModelView().getApp();
        
        //create the new view element;
        switch(viewType) {
            
            case CustomComponentView.VIEW_OUTPUT:
                displayContainer.setDestroyViewOnInactive(this.getComponent().getDestroyOnInactive());
                var dataDisplaySource = this.getOutputDataDisplaySource();
                var dataDisplay = new HtmlJsDataDisplay(displayContainer,dataDisplaySource);
                return dataDisplay;
                
            case CustomComponentView.VIEW_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case CustomComponentView.VIEW_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
            
            case CustomComponentView.VIEW_HTML:
                dataDisplaySource = this.getUiDataDisplaySource("html");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/html",AceTextEditor.OPTION_SET_DISPLAY_MAX);
        
            case CustomComponentView.VIEW_CSS:
                dataDisplaySource = this.getUiDataDisplaySource("css");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/css",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case CustomComponentView.VIEW_UI_CODE:
                dataDisplaySource = this.getUiDataDisplaySource("uiCode");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            default:
    //temporary error handling...
                alert("unrecognized view element!");
                return null;
        }
    }

    getOutputDataDisplaySource() {

        return {

            //This method reloads the component and checks if there is a DATA update. UI update is checked later.
            doUpdate: () => {
                //return value is whether or not the data display needs to be udpated
                let reloadData = this.getComponent().isMemberDataUpdated("member");
                let reloadDataDisplay = this.getComponent().areAnyFieldsUpdated(["html","uiCode"]);
                return {reloadData,reloadDataDisplay};
            },

            getData: () => {
                let member = this.getComponent().getMember();
                return member.getData();
            },

            //below - custom methods for HtmlJsDataDisplay

            //returns the HTML for the data display
            getHtml: () => {
                return this.getComponent().getField("html");
            },

            //returns the resource for the data display
            getResource: () => {
                return this.getComponent().createResource();
            },

            //gets the mebmer used as a refernce for the UI manager passed to the resource functions 
            getContextMember: () => {
                return this.getComponent().getMember();
            }
        }
    }

    /** This method returns the data dispklay data source for the code field data displays. */
    getUiDataDisplaySource(codeFieldName) {

        return {
            doUpdate: () => {
                //return value is whether or not the data display needs to be udpated
                let reloadData = this.getComponent().isFieldUpdated(codeFieldName);
                let reloadDataDisplay = false;
                return {reloadData,reloadDataDisplay};
            },

            getData: () => {
                let codeField = this.getComponent().getField(codeFieldName);
                if((codeField === undefined)||(codeField === null)) codeField = "";
                return codeField;
            },

            getEditOk: () => {
                return true;
            },
            
            saveData: (text) => {
                let app = this.getModelView().getApp();
                this.getComponent().doCodeFieldUpdate(app,codeFieldName,text);
                return true;
            }
        }
    }
}

CustomComponentView.VIEW_OUTPUT = "Display";
CustomComponentView.VIEW_CODE = "Input Code";
CustomComponentView.VIEW_SUPPLEMENTAL_CODE = "Input Private";
CustomComponentView.VIEW_HTML = "HTML";
CustomComponentView.VIEW_CSS = "CSS";
CustomComponentView.VIEW_UI_CODE = "uiGenerator()";

CustomComponentView.VIEW_MODES = [
    CustomComponentView.VIEW_OUTPUT,
    CustomComponentView.VIEW_CODE,
    CustomComponentView.VIEW_SUPPLEMENTAL_CODE,
    CustomComponentView.VIEW_HTML,
    CustomComponentView.VIEW_CSS,
    CustomComponentView.VIEW_UI_CODE
];

CustomComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": CustomComponentView.VIEW_MODES,
    "defaultView": CustomComponentView.VIEW_OUTPUT
};

/** This is the format string to create the code body for updateing the member
 * Input indices:
 * 0: resouce methods code
 * 1: uiPrivate
 * @private
 */
CustomComponentView.GENERATOR_FUNCTION_FORMAT_TEXT = [
    "//member functions",
    "var resourceFunction = function(component) {",
    "{0}",
    "}",
    "//end member functions",
    "return resourceFunction;",
    ""
       ].join("\n");
    
    


//======================================
// This is the control generator, to register the control
//======================================

CustomComponentView.componentName = "apogeeapp.CustomCell";
CustomComponentView.hasTabEntry = false;
CustomComponentView.hasChildEntry = true;
CustomComponentView.ICON_RES_PATH = "/componentIcons/chartControl.png";
CustomComponentView.propertyDialogLines = [
    {
        "type":"checkbox",
        "heading":"Destroy on Hide: ",
        "resultKey":"destroyOnInactive"
    }
];

/** This attempt has a single form edit page which returns an object. */
// To add - I should make it so it does not call set data until after it is initialized. I will cache it rather 
//than making the user do that.

/** This is a custom resource component. 
 * To implement it, the resource script must have the methods "run()" which will
 * be called when the component is updated. It also must have any methods that are
 * confugred with initialization data from the model. */
class CustomDataComponentView extends ComponentView {

    constructor(modelView,component) {
        //extend edit component
        super(modelView,component);

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        //add css to page! I think this should go in a separate on create event, but until I 
        //make this, I iwll put this here.
        let css = component.getField("css");
        if((css)&&(css != "")) {
            uiutil.setObjectCssData(component.getId(),css);
        }
        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    };

    /** This component overrides the componentupdated to process the css data, which is managed directly in the view. */
    componentUpdated(component) {
        super.componentUpdated(component);

        //if this is the css field, set it immediately
        if(component.isFieldUpdated("css")) {
            uiutil.setObjectCssData(component.getId(),component.getField("css"));
        }
    }

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /** This component extends the on delete method to get rid of any css data for this component. */
    onDelete() {
        //remove the css data for this component
        uiutil.setObjectCssData(this.component.getId(),"");
        
        super.onDelete();
    }


    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return CustomDataComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a data display of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        
        var dataDisplaySource;
        var app = this.getModelView().getApp();
        
        //create the new view element;
        switch(viewType) {
            
            case CustomDataComponentView.VIEW_FORM:
                displayContainer.setDestroyViewOnInactive(this.getComponent().getDestroyOnInactive());
                var dataDisplaySource = this.getOutputDataDisplaySource();
                var dataDisplay = new HtmlJsDataDisplay(displayContainer,dataDisplaySource);
                return dataDisplay;
                
            case CustomDataComponentView.VIEW_VALUE:
                dataDisplaySource = dataDisplayHelper.getMemberDataTextDataSource(app,this,"member.data");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/json",AceTextEditor.OPTION_SET_DISPLAY_SOME);
                
            case CustomDataComponentView.VIEW_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberFunctionBodyDataSource(app,this,"member.input");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case CustomDataComponentView.VIEW_SUPPLEMENTAL_CODE:
                dataDisplaySource = dataDisplayHelper.getMemberSupplementalDataSource(app,this,"member.input");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
            
            case CustomDataComponentView.VIEW_HTML:
                dataDisplaySource = this.getUiDataDisplaySource("html");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/html",AceTextEditor.OPTION_SET_DISPLAY_MAX);
        
            case CustomDataComponentView.VIEW_CSS:
                dataDisplaySource = this.getUiDataDisplaySource("css");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/css",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            case CustomDataComponentView.VIEW_UI_CODE:
                dataDisplaySource = this.getUiDataDisplaySource("uiCode");
                return new AceTextEditor(displayContainer,dataDisplaySource,"ace/mode/javascript",AceTextEditor.OPTION_SET_DISPLAY_MAX);
                
            default:
    //temporary error handling...
                alert("unrecognized view element!");
                return null;
        }
    }

    getOutputDataDisplaySource() {
        return {

            //This method reloads the component and checks if there is a DATA update. UI update is checked later.
            doUpdate: () => {
                //return value is whether or not the data display needs to be udpated
                let reloadData = this.getComponent().isMemberDataUpdated("member.data");
                let reloadDataDisplay = this.getComponent().areAnyFieldsUpdated(["html","uiCode","member.input"]);
                return {reloadData,reloadDataDisplay};
            },

            getDisplayData: () => {
                let inputMember = this.getComponent().getField("member.input");
                return inputMember.getData();
            },

            getData: () => {
                let dataMember = this.getComponent().getField("member.data");
                return dataMember.getData();
            },

            //edit ok - always true
            getEditOk: () => {
                return true;
            },

            saveData: (formValue) => {
                //send value to the table whose variable name is "data"
                //the context reference is the member called "input" 
                let inputMember = this.getComponent().getField("member.input");
                let commandMessenger = new UiCommandMessenger(this,inputMember.getId());
                commandMessenger.dataCommand("data",formValue);
                return true;
            },

            //below - custom methods for HtmlJsDataDisplay

            //returns the HTML for the data display
            getHtml: () => {
                return this.getComponent().getField("html");
            },

            //returns the resource for the data display
            getResource: () => {
                return this.getComponent().createResource();
            },

            //gets the mebmer used as a refernce for the UI manager passed to the resource functions 
            getContextMember: () => {
                let inputMember = this.getComponent().getField("member.input");
                return inputMember;
            }
        }
    }

    /** This method returns the data dispklay data source for the code field data displays. */
    getUiDataDisplaySource(codeFieldName) {
 
        return {
            doUpdate: () => {
                //return value is whether or not the data display needs to be udpated
                let reloadData = this.getComponent().isFieldUpdated(codeFieldName);
                let reloadDataDisplay = false;
                return {reloadData,reloadDataDisplay};
            },

            getData: () => {
                let codeField = this.getComponent().getField(codeFieldName);
                if((codeField === undefined)||(codeField === null)) codeField = "";
                return codeField;
            },

            getEditOk: () => {
                return true;
            },
            
            saveData: (text) => {
                let app = this.getModelView().getApp();
                this.getComponent().doCodeFieldUpdate(app,codeFieldName,text);
                return true;
            }
        }
    }



}



//======================================
// This is the control generator, to register the control
//======================================

CustomDataComponentView.componentName = "apogeeapp.CustomDataCell";
CustomDataComponentView.hasTabEntry = false;
CustomDataComponentView.hasChildEntry = true;
CustomDataComponentView.ICON_RES_PATH = "/componentIcons/formControl.png";

CustomDataComponentView.propertyDialogLines = [
    {
        "type":"checkbox",
        "heading":"Destroy on Hide: ",
        "resultKey":"destroyOnInactive"
    }
];

CustomDataComponentView.VIEW_FORM = "Form";
CustomDataComponentView.VIEW_VALUE = "Data Value";
CustomDataComponentView.VIEW_CODE = "Input Code";
CustomDataComponentView.VIEW_SUPPLEMENTAL_CODE = "Input Private";
CustomDataComponentView.VIEW_HTML = "HTML";
CustomDataComponentView.VIEW_CSS = "CSS";
CustomDataComponentView.VIEW_UI_CODE = "uiGenerator(mode)";

CustomDataComponentView.VIEW_MODES = [
    CustomDataComponentView.VIEW_FORM,
    CustomDataComponentView.VIEW_VALUE,
    CustomDataComponentView.VIEW_CODE,
    CustomDataComponentView.VIEW_SUPPLEMENTAL_CODE,
    CustomDataComponentView.VIEW_HTML,
    CustomDataComponentView.VIEW_CSS,
    CustomDataComponentView.VIEW_UI_CODE
];

CustomDataComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": CustomDataComponentView.VIEW_MODES,
    "defaultView": CustomDataComponentView.VIEW_FORM
};

/** This component represents a json table object. */
class ErrorComponentView extends ComponentView {

    constructor(modelView,component) {
        //extend edit component
        super(modelView,component);
    };

    //==============================
    // Protected and Private Instance Methods
    //==============================

    /**  This method retrieves the table edit settings for this component instance
     * @protected */
    getTableEditSettings() {
        return ErrorComponentView.TABLE_EDIT_SETTINGS;
    }

    /** This method should be implemented to retrieve a view mode of the give type. 
     * @protected. */
    getDataDisplay(displayContainer,viewType) {
        return new ErrorDisplay(displayContainer,false);
    }

    //======================================
    // Static methods
    //======================================

}

ErrorComponentView.EMPTY_VIEW = "EMPTY_VIEW";

ErrorComponentView.VIEW_MODES = [
    ErrorComponentView.EMPTY_VIEW
];

ErrorComponentView.TABLE_EDIT_SETTINGS = {
    "viewModes": ErrorComponentView.VIEW_MODES,
    "defaultView": ErrorComponentView.EMPTY_VIEW,
    "emptyDataValue": ""
};

//======================================
// This is the component generator, to register the component
//======================================

ErrorComponentView.componentName = "apogeeapp.ErrorCell";
ErrorComponentView.hasTabEntry = false;
ErrorComponentView.hasChildEntry = true;
ErrorComponentView.ICON_RES_PATH = "/componentIcons/genericDataTable.png";

registerComponentView(JsonTableComponentView);
registerComponentView(FolderComponentView);
registerComponentView(FunctionComponentView);
registerComponentView(FolderFunctionComponentView);
registerComponentView(ErrorComponentView);
registerComponentView(DynamicFormView);
registerComponentView(FormDataComponentView);
registerComponentView(CustomComponentView);
registerComponentView(CustomDataComponentView);

setErrorComponentView(ErrorComponentView);

/** This function initializes the resources paths. Thuis covers the following paths
 * - "resources" folder - where the resource images are held
 * - "ace_includes" folder - where ace include files like themes are held
 * The argument includeBasePath can be either a string which is the common base path for the two above fodlers
 * or a object (map) including the folder name as the key and the assoicated base path as the value.
 */
function initIncludePath(includePathInfo) {

    if(!includePathInfo.resources) throw new Error("Resources path must be specified");
    if(!includePathInfo.aceIncludes) throw new Error("Ace includes path must be specified");

    //initialize resource path (relative to base path in web page)
    uiutil.initResourcePath(includePathInfo.resources);

    //any needs mode or theme files for the ace editor should go in the folder set below (relative to base path in web page)
    exports$1.config.set('basePath',includePathInfo.aceIncludes);
}

var apogeeview = /*#__PURE__*/Object.freeze({
    __proto__: null,
    initIncludePath: initIncludePath,
    ApogeeView: ApogeeView,
    ApogeeWebView: ApogeeWebView,
    ComponentView: ComponentView,
    WebComponentDisplay: WebComponentDisplay,
    AceTextEditor: AceTextEditor,
    ConfigurableFormEditor: ConfigurableFormEditor,
    DataDisplay: DataDisplay,
    dataDisplayHelper: dataDisplayHelper,
    DATA_DISPLAY_CONSTANTS: DATA_DISPLAY_CONSTANTS,
    ErrorDisplay: ErrorDisplay,
    HandsonGridEditor: HandsonGridEditor,
    HtmlJsDataDisplay: HtmlJsDataDisplay,
    registerComponentView: registerComponentView,
    getComponentViewClass: getComponentViewClass,
    get ERROR_COMPONENT_VIEW_CLASS () { return ERROR_COMPONENT_VIEW_CLASS; },
    showConfigurableDialog: showConfigurableDialog,
    UiCommandMessenger: UiCommandMessenger
});

/** This method shows a dialog that inputs or outputs a text area.
 * The onSubmitFunction should return true if the dialog should close and false if it should stay open. 
 * This dialog uses a text area that allows for better cut/paste speed with very large input/output. */
function showTextIoDialog(options,onSubmitFunction) {
    
    var dialog = dialogMgr.createDialog({"minimizable":true,"maximizable":true,"movable":true});
            
    //add a scroll container
    var contentContainer = uiutil.createElement("div",null,
        {
			"display":"block",
            "position":"relative",
            "top":"0px",
            "height":"100%",
            "overflow": "auto"
        });
	dialog.setContent(contentContainer,uiutil.SIZE_WINDOW_TO_CONTENT);
    
	var content = uiutil.createElement("div",null,
			{
				"display":"table",
				"overflow":"hidden"
			});
	contentContainer.appendChild(content);
    
    var line;
    
    //title
    if(options.title) {
        line = uiutil.createElement("div",{"className":"dialogLine"});
        line.appendChild(uiutil.createElement("div",{"className":"dialogTitle"}));
        line.innerHTML = options.title;
        content.appendChild(line);
    }
    
    //instructions
    if(options.instructions) {
        line = uiutil.createElement("div",{"className":"dialogLine"});
        line.appendChild(uiutil.createElement("div",/*{"className":"xxx"}*/));
        line.innerHTML = options.instructions;
        content.appendChild(line);
    }
    
    //text area
    line = uiutil.createElement("div",{"className":"dialogLine"});
    var editorDiv = uiutil.createElement("div",null,
        {
            "position":"relative",
            "width":"500px",
            "height":"300px",
            "border":"1px solid darkgray"
        });
    line.appendChild(editorDiv);
    content.appendChild(line);
        
//    var jsLinksEditorDiv = uiutil.createElement("div",null,{
//        "position":"absolute",
//        "top":"0px",
//        "bottom":"0px",
//        "right":"0px",
//        "left":"0px"
//    });
//    editorDiv.appendChild(jsLinksEditorDiv);
    
    var textEditor = exports$1.edit(editorDiv);
//this stops an error message
textEditor.$blockScrolling = Infinity;
    textEditor.setTheme("ace/theme/eclipse");
    textEditor.getSession().setMode("ace/mode/text");
    //set the value
    if(options.initialText) {
        textEditor.getSession().setValue(options.initialText);
    }
    
    //save and cancel buttons
    //buttons and handler
    line = uiutil.createElement("div",{"className":"dialogLine"});
    var onCancel = function() {
        closeDialog();
    };
    
    var onSave = function() {
        var outputText = textEditor.getSession().getValue();
        var doClose = onSubmitFunction(outputText);
        if(doClose) closeDialog();
    };
    
    var closeDialog = function() {
        dialogMgr.closeDialog(dialog);
        
        //clean up the editor
        if(textEditor) { 
            textEditor.destroy();
            textEditor = null;
        }
    };
    
    var submitLabel = options.submitLabel ? options.submitLabel : "Submit";
    line.appendChild(uiutil.createElement("button",{"className":"dialogButton","innerHTML":submitLabel,"onclick":onSave}));
    line.appendChild(uiutil.createElement("button",{"className":"dialogButton","innerHTML":"Cancel","onclick":onCancel}));
    content.appendChild(line);
    
    dialog.setContent(content,uiutil.SIZE_WINDOW_TO_CONTENT);
    
    //show dialog
    dialogMgr.showDialog(dialog);
    
    //size the dialog to the content
    dialog.fitToContent();
    dialog.centerInParent();
}

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
class CutNPasteFileAccess extends BaseFileAccess {
    
    //========================================
    // Public
    //========================================
    
    constructor() {
        super();
    }
   
    /**
     * This method returns fileMetadata appropriate for a new workspace.
     */
    getNewFileMetadata() {
        return null;
    }
    
    /**
     * This method returns true if the workspace has an existing file to which 
     * is can be saved without opening a save dialog. 
     */
    directSaveOk(fileMetadata) {
        return false;
    }
    
    /**
     * This method opens a file, including dispalying a dialog
     * to select the file.
     */
    openFile(onOpen) {
        var onDataEntered = function(data) {
            onOpen(null,data,null);
            return true;
        };

        var options = {};
        options.title = "Open Workspace";
        options.instructions = "Paste saved workspace data in the space below.";
        options.submitLabel = "Open";
        showTextIoDialog(options,onDataEntered);
    }

    /** This  method shows a save dialog and saves the file. */
    saveFileAs(fileMetadata,data,onSave) {
        var onSubmit = () => true;
        var options = {};
        options.title = "Save Workspace";
        options.instructions = "Copy the data below and save it in a file to open later.";
        options.initialText = data;
        options.submitLabel = "Save";
        showTextIoDialog(options,onSubmit);

        //I should maybe only do this if you do not press cancel?
        if(onSaveSuccess) onSave(null,true,null);
    }

    /** 
     * This method saves a file to the give location. 
     */
    saveFile(fileMetadata,data,onSave) {
        this.saveFileAs(fileMetadata,data,onSave);
    }


}

/** 
 * This is the format of the AppConfigManager. This class does not need
 * to be extended. It has not internal functionality.
 */
class CutNPasteAppConfigManager {
    
    constructor() {
    }
    
    /** This method should return a Promise object the loades the
     * app configuration.
     */
    getConfigPromise(app) {
        var configUrl = apogeeutil$1.readQueryField("config",document.URL);
        var configFilePromise;
        if(configUrl) {
            configFilePromise = apogeeutil$1.jsonRequest(configUrl);
            //chain the file download promise to the init settings promise
            return configFilePromise.then(appSettings => app.getConfigurationPromise(appSettings));
        }
        else {
            //is there is no config file return an "empty" promise
            return Promise.resolve();
        }   
    };
    
    /** This method should return a default FileAccessObject. It will be loaded
     * if an alternate is not loaded in configuration.
     */
    getDefaultFileAccessObject(app) {
        return new CutNPasteFileAccess();
    }
    
    /** This method should return a promise for the initial workspace
     * that should be loaded
     */
    getInitialWorkspaceFilePromise(app) {
        var workspaceUrl = apogeeutil$1.readQueryField("url",document.URL);
        if(workspaceUrl) {
            return apogeeutil$1.textRequest(workspaceUrl);
        } else {
            return null;
        }
    }
    
    /** This method should return the file metadata for the intial workspace.
     * This will be used in saving the initail workspace. (For example, if the
     * initial workspace is a locally loaded file in the electron version, this
     * file metadata will allow the user to select "save" to update the file 
     * without having to select a file to save to.
     */
    getInitialWorkspaceFileMetadata(app) {
        return null;
    }
}

//expose these apogee libraries globally so plugins can use them
window.apogeeutil = apogeeutil$1;
window.apogee = apogee;
window.apogeeapp = apogeeapp;
window.apogeeui = apogeeui;
window.apogeeview = apogeeview;

let appView;

window.init = function(includeBasePathInfo) {
    //initialize include directories
    initIncludePath(includeBasePathInfo);
    
    //use cutnpaste file access
    let appConfigManager = new CutNPasteAppConfigManager();
    
    //create the application
    appView = new ApogeeView("appContainer",appConfigManager);
};

function beforeUnloadHandler(e) {
    var app = appView.getApp();
    if((app)&&(app.getWorkspaceIsDirty())) {
        console.log("Closing with unsaved data - It should query the user!");
        e.preventDefault();
        return "There is unsaved data. Exit?";
    }
    else {
        return undefined;
    }
}

window.addEventListener("beforeunload", beforeUnloadHandler);
